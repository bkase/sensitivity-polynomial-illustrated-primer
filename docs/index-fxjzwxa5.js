var ZL=Object.create;var{getPrototypeOf:$L,defineProperty:Q5,getOwnPropertyNames:QL}=Object;var WL=Object.prototype.hasOwnProperty;var U6=(F,_,$)=>{$=F!=null?ZL($L(F)):{};let W=_||!F||!F.__esModule?Q5($,"default",{value:F,enumerable:!0}):$;for(let H of QL(F))if(!WL.call(W,H))Q5(W,H,{get:()=>F[H],enumerable:!0});return W};var Y9=(F,_)=>()=>(_||F((_={exports:{}}).exports,_),_.exports);var Qw=(F,_)=>{for(var $ in _)Q5(F,$,{get:_[$],enumerable:!0,configurable:!0,set:(W)=>_[$]=()=>W})};var d_=Y9((HL,Ww)=>{(function(){function F(L,p){Object.defineProperty(W.prototype,L,{get:function(){console.warn("%s(...) is deprecated in plain JavaScript React classes. %s",p[0],p[1])}})}function _(L){if(L===null||typeof L!=="object")return null;return L=UF&&L[UF]||L["@@iterator"],typeof L==="function"?L:null}function $(L,p){L=(L=L.constructor)&&(L.displayName||L.name)||"ReactClass";var N0=L+"."+p;v0[N0]||(console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",p,L),v0[N0]=!0)}function W(L,p,N0){this.props=L,this.context=p,this.refs=jF,this.updater=N0||PF}function H(){}function Y(L,p,N0){this.props=L,this.context=p,this.refs=jF,this.updater=N0||PF}function K(){}function G(L){return""+L}function U(L){try{G(L);var p=!1}catch(h0){p=!0}if(p){p=console;var N0=p.error,g=typeof Symbol==="function"&&Symbol.toStringTag&&L[Symbol.toStringTag]||L.constructor.name||"Object";return N0.call(p,"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",g),G(L)}}function z(L){if(L==null)return null;if(typeof L==="function")return L.$$typeof===a?null:L.displayName||L.name||null;if(typeof L==="string")return L;switch(L){case O0:return"Fragment";case T0:return"Profiler";case t:return"StrictMode";case D0:return"Suspense";case P0:return"SuspenseList";case JF:return"Activity"}if(typeof L==="object")switch(typeof L.tag==="number"&&console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),L.$$typeof){case Q0:return"Portal";case _F:return L.displayName||"Context";case g0:return(L._context.displayName||"Context")+".Consumer";case c0:var p=L.render;return L=L.displayName,L||(L=p.displayName||p.name||"",L=L!==""?"ForwardRef("+L+")":"ForwardRef"),L;case S0:return p=L.displayName||null,p!==null?p:z(L.type)||"Memo";case e0:p=L._payload,L=L._init;try{return z(L(p))}catch(N0){}}return null}function h(L){if(L===O0)return"<>";if(typeof L==="object"&&L!==null&&L.$$typeof===e0)return"<...>";try{var p=z(L);return p?"<"+p+">":"<...>"}catch(N0){return"<...>"}}function A(){var L=C0.A;return L===null?null:L.getOwner()}function N(){return Error("react-stack-top-frame")}function M(L){if(AF.call(L,"key")){var p=Object.getOwnPropertyDescriptor(L,"key").get;if(p&&p.isReactWarning)return!1}return L.key!==void 0}function T(L,p){function N0(){j0||(j0=!0,console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",p))}N0.isReactWarning=!0,Object.defineProperty(L,"key",{get:N0,configurable:!0})}function P(){var L=z(this.type);return v[L]||(v[L]=!0,console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")),L=this.props.ref,L!==void 0?L:null}function D(L,p,N0,g,h0,M0){var L0=N0.ref;return L={$$typeof:n,type:L,key:p,props:N0,_owner:g},(L0!==void 0?L0:null)!==null?Object.defineProperty(L,"ref",{enumerable:!1,get:P}):Object.defineProperty(L,"ref",{enumerable:!1,value:null}),L._store={},Object.defineProperty(L._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:0}),Object.defineProperty(L,"_debugInfo",{configurable:!1,enumerable:!1,writable:!0,value:null}),Object.defineProperty(L,"_debugStack",{configurable:!1,enumerable:!1,writable:!0,value:h0}),Object.defineProperty(L,"_debugTask",{configurable:!1,enumerable:!1,writable:!0,value:M0}),Object.freeze&&(Object.freeze(L.props),Object.freeze(L)),L}function O(L,p){return p=D(L.type,p,L.props,L._owner,L._debugStack,L._debugTask),L._store&&(p._store.validated=L._store.validated),p}function b(L){k(L)?L._store&&(L._store.validated=1):typeof L==="object"&&L!==null&&L.$$typeof===e0&&(L._payload.status==="fulfilled"?k(L._payload.value)&&L._payload.value._store&&(L._payload.value._store.validated=1):L._store&&(L._store.validated=1))}function k(L){return typeof L==="object"&&L!==null&&L.$$typeof===n}function y(L){var p={"=":"=0",":":"=2"};return"$"+L.replace(/[=:]/g,function(N0){return p[N0]})}function m(L,p){return typeof L==="object"&&L!==null&&L.key!=null?(U(L.key),y(""+L.key)):p.toString(36)}function x(L){switch(L.status){case"fulfilled":return L.value;case"rejected":throw L.reason;default:switch(typeof L.status==="string"?L.then(K,K):(L.status="pending",L.then(function(p){L.status==="pending"&&(L.status="fulfilled",L.value=p)},function(p){L.status==="pending"&&(L.status="rejected",L.reason=p)})),L.status){case"fulfilled":return L.value;case"rejected":throw L.reason}}throw L}function o(L,p,N0,g,h0){var M0=typeof L;if(M0==="undefined"||M0==="boolean")L=null;var L0=!1;if(L===null)L0=!0;else switch(M0){case"bigint":case"string":case"number":L0=!0;break;case"object":switch(L.$$typeof){case n:case Q0:L0=!0;break;case e0:return L0=L._init,o(L0(L._payload),p,N0,g,h0)}}if(L0){L0=L,h0=h0(L0);var I0=g===""?"."+m(L0,0):g;return XF(h0)?(N0="",I0!=null&&(N0=I0.replace(H0,"$&/")+"/"),o(h0,p,N0,"",function(m0){return m0})):h0!=null&&(k(h0)&&(h0.key!=null&&(L0&&L0.key===h0.key||U(h0.key)),N0=O(h0,N0+(h0.key==null||L0&&L0.key===h0.key?"":(""+h0.key).replace(H0,"$&/")+"/")+I0),g!==""&&L0!=null&&k(L0)&&L0.key==null&&L0._store&&!L0._store.validated&&(N0._store.validated=2),h0=N0),p.push(h0)),1}if(L0=0,I0=g===""?".":g+":",XF(L))for(var Z0=0;Z0<L.length;Z0++)g=L[Z0],M0=I0+m(g,Z0),L0+=o(g,p,N0,M0,h0);else if(Z0=_(L),typeof Z0==="function")for(Z0===L.entries&&(q0||console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."),q0=!0),L=Z0.call(L),Z0=0;!(g=L.next()).done;)g=g.value,M0=I0+m(g,Z0++),L0+=o(g,p,N0,M0,h0);else if(M0==="object"){if(typeof L.then==="function")return o(x(L),p,N0,g,h0);throw p=String(L),Error("Objects are not valid as a React child (found: "+(p==="[object Object]"?"object with keys {"+Object.keys(L).join(", ")+"}":p)+"). If you meant to render a collection of children, use an array instead.")}return L0}function s(L,p,N0){if(L==null)return L;var g=[],h0=0;return o(L,g,"","",function(M0){return p.call(N0,M0,h0++)}),g}function j(L){if(L._status===-1){var p=L._ioInfo;p!=null&&(p.start=p.end=performance.now()),p=L._result;var N0=p();if(N0.then(function(h0){if(L._status===0||L._status===-1){L._status=1,L._result=h0;var M0=L._ioInfo;M0!=null&&(M0.end=performance.now()),N0.status===void 0&&(N0.status="fulfilled",N0.value=h0)}},function(h0){if(L._status===0||L._status===-1){L._status=2,L._result=h0;var M0=L._ioInfo;M0!=null&&(M0.end=performance.now()),N0.status===void 0&&(N0.status="rejected",N0.reason=h0)}}),p=L._ioInfo,p!=null){p.value=N0;var g=N0.displayName;typeof g==="string"&&(p.name=g)}L._status===-1&&(L._status=0,L._result=N0)}if(L._status===1)return p=L._result,p===void 0&&console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,p),"default"in p||console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,p),p.default;throw L._result}function V(){var L=C0.H;return L===null&&console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`),L}function d(){C0.asyncTransitions--}function $0(L){if(E0===null)try{var p=("require"+Math.random()).slice(0,7);E0=(Ww&&Ww[p]).call(Ww,"timers").setImmediate}catch(N0){E0=function(g){y0===!1&&(y0=!0,typeof MessageChannel>"u"&&console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));var h0=new MessageChannel;h0.port1.onmessage=g,h0.port2.postMessage(void 0)}}return E0(L)}function X0(L){return 1<L.length&&typeof AggregateError==="function"?AggregateError(L):L[0]}function K0(L,p){p!==n0-1&&console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "),n0=p}function J0(L,p,N0){var g=C0.actQueue;if(g!==null)if(g.length!==0)try{u(g),$0(function(){return J0(L,p,N0)});return}catch(h0){C0.thrownErrors.push(h0)}else C0.actQueue=null;0<C0.thrownErrors.length?(g=X0(C0.thrownErrors),C0.thrownErrors.length=0,N0(g)):p(L)}function u(L){if(!V0){V0=!0;var p=0;try{for(;p<L.length;p++){var N0=L[p];do{C0.didUsePromise=!1;var g=N0(!1);if(g!==null){if(C0.didUsePromise){L[p]=N0,L.splice(0,p);return}N0=g}else break}while(1)}L.length=0}catch(h0){L.splice(0,p+1),C0.thrownErrors.push(h0)}finally{V0=!1}}}typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());var n=Symbol.for("react.transitional.element"),Q0=Symbol.for("react.portal"),O0=Symbol.for("react.fragment"),t=Symbol.for("react.strict_mode"),T0=Symbol.for("react.profiler"),g0=Symbol.for("react.consumer"),_F=Symbol.for("react.context"),c0=Symbol.for("react.forward_ref"),D0=Symbol.for("react.suspense"),P0=Symbol.for("react.suspense_list"),S0=Symbol.for("react.memo"),e0=Symbol.for("react.lazy"),JF=Symbol.for("react.activity"),UF=Symbol.iterator,v0={},PF={isMounted:function(){return!1},enqueueForceUpdate:function(L){$(L,"forceUpdate")},enqueueReplaceState:function(L){$(L,"replaceState")},enqueueSetState:function(L){$(L,"setState")}},OF=Object.assign,jF={};Object.freeze(jF),W.prototype.isReactComponent={},W.prototype.setState=function(L,p){if(typeof L!=="object"&&typeof L!=="function"&&L!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,L,p,"setState")},W.prototype.forceUpdate=function(L){this.updater.enqueueForceUpdate(this,L,"forceUpdate")};var t0={isMounted:["isMounted","Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],replaceState:["replaceState","Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]};for(a0 in t0)t0.hasOwnProperty(a0)&&F(a0,t0[a0]);H.prototype=W.prototype,t0=Y.prototype=new H,t0.constructor=Y,OF(t0,W.prototype),t0.isPureReactComponent=!0;var XF=Array.isArray,a=Symbol.for("react.client.reference"),C0={H:null,A:null,T:null,S:null,actQueue:null,asyncTransitions:0,isBatchingLegacy:!1,didScheduleLegacyUpdate:!1,didUsePromise:!1,thrownErrors:[],getCurrentStack:null,recentlyCreatedOwnerStacks:0},AF=Object.prototype.hasOwnProperty,s0=console.createTask?console.createTask:function(){return null};t0={react_stack_bottom_frame:function(L){return L()}};var j0,fF,v={},E=t0.react_stack_bottom_frame.bind(t0,N)(),Y0=s0(h(N)),q0=!1,H0=/\/+/g,W0=typeof reportError==="function"?reportError:function(L){if(typeof window==="object"&&typeof window.ErrorEvent==="function"){var p=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof L==="object"&&L!==null&&typeof L.message==="string"?String(L.message):String(L),error:L});if(!window.dispatchEvent(p))return}else if(typeof process==="object"&&typeof process.emit==="function"){process.emit("uncaughtException",L);return}console.error(L)},y0=!1,E0=null,n0=0,ZF=!1,V0=!1,b0=typeof queueMicrotask==="function"?function(L){queueMicrotask(function(){return queueMicrotask(L)})}:$0;t0=Object.freeze({__proto__:null,c:function(L){return V().useMemoCache(L)}});var a0={map:s,forEach:function(L,p,N0){s(L,function(){p.apply(this,arguments)},N0)},count:function(L){var p=0;return s(L,function(){p++}),p},toArray:function(L){return s(L,function(p){return p})||[]},only:function(L){if(!k(L))throw Error("React.Children.only expected to receive a single React element child.");return L}};HL.Activity=JF,HL.Children=a0,HL.Component=W,HL.Fragment=O0,HL.Profiler=T0,HL.PureComponent=Y,HL.StrictMode=t,HL.Suspense=D0,HL.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=C0,HL.__COMPILER_RUNTIME=t0,HL.act=function(L){var p=C0.actQueue,N0=n0;n0++;var g=C0.actQueue=p!==null?p:[],h0=!1;try{var M0=L()}catch(Z0){C0.thrownErrors.push(Z0)}if(0<C0.thrownErrors.length)throw K0(p,N0),L=X0(C0.thrownErrors),C0.thrownErrors.length=0,L;if(M0!==null&&typeof M0==="object"&&typeof M0.then==="function"){var L0=M0;return b0(function(){h0||ZF||(ZF=!0,console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"))}),{then:function(Z0,m0){h0=!0,L0.then(function($F){if(K0(p,N0),N0===0){try{u(g),$0(function(){return J0($F,Z0,m0)})}catch(nF){C0.thrownErrors.push(nF)}if(0<C0.thrownErrors.length){var iF=X0(C0.thrownErrors);C0.thrownErrors.length=0,m0(iF)}}else Z0($F)},function($F){K0(p,N0),0<C0.thrownErrors.length?($F=X0(C0.thrownErrors),C0.thrownErrors.length=0,m0($F)):m0($F)})}}}var I0=M0;if(K0(p,N0),N0===0&&(u(g),g.length!==0&&b0(function(){h0||ZF||(ZF=!0,console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"))}),C0.actQueue=null),0<C0.thrownErrors.length)throw L=X0(C0.thrownErrors),C0.thrownErrors.length=0,L;return{then:function(Z0,m0){h0=!0,N0===0?(C0.actQueue=g,$0(function(){return J0(I0,Z0,m0)})):Z0(I0)}}},HL.cache=function(L){return function(){return L.apply(null,arguments)}},HL.cacheSignal=function(){return null},HL.captureOwnerStack=function(){var L=C0.getCurrentStack;return L===null?null:L()},HL.cloneElement=function(L,p,N0){if(L===null||L===void 0)throw Error("The argument must be a React element, but you passed "+L+".");var g=OF({},L.props),h0=L.key,M0=L._owner;if(p!=null){var L0;F:{if(AF.call(p,"ref")&&(L0=Object.getOwnPropertyDescriptor(p,"ref").get)&&L0.isReactWarning){L0=!1;break F}L0=p.ref!==void 0}L0&&(M0=A()),M(p)&&(U(p.key),h0=""+p.key);for(I0 in p)!AF.call(p,I0)||I0==="key"||I0==="__self"||I0==="__source"||I0==="ref"&&p.ref===void 0||(g[I0]=p[I0])}var I0=arguments.length-2;if(I0===1)g.children=N0;else if(1<I0){L0=Array(I0);for(var Z0=0;Z0<I0;Z0++)L0[Z0]=arguments[Z0+2];g.children=L0}g=D(L.type,h0,g,M0,L._debugStack,L._debugTask);for(h0=2;h0<arguments.length;h0++)b(arguments[h0]);return g},HL.createContext=function(L){return L={$$typeof:_F,_currentValue:L,_currentValue2:L,_threadCount:0,Provider:null,Consumer:null},L.Provider=L,L.Consumer={$$typeof:g0,_context:L},L._currentRenderer=null,L._currentRenderer2=null,L},HL.createElement=function(L,p,N0){for(var g=2;g<arguments.length;g++)b(arguments[g]);g={};var h0=null;if(p!=null)for(Z0 in fF||!("__self"in p)||"key"in p||(fF=!0,console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")),M(p)&&(U(p.key),h0=""+p.key),p)AF.call(p,Z0)&&Z0!=="key"&&Z0!=="__self"&&Z0!=="__source"&&(g[Z0]=p[Z0]);var M0=arguments.length-2;if(M0===1)g.children=N0;else if(1<M0){for(var L0=Array(M0),I0=0;I0<M0;I0++)L0[I0]=arguments[I0+2];Object.freeze&&Object.freeze(L0),g.children=L0}if(L&&L.defaultProps)for(Z0 in M0=L.defaultProps,M0)g[Z0]===void 0&&(g[Z0]=M0[Z0]);h0&&T(g,typeof L==="function"?L.displayName||L.name||"Unknown":L);var Z0=1e4>C0.recentlyCreatedOwnerStacks++;return D(L,h0,g,A(),Z0?Error("react-stack-top-frame"):E,Z0?s0(h(L)):Y0)},HL.createRef=function(){var L={current:null};return Object.seal(L),L},HL.forwardRef=function(L){L!=null&&L.$$typeof===S0?console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."):typeof L!=="function"?console.error("forwardRef requires a render function but was given %s.",L===null?"null":typeof L):L.length!==0&&L.length!==2&&console.error("forwardRef render functions accept exactly two parameters: props and ref. %s",L.length===1?"Did you forget to use the ref parameter?":"Any additional parameter will be undefined."),L!=null&&L.defaultProps!=null&&console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");var p={$$typeof:c0,render:L},N0;return Object.defineProperty(p,"displayName",{enumerable:!1,configurable:!0,get:function(){return N0},set:function(g){N0=g,L.name||L.displayName||(Object.defineProperty(L,"name",{value:g}),L.displayName=g)}}),p},HL.isValidElement=k,HL.lazy=function(L){L={_status:-1,_result:L};var p={$$typeof:e0,_payload:L,_init:j},N0={name:"lazy",start:-1,end:-1,value:null,owner:null,debugStack:Error("react-stack-top-frame"),debugTask:console.createTask?console.createTask("lazy()"):null};return L._ioInfo=N0,p._debugInfo=[{awaited:N0}],p},HL.memo=function(L,p){L==null&&console.error("memo: The first argument must be a component. Instead received: %s",L===null?"null":typeof L),p={$$typeof:S0,type:L,compare:p===void 0?null:p};var N0;return Object.defineProperty(p,"displayName",{enumerable:!1,configurable:!0,get:function(){return N0},set:function(g){N0=g,L.name||L.displayName||(Object.defineProperty(L,"name",{value:g}),L.displayName=g)}}),p},HL.startTransition=function(L){var p=C0.T,N0={};N0._updatedFibers=new Set,C0.T=N0;try{var g=L(),h0=C0.S;h0!==null&&h0(N0,g),typeof g==="object"&&g!==null&&typeof g.then==="function"&&(C0.asyncTransitions++,g.then(d,d),g.then(K,W0))}catch(M0){W0(M0)}finally{p===null&&N0._updatedFibers&&(L=N0._updatedFibers.size,N0._updatedFibers.clear(),10<L&&console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")),p!==null&&N0.types!==null&&(p.types!==null&&p.types!==N0.types&&console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."),p.types=N0.types),C0.T=p}},HL.unstable_useCacheRefresh=function(){return V().useCacheRefresh()},HL.use=function(L){return V().use(L)},HL.useActionState=function(L,p,N0){return V().useActionState(L,p,N0)},HL.useCallback=function(L,p){return V().useCallback(L,p)},HL.useContext=function(L){var p=V();return L.$$typeof===g0&&console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"),p.useContext(L)},HL.useDebugValue=function(L,p){return V().useDebugValue(L,p)},HL.useDeferredValue=function(L,p){return V().useDeferredValue(L,p)},HL.useEffect=function(L,p){return L==null&&console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"),V().useEffect(L,p)},HL.useEffectEvent=function(L){return V().useEffectEvent(L)},HL.useId=function(){return V().useId()},HL.useImperativeHandle=function(L,p,N0){return V().useImperativeHandle(L,p,N0)},HL.useInsertionEffect=function(L,p){return L==null&&console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"),V().useInsertionEffect(L,p)},HL.useLayoutEffect=function(L,p){return L==null&&console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"),V().useLayoutEffect(L,p)},HL.useMemo=function(L,p){return V().useMemo(L,p)},HL.useOptimistic=function(L,p){return V().useOptimistic(L,p)},HL.useReducer=function(L,p,N0){return V().useReducer(L,p,N0)},HL.useRef=function(L){return V().useRef(L)},HL.useState=function(L){return V().useState(L)},HL.useSyncExternalStore=function(L,p,N0){return V().useSyncExternalStore(L,p,N0)},HL.useTransition=function(){return V().useTransition()},HL.version="19.2.3",typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});var lM=Y9((wL)=>{(function(){function F(){if(y=!1,s){var J0=wL.unstable_now();d=J0;var u=!0;try{F:{b=!1,k&&(k=!1,x(j),j=-1),O=!0;var n=D;try{q:{Y(J0);for(P=$(N);P!==null&&!(P.expirationTime>J0&&G());){var Q0=P.callback;if(typeof Q0==="function"){P.callback=null,D=P.priorityLevel;var O0=Q0(P.expirationTime<=J0);if(J0=wL.unstable_now(),typeof O0==="function"){P.callback=O0,Y(J0),u=!0;break q}P===$(N)&&W(N),Y(J0)}else W(N);P=$(N)}if(P!==null)u=!0;else{var t=$(M);t!==null&&U(K,t.startTime-J0),u=!1}}break F}finally{P=null,D=n,O=!1}u=void 0}}finally{u?$0():s=!1}}}function _(J0,u){var n=J0.length;J0.push(u);F:for(;0<n;){var Q0=n-1>>>1,O0=J0[Q0];if(0<H(O0,u))J0[Q0]=u,J0[n]=O0,n=Q0;else break F}}function $(J0){return J0.length===0?null:J0[0]}function W(J0){if(J0.length===0)return null;var u=J0[0],n=J0.pop();if(n!==u){J0[0]=n;F:for(var Q0=0,O0=J0.length,t=O0>>>1;Q0<t;){var T0=2*(Q0+1)-1,g0=J0[T0],_F=T0+1,c0=J0[_F];if(0>H(g0,n))_F<O0&&0>H(c0,g0)?(J0[Q0]=c0,J0[_F]=n,Q0=_F):(J0[Q0]=g0,J0[T0]=n,Q0=T0);else if(_F<O0&&0>H(c0,n))J0[Q0]=c0,J0[_F]=n,Q0=_F;else break F}}return u}function H(J0,u){var n=J0.sortIndex-u.sortIndex;return n!==0?n:J0.id-u.id}function Y(J0){for(var u=$(M);u!==null;){if(u.callback===null)W(M);else if(u.startTime<=J0)W(M),u.sortIndex=u.expirationTime,_(N,u);else break;u=$(M)}}function K(J0){if(k=!1,Y(J0),!b)if($(N)!==null)b=!0,s||(s=!0,$0());else{var u=$(M);u!==null&&U(K,u.startTime-J0)}}function G(){return y?!0:wL.unstable_now()-d<V?!1:!0}function U(J0,u){j=m(function(){J0(wL.unstable_now())},u)}if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()),wL.unstable_now=void 0,typeof performance==="object"&&typeof performance.now==="function"){var z=performance;wL.unstable_now=function(){return z.now()}}else{var h=Date,A=h.now();wL.unstable_now=function(){return h.now()-A}}var N=[],M=[],T=1,P=null,D=3,O=!1,b=!1,k=!1,y=!1,m=typeof setTimeout==="function"?setTimeout:null,x=typeof clearTimeout==="function"?clearTimeout:null,o=typeof setImmediate<"u"?setImmediate:null,s=!1,j=-1,V=5,d=-1;if(typeof o==="function")var $0=function(){o(F)};else if(typeof MessageChannel<"u"){var X0=new MessageChannel,K0=X0.port2;X0.port1.onmessage=F,$0=function(){K0.postMessage(null)}}else $0=function(){m(F,0)};wL.unstable_IdlePriority=5,wL.unstable_ImmediatePriority=1,wL.unstable_LowPriority=4,wL.unstable_NormalPriority=3,wL.unstable_Profiling=null,wL.unstable_UserBlockingPriority=2,wL.unstable_cancelCallback=function(J0){J0.callback=null},wL.unstable_forceFrameRate=function(J0){0>J0||125<J0?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):V=0<J0?Math.floor(1000/J0):5},wL.unstable_getCurrentPriorityLevel=function(){return D},wL.unstable_next=function(J0){switch(D){case 1:case 2:case 3:var u=3;break;default:u=D}var n=D;D=u;try{return J0()}finally{D=n}},wL.unstable_requestPaint=function(){y=!0},wL.unstable_runWithPriority=function(J0,u){switch(J0){case 1:case 2:case 3:case 4:case 5:break;default:J0=3}var n=D;D=J0;try{return u()}finally{D=n}},wL.unstable_scheduleCallback=function(J0,u,n){var Q0=wL.unstable_now();switch(typeof n==="object"&&n!==null?(n=n.delay,n=typeof n==="number"&&0<n?Q0+n:Q0):n=Q0,J0){case 1:var O0=-1;break;case 2:O0=250;break;case 5:O0=1073741823;break;case 4:O0=1e4;break;default:O0=5000}return O0=n+O0,J0={id:T++,callback:u,priorityLevel:J0,startTime:n,expirationTime:O0,sortIndex:-1},n>Q0?(J0.sortIndex=n,_(M,J0),$(N)===null&&J0===$(M)&&(k?(x(j),j=-1):k=!0,U(K,n-Q0))):(J0.sortIndex=O0,_(N,J0),b||O||(b=!0,s||(s=!0,$0()))),J0},wL.unstable_shouldYield=G,wL.unstable_wrapCallback=function(J0){var u=D;return function(){var n=D;D=u;try{return J0.apply(this,arguments)}finally{D=n}}},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});var dM=Y9((YL)=>{var W5=U6(d_());(function(){function F(){}function _(h){return""+h}function $(h,A,N){var M=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;try{_(M);var T=!1}catch(P){T=!0}return T&&(console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",typeof Symbol==="function"&&Symbol.toStringTag&&M[Symbol.toStringTag]||M.constructor.name||"Object"),_(M)),{$$typeof:U,key:M==null?null:""+M,children:h,containerInfo:A,implementation:N}}function W(h,A){if(h==="font")return"";if(typeof A==="string")return A==="use-credentials"?A:""}function H(h){return h===null?"`null`":h===void 0?"`undefined`":h===""?"an empty string":'something with type "'+typeof h+'"'}function Y(h){return h===null?"`null`":h===void 0?"`undefined`":h===""?"an empty string":typeof h==="string"?JSON.stringify(h):typeof h==="number"?"`"+h+"`":'something with type "'+typeof h+'"'}function K(){var h=z.H;return h===null&&console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`),h}typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());var G={d:{f:F,r:function(){throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.")},D:F,C:F,L:F,m:F,X:F,S:F,M:F},p:0,findDOMNode:null},U=Symbol.for("react.portal"),z=W5.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;typeof Map==="function"&&Map.prototype!=null&&typeof Map.prototype.forEach==="function"&&typeof Set==="function"&&Set.prototype!=null&&typeof Set.prototype.clear==="function"&&typeof Set.prototype.forEach==="function"||console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),YL.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=G,YL.createPortal=function(h,A){var N=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!A||A.nodeType!==1&&A.nodeType!==9&&A.nodeType!==11)throw Error("Target container is not a DOM element.");return $(h,A,null,N)},YL.flushSync=function(h){var A=z.T,N=G.p;try{if(z.T=null,G.p=2,h)return h()}finally{z.T=A,G.p=N,G.d.f()&&console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.")}},YL.preconnect=function(h,A){typeof h==="string"&&h?A!=null&&typeof A!=="object"?console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",Y(A)):A!=null&&typeof A.crossOrigin!=="string"&&console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",H(A.crossOrigin)):console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",H(h)),typeof h==="string"&&(A?(A=A.crossOrigin,A=typeof A==="string"?A==="use-credentials"?A:"":void 0):A=null,G.d.C(h,A))},YL.prefetchDNS=function(h){if(typeof h!=="string"||!h)console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",H(h));else if(1<arguments.length){var A=arguments[1];typeof A==="object"&&A.hasOwnProperty("crossOrigin")?console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",Y(A)):console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",Y(A))}typeof h==="string"&&G.d.D(h)},YL.preinit=function(h,A){if(typeof h==="string"&&h?A==null||typeof A!=="object"?console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",Y(A)):A.as!=="style"&&A.as!=="script"&&console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',Y(A.as)):console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",H(h)),typeof h==="string"&&A&&typeof A.as==="string"){var N=A.as,M=W(N,A.crossOrigin),T=typeof A.integrity==="string"?A.integrity:void 0,P=typeof A.fetchPriority==="string"?A.fetchPriority:void 0;N==="style"?G.d.S(h,typeof A.precedence==="string"?A.precedence:void 0,{crossOrigin:M,integrity:T,fetchPriority:P}):N==="script"&&G.d.X(h,{crossOrigin:M,integrity:T,fetchPriority:P,nonce:typeof A.nonce==="string"?A.nonce:void 0})}},YL.preinitModule=function(h,A){var N="";if(typeof h==="string"&&h||(N+=" The `href` argument encountered was "+H(h)+"."),A!==void 0&&typeof A!=="object"?N+=" The `options` argument encountered was "+H(A)+".":A&&("as"in A)&&A.as!=="script"&&(N+=" The `as` option encountered was "+Y(A.as)+"."),N)console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",N);else switch(N=A&&typeof A.as==="string"?A.as:"script",N){case"script":break;default:N=Y(N),console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',N,h)}if(typeof h==="string")if(typeof A==="object"&&A!==null){if(A.as==null||A.as==="script")N=W(A.as,A.crossOrigin),G.d.M(h,{crossOrigin:N,integrity:typeof A.integrity==="string"?A.integrity:void 0,nonce:typeof A.nonce==="string"?A.nonce:void 0})}else A==null&&G.d.M(h)},YL.preload=function(h,A){var N="";if(typeof h==="string"&&h||(N+=" The `href` argument encountered was "+H(h)+"."),A==null||typeof A!=="object"?N+=" The `options` argument encountered was "+H(A)+".":typeof A.as==="string"&&A.as||(N+=" The `as` option encountered was "+H(A.as)+"."),N&&console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',N),typeof h==="string"&&typeof A==="object"&&A!==null&&typeof A.as==="string"){N=A.as;var M=W(N,A.crossOrigin);G.d.L(h,N,{crossOrigin:M,integrity:typeof A.integrity==="string"?A.integrity:void 0,nonce:typeof A.nonce==="string"?A.nonce:void 0,type:typeof A.type==="string"?A.type:void 0,fetchPriority:typeof A.fetchPriority==="string"?A.fetchPriority:void 0,referrerPolicy:typeof A.referrerPolicy==="string"?A.referrerPolicy:void 0,imageSrcSet:typeof A.imageSrcSet==="string"?A.imageSrcSet:void 0,imageSizes:typeof A.imageSizes==="string"?A.imageSizes:void 0,media:typeof A.media==="string"?A.media:void 0})}},YL.preloadModule=function(h,A){var N="";typeof h==="string"&&h||(N+=" The `href` argument encountered was "+H(h)+"."),A!==void 0&&typeof A!=="object"?N+=" The `options` argument encountered was "+H(A)+".":A&&("as"in A)&&typeof A.as!=="string"&&(N+=" The `as` option encountered was "+H(A.as)+"."),N&&console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',N),typeof h==="string"&&(A?(N=W(A.as,A.crossOrigin),G.d.m(h,{as:typeof A.as==="string"&&A.as!=="script"?A.as:void 0,crossOrigin:N,integrity:typeof A.integrity==="string"?A.integrity:void 0})):G.d.m(h))},YL.requestFormReset=function(h){G.d.r(h)},YL.unstable_batchedUpdates=function(h,A){return h(A)},YL.useFormState=function(h,A,N){return K().useFormState(h,A,N)},YL.useFormStatus=function(){return K().useHostTransitionStatus()},YL.version="19.2.3",typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});var nM=Y9((Lj,iM)=>{var XL=U6(dM());iM.exports=XL});var cM=Y9((GL)=>{var oF=U6(lM()),i_=U6(d_()),H5=U6(nM());(function(){function F(q,J){for(q=q.memoizedState;q!==null&&0<J;)q=q.next,J--;return q}function _(q,J,Z,Q){if(Z>=J.length)return Q;var w=J[Z],X=p1(q)?q.slice():yF({},q);return X[w]=_(q[w],J,Z+1,Q),X}function $(q,J,Z){if(J.length!==Z.length)console.warn("copyWithRename() expects paths of the same length");else{for(var Q=0;Q<Z.length-1;Q++)if(J[Q]!==Z[Q]){console.warn("copyWithRename() expects paths to be the same except for the deepest key");return}return W(q,J,Z,0)}}function W(q,J,Z,Q){var w=J[Q],X=p1(q)?q.slice():yF({},q);return Q+1===J.length?(X[Z[Q]]=X[w],p1(X)?X.splice(w,1):delete X[w]):X[w]=W(q[w],J,Z,Q+1),X}function H(q,J,Z){var Q=J[Z],w=p1(q)?q.slice():yF({},q);if(Z+1===J.length)return p1(w)?w.splice(Q,1):delete w[Q],w;return w[Q]=H(q[Q],J,Z+1),w}function Y(){return!1}function K(){return null}function G(){console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks")}function U(){console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().")}function z(){}function h(){}function A(q){var J=[];return q.forEach(function(Z){J.push(Z)}),J.sort().join(", ")}function N(q,J,Z,Q){return new cI(q,J,Z,Q)}function M(q,J){q.context===n9&&(TG(q.current,2,J,q,null,null),q_())}function T(q,J){if(A8!==null){var Z=J.staleFamilies;J=J.updatedFamilies,J$(),oz(q.current,J,Z),q_()}}function P(q){A8=q}function D(q){return!(!q||q.nodeType!==1&&q.nodeType!==9&&q.nodeType!==11)}function O(q){var J=q,Z=q;if(q.alternate)for(;J.return;)J=J.return;else{q=J;do J=q,(J.flags&4098)!==0&&(Z=J.return),q=J.return;while(q)}return J.tag===3?Z:null}function b(q){if(q.tag===13){var J=q.memoizedState;if(J===null&&(q=q.alternate,q!==null&&(J=q.memoizedState)),J!==null)return J.dehydrated}return null}function k(q){if(q.tag===31){var J=q.memoizedState;if(J===null&&(q=q.alternate,q!==null&&(J=q.memoizedState)),J!==null)return J.dehydrated}return null}function y(q){if(O(q)!==q)throw Error("Unable to find node on an unmounted component.")}function m(q){var J=q.alternate;if(!J){if(J=O(q),J===null)throw Error("Unable to find node on an unmounted component.");return J!==q?null:q}for(var Z=q,Q=J;;){var w=Z.return;if(w===null)break;var X=w.alternate;if(X===null){if(Q=w.return,Q!==null){Z=Q;continue}break}if(w.child===X.child){for(X=w.child;X;){if(X===Z)return y(w),q;if(X===Q)return y(w),J;X=X.sibling}throw Error("Unable to find node on an unmounted component.")}if(Z.return!==Q.return)Z=w,Q=X;else{for(var B=!1,R=w.child;R;){if(R===Z){B=!0,Z=w,Q=X;break}if(R===Q){B=!0,Q=w,Z=X;break}R=R.sibling}if(!B){for(R=X.child;R;){if(R===Z){B=!0,Z=X,Q=w;break}if(R===Q){B=!0,Q=X,Z=w;break}R=R.sibling}if(!B)throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.")}}if(Z.alternate!==Q)throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.")}if(Z.tag!==3)throw Error("Unable to find node on an unmounted component.");return Z.stateNode.current===Z?q:J}function x(q){var J=q.tag;if(J===5||J===26||J===27||J===6)return q;for(q=q.child;q!==null;){if(J=x(q),J!==null)return J;q=q.sibling}return null}function o(q){if(q===null||typeof q!=="object")return null;return q=JN&&q[JN]||q["@@iterator"],typeof q==="function"?q:null}function s(q){if(q==null)return null;if(typeof q==="function")return q.$$typeof===U4?null:q.displayName||q.name||null;if(typeof q==="string")return q;switch(q){case H_:return"Fragment";case kG:return"Profiler";case FH:return"StrictMode";case yG:return"Suspense";case vG:return"SuspenseList";case bG:return"Activity"}if(typeof q==="object")switch(typeof q.tag==="number"&&console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),q.$$typeof){case W_:return"Portal";case N7:return q.displayName||"Context";case SG:return(q._context.displayName||"Context")+".Consumer";case G$:var J=q.render;return q=q.displayName,q||(q=J.displayName||J.name||"",q=q!==""?"ForwardRef("+q+")":"ForwardRef"),q;case qH:return J=q.displayName||null,J!==null?J:s(q.type)||"Memo";case e6:J=q._payload,q=q._init;try{return s(q(J))}catch(Z){}}return null}function j(q){return typeof q.tag==="number"?V(q):typeof q.name==="string"?q.name:null}function V(q){var J=q.type;switch(q.tag){case 31:return"Activity";case 24:return"Cache";case 9:return(J._context.displayName||"Context")+".Consumer";case 10:return J.displayName||"Context";case 18:return"DehydratedFragment";case 11:return q=J.render,q=q.displayName||q.name||"",J.displayName||(q!==""?"ForwardRef("+q+")":"ForwardRef");case 7:return"Fragment";case 26:case 27:case 5:return J;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return s(J);case 8:return J===FH?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 14:case 15:if(typeof J==="function")return J.displayName||J.name||null;if(typeof J==="string")return J;break;case 29:if(J=q._debugInfo,J!=null){for(var Z=J.length-1;0<=Z;Z--)if(typeof J[Z].name==="string")return J[Z].name}if(q.return!==null)return V(q.return)}return null}function d(q){return{current:q}}function $0(q,J){0>c7?console.error("Unexpected pop."):(J!==xG[c7]&&console.error("Unexpected Fiber popped."),q.current=jG[c7],jG[c7]=null,xG[c7]=null,c7--)}function X0(q,J,Z){c7++,jG[c7]=q.current,xG[c7]=Z,q.current=J}function K0(q){return q===null&&console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."),q}function J0(q,J){X0(u9,J,q),X0(K$,q,q),X0(g9,null,q);var Z=J.nodeType;switch(Z){case 9:case 11:Z=Z===9?"#document":"#fragment",J=(J=J.documentElement)?(J=J.namespaceURI)?TR(J):W9:W9;break;default:if(Z=J.tagName,J=J.namespaceURI)J=TR(J),J=LR(J,Z);else switch(Z){case"svg":J=m_;break;case"math":J=eH;break;default:J=W9}}Z=Z.toLowerCase(),Z=HF(null,Z),Z={context:J,ancestorInfo:Z},$0(g9,q),X0(g9,Z,q)}function u(q){$0(g9,q),$0(K$,q),$0(u9,q)}function n(){return K0(g9.current)}function Q0(q){q.memoizedState!==null&&X0(JH,q,q);var J=K0(g9.current),Z=q.type,Q=LR(J.context,Z);Z=HF(J.ancestorInfo,Z),Q={context:Q,ancestorInfo:Z},J!==Q&&(X0(K$,q,q),X0(g9,Q,q))}function O0(q){K$.current===q&&($0(g9,q),$0(K$,q)),JH.current===q&&($0(JH,q),ZQ._currentValue=BJ)}function t(){}function T0(){if(U$===0){_N=console.log,ZN=console.info,$N=console.warn,QN=console.error,WN=console.group,HN=console.groupCollapsed,wN=console.groupEnd;var q={configurable:!0,enumerable:!0,value:t,writable:!0};Object.defineProperties(console,{info:q,log:q,warn:q,error:q,group:q,groupCollapsed:q,groupEnd:q})}U$++}function g0(){if(U$--,U$===0){var q={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:yF({},q,{value:_N}),info:yF({},q,{value:ZN}),warn:yF({},q,{value:$N}),error:yF({},q,{value:QN}),group:yF({},q,{value:WN}),groupCollapsed:yF({},q,{value:HN}),groupEnd:yF({},q,{value:wN})})}0>U$&&console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}function _F(q){var J=Error.prepareStackTrace;if(Error.prepareStackTrace=void 0,q=q.stack,Error.prepareStackTrace=J,q.startsWith(`Error: react-stack-top-frame
`)&&(q=q.slice(29)),J=q.indexOf(`
`),J!==-1&&(q=q.slice(J+1)),J=q.indexOf("react_stack_bottom_frame"),J!==-1&&(J=q.lastIndexOf(`
`,J)),J!==-1)q=q.slice(0,J);else return"";return q}function c0(q){if(gG===void 0)try{throw Error()}catch(Z){var J=Z.stack.trim().match(/\n( *(at )?)/);gG=J&&J[1]||"",YN=-1<Z.stack.indexOf(`
    at`)?" (<anonymous>)":-1<Z.stack.indexOf("@")?"@unknown:0:0":""}return`
`+gG+q+YN}function D0(q,J){if(!q||uG)return"";var Z=pG.get(q);if(Z!==void 0)return Z;uG=!0,Z=Error.prepareStackTrace,Error.prepareStackTrace=void 0;var Q=null;Q=R0.H,R0.H=null,T0();try{var w={DetermineComponentFrameRoot:function(){try{if(J){var i=function(){throw Error()};if(Object.defineProperty(i.prototype,"props",{set:function(){throw Error()}}),typeof Reflect==="object"&&Reflect.construct){try{Reflect.construct(i,[])}catch(x0){var U0=x0}Reflect.construct(q,[],i)}else{try{i.call()}catch(x0){U0=x0}q.call(i.prototype)}}else{try{throw Error()}catch(x0){U0=x0}(i=q())&&typeof i.catch==="function"&&i.catch(function(){})}}catch(x0){if(x0&&U0&&typeof x0.stack==="string")return[x0.stack,U0.stack]}return[null,null]}};w.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var X=Object.getOwnPropertyDescriptor(w.DetermineComponentFrameRoot,"name");X&&X.configurable&&Object.defineProperty(w.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var B=w.DetermineComponentFrameRoot(),R=B[0],I=B[1];if(R&&I){var C=R.split(`
`),e=I.split(`
`);for(B=X=0;X<C.length&&!C[X].includes("DetermineComponentFrameRoot");)X++;for(;B<e.length&&!e[B].includes("DetermineComponentFrameRoot");)B++;if(X===C.length||B===e.length)for(X=C.length-1,B=e.length-1;1<=X&&0<=B&&C[X]!==e[B];)B--;for(;1<=X&&0<=B;X--,B--)if(C[X]!==e[B]){if(X!==1||B!==1)do if(X--,B--,0>B||C[X]!==e[B]){var F0=`
`+C[X].replace(" at new "," at ");return q.displayName&&F0.includes("<anonymous>")&&(F0=F0.replace("<anonymous>",q.displayName)),typeof q==="function"&&pG.set(q,F0),F0}while(1<=X&&0<=B);break}}}finally{uG=!1,R0.H=Q,g0(),Error.prepareStackTrace=Z}return C=(C=q?q.displayName||q.name:"")?c0(C):"",typeof q==="function"&&pG.set(q,C),C}function P0(q,J){switch(q.tag){case 26:case 27:case 5:return c0(q.type);case 16:return c0("Lazy");case 13:return q.child!==J&&J!==null?c0("Suspense Fallback"):c0("Suspense");case 19:return c0("SuspenseList");case 0:case 15:return D0(q.type,!1);case 11:return D0(q.type.render,!1);case 1:return D0(q.type,!0);case 31:return c0("Activity");default:return""}}function S0(q){try{var J="",Z=null;do{J+=P0(q,Z);var Q=q._debugInfo;if(Q)for(var w=Q.length-1;0<=w;w--){var X=Q[w];if(typeof X.name==="string"){var B=J;F:{var{name:R,env:I,debugLocation:C}=X;if(C!=null){var e=_F(C),F0=e.lastIndexOf(`
`),i=F0===-1?e:e.slice(F0+1);if(i.indexOf(R)!==-1){var U0=`
`+i;break F}}U0=c0(R+(I?" ["+I+"]":""))}J=B+U0}}Z=q,q=q.return}while(q);return J}catch(x0){return`
Error generating stack: `+x0.message+`
`+x0.stack}}function e0(q){return(q=q?q.displayName||q.name:"")?c0(q):""}function JF(){if(F8===null)return null;var q=F8._debugOwner;return q!=null?j(q):null}function UF(){if(F8===null)return"";var q=F8;try{var J="";switch(q.tag===6&&(q=q.return),q.tag){case 26:case 27:case 5:J+=c0(q.type);break;case 13:J+=c0("Suspense");break;case 19:J+=c0("SuspenseList");break;case 31:J+=c0("Activity");break;case 30:case 0:case 15:case 1:q._debugOwner||J!==""||(J+=e0(q.type));break;case 11:q._debugOwner||J!==""||(J+=e0(q.type.render))}for(;q;)if(typeof q.tag==="number"){var Z=q;q=Z._debugOwner;var Q=Z._debugStack;if(q&&Q){var w=_F(Q);w!==""&&(J+=`
`+w)}}else if(q.debugStack!=null){var X=q.debugStack;(q=q.owner)&&X&&(J+=`
`+_F(X))}else break;var B=J}catch(R){B=`
Error generating stack: `+R.message+`
`+R.stack}return B}function v0(q,J,Z,Q,w,X,B){var R=F8;PF(q);try{return q!==null&&q._debugTask?q._debugTask.run(J.bind(null,Z,Q,w,X,B)):J(Z,Q,w,X,B)}finally{PF(R)}throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.")}function PF(q){R0.getCurrentStack=q===null?null:UF,D7=!1,F8=q}function OF(q){return typeof Symbol==="function"&&Symbol.toStringTag&&q[Symbol.toStringTag]||q.constructor.name||"Object"}function jF(q){try{return t0(q),!1}catch(J){return!0}}function t0(q){return""+q}function XF(q,J){if(jF(q))return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",J,OF(q)),t0(q)}function a(q,J){if(jF(q))return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",J,OF(q)),t0(q)}function C0(q){if(jF(q))return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",OF(q)),t0(q)}function AF(q){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")return!1;var J=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(J.isDisabled)return!0;if(!J.supportsFiber)return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"),!0;try{Y_=J.inject(q),G6=J}catch(Z){console.error("React instrumentation encountered an error: %o.",Z)}return J.checkDCE?!0:!1}function s0(q){if(typeof D4==="function"&&M4(q),G6&&typeof G6.setStrictMode==="function")try{G6.setStrictMode(Y_,q)}catch(J){M7||(M7=!0,console.error("React instrumentation encountered an error: %o",J))}}function j0(q){return q>>>=0,q===0?32:31-(O4(q)/f4|0)|0}function fF(q){var J=q&42;if(J!==0)return J;switch(q&-q){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return q&261888;case 262144:case 524288:case 1048576:case 2097152:return q&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return q&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return console.error("Should have found matching lanes. This is a bug in React."),q}}function v(q,J,Z){var Q=q.pendingLanes;if(Q===0)return 0;var w=0,X=q.suspendedLanes,B=q.pingedLanes;q=q.warmLanes;var R=Q&134217727;return R!==0?(Q=R&~X,Q!==0?w=fF(Q):(B&=R,B!==0?w=fF(B):Z||(Z=R&~q,Z!==0&&(w=fF(Z))))):(R=Q&~X,R!==0?w=fF(R):B!==0?w=fF(B):Z||(Z=Q&~q,Z!==0&&(w=fF(Z)))),w===0?0:J!==0&&J!==w&&(J&X)===0&&(X=w&-w,Z=J&-J,X>=Z||X===32&&(Z&4194048)!==0)?J:w}function E(q,J){return(q.pendingLanes&~(q.suspendedLanes&~q.pingedLanes)&J)===0}function Y0(q,J){switch(q){case 1:case 2:case 4:case 8:case 64:return J+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return J+5000;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return console.error("Should have found matching lanes. This is a bug in React."),-1}}function q0(){var q=$H;return $H<<=1,($H&62914560)===0&&($H=4194304),q}function H0(q){for(var J=[],Z=0;31>Z;Z++)J.push(q);return J}function W0(q,J){q.pendingLanes|=J,J!==268435456&&(q.suspendedLanes=0,q.pingedLanes=0,q.warmLanes=0)}function y0(q,J,Z,Q,w,X){var B=q.pendingLanes;q.pendingLanes=Z,q.suspendedLanes=0,q.pingedLanes=0,q.warmLanes=0,q.expiredLanes&=Z,q.entangledLanes&=Z,q.errorRecoveryDisabledLanes&=Z,q.shellSuspendCounter=0;var{entanglements:R,expirationTimes:I,hiddenUpdates:C}=q;for(Z=B&~Z;0<Z;){var e=31-M6(Z),F0=1<<e;R[e]=0,I[e]=-1;var i=C[e];if(i!==null)for(C[e]=null,e=0;e<i.length;e++){var U0=i[e];U0!==null&&(U0.lane&=-536870913)}Z&=~F0}Q!==0&&E0(q,Q,0),X!==0&&w===0&&q.tag!==0&&(q.suspendedLanes|=X&~(B&~J))}function E0(q,J,Z){q.pendingLanes|=J,q.suspendedLanes&=~J;var Q=31-M6(J);q.entangledLanes|=J,q.entanglements[Q]=q.entanglements[Q]|1073741824|Z&261930}function n0(q,J){var Z=q.entangledLanes|=J;for(q=q.entanglements;Z;){var Q=31-M6(Z),w=1<<Q;w&J|q[Q]&J&&(q[Q]|=J),Z&=~w}}function ZF(q,J){var Z=J&-J;return Z=(Z&42)!==0?1:V0(Z),(Z&(q.suspendedLanes|J))!==0?0:Z}function V0(q){switch(q){case 2:q=1;break;case 8:q=4;break;case 32:q=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:q=128;break;case 268435456:q=134217728;break;default:q=0}return q}function b0(q,J,Z){if(O7)for(q=q.pendingUpdatersLaneMap;0<Z;){var Q=31-M6(Z),w=1<<Q;q[Q].add(J),Z&=~w}}function a0(q,J){if(O7)for(var{pendingUpdatersLaneMap:Z,memoizedUpdaters:Q}=q;0<J;){var w=31-M6(J);q=1<<w,w=Z[w],0<w.size&&(w.forEach(function(X){var B=X.alternate;B!==null&&Q.has(B)||Q.add(X)}),w.clear()),J&=~q}}function L(q){return q&=-q,q8!==0&&q8<q?u8!==0&&u8<q?(q&134217727)!==0?f7:QH:u8:q8}function p(){var q=F1.p;if(q!==0)return q;return q=window.event,q===void 0?f7:oR(q.type)}function N0(q,J){var Z=F1.p;try{return F1.p=q,J()}finally{F1.p=Z}}function g(q){delete q[H6],delete q[O6],delete q[nG],delete q[I4],delete q[T4]}function h0(q){var J=q[H6];if(J)return J;for(var Z=q.parentNode;Z;){if(J=Z[m9]||Z[H6]){if(Z=J.alternate,J.child!==null||Z!==null&&Z.child!==null)for(q=vR(q);q!==null;){if(Z=q[H6])return Z;q=vR(q)}return J}q=Z,Z=q.parentNode}return null}function M0(q){if(q=q[H6]||q[m9]){var J=q.tag;if(J===5||J===6||J===13||J===31||J===26||J===27||J===3)return q}return null}function L0(q){var J=q.tag;if(J===5||J===26||J===27||J===6)return q.stateNode;throw Error("getNodeFromInstance: Invalid argument.")}function I0(q){var J=q[XN];return J||(J=q[XN]={hoistableStyles:new Map,hoistableScripts:new Map}),J}function Z0(q){q[B$]=!0}function m0(q,J){$F(q,J),$F(q+"Capture",J)}function $F(q,J){cq[q]&&console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",q),cq[q]=J;var Z=q.toLowerCase();cG[Z]=q,q==="onDoubleClick"&&(cG.ondblclick=q);for(q=0;q<J.length;q++)GN.add(J[q])}function iF(q,J){L4[J.type]||J.onChange||J.onInput||J.readOnly||J.disabled||J.value==null||(q==="select"?console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."):console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.")),J.onChange||J.readOnly||J.disabled||J.checked==null||console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.")}function nF(q){if(g8.call(UN,q))return!0;if(g8.call(KN,q))return!1;if(E4.test(q))return UN[q]=!0;return KN[q]=!0,console.error("Invalid attribute name: `%s`",q),!1}function K8(q,J,Z){if(nF(J)){if(!q.hasAttribute(J)){switch(typeof Z){case"symbol":case"object":return Z;case"function":return Z;case"boolean":if(Z===!1)return Z}return Z===void 0?void 0:null}if(q=q.getAttribute(J),q===""&&Z===!0)return!0;return XF(Z,J),q===""+Z?Z:q}}function y6(q,J,Z){if(nF(J))if(Z===null)q.removeAttribute(J);else{switch(typeof Z){case"undefined":case"function":case"symbol":q.removeAttribute(J);return;case"boolean":var Q=J.toLowerCase().slice(0,5);if(Q!=="data-"&&Q!=="aria-"){q.removeAttribute(J);return}}XF(Z,J),q.setAttribute(J,""+Z)}}function Cq(q,J,Z){if(Z===null)q.removeAttribute(J);else{switch(typeof Z){case"undefined":case"function":case"symbol":case"boolean":q.removeAttribute(J);return}XF(Z,J),q.setAttribute(J,""+Z)}}function i6(q,J,Z,Q){if(Q===null)q.removeAttribute(Z);else{switch(typeof Q){case"undefined":case"function":case"symbol":case"boolean":q.removeAttribute(Z);return}XF(Q,Z),q.setAttributeNS(J,Z,""+Q)}}function v6(q){switch(typeof q){case"bigint":case"boolean":case"number":case"string":case"undefined":return q;case"object":return C0(q),q;default:return""}}function kZ(q){var J=q.type;return(q=q.nodeName)&&q.toLowerCase()==="input"&&(J==="checkbox"||J==="radio")}function iQ(q,J,Z){var Q=Object.getOwnPropertyDescriptor(q.constructor.prototype,J);if(!q.hasOwnProperty(J)&&typeof Q<"u"&&typeof Q.get==="function"&&typeof Q.set==="function"){var{get:w,set:X}=Q;return Object.defineProperty(q,J,{configurable:!0,get:function(){return w.call(this)},set:function(B){C0(B),Z=""+B,X.call(this,B)}}),Object.defineProperty(q,J,{enumerable:Q.enumerable}),{getValue:function(){return Z},setValue:function(B){C0(B),Z=""+B},stopTracking:function(){q._valueTracker=null,delete q[J]}}}}function y8(q){if(!q._valueTracker){var J=kZ(q)?"checked":"value";q._valueTracker=iQ(q,J,""+q[J])}}function lJ(q){if(!q)return!1;var J=q._valueTracker;if(!J)return!0;var Z=J.getValue(),Q="";return q&&(Q=kZ(q)?q.checked?"true":"false":q.value),q=Q,q!==Z?(J.setValue(q),!0):!1}function Pq(q){if(q=q||(typeof document<"u"?document:void 0),typeof q>"u")return null;try{return q.activeElement||q.body}catch(J){return q.body}}function R6(q){return q.replace(C4,function(J){return"\\"+J.charCodeAt(0).toString(16)+" "})}function Vq(q,J){J.checked===void 0||J.defaultChecked===void 0||zN||(console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",JF()||"A component",J.type),zN=!0),J.value===void 0||J.defaultValue===void 0||BN||(console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",JF()||"A component",J.type),BN=!0)}function dJ(q,J,Z,Q,w,X,B,R){if(q.name="",B!=null&&typeof B!=="function"&&typeof B!=="symbol"&&typeof B!=="boolean"?(XF(B,"type"),q.type=B):q.removeAttribute("type"),J!=null)if(B==="number"){if(J===0&&q.value===""||q.value!=J)q.value=""+v6(J)}else q.value!==""+v6(J)&&(q.value=""+v6(J));else B!=="submit"&&B!=="reset"||q.removeAttribute("value");J!=null?iJ(q,B,v6(J)):Z!=null?iJ(q,B,v6(Z)):Q!=null&&q.removeAttribute("value"),w==null&&X!=null&&(q.defaultChecked=!!X),w!=null&&(q.checked=w&&typeof w!=="function"&&typeof w!=="symbol"),R!=null&&typeof R!=="function"&&typeof R!=="symbol"&&typeof R!=="boolean"?(XF(R,"name"),q.name=""+v6(R)):q.removeAttribute("name")}function kq(q,J,Z,Q,w,X,B,R){if(X!=null&&typeof X!=="function"&&typeof X!=="symbol"&&typeof X!=="boolean"&&(XF(X,"type"),q.type=X),J!=null||Z!=null){if(!(X!=="submit"&&X!=="reset"||J!==void 0&&J!==null)){y8(q);return}Z=Z!=null?""+v6(Z):"",J=J!=null?""+v6(J):Z,R||J===q.value||(q.value=J),q.defaultValue=J}Q=Q!=null?Q:w,Q=typeof Q!=="function"&&typeof Q!=="symbol"&&!!Q,q.checked=R?q.checked:!!Q,q.defaultChecked=!!Q,B!=null&&typeof B!=="function"&&typeof B!=="symbol"&&typeof B!=="boolean"&&(XF(B,"name"),q.name=B),y8(q)}function iJ(q,J,Z){J==="number"&&Pq(q.ownerDocument)===q||q.defaultValue===""+Z||(q.defaultValue=""+Z)}function SZ(q,J){J.value==null&&(typeof J.children==="object"&&J.children!==null?i_.Children.forEach(J.children,function(Z){Z==null||typeof Z==="string"||typeof Z==="number"||typeof Z==="bigint"||hN||(hN=!0,console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."))}):J.dangerouslySetInnerHTML==null||RN||(RN=!0,console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))),J.selected==null||AN||(console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."),AN=!0)}function nQ(){var q=JF();return q?`

Check the render method of \``+q+"`.":""}function T9(q,J,Z,Q){if(q=q.options,J){J={};for(var w=0;w<Z.length;w++)J["$"+Z[w]]=!0;for(Z=0;Z<q.length;Z++)w=J.hasOwnProperty("$"+q[Z].value),q[Z].selected!==w&&(q[Z].selected=w),w&&Q&&(q[Z].defaultSelected=!0)}else{Z=""+v6(Z),J=null;for(w=0;w<q.length;w++){if(q[w].value===Z){q[w].selected=!0,Q&&(q[w].defaultSelected=!0);return}J!==null||q[w].disabled||(J=q[w])}J!==null&&(J.selected=!0)}}function cQ(q,J){for(q=0;q<DN.length;q++){var Z=DN[q];if(J[Z]!=null){var Q=p1(J[Z]);J.multiple&&!Q?console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",Z,nQ()):!J.multiple&&Q&&console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",Z,nQ())}}J.value===void 0||J.defaultValue===void 0||NN||(console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"),NN=!0)}function sQ(q,J){J.value===void 0||J.defaultValue===void 0||MN||(console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",JF()||"A component"),MN=!0),J.children!=null&&J.value==null&&console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.")}function oQ(q,J,Z){if(J!=null&&(J=""+v6(J),J!==q.value&&(q.value=J),Z==null)){q.defaultValue!==J&&(q.defaultValue=J);return}q.defaultValue=Z!=null?""+v6(Z):""}function aQ(q,J,Z,Q){if(J==null){if(Q!=null){if(Z!=null)throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");if(p1(Q)){if(1<Q.length)throw Error("<textarea> can only have at most one child.");Q=Q[0]}Z=Q}Z==null&&(Z=""),J=Z}Z=v6(J),q.defaultValue=Z,Q=q.textContent,Q===Z&&Q!==""&&Q!==null&&(q.value=Q),y8(q)}function S(q,J){return q.serverProps===void 0&&q.serverTail.length===0&&q.children.length===1&&3<q.distanceFromLeaf&&q.distanceFromLeaf>15-J?S(q.children[0],J):q}function _0(q){return"  "+"  ".repeat(q)}function z0(q){return"+ "+"  ".repeat(q)}function B0(q){return"- "+"  ".repeat(q)}function G0(q){switch(q.tag){case 26:case 27:case 5:return q.type;case 16:return"Lazy";case 31:return"Activity";case 13:return"Suspense";case 19:return"SuspenseList";case 0:case 15:return q=q.type,q.displayName||q.name||null;case 11:return q=q.type.render,q.displayName||q.name||null;case 1:return q=q.type,q.displayName||q.name||null;default:return null}}function u0(q,J){return ON.test(q)?(q=JSON.stringify(q),q.length>J-2?8>J?'{"..."}':"{"+q.slice(0,J-7)+'..."}':"{"+q+"}"):q.length>J?5>J?'{"..."}':q.slice(0,J-3)+"...":q}function o0(q,J,Z){var Q=120-2*Z;if(J===null)return z0(Z)+u0(q,Q)+`
`;if(typeof J==="string"){for(var w=0;w<J.length&&w<q.length&&J.charCodeAt(w)===q.charCodeAt(w);w++);return w>Q-8&&10<w&&(q="..."+q.slice(w-8),J="..."+J.slice(w-8)),z0(Z)+u0(q,Q)+`
`+B0(Z)+u0(J,Q)+`
`}return _0(Z)+u0(q,Q)+`
`}function l0(q){return Object.prototype.toString.call(q).replace(/^\[object (.*)\]$/,function(J,Z){return Z})}function r0(q,J){switch(typeof q){case"string":return q=JSON.stringify(q),q.length>J?5>J?'"..."':q.slice(0,J-4)+'..."':q;case"object":if(q===null)return"null";if(p1(q))return"[...]";if(q.$$typeof===R7)return(J=s(q.type))?"<"+J+">":"<...>";var Z=l0(q);if(Z==="Object"){Z="",J-=2;for(var Q in q)if(q.hasOwnProperty(Q)){var w=JSON.stringify(Q);if(w!=='"'+Q+'"'&&(Q=w),J-=Q.length-2,w=r0(q[Q],15>J?J:15),J-=w.length,0>J){Z+=Z===""?"...":", ...";break}Z+=(Z===""?"":",")+Q+":"+w}return"{"+Z+"}"}return Z;case"function":return(J=q.displayName||q.name)?"function "+J:"function";default:return String(q)}}function FF(q,J){return typeof q!=="string"||ON.test(q)?"{"+r0(q,J-2)+"}":q.length>J-2?5>J?'"..."':'"'+q.slice(0,J-5)+'..."':'"'+q+'"'}function GF(q,J,Z){var Q=120-Z.length-q.length,w=[],X;for(X in J)if(J.hasOwnProperty(X)&&X!=="children"){var B=FF(J[X],120-Z.length-X.length-1);Q-=X.length+B.length+2,w.push(X+"="+B)}return w.length===0?Z+"<"+q+`>
`:0<Q?Z+"<"+q+" "+w.join(" ")+`>
`:Z+"<"+q+`
`+Z+"  "+w.join(`
`+Z+"  ")+`
`+Z+`>
`}function wF(q,J,Z){var Q="",w=yF({},J),X;for(X in q)if(q.hasOwnProperty(X)){delete w[X];var B=120-2*Z-X.length-2,R=r0(q[X],B);J.hasOwnProperty(X)?(B=r0(J[X],B),Q+=z0(Z)+X+": "+R+`
`,Q+=B0(Z)+X+": "+B+`
`):Q+=z0(Z)+X+": "+R+`
`}for(var I in w)w.hasOwnProperty(I)&&(q=r0(w[I],120-2*Z-I.length-2),Q+=B0(Z)+I+": "+q+`
`);return Q}function kF(q,J,Z,Q){var w="",X=new Map;for(C in Z)Z.hasOwnProperty(C)&&X.set(C.toLowerCase(),C);if(X.size===1&&X.has("children"))w+=GF(q,J,_0(Q));else{for(var B in J)if(J.hasOwnProperty(B)&&B!=="children"){var R=120-2*(Q+1)-B.length-1,I=X.get(B.toLowerCase());if(I!==void 0){X.delete(B.toLowerCase());var C=J[B];I=Z[I];var e=FF(C,R);R=FF(I,R),typeof C==="object"&&C!==null&&typeof I==="object"&&I!==null&&l0(C)==="Object"&&l0(I)==="Object"&&(2<Object.keys(C).length||2<Object.keys(I).length||-1<e.indexOf("...")||-1<R.indexOf("..."))?w+=_0(Q+1)+B+`={{
`+wF(C,I,Q+2)+_0(Q+1)+`}}
`:(w+=z0(Q+1)+B+"="+e+`
`,w+=B0(Q+1)+B+"="+R+`
`)}else w+=_0(Q+1)+B+"="+FF(J[B],R)+`
`}X.forEach(function(F0){if(F0!=="children"){var i=120-2*(Q+1)-F0.length-1;w+=B0(Q+1)+F0+"="+FF(Z[F0],i)+`
`}}),w=w===""?_0(Q)+"<"+q+`>
`:_0(Q)+"<"+q+`
`+w+_0(Q)+`>
`}if(q=Z.children,J=J.children,typeof q==="string"||typeof q==="number"||typeof q==="bigint"){if(X="",typeof J==="string"||typeof J==="number"||typeof J==="bigint")X=""+J;w+=o0(X,""+q,Q+1)}else if(typeof J==="string"||typeof J==="number"||typeof J==="bigint")w=q==null?w+o0(""+J,null,Q+1):w+o0(""+J,void 0,Q+1);return w}function tF(q,J){var Z=G0(q);if(Z===null){Z="";for(q=q.child;q;)Z+=tF(q,J),q=q.sibling;return Z}return _0(J)+"<"+Z+`>
`}function K1(q,J){var Z=S(q,J);if(Z!==q&&(q.children.length!==1||q.children[0]!==Z))return _0(J)+`...
`+K1(Z,J+1);Z="";var Q=q.fiber._debugInfo;if(Q)for(var w=0;w<Q.length;w++){var X=Q[w].name;typeof X==="string"&&(Z+=_0(J)+"<"+X+`>
`,J++)}if(Q="",w=q.fiber.pendingProps,q.fiber.tag===6)Q=o0(w,q.serverProps,J),J++;else if(X=G0(q.fiber),X!==null)if(q.serverProps===void 0){Q=J;var B=120-2*Q-X.length-2,R="";for(C in w)if(w.hasOwnProperty(C)&&C!=="children"){var I=FF(w[C],15);if(B-=C.length+I.length+2,0>B){R+=" ...";break}R+=" "+C+"="+I}Q=_0(Q)+"<"+X+R+`>
`,J++}else q.serverProps===null?(Q=GF(X,w,z0(J)),J++):typeof q.serverProps==="string"?console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React."):(Q=kF(X,w,q.serverProps,J),J++);var C="";w=q.fiber.child;for(X=0;w&&X<q.children.length;)B=q.children[X],B.fiber===w?(C+=K1(B,J),X++):C+=tF(w,J),w=w.sibling;w&&0<q.children.length&&(C+=_0(J)+`...
`),w=q.serverTail,q.serverProps===null&&J--;for(q=0;q<w.length;q++)X=w[q],C=typeof X==="string"?C+(B0(J)+u0(X,120-2*J)+`
`):C+GF(X.type,X.props,B0(J));return Z+Q+C}function U1(q){try{return`

`+K1(q,0)}catch(J){return""}}function q1(q,J,Z){for(var Q=J,w=null,X=0;Q;)Q===q&&(X=0),w={fiber:Q,children:w!==null?[w]:[],serverProps:Q===J?Z:Q===q?null:void 0,serverTail:[],distanceFromLeaf:X},X++,Q=Q.return;return w!==null?U1(w).replaceAll(/^[+-]/gm,">"):""}function HF(q,J){var Z=yF({},q||IN),Q={tag:J};if(fN.indexOf(J)!==-1&&(Z.aTagInScope=null,Z.buttonTagInScope=null,Z.nobrTagInScope=null),V4.indexOf(J)!==-1&&(Z.pTagInButtonScope=null),P4.indexOf(J)!==-1&&J!=="address"&&J!=="div"&&J!=="p"&&(Z.listItemTagAutoclosing=null,Z.dlItemTagAutoclosing=null),Z.current=Q,J==="form"&&(Z.formTag=Q),J==="a"&&(Z.aTagInScope=Q),J==="button"&&(Z.buttonTagInScope=Q),J==="nobr"&&(Z.nobrTagInScope=Q),J==="p"&&(Z.pTagInButtonScope=Q),J==="li"&&(Z.listItemTagAutoclosing=Q),J==="dd"||J==="dt")Z.dlItemTagAutoclosing=Q;return J==="#document"||J==="html"?Z.containerTagInScope=null:Z.containerTagInScope||(Z.containerTagInScope=Q),q!==null||J!=="#document"&&J!=="html"&&J!=="body"?Z.implicitRootScope===!0&&(Z.implicitRootScope=!1):Z.implicitRootScope=!0,Z}function rF(q,J,Z){switch(J){case"select":return q==="hr"||q==="option"||q==="optgroup"||q==="script"||q==="template"||q==="#text";case"optgroup":return q==="option"||q==="#text";case"option":return q==="#text";case"tr":return q==="th"||q==="td"||q==="style"||q==="script"||q==="template";case"tbody":case"thead":case"tfoot":return q==="tr"||q==="style"||q==="script"||q==="template";case"colgroup":return q==="col"||q==="template";case"table":return q==="caption"||q==="colgroup"||q==="tbody"||q==="tfoot"||q==="thead"||q==="style"||q==="script"||q==="template";case"head":return q==="base"||q==="basefont"||q==="bgsound"||q==="link"||q==="meta"||q==="title"||q==="noscript"||q==="noframes"||q==="style"||q==="script"||q==="template";case"html":if(Z)break;return q==="head"||q==="body"||q==="frameset";case"frameset":return q==="frame";case"#document":if(!Z)return q==="html"}switch(q){case"h1":case"h2":case"h3":case"h4":case"h5":case"h6":return J!=="h1"&&J!=="h2"&&J!=="h3"&&J!=="h4"&&J!=="h5"&&J!=="h6";case"rp":case"rt":return k4.indexOf(J)===-1;case"caption":case"col":case"colgroup":case"frameset":case"frame":case"tbody":case"td":case"tfoot":case"th":case"thead":case"tr":return J==null;case"head":return Z||J===null;case"html":return Z&&J==="#document"||J===null;case"body":return Z&&(J==="#document"||J==="html")||J===null}return!0}function sF(q,J){switch(q){case"address":case"article":case"aside":case"blockquote":case"center":case"details":case"dialog":case"dir":case"div":case"dl":case"fieldset":case"figcaption":case"figure":case"footer":case"header":case"hgroup":case"main":case"menu":case"nav":case"ol":case"p":case"section":case"summary":case"ul":case"pre":case"listing":case"table":case"hr":case"xmp":case"h1":case"h2":case"h3":case"h4":case"h5":case"h6":return J.pTagInButtonScope;case"form":return J.formTag||J.pTagInButtonScope;case"li":return J.listItemTagAutoclosing;case"dd":case"dt":return J.dlItemTagAutoclosing;case"button":return J.buttonTagInScope;case"a":return J.aTagInScope;case"nobr":return J.nobrTagInScope}return null}function Y6(q,J){for(;q;){switch(q.tag){case 5:case 26:case 27:if(q.type===J)return q}q=q.return}return null}function J7(q,J){J=J||IN;var Z=J.current;if(J=(Z=rF(q,Z&&Z.tag,J.implicitRootScope)?null:Z)?null:sF(q,J),J=Z||J,!J)return!0;var Q=J.tag;if(J=String(!!Z)+"|"+q+"|"+Q,WH[J])return!1;WH[J]=!0;var w=(J=F8)?Y6(J.return,Q):null,X=J!==null&&w!==null?q1(w,J,null):"",B="<"+q+">";return Z?(Z="",Q==="table"&&q==="tr"&&(Z+=" Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),console.error(`In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`,B,Q,Z,X)):console.error(`In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`,B,Q,X),J&&(q=J.return,w===null||q===null||w===q&&q._debugOwner===J._debugOwner||v0(w,function(){console.error(`<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`,Q,B)})),!1}function c1(q,J,Z){if(Z||rF("#text",J,!1))return!0;if(Z="#text|"+J,WH[Z])return!1;WH[Z]=!0;var Q=(Z=F8)?Y6(Z,J):null;return Z=Z!==null&&Q!==null?q1(Q,Z,Z.tag!==6?{children:null}:null):"",/\S/.test(q)?console.error(`In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`,J,Z):console.error(`In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`,J,Z),!1}function v8(q,J){if(J){var Z=q.firstChild;if(Z&&Z===q.lastChild&&Z.nodeType===3){Z.nodeValue=J;return}}q.textContent=J}function $1(q){return q.replace(v4,function(J,Z){return Z.toUpperCase()})}function _6(q,J,Z){var Q=J.indexOf("--")===0;Q||(-1<J.indexOf("-")?X_.hasOwnProperty(J)&&X_[J]||(X_[J]=!0,console.error("Unsupported style property %s. Did you mean %s?",J,$1(J.replace(y4,"ms-")))):S4.test(J)?X_.hasOwnProperty(J)&&X_[J]||(X_[J]=!0,console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?",J,J.charAt(0).toUpperCase()+J.slice(1))):!EN.test(Z)||oG.hasOwnProperty(Z)&&oG[Z]||(oG[Z]=!0,console.error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,J,Z.replace(EN,""))),typeof Z==="number"&&(isNaN(Z)?CN||(CN=!0,console.error("`NaN` is an invalid value for the `%s` css style property.",J)):isFinite(Z)||PN||(PN=!0,console.error("`Infinity` is an invalid value for the `%s` css style property.",J)))),Z==null||typeof Z==="boolean"||Z===""?Q?q.setProperty(J,""):J==="float"?q.cssFloat="":q[J]="":Q?q.setProperty(J,Z):typeof Z!=="number"||Z===0||VN.has(J)?J==="float"?q.cssFloat=Z:(a(Z,J),q[J]=(""+Z).trim()):q[J]=Z+"px"}function N6(q,J,Z){if(J!=null&&typeof J!=="object")throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");if(J&&Object.freeze(J),q=q.style,Z!=null){if(J){var Q={};if(Z){for(var w in Z)if(Z.hasOwnProperty(w)&&!J.hasOwnProperty(w))for(var X=sG[w]||[w],B=0;B<X.length;B++)Q[X[B]]=w}for(var R in J)if(J.hasOwnProperty(R)&&(!Z||Z[R]!==J[R]))for(w=sG[R]||[R],X=0;X<w.length;X++)Q[w[X]]=R;R={};for(var I in J)for(w=sG[I]||[I],X=0;X<w.length;X++)R[w[X]]=I;I={};for(var C in Q)if(w=Q[C],(X=R[C])&&w!==X&&(B=w+","+X,!I[B])){I[B]=!0,B=console;var e=J[w];B.error.call(B,"%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",e==null||typeof e==="boolean"||e===""?"Removing":"Updating",w,X)}}for(var F0 in Z)!Z.hasOwnProperty(F0)||J!=null&&J.hasOwnProperty(F0)||(F0.indexOf("--")===0?q.setProperty(F0,""):F0==="float"?q.cssFloat="":q[F0]="");for(var i in J)C=J[i],J.hasOwnProperty(i)&&Z[i]!==C&&_6(q,i,C)}else for(Q in J)J.hasOwnProperty(Q)&&_6(q,Q,J[Q])}function P1(q){if(q.indexOf("-")===-1)return!1;switch(q){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function Z6(q){return b4.get(q)||q}function yZ(q,J){if(g8.call(K_,J)&&K_[J])return!0;if(x4.test(J)){if(q="aria-"+J.slice(4).toLowerCase(),q=kN.hasOwnProperty(q)?q:null,q==null)return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",J),K_[J]=!0;if(J!==q)return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?",J,q),K_[J]=!0}if(j4.test(J)){if(q=J.toLowerCase(),q=kN.hasOwnProperty(q)?q:null,q==null)return K_[J]=!0,!1;J!==q&&(console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?",J,q),K_[J]=!0)}return!0}function x7(q,J){var Z=[],Q;for(Q in J)yZ(q,Q)||Z.push(Q);J=Z.map(function(w){return"`"+w+"`"}).join(", "),Z.length===1?console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",J,q):1<Z.length&&console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",J,q)}function VI(q,J,Z,Q){if(g8.call(f6,J)&&f6[J])return!0;var w=J.toLowerCase();if(w==="onfocusin"||w==="onfocusout")return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."),f6[J]=!0;if(typeof Z==="function"&&(q==="form"&&J==="action"||q==="input"&&J==="formAction"||q==="button"&&J==="formAction"))return!0;if(Q!=null){if(q=Q.possibleRegistrationNames,Q.registrationNameDependencies.hasOwnProperty(J))return!0;if(Q=q.hasOwnProperty(w)?q[w]:null,Q!=null)return console.error("Invalid event handler property `%s`. Did you mean `%s`?",J,Q),f6[J]=!0;if(yN.test(J))return console.error("Unknown event handler property `%s`. It will be ignored.",J),f6[J]=!0}else if(yN.test(J))return g4.test(J)&&console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",J),f6[J]=!0;if(u4.test(J)||p4.test(J))return!0;if(w==="innerhtml")return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."),f6[J]=!0;if(w==="aria")return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."),f6[J]=!0;if(w==="is"&&Z!==null&&Z!==void 0&&typeof Z!=="string")return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",typeof Z),f6[J]=!0;if(typeof Z==="number"&&isNaN(Z))return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",J),f6[J]=!0;if(wH.hasOwnProperty(w)){if(w=wH[w],w!==J)return console.error("Invalid DOM property `%s`. Did you mean `%s`?",J,w),f6[J]=!0}else if(J!==w)return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",J,w),f6[J]=!0;switch(J){case"dangerouslySetInnerHTML":case"children":case"style":case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":return!0;case"innerText":case"textContent":return!0}switch(typeof Z){case"boolean":switch(J){case"autoFocus":case"checked":case"multiple":case"muted":case"selected":case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":case"capture":case"download":case"inert":return!0;default:if(w=J.toLowerCase().slice(0,5),w==="data-"||w==="aria-")return!0;return Z?console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',Z,J,J,Z,J):console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',Z,J,J,Z,J,J,J),f6[J]=!0}case"function":case"symbol":return f6[J]=!0,!1;case"string":if(Z==="false"||Z==="true"){switch(J){case"checked":case"selected":case"multiple":case"muted":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":case"inert":break;default:return!0}console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",Z,J,Z==="false"?"The browser will interpret it as a truthy value.":'Although this works, it will not work as expected if you pass the string "false".',J,Z),f6[J]=!0}}return!0}function kI(q,J,Z){var Q=[],w;for(w in J)VI(q,w,J[w],Z)||Q.push(w);J=Q.map(function(X){return"`"+X+"`"}).join(", "),Q.length===1?console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",J,q):1<Q.length&&console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",J,q)}function vZ(q){return m4.test(""+q)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":q}function g7(){}function vY(q){return q=q.target||q.srcElement||window,q.correspondingUseElement&&(q=q.correspondingUseElement),q.nodeType===3?q.parentNode:q}function Tz(q){var J=M0(q);if(J&&(q=J.stateNode)){var Z=q[O6]||null;F:switch(q=J.stateNode,J.type){case"input":if(dJ(q,Z.value,Z.defaultValue,Z.defaultValue,Z.checked,Z.defaultChecked,Z.type,Z.name),J=Z.name,Z.type==="radio"&&J!=null){for(Z=q;Z.parentNode;)Z=Z.parentNode;XF(J,"name"),Z=Z.querySelectorAll('input[name="'+R6(""+J)+'"][type="radio"]');for(J=0;J<Z.length;J++){var Q=Z[J];if(Q!==q&&Q.form===q.form){var w=Q[O6]||null;if(!w)throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");dJ(Q,w.value,w.defaultValue,w.defaultValue,w.checked,w.defaultChecked,w.type,w.name)}}for(J=0;J<Z.length;J++)Q=Z[J],Q.form===q.form&&lJ(Q)}break F;case"textarea":oQ(q,Z.value,Z.defaultValue);break F;case"select":J=Z.value,J!=null&&T9(q,!!Z.multiple,J,!1)}}}function Lz(q,J,Z){if(aG)return q(J,Z);aG=!0;try{var Q=q(J);return Q}finally{if(aG=!1,U_!==null||B_!==null){if(q_(),U_&&(J=U_,q=B_,B_=U_=null,Tz(J),q))for(J=0;J<q.length;J++)Tz(q[J])}}}function bZ(q,J){var Z=q.stateNode;if(Z===null)return null;var Q=Z[O6]||null;if(Q===null)return null;Z=Q[J];F:switch(J){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(Q=!Q.disabled)||(q=q.type,Q=!(q==="button"||q==="input"||q==="select"||q==="textarea")),q=!Q;break F;default:q=!1}if(q)return null;if(Z&&typeof Z!=="function")throw Error("Expected `"+J+"` listener to be a function, instead got a value of `"+typeof Z+"` type.");return Z}function Ez(){if(YH)return YH;var q,J=tG,Z=J.length,Q,w="value"in l9?l9.value:l9.textContent,X=w.length;for(q=0;q<Z&&J[q]===w[q];q++);var B=Z-q;for(Q=1;Q<=B&&J[Z-Q]===w[X-Q];Q++);return YH=w.slice(q,1<Q?1-Q:void 0)}function rQ(q){var J=q.keyCode;return"charCode"in q?(q=q.charCode,q===0&&J===13&&(q=13)):q=J,q===10&&(q=13),32<=q||q===13?q:0}function tQ(){return!0}function Cz(){return!1}function b6(q){function J(Z,Q,w,X,B){this._reactName=Z,this._targetInst=w,this.type=Q,this.nativeEvent=X,this.target=B,this.currentTarget=null;for(var R in q)q.hasOwnProperty(R)&&(Z=q[R],this[R]=Z?Z(X):X[R]);return this.isDefaultPrevented=(X.defaultPrevented!=null?X.defaultPrevented:X.returnValue===!1)?tQ:Cz,this.isPropagationStopped=Cz,this}return yF(J.prototype,{preventDefault:function(){this.defaultPrevented=!0;var Z=this.nativeEvent;Z&&(Z.preventDefault?Z.preventDefault():typeof Z.returnValue!=="unknown"&&(Z.returnValue=!1),this.isDefaultPrevented=tQ)},stopPropagation:function(){var Z=this.nativeEvent;Z&&(Z.stopPropagation?Z.stopPropagation():typeof Z.cancelBubble!=="unknown"&&(Z.cancelBubble=!0),this.isPropagationStopped=tQ)},persist:function(){},isPersistent:tQ}),J}function SI(q){var J=this.nativeEvent;return J.getModifierState?J.getModifierState(q):(q=qT[q])?!!J[q]:!1}function bY(){return SI}function Pz(q,J){switch(q){case"keyup":return KT.indexOf(J.keyCode)!==-1;case"keydown":return J.keyCode!==xN;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Vz(q){return q=q.detail,typeof q==="object"&&"data"in q?q.data:null}function yI(q,J){switch(q){case"compositionend":return Vz(J);case"keypress":if(J.which!==uN)return null;return mN=!0,pN;case"textInput":return q=J.data,q===pN&&mN?null:q;default:return null}}function vI(q,J){if(z_)return q==="compositionend"||!JK&&Pz(q,J)?(q=Ez(),YH=tG=l9=null,z_=!1,q):null;switch(q){case"paste":return null;case"keypress":if(!(J.ctrlKey||J.altKey||J.metaKey)||J.ctrlKey&&J.altKey){if(J.char&&1<J.char.length)return J.char;if(J.which)return String.fromCharCode(J.which)}return null;case"compositionend":return gN&&J.locale!=="ko"?null:J.data;default:return null}}function kz(q){var J=q&&q.nodeName&&q.nodeName.toLowerCase();return J==="input"?!!BT[q.type]:J==="textarea"?!0:!1}function bI(q){if(!I7)return!1;q="on"+q;var J=q in document;return J||(J=document.createElement("div"),J.setAttribute(q,"return;"),J=typeof J[q]==="function"),J}function Sz(q,J,Z,Q){U_?B_?B_.push(Q):B_=[Q]:U_=Q,J=dW(J,"onChange"),0<J.length&&(Z=new XH("onChange","change",null,Z,Q),q.push({event:Z,listeners:J}))}function jI(q){BR(q,0)}function eQ(q){var J=L0(q);if(lJ(J))return q}function yz(q,J){if(q==="change")return J}function vz(){D$&&(D$.detachEvent("onpropertychange",bz),M$=D$=null)}function bz(q){if(q.propertyName==="value"&&eQ(M$)){var J=[];Sz(J,M$,q,vY(q)),Lz(jI,J)}}function xI(q,J,Z){q==="focusin"?(vz(),D$=J,M$=Z,D$.attachEvent("onpropertychange",bz)):q==="focusout"&&vz()}function gI(q){if(q==="selectionchange"||q==="keyup"||q==="keydown")return eQ(M$)}function uI(q,J){if(q==="click")return eQ(J)}function pI(q,J){if(q==="input"||q==="change")return eQ(J)}function mI(q,J){return q===J&&(q!==0||1/q===1/J)||q!==q&&J!==J}function jZ(q,J){if(I6(q,J))return!0;if(typeof q!=="object"||q===null||typeof J!=="object"||J===null)return!1;var Z=Object.keys(q),Q=Object.keys(J);if(Z.length!==Q.length)return!1;for(Q=0;Q<Z.length;Q++){var w=Z[Q];if(!g8.call(J,w)||!I6(q[w],J[w]))return!1}return!0}function jz(q){for(;q&&q.firstChild;)q=q.firstChild;return q}function xz(q,J){var Z=jz(q);q=0;for(var Q;Z;){if(Z.nodeType===3){if(Q=q+Z.textContent.length,q<=J&&Q>=J)return{node:Z,offset:J-q};q=Q}F:{for(;Z;){if(Z.nextSibling){Z=Z.nextSibling;break F}Z=Z.parentNode}Z=void 0}Z=jz(Z)}}function gz(q,J){return q&&J?q===J?!0:q&&q.nodeType===3?!1:J&&J.nodeType===3?gz(q,J.parentNode):("contains"in q)?q.contains(J):q.compareDocumentPosition?!!(q.compareDocumentPosition(J)&16):!1:!1}function uz(q){q=q!=null&&q.ownerDocument!=null&&q.ownerDocument.defaultView!=null?q.ownerDocument.defaultView:window;for(var J=Pq(q.document);J instanceof q.HTMLIFrameElement;){try{var Z=typeof J.contentWindow.location.href==="string"}catch(Q){Z=!1}if(Z)q=J.contentWindow;else break;J=Pq(q.document)}return J}function jY(q){var J=q&&q.nodeName&&q.nodeName.toLowerCase();return J&&(J==="input"&&(q.type==="text"||q.type==="search"||q.type==="tel"||q.type==="url"||q.type==="password")||J==="textarea"||q.contentEditable==="true")}function pz(q,J,Z){var Q=Z.window===Z?Z.document:Z.nodeType===9?Z:Z.ownerDocument;ZK||A_==null||A_!==Pq(Q)||(Q=A_,("selectionStart"in Q)&&jY(Q)?Q={start:Q.selectionStart,end:Q.selectionEnd}:(Q=(Q.ownerDocument&&Q.ownerDocument.defaultView||window).getSelection(),Q={anchorNode:Q.anchorNode,anchorOffset:Q.anchorOffset,focusNode:Q.focusNode,focusOffset:Q.focusOffset}),O$&&jZ(O$,Q)||(O$=Q,Q=dW(_K,"onSelect"),0<Q.length&&(J=new XH("onSelect","select",null,J,Z),q.push({event:J,listeners:Q}),J.target=A_)))}function Sq(q,J){var Z={};return Z[q.toLowerCase()]=J.toLowerCase(),Z["Webkit"+q]="webkit"+J,Z["Moz"+q]="moz"+J,Z}function yq(q){if($K[q])return $K[q];if(!h_[q])return q;var J=h_[q],Z;for(Z in J)if(J.hasOwnProperty(Z)&&Z in dN)return $K[q]=J[Z];return q}function b8(q,J){oN.set(q,J),m0(J,[q])}function lI(q){for(var J=KH,Z=0;Z<q.length;Z++){var Q=q[Z];if(typeof Q==="object"&&Q!==null)if(p1(Q)&&Q.length===2&&typeof Q[0]==="string"){if(J!==KH&&J!==YK)return HK;J=YK}else return HK;else{if(typeof Q==="function"||typeof Q==="string"&&50<Q.length||J!==KH&&J!==wK)return HK;J=wK}}return J}function xY(q,J,Z,Q){for(var w in q)g8.call(q,w)&&w[0]!=="_"&&_7(w,q[w],J,Z,Q)}function _7(q,J,Z,Q,w){switch(typeof J){case"object":if(J===null){J="null";break}else{if(J.$$typeof===R7){var X=s(J.type)||"",B=J.key;J=J.props;var R=Object.keys(J),I=R.length;if(B==null&&I===0){J="<"+X+" />";break}if(3>Q||I===1&&R[0]==="children"&&B==null){J="<"+X+"  />";break}Z.push([w+"".repeat(Q)+q,"<"+X]),B!==null&&_7("key",B,Z,Q+1,w),q=!1;for(var C in J)C==="children"?J.children!=null&&(!p1(J.children)||0<J.children.length)&&(q=!0):g8.call(J,C)&&C[0]!=="_"&&_7(C,J[C],Z,Q+1,w);Z.push(["",q?"></"+X+">":"/>"]);return}if(X=Object.prototype.toString.call(J),X=X.slice(8,X.length-1),X==="Array"){if(C=lI(J),C===wK||C===KH){J=JSON.stringify(J);break}else if(C===YK){Z.push([w+"".repeat(Q)+q,""]);for(q=0;q<J.length;q++)X=J[q],_7(X[0],X[1],Z,Q+1,w);return}}if(X==="Promise"){if(J.status==="fulfilled"){if(X=Z.length,_7(q,J.value,Z,Q,w),Z.length>X){Z=Z[X],Z[1]="Promise<"+(Z[1]||"Object")+">";return}}else if(J.status==="rejected"&&(X=Z.length,_7(q,J.reason,Z,Q,w),Z.length>X)){Z=Z[X],Z[1]="Rejected Promise<"+Z[1]+">";return}Z.push(["".repeat(Q)+q,"Promise"]);return}X==="Object"&&(C=Object.getPrototypeOf(J))&&typeof C.constructor==="function"&&(X=C.constructor.name),Z.push([w+"".repeat(Q)+q,X==="Object"?3>Q?"":"":X]),3>Q&&xY(J,Z,Q+1,w);return}case"function":J=J.name===""?"() => {}":J.name+"() {}";break;case"string":J=J===MT?"":JSON.stringify(J);break;case"undefined":J="undefined";break;case"boolean":J=J?"true":"false";break;default:J=String(J)}Z.push([w+"".repeat(Q)+q,J])}function mz(q,J,Z,Q){var w=!0;for(B in q)B in J||(Z.push([UH+"".repeat(Q)+B,""]),w=!1);for(var X in J)if(X in q){var B=q[X],R=J[X];if(B!==R){if(Q===0&&X==="children")w="".repeat(Q)+X,Z.push([UH+w,""],[BH+w,""]);else{if(!(3<=Q)){if(typeof B==="object"&&typeof R==="object"&&B!==null&&R!==null&&B.$$typeof===R.$$typeof)if(R.$$typeof===R7){if(B.type===R.type&&B.key===R.key){B=s(R.type)||"",w="".repeat(Q)+X,B="<"+B+"  />",Z.push([UH+w,B],[BH+w,B]),w=!1;continue}}else{var I=Object.prototype.toString.call(B),C=Object.prototype.toString.call(R);if(I===C&&(C==="[object Object]"||C==="[object Array]")){I=[tN+"".repeat(Q)+X,C==="[object Array]"?"Array":""],Z.push(I),C=Z.length,mz(B,R,Z,Q+1)?C===Z.length&&(I[1]="Referentially unequal but deeply equal objects. Consider memoization."):w=!1;continue}}else if(typeof B==="function"&&typeof R==="function"&&B.name===R.name&&B.length===R.length&&(I=Function.prototype.toString.call(B),C=Function.prototype.toString.call(R),I===C)){B=R.name===""?"() => {}":R.name+"() {}",Z.push([tN+"".repeat(Q)+X,B+" Referentially unequal function closure. Consider memoization."]);continue}}_7(X,B,Z,Q,UH),_7(X,R,Z,Q,BH)}w=!1}}else Z.push([BH+"".repeat(Q)+X,""]),w=!1;return w}function n6(q){xF=q&63?"Blocking":q&64?"Gesture":q&4194176?"Transition":q&62914560?"Suspense":q&2080374784?"Idle":"Other"}function Z7(q,J,Z,Q){B1&&(i9.start=J,i9.end=Z,s7.color="warning",s7.tooltipText=Q,s7.properties=null,(q=q._debugTask)?q.run(performance.measure.bind(performance,Q,i9)):performance.measure(Q,i9))}function FW(q,J,Z){Z7(q,J,Z,"Reconnect")}function qW(q,J,Z,Q,w){var X=V(q);if(X!==null&&B1){var{alternate:B,actualDuration:R}=q;if(B===null||B.child!==q.child)for(var I=q.child;I!==null;I=I.sibling)R-=I.actualDuration;Q=0.5>R?Q?"tertiary-light":"primary-light":10>R?Q?"tertiary":"primary":100>R?Q?"tertiary-dark":"primary-dark":"error";var C=q.memoizedProps;R=q._debugTask,C!==null&&B!==null&&B.memoizedProps!==C?(I=[OT],C=mz(B.memoizedProps,C,I,0),1<I.length&&(C&&!d9&&(B.lanes&w)===0&&100<q.actualDuration?(d9=!0,I[0]=fT,s7.color="warning",s7.tooltipText=eN):(s7.color=Q,s7.tooltipText=X),s7.properties=I,i9.start=J,i9.end=Z,R!=null?R.run(performance.measure.bind(performance,""+X,i9)):performance.measure(""+X,i9))):R!=null?R.run(console.timeStamp.bind(console,X,J,Z,B8,void 0,Q)):console.timeStamp(X,J,Z,B8,void 0,Q)}}function gY(q,J,Z,Q){if(B1){var w=V(q);if(w!==null){for(var X=null,B=[],R=0;R<Q.length;R++){var I=Q[R];X==null&&I.source!==null&&(X=I.source._debugTask),I=I.value,B.push(["Error",typeof I==="object"&&I!==null&&typeof I.message==="string"?String(I.message):String(I)])}q.key!==null&&_7("key",q.key,B,0,""),q.memoizedProps!==null&&xY(q.memoizedProps,B,0,""),X==null&&(X=q._debugTask),q={start:J,end:Z,detail:{devtools:{color:"error",track:B8,tooltipText:q.tag===13?"Hydration failed":"Error boundary caught an error",properties:B}}},X?X.run(performance.measure.bind(performance,""+w,q)):performance.measure(""+w,q)}}}function $7(q,J,Z,Q,w){if(w!==null){if(B1){var X=V(q);if(X!==null){Q=[];for(var B=0;B<w.length;B++){var R=w[B].value;Q.push(["Error",typeof R==="object"&&R!==null&&typeof R.message==="string"?String(R.message):String(R)])}q.key!==null&&_7("key",q.key,Q,0,""),q.memoizedProps!==null&&xY(q.memoizedProps,Q,0,""),J={start:J,end:Z,detail:{devtools:{color:"error",track:B8,tooltipText:"A lifecycle or effect errored",properties:Q}}},(q=q._debugTask)?q.run(performance.measure.bind(performance,""+X,J)):performance.measure(""+X,J)}}}else X=V(q),X!==null&&B1&&(w=1>Q?"secondary-light":100>Q?"secondary":500>Q?"secondary-dark":"error",(q=q._debugTask)?q.run(console.timeStamp.bind(console,X,J,Z,B8,void 0,w)):console.timeStamp(X,J,Z,B8,void 0,w))}function dI(q,J,Z,Q){if(B1&&!(J<=q)){var w=(Z&738197653)===Z?"tertiary-dark":"primary-dark";Z=(Z&536870912)===Z?"Prepared":(Z&201326741)===Z?"Hydrated":"Render",Q?Q.run(console.timeStamp.bind(console,Z,q,J,xF,vF,w)):console.timeStamp(Z,q,J,xF,vF,w)}}function lz(q,J,Z,Q){!B1||J<=q||(Z=(Z&738197653)===Z?"tertiary-dark":"primary-dark",Q?Q.run(console.timeStamp.bind(console,"Prewarm",q,J,xF,vF,Z)):console.timeStamp("Prewarm",q,J,xF,vF,Z))}function dz(q,J,Z,Q){!B1||J<=q||(Z=(Z&738197653)===Z?"tertiary-dark":"primary-dark",Q?Q.run(console.timeStamp.bind(console,"Suspended",q,J,xF,vF,Z)):console.timeStamp("Suspended",q,J,xF,vF,Z))}function iI(q,J,Z,Q,w,X){if(B1&&!(J<=q)){Z=[];for(var B=0;B<Q.length;B++){var R=Q[B].value;Z.push(["Recoverable Error",typeof R==="object"&&R!==null&&typeof R.message==="string"?String(R.message):String(R)])}q={start:q,end:J,detail:{devtools:{color:"primary-dark",track:xF,trackGroup:vF,tooltipText:w?"Hydration Failed":"Recovered after Error",properties:Z}}},X?X.run(performance.measure.bind(performance,"Recovered",q)):performance.measure("Recovered",q)}}function uY(q,J,Z,Q){!B1||J<=q||(Q?Q.run(console.timeStamp.bind(console,"Errored",q,J,xF,vF,"error")):console.timeStamp("Errored",q,J,xF,vF,"error"))}function nI(q,J,Z,Q){!B1||J<=q||(Q?Q.run(console.timeStamp.bind(console,Z,q,J,xF,vF,"secondary-light")):console.timeStamp(Z,q,J,xF,vF,"secondary-light"))}function iz(q,J,Z,Q,w){if(B1&&!(J<=q)){for(var X=[],B=0;B<Z.length;B++){var R=Z[B].value;X.push(["Error",typeof R==="object"&&R!==null&&typeof R.message==="string"?String(R.message):String(R)])}q={start:q,end:J,detail:{devtools:{color:"error",track:xF,trackGroup:vF,tooltipText:Q?"Remaining Effects Errored":"Commit Errored",properties:X}}},w?w.run(performance.measure.bind(performance,"Errored",q)):performance.measure("Errored",q)}}function xZ(q,J,Z){!B1||J<=q||(Z?Z.run(console.timeStamp.bind(console,"Animating",q,J,xF,vF,"secondary-dark")):console.timeStamp("Animating",q,J,xF,vF,"secondary-dark"))}function JW(){for(var q=R_,J=XK=R_=0;J<q;){var Z=z8[J];z8[J++]=null;var Q=z8[J];z8[J++]=null;var w=z8[J];z8[J++]=null;var X=z8[J];if(z8[J++]=null,Q!==null&&w!==null){var B=Q.pending;B===null?w.next=w:(w.next=B.next,B.next=w),Q.pending=w}X!==0&&nz(Z,w,X)}}function _W(q,J,Z,Q){z8[R_++]=q,z8[R_++]=J,z8[R_++]=Z,z8[R_++]=Q,XK|=Q,q.lanes|=Q,q=q.alternate,q!==null&&(q.lanes|=Q)}function pY(q,J,Z,Q){return _W(q,J,Z,Q),ZW(q)}function X6(q,J){return _W(q,null,null,J),ZW(q)}function nz(q,J,Z){q.lanes|=Z;var Q=q.alternate;Q!==null&&(Q.lanes|=Z);for(var w=!1,X=q.return;X!==null;)X.childLanes|=Z,Q=X.alternate,Q!==null&&(Q.childLanes|=Z),X.tag===22&&(q=X.stateNode,q===null||q._visibility&f$||(w=!0)),q=X,X=X.return;return q.tag===3?(X=q.stateNode,w&&J!==null&&(w=31-M6(Z),q=X.hiddenUpdates,Q=q[w],Q===null?q[w]=[J]:Q.push(J),J.lane=Z|536870912),X):null}function ZW(q){if(r$>gT)throw wJ=r$=0,t$=dK=null,Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");wJ>uT&&(wJ=0,t$=null,console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.")),q.alternate===null&&(q.flags&4098)!==0&&HR(q);for(var J=q,Z=J.return;Z!==null;)J.alternate===null&&(J.flags&4098)!==0&&HR(q),J=Z,Z=J.return;return J.tag===3?J.stateNode:null}function vq(q){if(A8===null)return q;var J=A8(q);return J===void 0?q:J.current}function mY(q){if(A8===null)return q;var J=A8(q);return J===void 0?q!==null&&q!==void 0&&typeof q.render==="function"&&(J=vq(q.render),q.render!==J)?(J={$$typeof:G$,render:J},q.displayName!==void 0&&(J.displayName=q.displayName),J):q:J.current}function cz(q,J){if(A8===null)return!1;var Z=q.elementType;J=J.type;var Q=!1,w=typeof J==="object"&&J!==null?J.$$typeof:null;switch(q.tag){case 1:typeof J==="function"&&(Q=!0);break;case 0:typeof J==="function"?Q=!0:w===e6&&(Q=!0);break;case 11:w===G$?Q=!0:w===e6&&(Q=!0);break;case 14:case 15:w===qH?Q=!0:w===e6&&(Q=!0);break;default:return!1}return Q&&(q=A8(Z),q!==void 0&&q===A8(J))?!0:!1}function sz(q){A8!==null&&typeof WeakSet==="function"&&(N_===null&&(N_=new WeakSet),N_.add(q))}function oz(q,J,Z){do{var Q=q,w=Q.alternate,X=Q.child,B=Q.sibling,R=Q.tag;Q=Q.type;var I=null;switch(R){case 0:case 15:case 1:I=Q;break;case 11:I=Q.render}if(A8===null)throw Error("Expected resolveFamily to be set during hot reload.");var C=!1;if(Q=!1,I!==null&&(I=A8(I),I!==void 0&&(Z.has(I)?Q=!0:J.has(I)&&(R===1?Q=!0:C=!0))),N_!==null&&(N_.has(q)||w!==null&&N_.has(w))&&(Q=!0),Q&&(q._debugNeedsRemount=!0),Q||C)w=X6(q,2),w!==null&&f1(w,q,2);if(X===null||Q||oz(X,J,Z),B===null)break;q=B}while(1)}function cI(q,J,Z,Q){this.tag=q,this.key=Z,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=J,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=Q,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null,this.actualDuration=-0,this.actualStartTime=-1.1,this.treeBaseDuration=this.selfBaseDuration=-0,this._debugTask=this._debugStack=this._debugOwner=this._debugInfo=null,this._debugNeedsRemount=!1,this._debugHookTypes=null,FD||typeof Object.preventExtensions!=="function"||Object.preventExtensions(this)}function lY(q){return q=q.prototype,!(!q||!q.isReactComponent)}function u7(q,J){var Z=q.alternate;switch(Z===null?(Z=N(q.tag,J,q.key,q.mode),Z.elementType=q.elementType,Z.type=q.type,Z.stateNode=q.stateNode,Z._debugOwner=q._debugOwner,Z._debugStack=q._debugStack,Z._debugTask=q._debugTask,Z._debugHookTypes=q._debugHookTypes,Z.alternate=q,q.alternate=Z):(Z.pendingProps=J,Z.type=q.type,Z.flags=0,Z.subtreeFlags=0,Z.deletions=null,Z.actualDuration=-0,Z.actualStartTime=-1.1),Z.flags=q.flags&65011712,Z.childLanes=q.childLanes,Z.lanes=q.lanes,Z.child=q.child,Z.memoizedProps=q.memoizedProps,Z.memoizedState=q.memoizedState,Z.updateQueue=q.updateQueue,J=q.dependencies,Z.dependencies=J===null?null:{lanes:J.lanes,firstContext:J.firstContext,_debugThenableState:J._debugThenableState},Z.sibling=q.sibling,Z.index=q.index,Z.ref=q.ref,Z.refCleanup=q.refCleanup,Z.selfBaseDuration=q.selfBaseDuration,Z.treeBaseDuration=q.treeBaseDuration,Z._debugInfo=q._debugInfo,Z._debugNeedsRemount=q._debugNeedsRemount,Z.tag){case 0:case 15:Z.type=vq(q.type);break;case 1:Z.type=vq(q.type);break;case 11:Z.type=mY(q.type)}return Z}function az(q,J){q.flags&=65011714;var Z=q.alternate;return Z===null?(q.childLanes=0,q.lanes=J,q.child=null,q.subtreeFlags=0,q.memoizedProps=null,q.memoizedState=null,q.updateQueue=null,q.dependencies=null,q.stateNode=null,q.selfBaseDuration=0,q.treeBaseDuration=0):(q.childLanes=Z.childLanes,q.lanes=Z.lanes,q.child=Z.child,q.subtreeFlags=0,q.deletions=null,q.memoizedProps=Z.memoizedProps,q.memoizedState=Z.memoizedState,q.updateQueue=Z.updateQueue,q.type=Z.type,J=Z.dependencies,q.dependencies=J===null?null:{lanes:J.lanes,firstContext:J.firstContext,_debugThenableState:J._debugThenableState},q.selfBaseDuration=Z.selfBaseDuration,q.treeBaseDuration=Z.treeBaseDuration),q}function dY(q,J,Z,Q,w,X){var B=0,R=q;if(typeof q==="function")lY(q)&&(B=1),R=vq(R);else if(typeof q==="string")B=n(),B=J4(q,Z,B)?26:q==="html"||q==="head"||q==="body"?27:5;else F:switch(q){case bG:return J=N(31,Z,J,w),J.elementType=bG,J.lanes=X,J;case H_:return bq(Z.children,w,X,J);case FH:B=8,w|=K6,w|=p8;break;case kG:return q=Z,Q=w,typeof q.id!=="string"&&console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',typeof q.id),J=N(12,q,J,Q|IF),J.elementType=kG,J.lanes=X,J.stateNode={effectDuration:0,passiveEffectDuration:0},J;case yG:return J=N(13,Z,J,w),J.elementType=yG,J.lanes=X,J;case vG:return J=N(19,Z,J,w),J.elementType=vG,J.lanes=X,J;default:if(typeof q==="object"&&q!==null)switch(q.$$typeof){case N7:B=10;break F;case SG:B=9;break F;case G$:B=11,R=mY(R);break F;case qH:B=14;break F;case e6:B=16,R=null;break F}if(R="",q===void 0||typeof q==="object"&&q!==null&&Object.keys(q).length===0)R+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";q===null?Z="null":p1(q)?Z="array":q!==void 0&&q.$$typeof===R7?(Z="<"+(s(q.type)||"Unknown")+" />",R=" Did you accidentally export a JSX literal instead of a component?"):Z=typeof q,(B=Q?j(Q):null)&&(R+=`

Check the render method of \``+B+"`."),B=29,Z=Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: "+(Z+"."+R)),R=null}return J=N(B,Z,J,w),J.elementType=q,J.type=R,J.lanes=X,J._debugOwner=Q,J}function $W(q,J,Z){return J=dY(q.type,q.key,q.props,q._owner,J,Z),J._debugOwner=q._owner,J._debugStack=q._debugStack,J._debugTask=q._debugTask,J}function bq(q,J,Z,Q){return q=N(7,q,Q,J),q.lanes=Z,q}function iY(q,J,Z){return q=N(6,q,null,J),q.lanes=Z,q}function rz(q){var J=N(18,null,null,BF);return J.stateNode=q,J}function nY(q,J,Z){return J=N(4,q.children!==null?q.children:[],q.key,J),J.lanes=Z,J.stateNode={containerInfo:q.containerInfo,pendingChildren:null,implementation:q.implementation},J}function c6(q,J){if(typeof q==="object"&&q!==null){var Z=GK.get(q);if(Z!==void 0)return Z;return J={value:q,source:J,stack:S0(J)},GK.set(q,J),J}return{value:q,source:J,stack:S0(J)}}function p7(q,J){L9(),D_[M_++]=I$,D_[M_++]=zH,zH=q,I$=J}function tz(q,J,Z){L9(),h8[R8++]=a7,h8[R8++]=r7,h8[R8++]=oq,oq=q;var Q=a7;q=r7;var w=32-M6(Q)-1;Q&=~(1<<w),Z+=1;var X=32-M6(J)+w;if(30<X){var B=w-w%5;X=(Q&(1<<B)-1).toString(32),Q>>=B,w-=B,a7=1<<32-M6(J)+w|Z<<w|Q,r7=X+q}else a7=1<<X|Z<<w|Q,r7=q}function cY(q){L9(),q.return!==null&&(p7(q,1),tz(q,1,0))}function sY(q){for(;q===zH;)zH=D_[--M_],D_[M_]=null,I$=D_[--M_],D_[M_]=null;for(;q===oq;)oq=h8[--R8],h8[R8]=null,r7=h8[--R8],h8[R8]=null,a7=h8[--R8],h8[R8]=null}function ez(){return L9(),oq!==null?{id:a7,overflow:r7}:null}function FA(q,J){L9(),h8[R8++]=a7,h8[R8++]=r7,h8[R8++]=oq,a7=J.id,r7=J.overflow,oq=q}function L9(){gF||console.error("Expected to be hydrating. This is a bug in React. Please file an issue.")}function jq(q,J){if(q.return===null){if(J8===null)J8={fiber:q,children:[],serverProps:void 0,serverTail:[],distanceFromLeaf:J};else{if(J8.fiber!==q)throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");J8.distanceFromLeaf>J&&(J8.distanceFromLeaf=J)}return J8}var Z=jq(q.return,J+1).children;if(0<Z.length&&Z[Z.length-1].fiber===q)return Z=Z[Z.length-1],Z.distanceFromLeaf>J&&(Z.distanceFromLeaf=J),Z;return J={fiber:q,children:[],serverProps:void 0,serverTail:[],distanceFromLeaf:J},Z.push(J),J}function qA(){gF&&console.error("We should not be hydrating here. This is a bug in React. Please file a bug.")}function QW(q,J){T7||(q=jq(q,0),q.serverProps=null,J!==null&&(J=SR(J),q.serverTail.push(J)))}function E9(q){var J=1<arguments.length&&arguments[1]!==void 0?arguments[1]:!1,Z="",Q=J8;throw Q!==null&&(J8=null,Z=U1(Q)),gZ(c6(Error("Hydration failed because the server rendered "+(J?"text":"HTML")+` didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch`+Z),q)),KK}function JA(q){var{stateNode:J,type:Z,memoizedProps:Q}=q;switch(J[H6]=q,J[O6]=Q,UG(Z,Q),Z){case"dialog":pF("cancel",J),pF("close",J);break;case"iframe":case"object":case"embed":pF("load",J);break;case"video":case"audio":for(Z=0;Z<e$.length;Z++)pF(e$[Z],J);break;case"source":pF("error",J);break;case"img":case"image":case"link":pF("error",J),pF("load",J);break;case"details":pF("toggle",J);break;case"input":iF("input",Q),pF("invalid",J),Vq(J,Q),kq(J,Q.value,Q.defaultValue,Q.checked,Q.defaultChecked,Q.type,Q.name,!0);break;case"option":SZ(J,Q);break;case"select":iF("select",Q),pF("invalid",J),cQ(J,Q);break;case"textarea":iF("textarea",Q),pF("invalid",J),sQ(J,Q),aQ(J,Q.value,Q.defaultValue,Q.children)}Z=Q.children,typeof Z!=="string"&&typeof Z!=="number"&&typeof Z!=="bigint"||J.textContent===""+Z||Q.suppressHydrationWarning===!0||RR(J.textContent,Z)?(Q.popover!=null&&(pF("beforetoggle",J),pF("toggle",J)),Q.onScroll!=null&&pF("scroll",J),Q.onScrollEnd!=null&&pF("scrollend",J),Q.onClick!=null&&(J.onclick=g7),J=!0):J=!1,J||E9(q,!0)}function _A(q){for(w6=q.return;w6;)switch(w6.tag){case 5:case 31:case 13:N8=!1;return;case 27:case 3:N8=!0;return;default:w6=w6.return}}function nJ(q){if(q!==w6)return!1;if(!gF)return _A(q),gF=!0,!1;var J=q.tag,Z;if(Z=J!==3&&J!==27){if(Z=J===5)Z=q.type,Z=!(Z!=="form"&&Z!=="button")||RG(q.type,q.memoizedProps);Z=!Z}if(Z&&z1){for(Z=z1;Z;){var Q=jq(q,0),w=SR(Z);Q.serverTail.push(w),Z=w.type==="Suspense"?OG(Z):t6(Z.nextSibling)}E9(q)}if(_A(q),J===13){if(q=q.memoizedState,q=q!==null?q.dehydrated:null,!q)throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");z1=OG(q)}else if(J===31){if(q=q.memoizedState,q=q!==null?q.dehydrated:null,!q)throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");z1=OG(q)}else J===27?(J=z1,x9(q.type)?(q=J5,J5=null,z1=q):z1=J):z1=w6?t6(q.stateNode.nextSibling):null;return!0}function xq(){z1=w6=null,T7=gF=!1}function oY(){var q=c9;return q!==null&&(C6===null?C6=q:C6.push.apply(C6,q),c9=null),q}function gZ(q){c9===null?c9=[q]:c9.push(q)}function aY(){var q=J8;if(q!==null){J8=null;for(var J=U1(q);0<q.children.length;)q=q.children[0];v0(q.fiber,function(){console.error(`A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`,"https://react.dev/link/hydration-mismatch",J)})}}function WW(){O_=AH=null,f_=!1}function C9(q,J,Z){X0(UK,J._currentValue,q),J._currentValue=Z,X0(BK,J._currentRenderer,q),J._currentRenderer!==void 0&&J._currentRenderer!==null&&J._currentRenderer!==JD&&console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."),J._currentRenderer=JD}function m7(q,J){q._currentValue=UK.current;var Z=BK.current;$0(BK,J),q._currentRenderer=Z,$0(UK,J)}function rY(q,J,Z){for(;q!==null;){var Q=q.alternate;if((q.childLanes&J)!==J?(q.childLanes|=J,Q!==null&&(Q.childLanes|=J)):Q!==null&&(Q.childLanes&J)!==J&&(Q.childLanes|=J),q===Z)break;q=q.return}q!==Z&&console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.")}function tY(q,J,Z,Q){var w=q.child;w!==null&&(w.return=q);for(;w!==null;){var X=w.dependencies;if(X!==null){var B=w.child;X=X.firstContext;F:for(;X!==null;){var R=X;X=w;for(var I=0;I<J.length;I++)if(R.context===J[I]){X.lanes|=Z,R=X.alternate,R!==null&&(R.lanes|=Z),rY(X.return,Z,q),Q||(B=null);break F}X=R.next}}else if(w.tag===18){if(B=w.return,B===null)throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");B.lanes|=Z,X=B.alternate,X!==null&&(X.lanes|=Z),rY(B,Z,q),B=null}else B=w.child;if(B!==null)B.return=w;else for(B=w;B!==null;){if(B===q){B=null;break}if(w=B.sibling,w!==null){w.return=B.return,B=w;break}B=B.return}w=B}}function cJ(q,J,Z,Q){q=null;for(var w=J,X=!1;w!==null;){if(!X){if((w.flags&524288)!==0)X=!0;else if((w.flags&262144)!==0)break}if(w.tag===10){var B=w.alternate;if(B===null)throw Error("Should have a current fiber. This is a bug in React.");if(B=B.memoizedProps,B!==null){var R=w.type;I6(w.pendingProps.value,B.value)||(q!==null?q.push(R):q=[R])}}else if(w===JH.current){if(B=w.alternate,B===null)throw Error("Should have a current fiber. This is a bug in React.");B.memoizedState.memoizedState!==w.memoizedState.memoizedState&&(q!==null?q.push(ZQ):q=[ZQ])}w=w.return}q!==null&&tY(J,q,Z,Q),J.flags|=262144}function HW(q){for(q=q.firstContext;q!==null;){if(!I6(q.context._currentValue,q.memoizedValue))return!0;q=q.next}return!1}function gq(q){AH=q,O_=null,q=q.dependencies,q!==null&&(q.firstContext=null)}function h1(q){return f_&&console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."),ZA(AH,q)}function wW(q,J){return AH===null&&gq(q),ZA(q,J)}function ZA(q,J){var Z=J._currentValue;if(J={context:J,memoizedValue:Z,next:null},O_===null){if(q===null)throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");O_=J,q.dependencies={lanes:0,firstContext:J,_debugThenableState:null},q.flags|=524288}else O_=O_.next=J;return Z}function eY(){return{controller:new LT,data:new Map,refCount:0}}function uq(q){q.controller.signal.aborted&&console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React."),q.refCount++}function uZ(q){q.refCount--,0>q.refCount&&console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React."),q.refCount===0&&ET(CT,function(){q.controller.abort()})}function Q7(q,J,Z){if((q&127)!==0)0>L7&&(L7=y1(),L$=hH(J),zK=J,Z!=null&&(AK=V(Z)),(cF&(l1|$8))!==t1&&(I1=!0,a9=T$),q=W$(),J=Q$(),q!==I_||J!==E$?I_=-1.1:J!==null&&(a9=T$),rq=q,E$=J);else if((q&4194048)!==0&&0>D8&&(D8=y1(),C$=hH(J),_D=J,Z!=null&&(ZD=V(Z)),0>F9)){if(q=W$(),J=Q$(),q!==t9||J!==tq)t9=-1.1;r9=q,tq=J}}function sI(q){if(0>L7){L7=y1(),L$=q._debugTask!=null?q._debugTask:null,(cF&(l1|$8))!==t1&&(a9=T$);var J=W$(),Z=Q$();J!==I_||Z!==E$?I_=-1.1:Z!==null&&(a9=T$),rq=J,E$=Z}if(0>D8&&(D8=y1(),C$=q._debugTask!=null?q._debugTask:null,0>F9)){if(q=W$(),J=Q$(),q!==t9||J!==tq)t9=-1.1;r9=q,tq=J}}function l7(){var q=aq;return aq=0,q}function YW(q){var J=aq;return aq=q,J}function pZ(q){var J=aq;return aq+=q,J}function XW(){KF=WF=-1.1}function s6(){var q=WF;return WF=-1.1,q}function o6(q){0<=q&&(WF=q)}function W7(){var q=M1;return M1=-0,q}function H7(q){0<=q&&(M1=q)}function w7(){var q=R1;return R1=null,q}function Y7(){var q=I1;return I1=!1,q}function FX(q){T6=y1(),0>q.actualStartTime&&(q.actualStartTime=T6)}function qX(q){if(0<=T6){var J=y1()-T6;q.actualDuration+=J,q.selfBaseDuration=J,T6=-1}}function $A(q){if(0<=T6){var J=y1()-T6;q.actualDuration+=J,T6=-1}}function X7(){if(0<=T6){var q=y1(),J=q-T6;T6=-1,aq+=J,M1+=J,KF=q}}function QA(q){R1===null&&(R1=[]),R1.push(q),e7===null&&(e7=[]),e7.push(q)}function G7(){T6=y1(),0>WF&&(WF=T6)}function mZ(q){for(var J=q.child;J;)q.actualDuration+=J.actualDuration,J=J.sibling}function oI(q,J){if(V$===null){var Z=V$=[];RK=0,eq=YG(),T_={status:"pending",value:void 0,then:function(Q){Z.push(Q)}}}return RK++,J.then(WA,WA),J}function WA(){if(--RK===0&&(-1<D8||(F9=-1.1),V$!==null)){T_!==null&&(T_.status="fulfilled");var q=V$;V$=null,eq=0,T_=null;for(var J=0;J<q.length;J++)(0,q[J])()}}function aI(q,J){var Z=[],Q={status:"pending",value:null,reason:null,then:function(w){Z.push(w)}};return q.then(function(){Q.status="fulfilled",Q.value=J;for(var w=0;w<Z.length;w++)(0,Z[w])(J)},function(w){Q.status="rejected",Q.reason=w;for(w=0;w<Z.length;w++)(0,Z[w])(void 0)}),Q}function JX(){var q=FJ.current;return q!==null?q:H1.pooledCache}function GW(q,J){J===null?X0(FJ,FJ.current,q):X0(FJ,J.pool,q)}function HA(){var q=JX();return q===null?null:{parent:S1._currentValue,pool:q}}function wA(){return{didWarnAboutUncachedPromise:!1,thenables:[]}}function YA(q){return q=q.status,q==="fulfilled"||q==="rejected"}function XA(q,J,Z){R0.actQueue!==null&&(R0.didUsePromise=!0);var Q=q.thenables;if(Z=Q[Z],Z===void 0?Q.push(J):Z!==J&&(q.didWarnAboutUncachedPromise||(q.didWarnAboutUncachedPromise=!0,console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")),J.then(g7,g7),J=Z),J._debugInfo===void 0){q=performance.now(),Q=J.displayName;var w={name:typeof Q==="string"?Q:"Promise",start:q,end:q,value:J};J._debugInfo=[{awaited:w}],J.status!=="fulfilled"&&J.status!=="rejected"&&(q=function(){w.end=performance.now()},J.then(q,q))}switch(J.status){case"fulfilled":return J.value;case"rejected":throw q=J.reason,KA(q),q;default:if(typeof J.status==="string")J.then(g7,g7);else{if(q=H1,q!==null&&100<q.shellSuspendCounter)throw Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");q=J,q.status="pending",q.then(function(X){if(J.status==="pending"){var B=J;B.status="fulfilled",B.value=X}},function(X){if(J.status==="pending"){var B=J;B.status="rejected",B.reason=X}})}switch(J.status){case"fulfilled":return J.value;case"rejected":throw q=J.reason,KA(q),q}throw JJ=J,x$=!0,L_}}function P9(q){try{return ST(q)}catch(J){if(J!==null&&typeof J==="object"&&typeof J.then==="function")throw JJ=J,x$=!0,L_;throw J}}function GA(){if(JJ===null)throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");var q=JJ;return JJ=null,x$=!1,q}function KA(q){if(q===L_||q===TH)throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.")}function $6(q){var J=TF;return q!=null&&(TF=J===null?q:J.concat(q)),J}function _X(){var q=TF;if(q!=null){for(var J=q.length-1;0<=J;J--)if(q[J].name!=null){var Z=q[J].debugTask;if(Z!=null)return Z}}return null}function KW(q,J,Z){for(var Q=Object.keys(q.props),w=0;w<Q.length;w++){var X=Q[w];if(X!=="children"&&X!=="key"){J===null&&(J=$W(q,Z.mode,0),J._debugInfo=TF,J.return=Z),v0(J,function(B){console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",B)},X);break}}}function UW(q){var J=g$;return g$+=1,E_===null&&(E_=wA()),XA(E_,q,J)}function lZ(q,J){J=J.props.ref,q.ref=J!==void 0?J:null}function UA(q,J){if(J.$$typeof===G4)throw Error(`A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`);throw q=Object.prototype.toString.call(J),Error("Objects are not valid as a React child (found: "+(q==="[object Object]"?"object with keys {"+Object.keys(J).join(", ")+"}":q)+"). If you meant to render a collection of children, use an array instead.")}function BW(q,J){var Z=_X();Z!==null?Z.run(UA.bind(null,q,J)):UA(q,J)}function BA(q,J){var Z=V(q)||"Component";fD[Z]||(fD[Z]=!0,J=J.displayName||J.name||"Component",q.tag===3?console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`,J,J,J):console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`,J,J,Z,J,Z))}function zW(q,J){var Z=_X();Z!==null?Z.run(BA.bind(null,q,J)):BA(q,J)}function zA(q,J){var Z=V(q)||"Component";ID[Z]||(ID[Z]=!0,J=String(J),q.tag===3?console.error(`Symbols are not valid as a React child.
  root.render(%s)`,J):console.error(`Symbols are not valid as a React child.
  <%s>%s</%s>`,Z,J,Z))}function AW(q,J){var Z=_X();Z!==null?Z.run(zA.bind(null,q,J)):zA(q,J)}function AA(q){function J(l,c){if(q){var r=l.deletions;r===null?(l.deletions=[c],l.flags|=16):r.push(c)}}function Z(l,c){if(!q)return null;for(;c!==null;)J(l,c),c=c.sibling;return null}function Q(l){for(var c=new Map;l!==null;)l.key!==null?c.set(l.key,l):c.set(l.index,l),l=l.sibling;return c}function w(l,c){return l=u7(l,c),l.index=0,l.sibling=null,l}function X(l,c,r){if(l.index=r,!q)return l.flags|=1048576,c;if(r=l.alternate,r!==null)return r=r.index,r<c?(l.flags|=67108866,c):r;return l.flags|=67108866,c}function B(l){return q&&l.alternate===null&&(l.flags|=67108866),l}function R(l,c,r,f0){if(c===null||c.tag!==6)return c=iY(r,l.mode,f0),c.return=l,c._debugOwner=l,c._debugTask=l._debugTask,c._debugInfo=TF,c;return c=w(c,r),c.return=l,c._debugInfo=TF,c}function I(l,c,r,f0){var p0=r.type;if(p0===H_)return c=e(l,c,r.props.children,f0,r.key),KW(r,c,l),c;if(c!==null&&(c.elementType===p0||cz(c,r)||typeof p0==="object"&&p0!==null&&p0.$$typeof===e6&&P9(p0)===c.type))return c=w(c,r.props),lZ(c,r),c.return=l,c._debugOwner=r._owner,c._debugInfo=TF,c;return c=$W(r,l.mode,f0),lZ(c,r),c.return=l,c._debugInfo=TF,c}function C(l,c,r,f0){if(c===null||c.tag!==4||c.stateNode.containerInfo!==r.containerInfo||c.stateNode.implementation!==r.implementation)return c=nY(r,l.mode,f0),c.return=l,c._debugInfo=TF,c;return c=w(c,r.children||[]),c.return=l,c._debugInfo=TF,c}function e(l,c,r,f0,p0){if(c===null||c.tag!==7)return c=bq(r,l.mode,f0,p0),c.return=l,c._debugOwner=l,c._debugTask=l._debugTask,c._debugInfo=TF,c;return c=w(c,r),c.return=l,c._debugInfo=TF,c}function F0(l,c,r){if(typeof c==="string"&&c!==""||typeof c==="number"||typeof c==="bigint")return c=iY(""+c,l.mode,r),c.return=l,c._debugOwner=l,c._debugTask=l._debugTask,c._debugInfo=TF,c;if(typeof c==="object"&&c!==null){switch(c.$$typeof){case R7:return r=$W(c,l.mode,r),lZ(r,c),r.return=l,l=$6(c._debugInfo),r._debugInfo=TF,TF=l,r;case W_:return c=nY(c,l.mode,r),c.return=l,c._debugInfo=TF,c;case e6:var f0=$6(c._debugInfo);return c=P9(c),l=F0(l,c,r),TF=f0,l}if(p1(c)||o(c))return r=bq(c,l.mode,r,null),r.return=l,r._debugOwner=l,r._debugTask=l._debugTask,l=$6(c._debugInfo),r._debugInfo=TF,TF=l,r;if(typeof c.then==="function")return f0=$6(c._debugInfo),l=F0(l,UW(c),r),TF=f0,l;if(c.$$typeof===N7)return F0(l,wW(l,c),r);BW(l,c)}return typeof c==="function"&&zW(l,c),typeof c==="symbol"&&AW(l,c),null}function i(l,c,r,f0){var p0=c!==null?c.key:null;if(typeof r==="string"&&r!==""||typeof r==="number"||typeof r==="bigint")return p0!==null?null:R(l,c,""+r,f0);if(typeof r==="object"&&r!==null){switch(r.$$typeof){case R7:return r.key===p0?(p0=$6(r._debugInfo),l=I(l,c,r,f0),TF=p0,l):null;case W_:return r.key===p0?C(l,c,r,f0):null;case e6:return p0=$6(r._debugInfo),r=P9(r),l=i(l,c,r,f0),TF=p0,l}if(p1(r)||o(r)){if(p0!==null)return null;return p0=$6(r._debugInfo),l=e(l,c,r,f0,null),TF=p0,l}if(typeof r.then==="function")return p0=$6(r._debugInfo),l=i(l,c,UW(r),f0),TF=p0,l;if(r.$$typeof===N7)return i(l,c,wW(l,r),f0);BW(l,r)}return typeof r==="function"&&zW(l,r),typeof r==="symbol"&&AW(l,r),null}function U0(l,c,r,f0,p0){if(typeof f0==="string"&&f0!==""||typeof f0==="number"||typeof f0==="bigint")return l=l.get(r)||null,R(c,l,""+f0,p0);if(typeof f0==="object"&&f0!==null){switch(f0.$$typeof){case R7:return r=l.get(f0.key===null?r:f0.key)||null,l=$6(f0._debugInfo),c=I(c,r,f0,p0),TF=l,c;case W_:return l=l.get(f0.key===null?r:f0.key)||null,C(c,l,f0,p0);case e6:var NF=$6(f0._debugInfo);return f0=P9(f0),c=U0(l,c,r,f0,p0),TF=NF,c}if(p1(f0)||o(f0))return r=l.get(r)||null,l=$6(f0._debugInfo),c=e(c,r,f0,p0,null),TF=l,c;if(typeof f0.then==="function")return NF=$6(f0._debugInfo),c=U0(l,c,r,UW(f0),p0),TF=NF,c;if(f0.$$typeof===N7)return U0(l,c,r,wW(c,f0),p0);BW(c,f0)}return typeof f0==="function"&&zW(c,f0),typeof f0==="symbol"&&AW(c,f0),null}function x0(l,c,r,f0){if(typeof r!=="object"||r===null)return f0;switch(r.$$typeof){case R7:case W_:h(l,c,r);var p0=r.key;if(typeof p0!=="string")break;if(f0===null){f0=new Set,f0.add(p0);break}if(!f0.has(p0)){f0.add(p0);break}v0(c,function(){console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.",p0)});break;case e6:r=P9(r),x0(l,c,r,f0)}return f0}function i0(l,c,r,f0){for(var p0=null,NF=null,QF=null,qF=c,MF=c=0,A1=null;qF!==null&&MF<r.length;MF++){qF.index>MF?(A1=qF,qF=null):A1=qF.sibling;var k1=i(l,qF,r[MF],f0);if(k1===null){qF===null&&(qF=A1);break}p0=x0(l,k1,r[MF],p0),q&&qF&&k1.alternate===null&&J(l,qF),c=X(k1,c,MF),QF===null?NF=k1:QF.sibling=k1,QF=k1,qF=A1}if(MF===r.length)return Z(l,qF),gF&&p7(l,MF),NF;if(qF===null){for(;MF<r.length;MF++)qF=F0(l,r[MF],f0),qF!==null&&(p0=x0(l,qF,r[MF],p0),c=X(qF,c,MF),QF===null?NF=qF:QF.sibling=qF,QF=qF);return gF&&p7(l,MF),NF}for(qF=Q(qF);MF<r.length;MF++)A1=U0(qF,l,MF,r[MF],f0),A1!==null&&(p0=x0(l,A1,r[MF],p0),q&&A1.alternate!==null&&qF.delete(A1.key===null?MF:A1.key),c=X(A1,c,MF),QF===null?NF=A1:QF.sibling=A1,QF=A1);return q&&qF.forEach(function(w9){return J(l,w9)}),gF&&p7(l,MF),NF}function X1(l,c,r,f0){if(r==null)throw Error("An iterable object provided no iterator.");for(var p0=null,NF=null,QF=c,qF=c=0,MF=null,A1=null,k1=r.next();QF!==null&&!k1.done;qF++,k1=r.next()){QF.index>qF?(MF=QF,QF=null):MF=QF.sibling;var w9=i(l,QF,k1.value,f0);if(w9===null){QF===null&&(QF=MF);break}A1=x0(l,w9,k1.value,A1),q&&QF&&w9.alternate===null&&J(l,QF),c=X(w9,c,qF),NF===null?p0=w9:NF.sibling=w9,NF=w9,QF=MF}if(k1.done)return Z(l,QF),gF&&p7(l,qF),p0;if(QF===null){for(;!k1.done;qF++,k1=r.next())QF=F0(l,k1.value,f0),QF!==null&&(A1=x0(l,QF,k1.value,A1),c=X(QF,c,qF),NF===null?p0=QF:NF.sibling=QF,NF=QF);return gF&&p7(l,qF),p0}for(QF=Q(QF);!k1.done;qF++,k1=r.next())MF=U0(QF,l,qF,k1.value,f0),MF!==null&&(A1=x0(l,MF,k1.value,A1),q&&MF.alternate!==null&&QF.delete(MF.key===null?qF:MF.key),c=X(MF,c,qF),NF===null?p0=MF:NF.sibling=MF,NF=MF);return q&&QF.forEach(function(_L){return J(l,_L)}),gF&&p7(l,qF),p0}function mF(l,c,r,f0){if(typeof r==="object"&&r!==null&&r.type===H_&&r.key===null&&(KW(r,null,l),r=r.props.children),typeof r==="object"&&r!==null){switch(r.$$typeof){case R7:var p0=$6(r._debugInfo);F:{for(var NF=r.key;c!==null;){if(c.key===NF){if(NF=r.type,NF===H_){if(c.tag===7){Z(l,c.sibling),f0=w(c,r.props.children),f0.return=l,f0._debugOwner=r._owner,f0._debugInfo=TF,KW(r,f0,l),l=f0;break F}}else if(c.elementType===NF||cz(c,r)||typeof NF==="object"&&NF!==null&&NF.$$typeof===e6&&P9(NF)===c.type){Z(l,c.sibling),f0=w(c,r.props),lZ(f0,r),f0.return=l,f0._debugOwner=r._owner,f0._debugInfo=TF,l=f0;break F}Z(l,c);break}else J(l,c);c=c.sibling}r.type===H_?(f0=bq(r.props.children,l.mode,f0,r.key),f0.return=l,f0._debugOwner=l,f0._debugTask=l._debugTask,f0._debugInfo=TF,KW(r,f0,l),l=f0):(f0=$W(r,l.mode,f0),lZ(f0,r),f0.return=l,f0._debugInfo=TF,l=f0)}return l=B(l),TF=p0,l;case W_:F:{p0=r;for(r=p0.key;c!==null;){if(c.key===r)if(c.tag===4&&c.stateNode.containerInfo===p0.containerInfo&&c.stateNode.implementation===p0.implementation){Z(l,c.sibling),f0=w(c,p0.children||[]),f0.return=l,l=f0;break F}else{Z(l,c);break}else J(l,c);c=c.sibling}f0=nY(p0,l.mode,f0),f0.return=l,l=f0}return B(l);case e6:return p0=$6(r._debugInfo),r=P9(r),l=mF(l,c,r,f0),TF=p0,l}if(p1(r))return p0=$6(r._debugInfo),l=i0(l,c,r,f0),TF=p0,l;if(o(r)){if(p0=$6(r._debugInfo),NF=o(r),typeof NF!=="function")throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");var QF=NF.call(r);if(QF===r){if(l.tag!==0||Object.prototype.toString.call(l.type)!=="[object GeneratorFunction]"||Object.prototype.toString.call(QF)!=="[object Generator]")MD||console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."),MD=!0}else r.entries!==NF||OK||(console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."),OK=!0);return l=X1(l,c,QF,f0),TF=p0,l}if(typeof r.then==="function")return p0=$6(r._debugInfo),l=mF(l,c,UW(r),f0),TF=p0,l;if(r.$$typeof===N7)return mF(l,c,wW(l,r),f0);BW(l,r)}if(typeof r==="string"&&r!==""||typeof r==="number"||typeof r==="bigint")return p0=""+r,c!==null&&c.tag===6?(Z(l,c.sibling),f0=w(c,p0),f0.return=l,l=f0):(Z(l,c),f0=iY(p0,l.mode,f0),f0.return=l,f0._debugOwner=l,f0._debugTask=l._debugTask,f0._debugInfo=TF,l=f0),B(l);return typeof r==="function"&&zW(l,r),typeof r==="symbol"&&AW(l,r),Z(l,c)}return function(l,c,r,f0){var p0=TF;TF=null;try{g$=0;var NF=mF(l,c,r,f0);return E_=null,NF}catch(A1){if(A1===L_||A1===TH)throw A1;var QF=N(29,A1,null,l.mode);QF.lanes=f0,QF.return=l;var qF=QF._debugInfo=TF;if(QF._debugOwner=l._debugOwner,QF._debugTask=l._debugTask,qF!=null){for(var MF=qF.length-1;0<=MF;MF--)if(typeof qF[MF].stack==="string"){QF._debugOwner=qF[MF],QF._debugTask=qF[MF].debugTask;break}}return QF}finally{TF=p0}}}function hA(q,J){var Z=p1(q);return q=!Z&&typeof o(q)==="function",Z||q?(Z=Z?"array":"iterable",console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",Z,J,Z),!1):!0}function ZX(q){q.updateQueue={baseState:q.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function $X(q,J){q=q.updateQueue,J.updateQueue===q&&(J.updateQueue={baseState:q.baseState,firstBaseUpdate:q.firstBaseUpdate,lastBaseUpdate:q.lastBaseUpdate,shared:q.shared,callbacks:null})}function V9(q){return{lane:q,tag:LD,payload:null,callback:null,next:null}}function k9(q,J,Z){var Q=q.updateQueue;if(Q===null)return null;if(Q=Q.shared,IK===Q&&!PD){var w=V(q);console.error(`An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`,w),PD=!0}if((cF&l1)!==t1)return w=Q.pending,w===null?J.next=J:(J.next=w.next,w.next=J),Q.pending=J,J=ZW(q),nz(q,null,Z),J;return _W(q,Q,J,Z),ZW(q)}function dZ(q,J,Z){if(J=J.updateQueue,J!==null&&(J=J.shared,(Z&4194048)!==0)){var Q=J.lanes;Q&=q.pendingLanes,Z|=Q,J.lanes=Z,n0(q,Z)}}function hW(q,J){var{updateQueue:Z,alternate:Q}=q;if(Q!==null&&(Q=Q.updateQueue,Z===Q)){var w=null,X=null;if(Z=Z.firstBaseUpdate,Z!==null){do{var B={lane:Z.lane,tag:Z.tag,payload:Z.payload,callback:null,next:null};X===null?w=X=B:X=X.next=B,Z=Z.next}while(Z!==null);X===null?w=X=J:X=X.next=J}else w=X=J;Z={baseState:Q.baseState,firstBaseUpdate:w,lastBaseUpdate:X,shared:Q.shared,callbacks:Q.callbacks},q.updateQueue=Z;return}q=Z.lastBaseUpdate,q===null?Z.firstBaseUpdate=J:q.next=J,Z.lastBaseUpdate=J}function iZ(){if(TK){var q=T_;if(q!==null)throw q}}function nZ(q,J,Z,Q){TK=!1;var w=q.updateQueue;e9=!1,IK=w.shared;var{firstBaseUpdate:X,lastBaseUpdate:B}=w,R=w.shared.pending;if(R!==null){w.shared.pending=null;var I=R,C=I.next;I.next=null,B===null?X=C:B.next=C,B=I;var e=q.alternate;e!==null&&(e=e.updateQueue,R=e.lastBaseUpdate,R!==B&&(R===null?e.firstBaseUpdate=C:R.next=C,e.lastBaseUpdate=I))}if(X!==null){var F0=w.baseState;B=0,e=C=I=null,R=X;do{var i=R.lane&-536870913,U0=i!==R.lane;if(U0?(LF&i)===i:(Q&i)===i){i!==0&&i===eq&&(TK=!0),e!==null&&(e=e.next={lane:0,tag:R.tag,payload:R.payload,callback:null,next:null});F:{i=q;var x0=R,i0=J,X1=Z;switch(x0.tag){case ED:if(x0=x0.payload,typeof x0==="function"){f_=!0;var mF=x0.call(X1,F0,i0);if(i.mode&K6){s0(!0);try{x0.call(X1,F0,i0)}finally{s0(!1)}}f_=!1,F0=mF;break F}F0=x0;break F;case fK:i.flags=i.flags&-65537|128;case LD:if(mF=x0.payload,typeof mF==="function"){if(f_=!0,x0=mF.call(X1,F0,i0),i.mode&K6){s0(!0);try{mF.call(X1,F0,i0)}finally{s0(!1)}}f_=!1}else x0=mF;if(x0===null||x0===void 0)break F;F0=yF({},F0,x0);break F;case CD:e9=!0}}i=R.callback,i!==null&&(q.flags|=64,U0&&(q.flags|=8192),U0=w.callbacks,U0===null?w.callbacks=[i]:U0.push(i))}else U0={lane:i,tag:R.tag,payload:R.payload,callback:R.callback,next:null},e===null?(C=e=U0,I=F0):e=e.next=U0,B|=i;if(R=R.next,R===null)if(R=w.shared.pending,R===null)break;else U0=R,R=U0.next,U0.next=null,w.lastBaseUpdate=U0,w.shared.pending=null}while(1);e===null&&(I=F0),w.baseState=I,w.firstBaseUpdate=C,w.lastBaseUpdate=e,X===null&&(w.shared.lanes=0),Jq|=B,q.lanes=B,q.memoizedState=F0}IK=null}function RA(q,J){if(typeof q!=="function")throw Error("Invalid argument passed as callback. Expected a function. Instead received: "+q);q.call(J)}function rI(q,J){var Z=q.shared.hiddenCallbacks;if(Z!==null)for(q.shared.hiddenCallbacks=null,q=0;q<Z.length;q++)RA(Z[q],J)}function NA(q,J){var Z=q.callbacks;if(Z!==null)for(q.callbacks=null,q=0;q<Z.length;q++)RA(Z[q],J)}function DA(q,J){var Z=P7;X0(EH,Z,q),X0(C_,J,q),P7=Z|J.baseLanes}function QX(q){X0(EH,P7,q),X0(C_,C_.current,q)}function WX(q){P7=EH.current,$0(C_,q),$0(EH,q)}function S9(q){var J=q.alternate;X0(V1,V1.current&P_,q),X0(_8,q,q),M8===null&&(J===null||C_.current!==null?M8=q:J.memoizedState!==null&&(M8=q))}function HX(q){X0(V1,V1.current,q),X0(_8,q,q),M8===null&&(M8=q)}function MA(q){q.tag===22?(X0(V1,V1.current,q),X0(_8,q,q),M8===null&&(M8=q)):y9(q)}function y9(q){X0(V1,V1.current,q),X0(_8,_8.current,q)}function a6(q){$0(_8,q),M8===q&&(M8=null),$0(V1,q)}function RW(q){for(var J=q;J!==null;){if(J.tag===13){var Z=J.memoizedState;if(Z!==null&&(Z=Z.dehydrated,Z===null||DG(Z)||MG(Z)))return J}else if(J.tag===19&&(J.memoizedProps.revealOrder==="forwards"||J.memoizedProps.revealOrder==="backwards"||J.memoizedProps.revealOrder==="unstable_legacy-backwards"||J.memoizedProps.revealOrder==="together")){if((J.flags&128)!==0)return J}else if(J.child!==null){J.child.return=J,J=J.child;continue}if(J===q)break;for(;J.sibling===null;){if(J.return===null||J.return===q)return null;J=J.return}J.sibling.return=J.return,J=J.sibling}return null}function SF(){var q=A0;f8===null?f8=[q]:f8.push(q)}function k0(){var q=A0;if(f8!==null&&(Z9++,f8[Z9]!==q)){var J=V(RF);if(!VD.has(J)&&(VD.add(J),f8!==null)){for(var Z="",Q=0;Q<=Z9;Q++){var w=f8[Q],X=Q===Z9?q:w;for(w=Q+1+". "+w;30>w.length;)w+=" ";w+=X+`
`,Z+=w}console.error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,J,Z)}}}function sJ(q){q===void 0||q===null||p1(q)||console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",A0,typeof q)}function NW(){var q=V(RF);SD.has(q)||(SD.add(q),console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",q))}function E1(){throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`)}function wX(q,J){if(m$)return!1;if(J===null)return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",A0),!1;q.length!==J.length&&console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,A0,"["+J.join(", ")+"]","["+q.join(", ")+"]");for(var Z=0;Z<J.length&&Z<q.length;Z++)if(!I6(q[Z],J[Z]))return!1;return!0}function YX(q,J,Z,Q,w,X){if(J9=X,RF=J,f8=q!==null?q._debugHookTypes:null,Z9=-1,m$=q!==null&&q.type!==J.type,Object.prototype.toString.call(Z)==="[object AsyncFunction]"||Object.prototype.toString.call(Z)==="[object AsyncGeneratorFunction]")X=V(RF),LK.has(X)||(LK.add(X),console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",X===null?"An unknown Component":"<"+X+">"));J.memoizedState=null,J.updateQueue=null,J.lanes=0,R0.H=q!==null&&q.memoizedState!==null?CK:f8!==null?yD:EK,ZJ=X=(J.mode&K6)!==BF;var B=NK(Z,Q,w);if(ZJ=!1,k_&&(B=XX(J,Z,Q,w)),X){s0(!0);try{B=XX(J,Z,Q,w)}finally{s0(!1)}}return OA(q,J),B}function OA(q,J){J._debugHookTypes=f8,J.dependencies===null?_9!==null&&(J.dependencies={lanes:0,firstContext:null,_debugThenableState:_9}):J.dependencies._debugThenableState=_9,R0.H=l$;var Z=W1!==null&&W1.next!==null;if(J9=0,f8=A0=v1=W1=RF=null,Z9=-1,q!==null&&(q.flags&65011712)!==(J.flags&65011712)&&console.error("Internal React error: Expected static flag was missing. Please notify the React team."),PH=!1,p$=0,_9=null,Z)throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");q===null||b1||(q=q.dependencies,q!==null&&HW(q)&&(b1=!0)),x$?(x$=!1,q=!0):q=!1,q&&(J=V(J)||"Unknown",kD.has(J)||LK.has(J)||(kD.add(J),console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")))}function XX(q,J,Z,Q){RF=q;var w=0;do{if(k_&&(_9=null),p$=0,k_=!1,w>=vT)throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");if(w+=1,m$=!1,v1=W1=null,q.updateQueue!=null){var X=q.updateQueue;X.lastEffect=null,X.events=null,X.stores=null,X.memoCache!=null&&(X.memoCache.index=0)}Z9=-1,R0.H=vD,X=NK(J,Z,Q)}while(k_);return X}function tI(){var q=R0.H,J=q.useState()[0];return J=typeof J.then==="function"?cZ(J):J,q=q.useState()[0],(W1!==null?W1.memoizedState:null)!==q&&(RF.flags|=1024),J}function GX(){var q=VH!==0;return VH=0,q}function KX(q,J,Z){J.updateQueue=q.updateQueue,J.flags=(J.mode&p8)!==BF?J.flags&-402655237:J.flags&-2053,q.lanes&=~Z}function UX(q){if(PH){for(q=q.memoizedState;q!==null;){var J=q.queue;J!==null&&(J.pending=null),q=q.next}PH=!1}J9=0,f8=v1=W1=RF=null,Z9=-1,A0=null,k_=!1,p$=VH=0,_9=null}function D6(){var q={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return v1===null?RF.memoizedState=v1=q:v1=v1.next=q,v1}function J1(){if(W1===null){var q=RF.alternate;q=q!==null?q.memoizedState:null}else q=W1.next;var J=v1===null?RF.memoizedState:v1.next;if(J!==null)v1=J,W1=q;else{if(q===null){if(RF.alternate===null)throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");throw Error("Rendered more hooks than during the previous render.")}W1=q,q={memoizedState:W1.memoizedState,baseState:W1.baseState,baseQueue:W1.baseQueue,queue:W1.queue,next:null},v1===null?RF.memoizedState=v1=q:v1=v1.next=q}return v1}function DW(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function cZ(q){var J=p$;return p$+=1,_9===null&&(_9=wA()),q=XA(_9,q,J),J=RF,(v1===null?J.memoizedState:v1.next)===null&&(J=J.alternate,R0.H=J!==null&&J.memoizedState!==null?CK:EK),q}function v9(q){if(q!==null&&typeof q==="object"){if(typeof q.then==="function")return cZ(q);if(q.$$typeof===N7)return h1(q)}throw Error("An unsupported type was passed to use(): "+String(q))}function pq(q){var J=null,Z=RF.updateQueue;if(Z!==null&&(J=Z.memoCache),J==null){var Q=RF.alternate;Q!==null&&(Q=Q.updateQueue,Q!==null&&(Q=Q.memoCache,Q!=null&&(J={data:Q.data.map(function(w){return w.slice()}),index:0})))}if(J==null&&(J={data:[],index:0}),Z===null&&(Z=DW(),RF.updateQueue=Z),Z.memoCache=J,Z=J.data[J.index],Z===void 0||m$)for(Z=J.data[J.index]=Array(q),Q=0;Q<q;Q++)Z[Q]=K4;else Z.length!==q&&console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",Z.length,q);return J.index++,Z}function j8(q,J){return typeof J==="function"?J(q):J}function BX(q,J,Z){var Q=D6();if(Z!==void 0){var w=Z(J);if(ZJ){s0(!0);try{Z(J)}finally{s0(!1)}}}else w=J;return Q.memoizedState=Q.baseState=w,q={pending:null,lanes:0,dispatch:null,lastRenderedReducer:q,lastRenderedState:w},Q.queue=q,q=q.dispatch=_3.bind(null,RF,q),[Q.memoizedState,q]}function oJ(q){var J=J1();return zX(J,W1,q)}function zX(q,J,Z){var Q=q.queue;if(Q===null)throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");Q.lastRenderedReducer=Z;var w=q.baseQueue,X=Q.pending;if(X!==null){if(w!==null){var B=w.next;w.next=X.next,X.next=B}J.baseQueue!==w&&console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."),J.baseQueue=w=X,Q.pending=null}if(X=q.baseState,w===null)q.memoizedState=X;else{J=w.next;var R=B=null,I=null,C=J,e=!1;do{var F0=C.lane&-536870913;if(F0!==C.lane?(LF&F0)===F0:(J9&F0)===F0){var i=C.revertLane;if(i===0)I!==null&&(I=I.next={lane:0,revertLane:0,gesture:null,action:C.action,hasEagerState:C.hasEagerState,eagerState:C.eagerState,next:null}),F0===eq&&(e=!0);else if((J9&i)===i){C=C.next,i===eq&&(e=!0);continue}else F0={lane:0,revertLane:C.revertLane,gesture:null,action:C.action,hasEagerState:C.hasEagerState,eagerState:C.eagerState,next:null},I===null?(R=I=F0,B=X):I=I.next=F0,RF.lanes|=i,Jq|=i;F0=C.action,ZJ&&Z(X,F0),X=C.hasEagerState?C.eagerState:Z(X,F0)}else i={lane:F0,revertLane:C.revertLane,gesture:C.gesture,action:C.action,hasEagerState:C.hasEagerState,eagerState:C.eagerState,next:null},I===null?(R=I=i,B=X):I=I.next=i,RF.lanes|=F0,Jq|=F0;C=C.next}while(C!==null&&C!==J);if(I===null?B=X:I.next=R,!I6(X,q.memoizedState)&&(b1=!0,e&&(Z=T_,Z!==null)))throw Z;q.memoizedState=X,q.baseState=B,q.baseQueue=I,Q.lastRenderedState=X}return w===null&&(Q.lanes=0),[q.memoizedState,Q.dispatch]}function sZ(q){var J=J1(),Z=J.queue;if(Z===null)throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");Z.lastRenderedReducer=q;var{dispatch:Q,pending:w}=Z,X=J.memoizedState;if(w!==null){Z.pending=null;var B=w=w.next;do X=q(X,B.action),B=B.next;while(B!==w);I6(X,J.memoizedState)||(b1=!0),J.memoizedState=X,J.baseQueue===null&&(J.baseState=X),Z.lastRenderedState=X}return[X,Q]}function AX(q,J,Z){var Q=RF,w=D6();if(gF){if(Z===void 0)throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");var X=Z();V_||X===Z()||(console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"),V_=!0)}else{if(X=J(),V_||(Z=J(),I6(X,Z)||(console.error("The result of getSnapshot should be cached to avoid an infinite loop"),V_=!0)),H1===null)throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");(LF&127)!==0||fA(Q,J,X)}return w.memoizedState=X,Z={value:X,getSnapshot:J},w.queue=Z,IW(TA.bind(null,Q,Z,q),[q]),Q.flags|=2048,rJ(O8|E6,{destroy:void 0},IA.bind(null,Q,Z,X,J),null),X}function MW(q,J,Z){var Q=RF,w=J1(),X=gF;if(X){if(Z===void 0)throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");Z=Z()}else if(Z=J(),!V_){var B=J();I6(Z,B)||(console.error("The result of getSnapshot should be cached to avoid an infinite loop"),V_=!0)}if(B=!I6((W1||w).memoizedState,Z))w.memoizedState=Z,b1=!0;w=w.queue;var R=TA.bind(null,Q,w,q);if(j6(2048,E6,R,[q]),w.getSnapshot!==J||B||v1!==null&&v1.memoizedState.tag&O8){if(Q.flags|=2048,rJ(O8|E6,{destroy:void 0},IA.bind(null,Q,w,Z,J),null),H1===null)throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");X||(J9&127)!==0||fA(Q,J,Z)}return Z}function fA(q,J,Z){q.flags|=16384,q={getSnapshot:J,value:Z},J=RF.updateQueue,J===null?(J=DW(),RF.updateQueue=J,J.stores=[q]):(Z=J.stores,Z===null?J.stores=[q]:Z.push(q))}function IA(q,J,Z,Q){J.value=Z,J.getSnapshot=Q,LA(J)&&EA(q)}function TA(q,J,Z){return Z(function(){LA(J)&&(Q7(2,"updateSyncExternalStore()",q),EA(q))})}function LA(q){var J=q.getSnapshot;q=q.value;try{var Z=J();return!I6(q,Z)}catch(Q){return!0}}function EA(q){var J=X6(q,2);J!==null&&f1(J,q,2)}function hX(q){var J=D6();if(typeof q==="function"){var Z=q;if(q=Z(),ZJ){s0(!0);try{Z()}finally{s0(!1)}}}return J.memoizedState=J.baseState=q,J.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:j8,lastRenderedState:q},J}function RX(q){q=hX(q);var J=q.queue,Z=cA.bind(null,RF,J);return J.dispatch=Z,[q.memoizedState,Z]}function NX(q){var J=D6();J.memoizedState=J.baseState=q;var Z={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return J.queue=Z,J=yX.bind(null,RF,!0,Z),Z.dispatch=J,[q,J]}function CA(q,J){var Z=J1();return PA(Z,W1,q,J)}function PA(q,J,Z,Q){return q.baseState=Z,zX(q,W1,typeof Q==="function"?Q:j8)}function VA(q,J){var Z=J1();if(W1!==null)return PA(Z,W1,q,J);return Z.baseState=q,[q,Z.queue.dispatch]}function eI(q,J,Z,Q,w){if(VW(q))throw Error("Cannot update form state while rendering.");if(q=J.action,q!==null){var X={payload:w,action:q,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(B){X.listeners.push(B)}};R0.T!==null?Z(!0):X.isTransition=!1,Q(X),Z=J.pending,Z===null?(X.next=J.pending=X,kA(J,X)):(X.next=Z.next,J.pending=Z.next=X)}}function kA(q,J){var{action:Z,payload:Q}=J,w=q.state;if(J.isTransition){var X=R0.T,B={};B._updatedFibers=new Set,R0.T=B;try{var R=Z(w,Q),I=R0.S;I!==null&&I(B,R),SA(q,J,R)}catch(C){DX(q,J,C)}finally{X!==null&&B.types!==null&&(X.types!==null&&X.types!==B.types&&console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."),X.types=B.types),R0.T=X,X===null&&B._updatedFibers&&(q=B._updatedFibers.size,B._updatedFibers.clear(),10<q&&console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."))}}else try{B=Z(w,Q),SA(q,J,B)}catch(C){DX(q,J,C)}}function SA(q,J,Z){Z!==null&&typeof Z==="object"&&typeof Z.then==="function"?(R0.asyncTransitions++,Z.then(PW,PW),Z.then(function(Q){yA(q,J,Q)},function(Q){return DX(q,J,Q)}),J.isTransition||console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")):yA(q,J,Z)}function yA(q,J,Z){J.status="fulfilled",J.value=Z,vA(J),q.state=Z,J=q.pending,J!==null&&(Z=J.next,Z===J?q.pending=null:(Z=Z.next,J.next=Z,kA(q,Z)))}function DX(q,J,Z){var Q=q.pending;if(q.pending=null,Q!==null){Q=Q.next;do J.status="rejected",J.reason=Z,vA(J),J=J.next;while(J!==Q)}q.action=null}function vA(q){q=q.listeners;for(var J=0;J<q.length;J++)(0,q[J])()}function bA(q,J){return J}function aJ(q,J){if(gF){var Z=H1.formState;if(Z!==null){F:{var Q=RF;if(gF){if(z1){q:{var w=z1;for(var X=N8;w.nodeType!==8;){if(!X){w=null;break q}if(w=t6(w.nextSibling),w===null){w=null;break q}}X=w.data,w=X===tK||X===NM?w:null}if(w){z1=t6(w.nextSibling),Q=w.data===tK;break F}}E9(Q)}Q=!1}Q&&(J=Z[0])}}return Z=D6(),Z.memoizedState=Z.baseState=J,Q={pending:null,lanes:0,dispatch:null,lastRenderedReducer:bA,lastRenderedState:J},Z.queue=Q,Z=cA.bind(null,RF,Q),Q.dispatch=Z,Q=hX(!1),X=yX.bind(null,RF,!1,Q.queue),Q=D6(),w={state:J,dispatch:null,action:q,pending:null},Q.queue=w,Z=eI.bind(null,RF,w,X,Z),w.dispatch=Z,Q.memoizedState=q,[J,Z,!1]}function OW(q){var J=J1();return jA(J,W1,q)}function jA(q,J,Z){if(J=zX(q,J,bA)[0],q=oJ(j8)[0],typeof J==="object"&&J!==null&&typeof J.then==="function")try{var Q=cZ(J)}catch(B){if(B===L_)throw TH;throw B}else Q=J;J=J1();var w=J.queue,X=w.dispatch;return Z!==J.memoizedState&&(RF.flags|=2048,rJ(O8|E6,{destroy:void 0},F3.bind(null,w,Z),null)),[Q,X,q]}function F3(q,J){q.action=J}function fW(q){var J=J1(),Z=W1;if(Z!==null)return jA(J,Z,q);J1(),J=J.memoizedState,Z=J1();var Q=Z.queue.dispatch;return Z.memoizedState=q,[J,Q,!1]}function rJ(q,J,Z,Q){return q={tag:q,create:Z,deps:Q,inst:J,next:null},J=RF.updateQueue,J===null&&(J=DW(),RF.updateQueue=J),Z=J.lastEffect,Z===null?J.lastEffect=q.next=q:(Q=Z.next,Z.next=q,q.next=Q,J.lastEffect=q),q}function MX(q){var J=D6();return q={current:q},J.memoizedState=q}function mq(q,J,Z,Q){var w=D6();RF.flags|=q,w.memoizedState=rJ(O8|J,{destroy:void 0},Z,Q===void 0?null:Q)}function j6(q,J,Z,Q){var w=J1();Q=Q===void 0?null:Q;var X=w.memoizedState.inst;W1!==null&&Q!==null&&wX(Q,W1.memoizedState.deps)?w.memoizedState=rJ(J,X,Z,Q):(RF.flags|=q,w.memoizedState=rJ(O8|J,X,Z,Q))}function IW(q,J){(RF.mode&p8)!==BF?mq(276826112,E6,q,J):mq(8390656,E6,q,J)}function q3(q){RF.flags|=4;var J=RF.updateQueue;if(J===null)J=DW(),RF.updateQueue=J,J.events=[q];else{var Z=J.events;Z===null?J.events=[q]:Z.push(q)}}function OX(q){var J=D6(),Z={impl:q};return J.memoizedState=Z,function(){if((cF&l1)!==t1)throw Error("A function wrapped in useEffectEvent can't be called during rendering.");return Z.impl.apply(void 0,arguments)}}function TW(q){var J=J1().memoizedState;return q3({ref:J,nextImpl:q}),function(){if((cF&l1)!==t1)throw Error("A function wrapped in useEffectEvent can't be called during rendering.");return J.impl.apply(void 0,arguments)}}function fX(q,J){var Z=4194308;return(RF.mode&p8)!==BF&&(Z|=134217728),mq(Z,Z8,q,J)}function xA(q,J){if(typeof J==="function"){q=q();var Z=J(q);return function(){typeof Z==="function"?Z():J(null)}}if(J!==null&&J!==void 0)return J.hasOwnProperty("current")||console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.","an object with keys {"+Object.keys(J).join(", ")+"}"),q=q(),J.current=q,function(){J.current=null}}function IX(q,J,Z){typeof J!=="function"&&console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",J!==null?typeof J:"null"),Z=Z!==null&&Z!==void 0?Z.concat([q]):null;var Q=4194308;(RF.mode&p8)!==BF&&(Q|=134217728),mq(Q,Z8,xA.bind(null,J,q),Z)}function LW(q,J,Z){typeof J!=="function"&&console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",J!==null?typeof J:"null"),Z=Z!==null&&Z!==void 0?Z.concat([q]):null,j6(4,Z8,xA.bind(null,J,q),Z)}function TX(q,J){return D6().memoizedState=[q,J===void 0?null:J],q}function EW(q,J){var Z=J1();J=J===void 0?null:J;var Q=Z.memoizedState;if(J!==null&&wX(J,Q[1]))return Q[0];return Z.memoizedState=[q,J],q}function LX(q,J){var Z=D6();J=J===void 0?null:J;var Q=q();if(ZJ){s0(!0);try{q()}finally{s0(!1)}}return Z.memoizedState=[Q,J],Q}function CW(q,J){var Z=J1();J=J===void 0?null:J;var Q=Z.memoizedState;if(J!==null&&wX(J,Q[1]))return Q[0];if(Q=q(),ZJ){s0(!0);try{q()}finally{s0(!1)}}return Z.memoizedState=[Q,J],Q}function EX(q,J){var Z=D6();return CX(Z,q,J)}function gA(q,J){var Z=J1();return pA(Z,W1.memoizedState,q,J)}function uA(q,J){var Z=J1();return W1===null?CX(Z,q,J):pA(Z,W1.memoizedState,q,J)}function CX(q,J,Z){if(Z===void 0||(J9&1073741824)!==0&&(LF&261930)===0)return q.memoizedState=J;return q.memoizedState=Z,q=mh(),RF.lanes|=q,Jq|=q,Z}function pA(q,J,Z,Q){if(I6(Z,J))return Z;if(C_.current!==null)return q=CX(q,Z,Q),I6(q,J)||(b1=!0),q;if((J9&42)===0||(J9&1073741824)!==0&&(LF&261930)===0)return b1=!0,q.memoizedState=Z;return q=mh(),RF.lanes|=q,Jq|=q,J}function PW(){R0.asyncTransitions--}function mA(q,J,Z,Q,w){var X=F1.p;F1.p=X!==0&&X<u8?X:u8;var B=R0.T,R={};R._updatedFibers=new Set,R0.T=R,yX(q,!1,J,Z);try{var I=w(),C=R0.S;if(C!==null&&C(R,I),I!==null&&typeof I==="object"&&typeof I.then==="function"){R0.asyncTransitions++,I.then(PW,PW);var e=aI(I,Q);oZ(q,J,e,r6(q))}else oZ(q,J,Q,r6(q))}catch(F0){oZ(q,J,{then:function(){},status:"rejected",reason:F0},r6(q))}finally{F1.p=X,B!==null&&R.types!==null&&(B.types!==null&&B.types!==R.types&&console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."),B.types=R.types),R0.T=B,B===null&&R._updatedFibers&&(q=R._updatedFibers.size,R._updatedFibers.clear(),10<q&&console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."))}}function PX(q,J,Z,Q){if(q.tag!==5)throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");var w=lA(q).queue;sI(q),mA(q,w,J,BJ,Z===null?z:function(){return dA(q),Z(Q)})}function lA(q){var J=q.memoizedState;if(J!==null)return J;J={memoizedState:BJ,baseState:BJ,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:j8,lastRenderedState:BJ},next:null};var Z={};return J.next={memoizedState:Z,baseState:Z,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:j8,lastRenderedState:Z},next:null},q.memoizedState=J,q=q.alternate,q!==null&&(q.memoizedState=J),J}function dA(q){R0.T===null&&console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");var J=lA(q);J.next===null&&(J=q.alternate.memoizedState),oZ(q,J.next.queue,{},r6(q))}function VX(){var q=hX(!1);return q=mA.bind(null,RF,q.queue,!0,!1),D6().memoizedState=q,[!1,q]}function iA(){var q=oJ(j8)[0],J=J1().memoizedState;return[typeof q==="boolean"?q:cZ(q),J]}function nA(){var q=sZ(j8)[0],J=J1().memoizedState;return[typeof q==="boolean"?q:cZ(q),J]}function lq(){return h1(ZQ)}function kX(){var q=D6(),J=H1.identifierPrefix;if(gF){var Z=r7,Q=a7;Z=(Q&~(1<<32-M6(Q)-1)).toString(32)+Z,J="_"+J+"R_"+Z,Z=VH++,0<Z&&(J+="H"+Z.toString(32)),J+="_"}else Z=yT++,J="_"+J+"r_"+Z.toString(32)+"_";return q.memoizedState=J}function SX(){return D6().memoizedState=J3.bind(null,RF)}function J3(q,J){for(var Z=q.return;Z!==null;){switch(Z.tag){case 24:case 3:var Q=r6(Z),w=V9(Q),X=k9(Z,w,Q);X!==null&&(Q7(Q,"refresh()",q),f1(X,Z,Q),dZ(X,Z,Q)),q=eY(),J!==null&&J!==void 0&&X!==null&&console.error("The seed argument is not enabled outside experimental channels."),w.payload={cache:q};return}Z=Z.return}}function _3(q,J,Z){var Q=arguments;typeof Q[3]==="function"&&console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."),Q=r6(q);var w={lane:Q,revertLane:0,gesture:null,action:Z,hasEagerState:!1,eagerState:null,next:null};VW(q)?sA(J,w):(w=pY(q,J,w,Q),w!==null&&(Q7(Q,"dispatch()",q),f1(w,q,Q),oA(w,J,Q)))}function cA(q,J,Z){var Q=arguments;typeof Q[3]==="function"&&console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."),Q=r6(q),oZ(q,J,Z,Q)&&Q7(Q,"setState()",q)}function oZ(q,J,Z,Q){var w={lane:Q,revertLane:0,gesture:null,action:Z,hasEagerState:!1,eagerState:null,next:null};if(VW(q))sA(J,w);else{var X=q.alternate;if(q.lanes===0&&(X===null||X.lanes===0)&&(X=J.lastRenderedReducer,X!==null)){var B=R0.H;R0.H=l8;try{var R=J.lastRenderedState,I=X(R,Z);if(w.hasEagerState=!0,w.eagerState=I,I6(I,R))return _W(q,J,w,0),H1===null&&JW(),!1}catch(C){}finally{R0.H=B}}if(Z=pY(q,J,w,Q),Z!==null)return f1(Z,q,Q),oA(Z,J,Q),!0}return!1}function yX(q,J,Z,Q){if(R0.T===null&&eq===0&&console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."),Q={lane:2,revertLane:YG(),gesture:null,action:Q,hasEagerState:!1,eagerState:null,next:null},VW(q)){if(J)throw Error("Cannot update optimistic state while rendering.");console.error("Cannot call startTransition while rendering.")}else J=pY(q,Z,Q,2),J!==null&&(Q7(2,"setOptimistic()",q),f1(J,q,2))}function VW(q){var J=q.alternate;return q===RF||J!==null&&J===RF}function sA(q,J){k_=PH=!0;var Z=q.pending;Z===null?J.next=J:(J.next=Z.next,Z.next=J),q.pending=J}function oA(q,J,Z){if((Z&4194048)!==0){var Q=J.lanes;Q&=q.pendingLanes,Z|=Q,J.lanes=Z,n0(q,Z)}}function vX(q){if(q!==null&&typeof q!=="function"){var J=String(q);nD.has(J)||(nD.add(J),console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.",q))}}function bX(q,J,Z,Q){var w=q.memoizedState,X=Z(Q,w);if(q.mode&K6){s0(!0);try{X=Z(Q,w)}finally{s0(!1)}}X===void 0&&(J=s(J)||"Component",mD.has(J)||(mD.add(J),console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",J))),w=X===null||X===void 0?w:yF({},w,X),q.memoizedState=w,q.lanes===0&&(q.updateQueue.baseState=w)}function aA(q,J,Z,Q,w,X,B){var R=q.stateNode;if(typeof R.shouldComponentUpdate==="function"){if(Z=R.shouldComponentUpdate(Q,X,B),q.mode&K6){s0(!0);try{Z=R.shouldComponentUpdate(Q,X,B)}finally{s0(!1)}}return Z===void 0&&console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",s(J)||"Component"),Z}return J.prototype&&J.prototype.isPureReactComponent?!jZ(Z,Q)||!jZ(w,X):!0}function rA(q,J,Z,Q){var w=J.state;typeof J.componentWillReceiveProps==="function"&&J.componentWillReceiveProps(Z,Q),typeof J.UNSAFE_componentWillReceiveProps==="function"&&J.UNSAFE_componentWillReceiveProps(Z,Q),J.state!==w&&(q=V(q)||"Component",jD.has(q)||(jD.add(q),console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",q)),PK.enqueueReplaceState(J,J.state,null))}function dq(q,J){var Z=J;if("ref"in J){Z={};for(var Q in J)Q!=="ref"&&(Z[Q]=J[Q])}if(q=q.defaultProps){Z===J&&(Z=yF({},Z));for(var w in q)Z[w]===void 0&&(Z[w]=q[w])}return Z}function tA(q){WK(q),console.warn(`%s

%s
`,S_?"An error occurred in the <"+S_+"> component.":"An error occurred in one of your React components.",`Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`)}function eA(q){var J=S_?"The above error occurred in the <"+S_+"> component.":"The above error occurred in one of your React components.",Z="React will try to recreate this component tree from scratch using the error boundary you provided, "+((VK||"Anonymous")+".");if(typeof q==="object"&&q!==null&&typeof q.environmentName==="string"){var Q=q.environmentName;q=[`%o

%s

%s
`,q,J,Z].slice(0),typeof q[0]==="string"?q.splice(0,1,EM+" "+q[0],CM,Jw+Q+Jw,PM):q.splice(0,0,EM,CM,Jw+Q+Jw,PM),q.unshift(console),Q=qL.apply(console.error,q),Q()}else console.error(`%o

%s

%s
`,q,J,Z)}function Fh(q){WK(q)}function kW(q,J){try{S_=J.source?V(J.source):null,VK=null;var Z=J.value;if(R0.actQueue!==null)R0.thrownErrors.push(Z);else{var Q=q.onUncaughtError;Q(Z,{componentStack:J.stack})}}catch(w){setTimeout(function(){throw w})}}function qh(q,J,Z){try{S_=Z.source?V(Z.source):null,VK=V(J);var Q=q.onCaughtError;Q(Z.value,{componentStack:Z.stack,errorBoundary:J.tag===1?J.stateNode:null})}catch(w){setTimeout(function(){throw w})}}function jX(q,J,Z){return Z=V9(Z),Z.tag=fK,Z.payload={element:null},Z.callback=function(){v0(J.source,kW,q,J)},Z}function xX(q){return q=V9(q),q.tag=fK,q}function gX(q,J,Z,Q){var w=Z.type.getDerivedStateFromError;if(typeof w==="function"){var X=Q.value;q.payload=function(){return w(X)},q.callback=function(){sz(Z),v0(Q.source,qh,J,Z,Q)}}var B=Z.stateNode;B!==null&&typeof B.componentDidCatch==="function"&&(q.callback=function(){sz(Z),v0(Q.source,qh,J,Z,Q),typeof w!=="function"&&(Zq===null?Zq=new Set([this]):Zq.add(this)),PT(this,Q),typeof w==="function"||(Z.lanes&2)===0&&console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",V(Z)||"Unknown")})}function Z3(q,J,Z,Q,w){if(Z.flags|=32768,O7&&_$(q,w),Q!==null&&typeof Q==="object"&&typeof Q.then==="function"){if(J=Z.alternate,J!==null&&cJ(J,Z,w,!0),gF&&(T7=!0),Z=_8.current,Z!==null){switch(Z.tag){case 31:case 13:return M8===null?pW():Z.alternate===null&&O1===Q9&&(O1=yH),Z.flags&=-257,Z.flags|=65536,Z.lanes=w,Q===LH?Z.flags|=16384:(J=Z.updateQueue,J===null?Z.updateQueue=new Set([Q]):J.add(Q),QG(q,Q,w)),!1;case 22:return Z.flags|=65536,Q===LH?Z.flags|=16384:(J=Z.updateQueue,J===null?(J={transitions:null,markerInstances:null,retryQueue:new Set([Q])},Z.updateQueue=J):(Z=J.retryQueue,Z===null?J.retryQueue=new Set([Q]):Z.add(Q)),QG(q,Q,w)),!1}throw Error("Unexpected Suspense handler tag ("+Z.tag+"). This is a bug in React.")}return QG(q,Q,w),pW(),!1}if(gF)return T7=!0,J=_8.current,J!==null?((J.flags&65536)===0&&(J.flags|=256),J.flags|=65536,J.lanes=w,Q!==KK&&gZ(c6(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",{cause:Q}),Z))):(Q!==KK&&gZ(c6(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.",{cause:Q}),Z)),q=q.current.alternate,q.flags|=65536,w&=-w,q.lanes|=w,Q=c6(Q,Z),w=jX(q.stateNode,Q,w),hW(q,w),O1!==Fq&&(O1=$J)),!1;var X=c6(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",{cause:Q}),Z);if(o$===null?o$=[X]:o$.push(X),O1!==Fq&&(O1=$J),J===null)return!0;Q=c6(Q,Z),Z=J;do{switch(Z.tag){case 3:return Z.flags|=65536,q=w&-w,Z.lanes|=q,q=jX(Z.stateNode,Q,q),hW(Z,q),!1;case 1:if(J=Z.type,X=Z.stateNode,(Z.flags&128)===0&&(typeof J.getDerivedStateFromError==="function"||X!==null&&typeof X.componentDidCatch==="function"&&(Zq===null||!Zq.has(X))))return Z.flags|=65536,w&=-w,Z.lanes|=w,w=xX(w),gX(w,q,Z,Q),hW(Z,w),!1}Z=Z.return}while(Z!==null);return!1}function Q6(q,J,Z,Q){J.child=q===null?TD(J,null,Z,Q):_J(J,q.child,Z,Q)}function Jh(q,J,Z,Q,w){Z=Z.render;var X=J.ref;if("ref"in Q){var B={};for(var R in Q)R!=="ref"&&(B[R]=Q[R])}else B=Q;if(gq(J),Q=YX(q,J,Z,B,X,w),R=GX(),q!==null&&!b1)return KX(q,J,w),d7(q,J,w);return gF&&R&&cY(J),J.flags|=1,Q6(q,J,Q,w),J.child}function _h(q,J,Z,Q,w){if(q===null){var X=Z.type;if(typeof X==="function"&&!lY(X)&&X.defaultProps===void 0&&Z.compare===null)return Z=vq(X),J.tag=15,J.type=Z,pX(J,X),Zh(q,J,Z,Q,w);return q=dY(Z.type,null,Q,J,J.mode,w),q.ref=J.ref,q.return=J,J.child=q}if(X=q.child,!cX(q,w)){var B=X.memoizedProps;if(Z=Z.compare,Z=Z!==null?Z:jZ,Z(B,Q)&&q.ref===J.ref)return d7(q,J,w)}return J.flags|=1,q=u7(X,Q),q.ref=J.ref,q.return=J,J.child=q}function Zh(q,J,Z,Q,w){if(q!==null){var X=q.memoizedProps;if(jZ(X,Q)&&q.ref===J.ref&&J.type===q.type)if(b1=!1,J.pendingProps=Q=X,cX(q,w))(q.flags&131072)!==0&&(b1=!0);else return J.lanes=q.lanes,d7(q,J,w)}return uX(q,J,Z,Q,w)}function $h(q,J,Z,Q){var w=Q.children,X=q!==null?q.memoizedState:null;if(q===null&&J.stateNode===null&&(J.stateNode={_visibility:f$,_pendingMarkers:null,_retryCache:null,_transitions:null}),Q.mode==="hidden"){if((J.flags&128)!==0){if(X=X!==null?X.baseLanes|Z:Z,q!==null){Q=J.child=q.child;for(w=0;Q!==null;)w=w|Q.lanes|Q.childLanes,Q=Q.sibling;Q=w&~X}else Q=0,J.child=null;return Qh(q,J,X,Z,Q)}if((Z&536870912)!==0)J.memoizedState={baseLanes:0,cachePool:null},q!==null&&GW(J,X!==null?X.cachePool:null),X!==null?DA(J,X):QX(J),MA(J);else return Q=J.lanes=536870912,Qh(q,J,X!==null?X.baseLanes|Z:Z,Z,Q)}else X!==null?(GW(J,X.cachePool),DA(J,X),y9(J),J.memoizedState=null):(q!==null&&GW(J,null),QX(J),y9(J));return Q6(q,J,w,Z),J.child}function aZ(q,J){return q!==null&&q.tag===22||J.stateNode!==null||(J.stateNode={_visibility:f$,_pendingMarkers:null,_retryCache:null,_transitions:null}),J.sibling}function Qh(q,J,Z,Q,w){var X=JX();return X=X===null?null:{parent:S1._currentValue,pool:X},J.memoizedState={baseLanes:Z,cachePool:X},q!==null&&GW(J,null),QX(J),MA(J),q!==null&&cJ(q,J,Q,!0),J.childLanes=w,null}function SW(q,J){var Z=J.hidden;return Z!==void 0&&console.error(`<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`,Z===!0?"hidden":Z===!1?"hidden={false}":"hidden={...}",Z?'mode="hidden"':'mode="visible"'),J=vW({mode:J.mode,children:J.children},q.mode),J.ref=q.ref,q.child=J,J.return=q,J}function Wh(q,J,Z){return _J(J,q.child,null,Z),q=SW(J,J.pendingProps),q.flags|=2,a6(J),J.memoizedState=null,q}function $3(q,J,Z){var Q=J.pendingProps,w=(J.flags&128)!==0;if(J.flags&=-129,q===null){if(gF){if(Q.mode==="hidden")return q=SW(J,Q),J.lanes=536870912,aZ(null,q);if(HX(J),(q=z1)?(Z=kR(q,N8),Z=Z!==null&&Z.data===XJ?Z:null,Z!==null&&(Q={dehydrated:Z,treeContext:ez(),retryLane:536870912,hydrationErrors:null},J.memoizedState=Q,Q=rz(Z),Q.return=J,J.child=Q,w6=J,z1=null)):Z=null,Z===null)throw QW(J,q),E9(J);return J.lanes=536870912,null}return SW(J,Q)}var X=q.memoizedState;if(X!==null){var B=X.dehydrated;if(HX(J),w)if(J.flags&256)J.flags&=-257,J=Wh(q,J,Z);else if(J.memoizedState!==null)J.child=q.child,J.flags|=128,J=null;else throw Error("Client rendering an Activity suspended it again. This is a bug in React.");else if(qA(),(Z&536870912)!==0&&uW(J),b1||cJ(q,J,Z,!1),w=(Z&q.childLanes)!==0,b1||w){if(Q=H1,Q!==null&&(B=ZF(Q,Z),B!==0&&B!==X.retryLane))throw X.retryLane=B,X6(q,B),f1(Q,q,B),kK;pW(),J=Wh(q,J,Z)}else q=X.treeContext,z1=t6(B.nextSibling),w6=J,gF=!0,c9=null,T7=!1,J8=null,N8=!1,q!==null&&FA(J,q),J=SW(J,Q),J.flags|=4096;return J}return X=q.child,Q={mode:Q.mode,children:Q.children},(Z&536870912)!==0&&(Z&q.lanes)!==0&&uW(J),q=u7(X,Q),q.ref=J.ref,J.child=q,q.return=J,q}function yW(q,J){var Z=J.ref;if(Z===null)q!==null&&q.ref!==null&&(J.flags|=4194816);else{if(typeof Z!=="function"&&typeof Z!=="object")throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");if(q===null||q.ref!==Z)J.flags|=4194816}}function uX(q,J,Z,Q,w){if(Z.prototype&&typeof Z.prototype.render==="function"){var X=s(Z)||"Unknown";cD[X]||(console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",X,X),cD[X]=!0)}if(J.mode&K6&&m8.recordLegacyContextWarning(J,null),q===null&&(pX(J,J.type),Z.contextTypes&&(X=s(Z)||"Unknown",oD[X]||(oD[X]=!0,console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",X)))),gq(J),Z=YX(q,J,Z,Q,void 0,w),Q=GX(),q!==null&&!b1)return KX(q,J,w),d7(q,J,w);return gF&&Q&&cY(J),J.flags|=1,Q6(q,J,Z,w),J.child}function Hh(q,J,Z,Q,w,X){if(gq(J),Z9=-1,m$=q!==null&&q.type!==J.type,J.updateQueue=null,Z=XX(J,Q,Z,w),OA(q,J),Q=GX(),q!==null&&!b1)return KX(q,J,X),d7(q,J,X);return gF&&Q&&cY(J),J.flags|=1,Q6(q,J,Z,X),J.child}function wh(q,J,Z,Q,w){switch(K(J)){case!1:var X=J.stateNode,B=new J.type(J.memoizedProps,X.context).state;X.updater.enqueueSetState(X,B,null);break;case!0:J.flags|=128,J.flags|=65536,X=Error("Simulated error coming from DevTools");var R=w&-w;if(J.lanes|=R,B=H1,B===null)throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");R=xX(R),gX(R,B,J,c6(X,J)),hW(J,R)}if(gq(J),J.stateNode===null){if(B=n9,X=Z.contextType,"contextType"in Z&&X!==null&&(X===void 0||X.$$typeof!==N7)&&!iD.has(Z)&&(iD.add(Z),R=X===void 0?" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.":typeof X!=="object"?" However, it is set to a "+typeof X+".":X.$$typeof===SG?" Did you accidentally pass the Context.Consumer instead?":" However, it is set to an object with keys {"+Object.keys(X).join(", ")+"}.",console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",s(Z)||"Component",R)),typeof X==="object"&&X!==null&&(B=h1(X)),X=new Z(Q,B),J.mode&K6){s0(!0);try{X=new Z(Q,B)}finally{s0(!1)}}if(B=J.memoizedState=X.state!==null&&X.state!==void 0?X.state:null,X.updater=PK,J.stateNode=X,X._reactInternals=J,X._reactInternalInstance=bD,typeof Z.getDerivedStateFromProps==="function"&&B===null&&(B=s(Z)||"Component",xD.has(B)||(xD.add(B),console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",B,X.state===null?"null":"undefined",B))),typeof Z.getDerivedStateFromProps==="function"||typeof X.getSnapshotBeforeUpdate==="function"){var I=R=B=null;if(typeof X.componentWillMount==="function"&&X.componentWillMount.__suppressDeprecationWarning!==!0?B="componentWillMount":typeof X.UNSAFE_componentWillMount==="function"&&(B="UNSAFE_componentWillMount"),typeof X.componentWillReceiveProps==="function"&&X.componentWillReceiveProps.__suppressDeprecationWarning!==!0?R="componentWillReceiveProps":typeof X.UNSAFE_componentWillReceiveProps==="function"&&(R="UNSAFE_componentWillReceiveProps"),typeof X.componentWillUpdate==="function"&&X.componentWillUpdate.__suppressDeprecationWarning!==!0?I="componentWillUpdate":typeof X.UNSAFE_componentWillUpdate==="function"&&(I="UNSAFE_componentWillUpdate"),B!==null||R!==null||I!==null){X=s(Z)||"Component";var C=typeof Z.getDerivedStateFromProps==="function"?"getDerivedStateFromProps()":"getSnapshotBeforeUpdate()";uD.has(X)||(uD.add(X),console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`,X,C,B!==null?`
  `+B:"",R!==null?`
  `+R:"",I!==null?`
  `+I:""))}}X=J.stateNode,B=s(Z)||"Component",X.render||(Z.prototype&&typeof Z.prototype.render==="function"?console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?",B):console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.",B)),!X.getInitialState||X.getInitialState.isReactClassApproved||X.state||console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",B),X.getDefaultProps&&!X.getDefaultProps.isReactClassApproved&&console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",B),X.contextType&&console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.",B),Z.childContextTypes&&!dD.has(Z)&&(dD.add(Z),console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",B)),Z.contextTypes&&!lD.has(Z)&&(lD.add(Z),console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",B)),typeof X.componentShouldUpdate==="function"&&console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",B),Z.prototype&&Z.prototype.isPureReactComponent&&typeof X.shouldComponentUpdate<"u"&&console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",s(Z)||"A pure component"),typeof X.componentDidUnmount==="function"&&console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",B),typeof X.componentDidReceiveProps==="function"&&console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",B),typeof X.componentWillRecieveProps==="function"&&console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",B),typeof X.UNSAFE_componentWillRecieveProps==="function"&&console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",B),R=X.props!==Q,X.props!==void 0&&R&&console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",B),X.defaultProps&&console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",B,B),typeof X.getSnapshotBeforeUpdate!=="function"||typeof X.componentDidUpdate==="function"||gD.has(Z)||(gD.add(Z),console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",s(Z))),typeof X.getDerivedStateFromProps==="function"&&console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",B),typeof X.getDerivedStateFromError==="function"&&console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",B),typeof Z.getSnapshotBeforeUpdate==="function"&&console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",B),(R=X.state)&&(typeof R!=="object"||p1(R))&&console.error("%s.state: must be set to an object or null",B),typeof X.getChildContext==="function"&&typeof Z.childContextTypes!=="object"&&console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",B),X=J.stateNode,X.props=Q,X.state=J.memoizedState,X.refs={},ZX(J),B=Z.contextType,X.context=typeof B==="object"&&B!==null?h1(B):n9,X.state===Q&&(B=s(Z)||"Component",pD.has(B)||(pD.add(B),console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",B))),J.mode&K6&&m8.recordLegacyContextWarning(J,X),m8.recordUnsafeLifecycleWarnings(J,X),X.state=J.memoizedState,B=Z.getDerivedStateFromProps,typeof B==="function"&&(bX(J,Z,B,Q),X.state=J.memoizedState),typeof Z.getDerivedStateFromProps==="function"||typeof X.getSnapshotBeforeUpdate==="function"||typeof X.UNSAFE_componentWillMount!=="function"&&typeof X.componentWillMount!=="function"||(B=X.state,typeof X.componentWillMount==="function"&&X.componentWillMount(),typeof X.UNSAFE_componentWillMount==="function"&&X.UNSAFE_componentWillMount(),B!==X.state&&(console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",V(J)||"Component"),PK.enqueueReplaceState(X,X.state,null)),nZ(J,Q,X,w),iZ(),X.state=J.memoizedState),typeof X.componentDidMount==="function"&&(J.flags|=4194308),(J.mode&p8)!==BF&&(J.flags|=134217728),X=!0}else if(q===null){X=J.stateNode;var e=J.memoizedProps;R=dq(Z,e),X.props=R;var F0=X.context;I=Z.contextType,B=n9,typeof I==="object"&&I!==null&&(B=h1(I)),C=Z.getDerivedStateFromProps,I=typeof C==="function"||typeof X.getSnapshotBeforeUpdate==="function",e=J.pendingProps!==e,I||typeof X.UNSAFE_componentWillReceiveProps!=="function"&&typeof X.componentWillReceiveProps!=="function"||(e||F0!==B)&&rA(J,X,Q,B),e9=!1;var i=J.memoizedState;X.state=i,nZ(J,Q,X,w),iZ(),F0=J.memoizedState,e||i!==F0||e9?(typeof C==="function"&&(bX(J,Z,C,Q),F0=J.memoizedState),(R=e9||aA(J,Z,R,Q,i,F0,B))?(I||typeof X.UNSAFE_componentWillMount!=="function"&&typeof X.componentWillMount!=="function"||(typeof X.componentWillMount==="function"&&X.componentWillMount(),typeof X.UNSAFE_componentWillMount==="function"&&X.UNSAFE_componentWillMount()),typeof X.componentDidMount==="function"&&(J.flags|=4194308),(J.mode&p8)!==BF&&(J.flags|=134217728)):(typeof X.componentDidMount==="function"&&(J.flags|=4194308),(J.mode&p8)!==BF&&(J.flags|=134217728),J.memoizedProps=Q,J.memoizedState=F0),X.props=Q,X.state=F0,X.context=B,X=R):(typeof X.componentDidMount==="function"&&(J.flags|=4194308),(J.mode&p8)!==BF&&(J.flags|=134217728),X=!1)}else{X=J.stateNode,$X(q,J),B=J.memoizedProps,I=dq(Z,B),X.props=I,C=J.pendingProps,i=X.context,F0=Z.contextType,R=n9,typeof F0==="object"&&F0!==null&&(R=h1(F0)),e=Z.getDerivedStateFromProps,(F0=typeof e==="function"||typeof X.getSnapshotBeforeUpdate==="function")||typeof X.UNSAFE_componentWillReceiveProps!=="function"&&typeof X.componentWillReceiveProps!=="function"||(B!==C||i!==R)&&rA(J,X,Q,R),e9=!1,i=J.memoizedState,X.state=i,nZ(J,Q,X,w),iZ();var U0=J.memoizedState;B!==C||i!==U0||e9||q!==null&&q.dependencies!==null&&HW(q.dependencies)?(typeof e==="function"&&(bX(J,Z,e,Q),U0=J.memoizedState),(I=e9||aA(J,Z,I,Q,i,U0,R)||q!==null&&q.dependencies!==null&&HW(q.dependencies))?(F0||typeof X.UNSAFE_componentWillUpdate!=="function"&&typeof X.componentWillUpdate!=="function"||(typeof X.componentWillUpdate==="function"&&X.componentWillUpdate(Q,U0,R),typeof X.UNSAFE_componentWillUpdate==="function"&&X.UNSAFE_componentWillUpdate(Q,U0,R)),typeof X.componentDidUpdate==="function"&&(J.flags|=4),typeof X.getSnapshotBeforeUpdate==="function"&&(J.flags|=1024)):(typeof X.componentDidUpdate!=="function"||B===q.memoizedProps&&i===q.memoizedState||(J.flags|=4),typeof X.getSnapshotBeforeUpdate!=="function"||B===q.memoizedProps&&i===q.memoizedState||(J.flags|=1024),J.memoizedProps=Q,J.memoizedState=U0),X.props=Q,X.state=U0,X.context=R,X=I):(typeof X.componentDidUpdate!=="function"||B===q.memoizedProps&&i===q.memoizedState||(J.flags|=4),typeof X.getSnapshotBeforeUpdate!=="function"||B===q.memoizedProps&&i===q.memoizedState||(J.flags|=1024),X=!1)}if(R=X,yW(q,J),B=(J.flags&128)!==0,R||B){if(R=J.stateNode,PF(J),B&&typeof Z.getDerivedStateFromError!=="function")Z=null,T6=-1;else if(Z=GD(R),J.mode&K6){s0(!0);try{GD(R)}finally{s0(!1)}}J.flags|=1,q!==null&&B?(J.child=_J(J,q.child,null,w),J.child=_J(J,null,Z,w)):Q6(q,J,Z,w),J.memoizedState=R.state,q=J.child}else q=d7(q,J,w);return w=J.stateNode,X&&w.props!==Q&&(y_||console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",V(J)||"a component"),y_=!0),q}function Yh(q,J,Z,Q){return xq(),J.flags|=256,Q6(q,J,Z,Q),J.child}function pX(q,J){J&&J.childContextTypes&&console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`,J.displayName||J.name||"Component"),typeof J.getDerivedStateFromProps==="function"&&(q=s(J)||"Unknown",aD[q]||(console.error("%s: Function components do not support getDerivedStateFromProps.",q),aD[q]=!0)),typeof J.contextType==="object"&&J.contextType!==null&&(J=s(J)||"Unknown",sD[J]||(console.error("%s: Function components do not support contextType.",J),sD[J]=!0))}function mX(q){return{baseLanes:q,cachePool:HA()}}function lX(q,J,Z){return q=q!==null?q.childLanes&~Z:0,J&&(q|=m6),q}function Xh(q,J,Z){var Q,w=J.pendingProps;Y(J)&&(J.flags|=128);var X=!1,B=(J.flags&128)!==0;if((Q=B)||(Q=q!==null&&q.memoizedState===null?!1:(V1.current&u$)!==0),Q&&(X=!0,J.flags&=-129),Q=(J.flags&32)!==0,J.flags&=-33,q===null){if(gF){if(X?S9(J):y9(J),(q=z1)?(Z=kR(q,N8),Z=Z!==null&&Z.data!==XJ?Z:null,Z!==null&&(Q={dehydrated:Z,treeContext:ez(),retryLane:536870912,hydrationErrors:null},J.memoizedState=Q,Q=rz(Z),Q.return=J,J.child=Q,w6=J,z1=null)):Z=null,Z===null)throw QW(J,q),E9(J);return MG(Z)?J.lanes=32:J.lanes=536870912,null}var R=w.children;if(w=w.fallback,X){y9(J);var I=J.mode;return R=vW({mode:"hidden",children:R},I),w=bq(w,I,Z,null),R.return=J,w.return=J,R.sibling=w,J.child=R,w=J.child,w.memoizedState=mX(Z),w.childLanes=lX(q,Q,Z),J.memoizedState=SK,aZ(null,w)}return S9(J),dX(J,R)}var C=q.memoizedState;if(C!==null){var e=C.dehydrated;if(e!==null){if(B)J.flags&256?(S9(J),J.flags&=-257,J=iX(q,J,Z)):J.memoizedState!==null?(y9(J),J.child=q.child,J.flags|=128,J=null):(y9(J),R=w.fallback,I=J.mode,w=vW({mode:"visible",children:w.children},I),R=bq(R,I,Z,null),R.flags|=2,w.return=J,R.return=J,w.sibling=R,J.child=w,_J(J,q.child,null,Z),w=J.child,w.memoizedState=mX(Z),w.childLanes=lX(q,Q,Z),J.memoizedState=SK,J=aZ(null,w));else if(S9(J),qA(),(Z&536870912)!==0&&uW(J),MG(e)){if(Q=e.nextSibling&&e.nextSibling.dataset,Q){R=Q.dgst;var F0=Q.msg;I=Q.stck;var i=Q.cstck}X=F0,Q=R,w=I,e=i,R=X,I=e,R=R?Error(R):Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."),R.stack=w||"",R.digest=Q,Q=I===void 0?null:I,w={value:R,source:null,stack:Q},typeof Q==="string"&&GK.set(R,w),gZ(w),J=iX(q,J,Z)}else if(b1||cJ(q,J,Z,!1),Q=(Z&q.childLanes)!==0,b1||Q){if(Q=H1,Q!==null&&(w=ZF(Q,Z),w!==0&&w!==C.retryLane))throw C.retryLane=w,X6(q,w),f1(Q,q,w),kK;DG(e)||pW(),J=iX(q,J,Z)}else DG(e)?(J.flags|=192,J.child=q.child,J=null):(q=C.treeContext,z1=t6(e.nextSibling),w6=J,gF=!0,c9=null,T7=!1,J8=null,N8=!1,q!==null&&FA(J,q),J=dX(J,w.children),J.flags|=4096);return J}}if(X)return y9(J),R=w.fallback,I=J.mode,i=q.child,e=i.sibling,w=u7(i,{mode:"hidden",children:w.children}),w.subtreeFlags=i.subtreeFlags&65011712,e!==null?R=u7(e,R):(R=bq(R,I,Z,null),R.flags|=2),R.return=J,w.return=J,w.sibling=R,J.child=w,aZ(null,w),w=J.child,R=q.child.memoizedState,R===null?R=mX(Z):(I=R.cachePool,I!==null?(i=S1._currentValue,I=I.parent!==i?{parent:i,pool:i}:I):I=HA(),R={baseLanes:R.baseLanes|Z,cachePool:I}),w.memoizedState=R,w.childLanes=lX(q,Q,Z),J.memoizedState=SK,aZ(q.child,w);return C!==null&&(Z&62914560)===Z&&(Z&q.lanes)!==0&&uW(J),S9(J),Z=q.child,q=Z.sibling,Z=u7(Z,{mode:"visible",children:w.children}),Z.return=J,Z.sibling=null,q!==null&&(Q=J.deletions,Q===null?(J.deletions=[q],J.flags|=16):Q.push(q)),J.child=Z,J.memoizedState=null,Z}function dX(q,J){return J=vW({mode:"visible",children:J},q.mode),J.return=q,q.child=J}function vW(q,J){return q=N(22,q,null,J),q.lanes=0,q}function iX(q,J,Z){return _J(J,q.child,null,Z),q=dX(J,J.pendingProps.children),q.flags|=2,J.memoizedState=null,q}function Gh(q,J,Z){q.lanes|=J;var Q=q.alternate;Q!==null&&(Q.lanes|=J),rY(q.return,J,Z)}function nX(q,J,Z,Q,w,X){var B=q.memoizedState;B===null?q.memoizedState={isBackwards:J,rendering:null,renderingStartTime:0,last:Q,tail:Z,tailMode:w,treeForkCount:X}:(B.isBackwards=J,B.rendering=null,B.renderingStartTime=0,B.last=Q,B.tail=Z,B.tailMode=w,B.treeForkCount=X)}function Kh(q,J,Z){var Q=J.pendingProps,w=Q.revealOrder,X=Q.tail,B=Q.children,R=V1.current;if((Q=(R&u$)!==0)?(R=R&P_|u$,J.flags|=128):R&=P_,X0(V1,R,J),R=w==null?"null":w,w!=="forwards"&&w!=="unstable_legacy-backwards"&&w!=="together"&&w!=="independent"&&!rD[R])if(rD[R]=!0,w==null)console.error('The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".');else if(w==="backwards")console.error('The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.');else if(typeof w==="string")switch(w.toLowerCase()){case"together":case"forwards":case"backwards":case"independent":console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',w,w.toLowerCase());break;case"forward":case"backward":console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',w,w.toLowerCase());break;default:console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',w)}else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?',w);if(R=X==null?"null":X,!SH[R])if(X==null){if(w==="forwards"||w==="backwards"||w==="unstable_legacy-backwards")SH[R]=!0,console.error('The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".')}else X!=="visible"&&X!=="collapsed"&&X!=="hidden"?(SH[R]=!0,console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?',X)):w!=="forwards"&&w!=="backwards"&&w!=="unstable_legacy-backwards"&&(SH[R]=!0,console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',X));F:if((w==="forwards"||w==="backwards"||w==="unstable_legacy-backwards")&&B!==void 0&&B!==null&&B!==!1)if(p1(B)){for(R=0;R<B.length;R++)if(!hA(B[R],R))break F}else if(R=o(B),typeof R==="function"){if(R=R.call(B))for(var I=R.next(),C=0;!I.done;I=R.next()){if(!hA(I.value,C))break F;C++}}else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',w);if(Q6(q,J,B,Z),gF?(L9(),B=I$):B=0,!Q&&q!==null&&(q.flags&128)!==0)F:for(q=J.child;q!==null;){if(q.tag===13)q.memoizedState!==null&&Gh(q,Z,J);else if(q.tag===19)Gh(q,Z,J);else if(q.child!==null){q.child.return=q,q=q.child;continue}if(q===J)break F;for(;q.sibling===null;){if(q.return===null||q.return===J)break F;q=q.return}q.sibling.return=q.return,q=q.sibling}switch(w){case"forwards":Z=J.child;for(w=null;Z!==null;)q=Z.alternate,q!==null&&RW(q)===null&&(w=Z),Z=Z.sibling;Z=w,Z===null?(w=J.child,J.child=null):(w=Z.sibling,Z.sibling=null),nX(J,!1,w,Z,X,B);break;case"backwards":case"unstable_legacy-backwards":Z=null,w=J.child;for(J.child=null;w!==null;){if(q=w.alternate,q!==null&&RW(q)===null){J.child=w;break}q=w.sibling,w.sibling=Z,Z=w,w=q}nX(J,!0,Z,null,X,B);break;case"together":nX(J,!1,null,null,void 0,B);break;default:J.memoizedState=null}return J.child}function d7(q,J,Z){if(q!==null&&(J.dependencies=q.dependencies),T6=-1,Jq|=J.lanes,(Z&J.childLanes)===0)if(q!==null){if(cJ(q,J,Z,!1),(Z&J.childLanes)===0)return null}else return null;if(q!==null&&J.child!==q.child)throw Error("Resuming work not yet implemented.");if(J.child!==null){q=J.child,Z=u7(q,q.pendingProps),J.child=Z;for(Z.return=J;q.sibling!==null;)q=q.sibling,Z=Z.sibling=u7(q,q.pendingProps),Z.return=J;Z.sibling=null}return J.child}function cX(q,J){if((q.lanes&J)!==0)return!0;return q=q.dependencies,q!==null&&HW(q)?!0:!1}function Q3(q,J,Z){switch(J.tag){case 3:J0(J,J.stateNode.containerInfo),C9(J,S1,q.memoizedState.cache),xq();break;case 27:case 5:Q0(J);break;case 4:J0(J,J.stateNode.containerInfo);break;case 10:C9(J,J.type,J.memoizedProps.value);break;case 12:(Z&J.childLanes)!==0&&(J.flags|=4),J.flags|=2048;var Q=J.stateNode;Q.effectDuration=-0,Q.passiveEffectDuration=-0;break;case 31:if(J.memoizedState!==null)return J.flags|=128,HX(J),null;break;case 13:if(Q=J.memoizedState,Q!==null){if(Q.dehydrated!==null)return S9(J),J.flags|=128,null;if((Z&J.child.childLanes)!==0)return Xh(q,J,Z);return S9(J),q=d7(q,J,Z),q!==null?q.sibling:null}S9(J);break;case 19:var w=(q.flags&128)!==0;if(Q=(Z&J.childLanes)!==0,Q||(cJ(q,J,Z,!1),Q=(Z&J.childLanes)!==0),w){if(Q)return Kh(q,J,Z);J.flags|=128}if(w=J.memoizedState,w!==null&&(w.rendering=null,w.tail=null,w.lastEffect=null),X0(V1,V1.current,J),Q)break;else return null;case 22:return J.lanes=0,$h(q,J,Z,J.pendingProps);case 24:C9(J,S1,q.memoizedState.cache)}return d7(q,J,Z)}function sX(q,J,Z){if(J._debugNeedsRemount&&q!==null){Z=dY(J.type,J.key,J.pendingProps,J._debugOwner||null,J.mode,J.lanes),Z._debugStack=J._debugStack,Z._debugTask=J._debugTask;var Q=J.return;if(Q===null)throw Error("Cannot swap the root fiber.");if(q.alternate=null,J.alternate=null,Z.index=J.index,Z.sibling=J.sibling,Z.return=J.return,Z.ref=J.ref,Z._debugInfo=J._debugInfo,J===Q.child)Q.child=Z;else{var w=Q.child;if(w===null)throw Error("Expected parent to have a child.");for(;w.sibling!==J;)if(w=w.sibling,w===null)throw Error("Expected to find the previous sibling.");w.sibling=Z}return J=Q.deletions,J===null?(Q.deletions=[q],Q.flags|=16):J.push(q),Z.flags|=2,Z}if(q!==null)if(q.memoizedProps!==J.pendingProps||J.type!==q.type)b1=!0;else{if(!cX(q,Z)&&(J.flags&128)===0)return b1=!1,Q3(q,J,Z);b1=(q.flags&131072)!==0?!0:!1}else{if(b1=!1,Q=gF)L9(),Q=(J.flags&1048576)!==0;Q&&(Q=J.index,L9(),tz(J,I$,Q))}switch(J.lanes=0,J.tag){case 16:F:if(Q=J.pendingProps,q=P9(J.elementType),J.type=q,typeof q==="function")lY(q)?(Q=dq(q,Q),J.tag=1,J.type=q=vq(q),J=wh(null,J,q,Q,Z)):(J.tag=0,pX(J,q),J.type=q=vq(q),J=uX(null,J,q,Q,Z));else{if(q!==void 0&&q!==null){if(w=q.$$typeof,w===G$){J.tag=11,J.type=q=mY(q),J=Jh(null,J,q,Q,Z);break F}else if(w===qH){J.tag=14,J=_h(null,J,q,Q,Z);break F}}throw J="",q!==null&&typeof q==="object"&&q.$$typeof===e6&&(J=" Did you wrap a component in React.lazy() more than once?"),Z=s(q)||q,Error("Element type is invalid. Received a promise that resolves to: "+Z+". Lazy element type must resolve to a class or function."+J)}return J;case 0:return uX(q,J,J.type,J.pendingProps,Z);case 1:return Q=J.type,w=dq(Q,J.pendingProps),wh(q,J,Q,w,Z);case 3:F:{if(J0(J,J.stateNode.containerInfo),q===null)throw Error("Should have a current fiber. This is a bug in React.");Q=J.pendingProps;var X=J.memoizedState;w=X.element,$X(q,J),nZ(J,Q,null,Z);var B=J.memoizedState;if(Q=B.cache,C9(J,S1,Q),Q!==X.cache&&tY(J,[S1],Z,!0),iZ(),Q=B.element,X.isDehydrated)if(X={element:Q,isDehydrated:!1,cache:B.cache},J.updateQueue.baseState=X,J.memoizedState=X,J.flags&256){J=Yh(q,J,Q,Z);break F}else if(Q!==w){w=c6(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."),J),gZ(w),J=Yh(q,J,Q,Z);break F}else{switch(q=J.stateNode.containerInfo,q.nodeType){case 9:q=q.body;break;default:q=q.nodeName==="HTML"?q.ownerDocument.body:q}z1=t6(q.firstChild),w6=J,gF=!0,c9=null,T7=!1,J8=null,N8=!0,Z=TD(J,null,Q,Z);for(J.child=Z;Z;)Z.flags=Z.flags&-3|4096,Z=Z.sibling}else{if(xq(),Q===w){J=d7(q,J,Z);break F}Q6(q,J,Q,Z)}J=J.child}return J;case 26:return yW(q,J),q===null?(Z=xR(J.type,null,J.pendingProps,null))?J.memoizedState=Z:gF||(Z=J.type,q=J.pendingProps,Q=K0(u9.current),Q=iW(Q).createElement(Z),Q[H6]=J,Q[O6]=q,W6(Q,Z,q),Z0(Q),J.stateNode=Q):J.memoizedState=xR(J.type,q.memoizedProps,J.pendingProps,q.memoizedState),null;case 27:return Q0(J),q===null&&gF&&(Q=K0(u9.current),w=n(),Q=J.stateNode=bR(J.type,J.pendingProps,Q,w,!1),T7||(w=fR(Q,J.type,J.pendingProps,w),w!==null&&(jq(J,0).serverProps=w)),w6=J,N8=!0,w=z1,x9(J.type)?(J5=w,z1=t6(Q.firstChild)):z1=w),Q6(q,J,J.pendingProps.children,Z),yW(q,J),q===null&&(J.flags|=4194304),J.child;case 5:return q===null&&gF&&(X=n(),Q=J7(J.type,X.ancestorInfo),w=z1,(B=!w)||(B=s3(w,J.type,J.pendingProps,N8),B!==null?(J.stateNode=B,T7||(X=fR(B,J.type,J.pendingProps,X),X!==null&&(jq(J,0).serverProps=X)),w6=J,z1=t6(B.firstChild),N8=!1,X=!0):X=!1,B=!X),B&&(Q&&QW(J,w),E9(J))),Q0(J),w=J.type,X=J.pendingProps,B=q!==null?q.memoizedProps:null,Q=X.children,RG(w,X)?Q=null:B!==null&&RG(w,B)&&(J.flags|=32),J.memoizedState!==null&&(w=YX(q,J,tI,null,null,Z),ZQ._currentValue=w),yW(q,J),Q6(q,J,Q,Z),J.child;case 6:return q===null&&gF&&(Z=J.pendingProps,q=n(),Q=q.ancestorInfo.current,Z=Q!=null?c1(Z,Q.tag,q.ancestorInfo.implicitRootScope):!0,q=z1,(Q=!q)||(Q=o3(q,J.pendingProps,N8),Q!==null?(J.stateNode=Q,w6=J,z1=null,Q=!0):Q=!1,Q=!Q),Q&&(Z&&QW(J,q),E9(J))),null;case 13:return Xh(q,J,Z);case 4:return J0(J,J.stateNode.containerInfo),Q=J.pendingProps,q===null?J.child=_J(J,null,Q,Z):Q6(q,J,Q,Z),J.child;case 11:return Jh(q,J,J.type,J.pendingProps,Z);case 7:return Q6(q,J,J.pendingProps,Z),J.child;case 8:return Q6(q,J,J.pendingProps.children,Z),J.child;case 12:return J.flags|=4,J.flags|=2048,Q=J.stateNode,Q.effectDuration=-0,Q.passiveEffectDuration=-0,Q6(q,J,J.pendingProps.children,Z),J.child;case 10:return Q=J.type,w=J.pendingProps,X=w.value,"value"in w||tD||(tD=!0,console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")),C9(J,Q,X),Q6(q,J,w.children,Z),J.child;case 9:return w=J.type._context,Q=J.pendingProps.children,typeof Q!=="function"&&console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."),gq(J),w=h1(w),Q=NK(Q,w,void 0),J.flags|=1,Q6(q,J,Q,Z),J.child;case 14:return _h(q,J,J.type,J.pendingProps,Z);case 15:return Zh(q,J,J.type,J.pendingProps,Z);case 19:return Kh(q,J,Z);case 31:return $3(q,J,Z);case 22:return $h(q,J,Z,J.pendingProps);case 24:return gq(J),Q=h1(S1),q===null?(w=JX(),w===null&&(w=H1,X=eY(),w.pooledCache=X,uq(X),X!==null&&(w.pooledCacheLanes|=Z),w=X),J.memoizedState={parent:Q,cache:w},ZX(J),C9(J,S1,w)):((q.lanes&Z)!==0&&($X(q,J),nZ(J,null,null,Z),iZ()),w=q.memoizedState,X=J.memoizedState,w.parent!==Q?(w={parent:Q,cache:Q},J.memoizedState=w,J.lanes===0&&(J.memoizedState=J.updateQueue.baseState=w),C9(J,S1,Q)):(Q=X.cache,C9(J,S1,Q),Q!==w.cache&&tY(J,[S1],Z,!0))),Q6(q,J,J.pendingProps.children,Z),J.child;case 29:throw J.pendingProps}throw Error("Unknown unit of work tag ("+J.tag+"). This error is likely caused by a bug in React. Please file an issue.")}function i7(q){q.flags|=4}function oX(q,J,Z,Q,w){if(J=(q.mode&TT)!==BF)J=!1;if(J){if(q.flags|=16777216,(w&335544128)===w)if(q.stateNode.complete)q.flags|=8192;else if(nh())q.flags|=8192;else throw JJ=LH,MK}else q.flags&=-16777217}function Uh(q,J){if(J.type!=="stylesheet"||(J.state.loading&I8)!==UJ)q.flags&=-16777217;else if(q.flags|=16777216,!lR(J))if(nh())q.flags|=8192;else throw JJ=LH,MK}function bW(q,J){J!==null&&(q.flags|=4),q.flags&16384&&(J=q.tag!==22?q0():536870912,q.lanes|=J,HJ|=J)}function rZ(q,J){if(!gF)switch(q.tailMode){case"hidden":J=q.tail;for(var Z=null;J!==null;)J.alternate!==null&&(Z=J),J=J.sibling;Z===null?q.tail=null:Z.sibling=null;break;case"collapsed":Z=q.tail;for(var Q=null;Z!==null;)Z.alternate!==null&&(Q=Z),Z=Z.sibling;Q===null?J||q.tail===null?q.tail=null:q.tail.sibling=null:Q.sibling=null}}function Y1(q){var J=q.alternate!==null&&q.alternate.child===q.child,Z=0,Q=0;if(J)if((q.mode&IF)!==BF){for(var{selfBaseDuration:w,child:X}=q;X!==null;)Z|=X.lanes|X.childLanes,Q|=X.subtreeFlags&65011712,Q|=X.flags&65011712,w+=X.treeBaseDuration,X=X.sibling;q.treeBaseDuration=w}else for(w=q.child;w!==null;)Z|=w.lanes|w.childLanes,Q|=w.subtreeFlags&65011712,Q|=w.flags&65011712,w.return=q,w=w.sibling;else if((q.mode&IF)!==BF){w=q.actualDuration,X=q.selfBaseDuration;for(var B=q.child;B!==null;)Z|=B.lanes|B.childLanes,Q|=B.subtreeFlags,Q|=B.flags,w+=B.actualDuration,X+=B.treeBaseDuration,B=B.sibling;q.actualDuration=w,q.treeBaseDuration=X}else for(w=q.child;w!==null;)Z|=w.lanes|w.childLanes,Q|=w.subtreeFlags,Q|=w.flags,w.return=q,w=w.sibling;return q.subtreeFlags|=Q,q.childLanes=Z,J}function W3(q,J,Z){var Q=J.pendingProps;switch(sY(J),J.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Y1(J),null;case 1:return Y1(J),null;case 3:if(Z=J.stateNode,Q=null,q!==null&&(Q=q.memoizedState.cache),J.memoizedState.cache!==Q&&(J.flags|=2048),m7(S1,J),u(J),Z.pendingContext&&(Z.context=Z.pendingContext,Z.pendingContext=null),q===null||q.child===null)nJ(J)?(aY(),i7(J)):q===null||q.memoizedState.isDehydrated&&(J.flags&256)===0||(J.flags|=1024,oY());return Y1(J),null;case 26:var{type:w,memoizedState:X}=J;return q===null?(i7(J),X!==null?(Y1(J),Uh(J,X)):(Y1(J),oX(J,w,null,Q,Z))):X?X!==q.memoizedState?(i7(J),Y1(J),Uh(J,X)):(Y1(J),J.flags&=-16777217):(q=q.memoizedProps,q!==Q&&i7(J),Y1(J),oX(J,w,q,Q,Z)),null;case 27:if(O0(J),Z=K0(u9.current),w=J.type,q!==null&&J.stateNode!=null)q.memoizedProps!==Q&&i7(J);else{if(!Q){if(J.stateNode===null)throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");return Y1(J),null}q=n(),nJ(J)?JA(J,q):(q=bR(w,Q,Z,q,!0),J.stateNode=q,i7(J))}return Y1(J),null;case 5:if(O0(J),w=J.type,q!==null&&J.stateNode!=null)q.memoizedProps!==Q&&i7(J);else{if(!Q){if(J.stateNode===null)throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");return Y1(J),null}var B=n();if(nJ(J))JA(J,B);else{switch(X=K0(u9.current),J7(w,B.ancestorInfo),B=B.context,X=iW(X),B){case m_:X=X.createElementNS(G_,w);break;case eH:X=X.createElementNS(HH,w);break;default:switch(w){case"svg":X=X.createElementNS(G_,w);break;case"math":X=X.createElementNS(HH,w);break;case"script":X=X.createElement("div"),X.innerHTML="<script></script>",X=X.removeChild(X.firstChild);break;case"select":X=typeof Q.is==="string"?X.createElement("select",{is:Q.is}):X.createElement("select"),Q.multiple?X.multiple=!0:Q.size&&(X.size=Q.size);break;default:X=typeof Q.is==="string"?X.createElement(w,{is:Q.is}):X.createElement(w),w.indexOf("-")===-1&&(w!==w.toLowerCase()&&console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",w),Object.prototype.toString.call(X)!=="[object HTMLUnknownElement]"||g8.call(MM,w)||(MM[w]=!0,console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",w)))}}X[H6]=J,X[O6]=Q;F:for(B=J.child;B!==null;){if(B.tag===5||B.tag===6)X.appendChild(B.stateNode);else if(B.tag!==4&&B.tag!==27&&B.child!==null){B.child.return=B,B=B.child;continue}if(B===J)break F;for(;B.sibling===null;){if(B.return===null||B.return===J)break F;B=B.return}B.sibling.return=B.return,B=B.sibling}J.stateNode=X;F:switch(W6(X,w,Q),w){case"button":case"input":case"select":case"textarea":Q=!!Q.autoFocus;break F;case"img":Q=!0;break F;default:Q=!1}Q&&i7(J)}}return Y1(J),oX(J,J.type,q===null?null:q.memoizedProps,J.pendingProps,Z),null;case 6:if(q&&J.stateNode!=null)q.memoizedProps!==Q&&i7(J);else{if(typeof Q!=="string"&&J.stateNode===null)throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");if(q=K0(u9.current),Z=n(),nJ(J)){if(q=J.stateNode,Z=J.memoizedProps,w=!T7,Q=null,X=w6,X!==null)switch(X.tag){case 3:w&&(w=yR(q,Z,Q),w!==null&&(jq(J,0).serverProps=w));break;case 27:case 5:Q=X.memoizedProps,w&&(w=yR(q,Z,Q),w!==null&&(jq(J,0).serverProps=w))}q[H6]=J,q=q.nodeValue===Z||Q!==null&&Q.suppressHydrationWarning===!0||RR(q.nodeValue,Z)?!0:!1,q||E9(J,!0)}else w=Z.ancestorInfo.current,w!=null&&c1(Q,w.tag,Z.ancestorInfo.implicitRootScope),q=iW(q).createTextNode(Q),q[H6]=J,J.stateNode=q}return Y1(J),null;case 31:if(Z=J.memoizedState,q===null||q.memoizedState!==null){if(Q=nJ(J),Z!==null){if(q===null){if(!Q)throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");if(q=J.memoizedState,q=q!==null?q.dehydrated:null,!q)throw Error("Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue.");q[H6]=J,Y1(J),(J.mode&IF)!==BF&&Z!==null&&(q=J.child,q!==null&&(J.treeBaseDuration-=q.treeBaseDuration))}else aY(),xq(),(J.flags&128)===0&&(Z=J.memoizedState=null),J.flags|=4,Y1(J),(J.mode&IF)!==BF&&Z!==null&&(q=J.child,q!==null&&(J.treeBaseDuration-=q.treeBaseDuration));q=!1}else Z=oY(),q!==null&&q.memoizedState!==null&&(q.memoizedState.hydrationErrors=Z),q=!0;if(!q){if(J.flags&256)return a6(J),J;return a6(J),null}if((J.flags&128)!==0)throw Error("Client rendering an Activity suspended it again. This is a bug in React.")}return Y1(J),null;case 13:if(Q=J.memoizedState,q===null||q.memoizedState!==null&&q.memoizedState.dehydrated!==null){if(w=Q,X=nJ(J),w!==null&&w.dehydrated!==null){if(q===null){if(!X)throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");if(X=J.memoizedState,X=X!==null?X.dehydrated:null,!X)throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");X[H6]=J,Y1(J),(J.mode&IF)!==BF&&w!==null&&(w=J.child,w!==null&&(J.treeBaseDuration-=w.treeBaseDuration))}else aY(),xq(),(J.flags&128)===0&&(w=J.memoizedState=null),J.flags|=4,Y1(J),(J.mode&IF)!==BF&&w!==null&&(w=J.child,w!==null&&(J.treeBaseDuration-=w.treeBaseDuration));w=!1}else w=oY(),q!==null&&q.memoizedState!==null&&(q.memoizedState.hydrationErrors=w),w=!0;if(!w){if(J.flags&256)return a6(J),J;return a6(J),null}}if(a6(J),(J.flags&128)!==0)return J.lanes=Z,(J.mode&IF)!==BF&&mZ(J),J;return Z=Q!==null,q=q!==null&&q.memoizedState!==null,Z&&(Q=J.child,w=null,Q.alternate!==null&&Q.alternate.memoizedState!==null&&Q.alternate.memoizedState.cachePool!==null&&(w=Q.alternate.memoizedState.cachePool.pool),X=null,Q.memoizedState!==null&&Q.memoizedState.cachePool!==null&&(X=Q.memoizedState.cachePool.pool),X!==w&&(Q.flags|=2048)),Z!==q&&Z&&(J.child.flags|=8192),bW(J,J.updateQueue),Y1(J),(J.mode&IF)!==BF&&Z&&(q=J.child,q!==null&&(J.treeBaseDuration-=q.treeBaseDuration)),null;case 4:return u(J),q===null&&GG(J.stateNode.containerInfo),Y1(J),null;case 10:return m7(J.type,J),Y1(J),null;case 19:if($0(V1,J),Q=J.memoizedState,Q===null)return Y1(J),null;if(w=(J.flags&128)!==0,X=Q.rendering,X===null)if(w)rZ(Q,!1);else{if(O1!==Q9||q!==null&&(q.flags&128)!==0)for(q=J.child;q!==null;){if(X=RW(q),X!==null){J.flags|=128,rZ(Q,!1),q=X.updateQueue,J.updateQueue=q,bW(J,q),J.subtreeFlags=0,q=Z;for(Z=J.child;Z!==null;)az(Z,q),Z=Z.sibling;return X0(V1,V1.current&P_|u$,J),gF&&p7(J,Q.treeForkCount),J.child}q=q.sibling}Q.tail!==null&&o1()>uH&&(J.flags|=128,w=!0,rZ(Q,!1),J.lanes=4194304)}else{if(!w)if(q=RW(X),q!==null){if(J.flags|=128,w=!0,q=q.updateQueue,J.updateQueue=q,bW(J,q),rZ(Q,!0),Q.tail===null&&Q.tailMode==="hidden"&&!X.alternate&&!gF)return Y1(J),null}else 2*o1()-Q.renderingStartTime>uH&&Z!==536870912&&(J.flags|=128,w=!0,rZ(Q,!1),J.lanes=4194304);Q.isBackwards?(X.sibling=J.child,J.child=X):(q=Q.last,q!==null?q.sibling=X:J.child=X,Q.last=X)}if(Q.tail!==null)return q=Q.tail,Q.rendering=q,Q.tail=q.sibling,Q.renderingStartTime=o1(),q.sibling=null,Z=V1.current,Z=w?Z&P_|u$:Z&P_,X0(V1,Z,J),gF&&p7(J,Q.treeForkCount),q;return Y1(J),null;case 22:case 23:return a6(J),WX(J),Q=J.memoizedState!==null,q!==null?q.memoizedState!==null!==Q&&(J.flags|=8192):Q&&(J.flags|=8192),Q?(Z&536870912)!==0&&(J.flags&128)===0&&(Y1(J),J.subtreeFlags&6&&(J.flags|=8192)):Y1(J),Z=J.updateQueue,Z!==null&&bW(J,Z.retryQueue),Z=null,q!==null&&q.memoizedState!==null&&q.memoizedState.cachePool!==null&&(Z=q.memoizedState.cachePool.pool),Q=null,J.memoizedState!==null&&J.memoizedState.cachePool!==null&&(Q=J.memoizedState.cachePool.pool),Q!==Z&&(J.flags|=2048),q!==null&&$0(FJ,J),null;case 24:return Z=null,q!==null&&(Z=q.memoizedState.cache),J.memoizedState.cache!==Z&&(J.flags|=2048),m7(S1,J),Y1(J),null;case 25:return null;case 30:return null}throw Error("Unknown unit of work tag ("+J.tag+"). This error is likely caused by a bug in React. Please file an issue.")}function H3(q,J){switch(sY(J),J.tag){case 1:return q=J.flags,q&65536?(J.flags=q&-65537|128,(J.mode&IF)!==BF&&mZ(J),J):null;case 3:return m7(S1,J),u(J),q=J.flags,(q&65536)!==0&&(q&128)===0?(J.flags=q&-65537|128,J):null;case 26:case 27:case 5:return O0(J),null;case 31:if(J.memoizedState!==null){if(a6(J),J.alternate===null)throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");xq()}return q=J.flags,q&65536?(J.flags=q&-65537|128,(J.mode&IF)!==BF&&mZ(J),J):null;case 13:if(a6(J),q=J.memoizedState,q!==null&&q.dehydrated!==null){if(J.alternate===null)throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");xq()}return q=J.flags,q&65536?(J.flags=q&-65537|128,(J.mode&IF)!==BF&&mZ(J),J):null;case 19:return $0(V1,J),null;case 4:return u(J),null;case 10:return m7(J.type,J),null;case 22:case 23:return a6(J),WX(J),q!==null&&$0(FJ,J),q=J.flags,q&65536?(J.flags=q&-65537|128,(J.mode&IF)!==BF&&mZ(J),J):null;case 24:return m7(S1,J),null;case 25:return null;default:return null}}function Bh(q,J){switch(sY(J),J.tag){case 3:m7(S1,J),u(J);break;case 26:case 27:case 5:O0(J);break;case 4:u(J);break;case 31:J.memoizedState!==null&&a6(J);break;case 13:a6(J);break;case 19:$0(V1,J);break;case 10:m7(J.type,J);break;case 22:case 23:a6(J),WX(J),q!==null&&$0(FJ,J);break;case 24:m7(S1,J)}}function K7(q){return(q.mode&IF)!==BF}function zh(q,J){K7(q)?(G7(),tZ(J,q),X7()):tZ(J,q)}function aX(q,J,Z){K7(q)?(G7(),tJ(Z,q,J),X7()):tJ(Z,q,J)}function tZ(q,J){try{var Z=J.updateQueue,Q=Z!==null?Z.lastEffect:null;if(Q!==null){var w=Q.next;Z=w;do{if((Z.tag&q)===q&&(Q=void 0,(q&L6)!==CH&&(g_=!0),Q=v0(J,VT,Z),(q&L6)!==CH&&(g_=!1),Q!==void 0&&typeof Q!=="function")){var X=void 0;X=(Z.tag&Z8)!==0?"useLayoutEffect":(Z.tag&L6)!==0?"useInsertionEffect":"useEffect";var B=void 0;B=Q===null?" You returned null. If your effect does not require clean up, return undefined (or nothing).":typeof Q.then==="function"?`

It looks like you wrote `+X+`(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

`+X+`(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching`:" You returned: "+Q,v0(J,function(R,I){console.error("%s must not return anything besides a function, which is used for clean-up.%s",R,I)},X,B)}Z=Z.next}while(Z!==w)}}catch(R){eF(J,J.return,R)}}function tJ(q,J,Z){try{var Q=J.updateQueue,w=Q!==null?Q.lastEffect:null;if(w!==null){var X=w.next;Q=X;do{if((Q.tag&q)===q){var B=Q.inst,R=B.destroy;R!==void 0&&(B.destroy=void 0,(q&L6)!==CH&&(g_=!0),w=J,v0(w,kT,w,Z,R),(q&L6)!==CH&&(g_=!1))}Q=Q.next}while(Q!==X)}}catch(I){eF(J,J.return,I)}}function Ah(q,J){K7(q)?(G7(),tZ(J,q),X7()):tZ(J,q)}function rX(q,J,Z){K7(q)?(G7(),tJ(Z,q,J),X7()):tJ(Z,q,J)}function hh(q){var J=q.updateQueue;if(J!==null){var Z=q.stateNode;q.type.defaultProps||"ref"in q.memoizedProps||y_||(Z.props!==q.memoizedProps&&console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",V(q)||"instance"),Z.state!==q.memoizedState&&console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",V(q)||"instance"));try{v0(q,NA,J,Z)}catch(Q){eF(q,q.return,Q)}}}function w3(q,J,Z){return q.getSnapshotBeforeUpdate(J,Z)}function Y3(q,J){var{memoizedProps:Z,memoizedState:Q}=J;J=q.stateNode,q.type.defaultProps||"ref"in q.memoizedProps||y_||(J.props!==q.memoizedProps&&console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",V(q)||"instance"),J.state!==q.memoizedState&&console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",V(q)||"instance"));try{var w=dq(q.type,Z),X=v0(q,w3,J,w,Q);Z=eD,X!==void 0||Z.has(q.type)||(Z.add(q.type),v0(q,function(){console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",V(q))})),J.__reactInternalSnapshotBeforeUpdate=X}catch(B){eF(q,q.return,B)}}function Rh(q,J,Z){Z.props=dq(q.type,q.memoizedProps),Z.state=q.memoizedState,K7(q)?(G7(),v0(q,hD,q,J,Z),X7()):v0(q,hD,q,J,Z)}function X3(q){var J=q.ref;if(J!==null){switch(q.tag){case 26:case 27:case 5:var Z=q.stateNode;break;case 30:Z=q.stateNode;break;default:Z=q.stateNode}if(typeof J==="function")if(K7(q))try{G7(),q.refCleanup=J(Z)}finally{X7()}else q.refCleanup=J(Z);else typeof J==="string"?console.error("String refs are no longer supported."):J.hasOwnProperty("current")||console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",V(q)),J.current=Z}}function eZ(q,J){try{v0(q,X3,q)}catch(Z){eF(q,J,Z)}}function U7(q,J){var{ref:Z,refCleanup:Q}=q;if(Z!==null)if(typeof Q==="function")try{if(K7(q))try{G7(),v0(q,Q)}finally{X7(q)}else v0(q,Q)}catch(w){eF(q,J,w)}finally{q.refCleanup=null,q=q.alternate,q!=null&&(q.refCleanup=null)}else if(typeof Z==="function")try{if(K7(q))try{G7(),v0(q,Z,null)}finally{X7(q)}else v0(q,Z,null)}catch(w){eF(q,J,w)}else Z.current=null}function Nh(q,J,Z,Q){var w=q.memoizedProps,X=w.id,B=w.onCommit;w=w.onRender,J=J===null?"mount":"update",OH&&(J="nested-update"),typeof w==="function"&&w(X,J,q.actualDuration,q.treeBaseDuration,q.actualStartTime,Z),typeof B==="function"&&B(X,J,Q,Z)}function G3(q,J,Z,Q){var w=q.memoizedProps;q=w.id,w=w.onPostCommit,J=J===null?"mount":"update",OH&&(J="nested-update"),typeof w==="function"&&w(q,J,Q,Z)}function Dh(q){var{type:J,memoizedProps:Z,stateNode:Q}=q;try{v0(q,b3,Q,J,Z,q)}catch(w){eF(q,q.return,w)}}function tX(q,J,Z){try{v0(q,x3,q.stateNode,q.type,Z,J,q)}catch(Q){eF(q,q.return,Q)}}function Mh(q){return q.tag===5||q.tag===3||q.tag===26||q.tag===27&&x9(q.type)||q.tag===4}function eX(q){F:for(;;){for(;q.sibling===null;){if(q.return===null||Mh(q.return))return null;q=q.return}q.sibling.return=q.return;for(q=q.sibling;q.tag!==5&&q.tag!==6&&q.tag!==18;){if(q.tag===27&&x9(q.type))continue F;if(q.flags&2)continue F;if(q.child===null||q.tag===4)continue F;else q.child.return=q,q=q.child}if(!(q.flags&2))return q.stateNode}}function FG(q,J,Z){var Q=q.tag;if(Q===5||Q===6)q=q.stateNode,J?(CR(Z),(Z.nodeType===9?Z.body:Z.nodeName==="HTML"?Z.ownerDocument.body:Z).insertBefore(q,J)):(CR(Z),J=Z.nodeType===9?Z.body:Z.nodeName==="HTML"?Z.ownerDocument.body:Z,J.appendChild(q),Z=Z._reactRootContainer,Z!==null&&Z!==void 0||J.onclick!==null||(J.onclick=g7));else if(Q!==4&&(Q===27&&x9(q.type)&&(Z=q.stateNode,J=null),q=q.child,q!==null))for(FG(q,J,Z),q=q.sibling;q!==null;)FG(q,J,Z),q=q.sibling}function jW(q,J,Z){var Q=q.tag;if(Q===5||Q===6)q=q.stateNode,J?Z.insertBefore(q,J):Z.appendChild(q);else if(Q!==4&&(Q===27&&x9(q.type)&&(Z=q.stateNode),q=q.child,q!==null))for(jW(q,J,Z),q=q.sibling;q!==null;)jW(q,J,Z),q=q.sibling}function K3(q){for(var J,Z=q.return;Z!==null;){if(Mh(Z)){J=Z;break}Z=Z.return}if(J==null)throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");switch(J.tag){case 27:J=J.stateNode,Z=eX(q),jW(q,Z,J);break;case 5:Z=J.stateNode,J.flags&32&&(ER(Z),J.flags&=-33),J=eX(q),jW(q,J,Z);break;case 3:case 4:J=J.stateNode.containerInfo,Z=eX(q),FG(q,Z,J);break;default:throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.")}}function Oh(q){var{stateNode:J,memoizedProps:Z}=q;try{v0(q,F4,q.type,Z,J,q)}catch(Q){eF(q,q.return,Q)}}function fh(q,J){return J.tag===31?(J=J.memoizedState,q.memoizedState!==null&&J===null):J.tag===13?(q=q.memoizedState,J=J.memoizedState,q!==null&&q.dehydrated!==null&&(J===null||J.dehydrated===null)):J.tag===3?q.memoizedState.isDehydrated&&(J.flags&256)===0:!1}function U3(q,J){if(q=q.containerInfo,eK=_w,q=uz(q),jY(q)){if("selectionStart"in q)var Z={start:q.selectionStart,end:q.selectionEnd};else F:{Z=(Z=q.ownerDocument)&&Z.defaultView||window;var Q=Z.getSelection&&Z.getSelection();if(Q&&Q.rangeCount!==0){Z=Q.anchorNode;var{anchorOffset:w,focusNode:X}=Q;Q=Q.focusOffset;try{Z.nodeType,X.nodeType}catch(x0){Z=null;break F}var B=0,R=-1,I=-1,C=0,e=0,F0=q,i=null;q:for(;;){for(var U0;;){if(F0!==Z||w!==0&&F0.nodeType!==3||(R=B+w),F0!==X||Q!==0&&F0.nodeType!==3||(I=B+Q),F0.nodeType===3&&(B+=F0.nodeValue.length),(U0=F0.firstChild)===null)break;i=F0,F0=U0}for(;;){if(F0===q)break q;if(i===Z&&++C===w&&(R=B),i===X&&++e===Q&&(I=B),(U0=F0.nextSibling)!==null)break;F0=i,i=F0.parentNode}F0=U0}Z=R===-1||I===-1?null:{start:R,end:I}}else Z=null}Z=Z||{start:0,end:0}}else Z=null;F5={focusedElem:q,selectionRange:Z},_w=!1;for(r1=J;r1!==null;)if(J=r1,q=J.child,(J.subtreeFlags&1028)!==0&&q!==null)q.return=J,r1=q;else for(;r1!==null;){switch(q=J=r1,Z=q.alternate,w=q.flags,q.tag){case 0:if((w&4)!==0&&(q=q.updateQueue,q=q!==null?q.events:null,q!==null))for(Z=0;Z<q.length;Z++)w=q[Z],w.ref.impl=w.nextImpl;break;case 11:case 15:break;case 1:(w&1024)!==0&&Z!==null&&Y3(q,Z);break;case 3:if((w&1024)!==0){if(q=q.stateNode.containerInfo,Z=q.nodeType,Z===9)NG(q);else if(Z===1)switch(q.nodeName){case"HEAD":case"HTML":case"BODY":NG(q);break;default:q.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((w&1024)!==0)throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")}if(q=J.sibling,q!==null){q.return=J.return,r1=q;break}r1=J.return}}function Ih(q,J,Z){var Q=s6(),w=W7(),X=w7(),B=Y7(),R=Z.flags;switch(Z.tag){case 0:case 11:case 15:B7(q,Z),R&4&&zh(Z,Z8|O8);break;case 1:if(B7(q,Z),R&4)if(q=Z.stateNode,J===null)Z.type.defaultProps||"ref"in Z.memoizedProps||y_||(q.props!==Z.memoizedProps&&console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",V(Z)||"instance"),q.state!==Z.memoizedState&&console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",V(Z)||"instance")),K7(Z)?(G7(),v0(Z,DK,Z,q),X7()):v0(Z,DK,Z,q);else{var I=dq(Z.type,J.memoizedProps);J=J.memoizedState,Z.type.defaultProps||"ref"in Z.memoizedProps||y_||(q.props!==Z.memoizedProps&&console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",V(Z)||"instance"),q.state!==Z.memoizedState&&console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",V(Z)||"instance")),K7(Z)?(G7(),v0(Z,BD,Z,q,I,J,q.__reactInternalSnapshotBeforeUpdate),X7()):v0(Z,BD,Z,q,I,J,q.__reactInternalSnapshotBeforeUpdate)}R&64&&hh(Z),R&512&&eZ(Z,Z.return);break;case 3:if(J=l7(),B7(q,Z),R&64&&(R=Z.updateQueue,R!==null)){if(I=null,Z.child!==null)switch(Z.child.tag){case 27:case 5:I=Z.child.stateNode;break;case 1:I=Z.child.stateNode}try{v0(Z,NA,R,I)}catch(e){eF(Z,Z.return,e)}}q.effectDuration+=YW(J);break;case 27:J===null&&R&4&&Oh(Z);case 26:case 5:if(B7(q,Z),J===null){if(R&4)Dh(Z);else if(R&64){q=Z.type,J=Z.memoizedProps,I=Z.stateNode;try{v0(Z,j3,I,q,J,Z)}catch(e){eF(Z,Z.return,e)}}}R&512&&eZ(Z,Z.return);break;case 12:if(R&4){R=l7(),B7(q,Z),q=Z.stateNode,q.effectDuration+=pZ(R);try{v0(Z,Nh,Z,J,s9,q.effectDuration)}catch(e){eF(Z,Z.return,e)}}else B7(q,Z);break;case 31:B7(q,Z),R&4&&Eh(q,Z);break;case 13:B7(q,Z),R&4&&Ch(q,Z),R&64&&(q=Z.memoizedState,q!==null&&(q=q.dehydrated,q!==null&&(R=O3.bind(null,Z),a3(q,R))));break;case 22:if(R=Z.memoizedState!==null||$9,!R){J=J!==null&&J.memoizedState!==null||j1,I=$9;var C=j1;$9=R,(j1=J)&&!C?(z7(q,Z,(Z.subtreeFlags&8772)!==0),(Z.mode&IF)!==BF&&0<=WF&&0<=KF&&0.05<KF-WF&&FW(Z,WF,KF)):B7(q,Z),$9=I,j1=C}break;case 30:break;default:B7(q,Z)}(Z.mode&IF)!==BF&&0<=WF&&0<=KF&&((I1||0.05<M1)&&$7(Z,WF,KF,M1,R1),Z.alternate===null&&Z.return!==null&&Z.return.alternate!==null&&0.05<KF-WF&&(fh(Z.return.alternate,Z.return)||Z7(Z,WF,KF,"Mount"))),o6(Q),H7(w),R1=X,I1=B}function Th(q){var J=q.alternate;J!==null&&(q.alternate=null,Th(J)),q.child=null,q.deletions=null,q.sibling=null,q.tag===5&&(J=q.stateNode,J!==null&&g(J)),q.stateNode=null,q._debugOwner=null,q.return=null,q.dependencies=null,q.memoizedProps=null,q.memoizedState=null,q.pendingProps=null,q.stateNode=null,q.updateQueue=null}function n7(q,J,Z){for(Z=Z.child;Z!==null;)Lh(q,J,Z),Z=Z.sibling}function Lh(q,J,Z){if(G6&&typeof G6.onCommitFiberUnmount==="function")try{G6.onCommitFiberUnmount(Y_,Z)}catch(C){M7||(M7=!0,console.error("React instrumentation encountered an error: %o",C))}var Q=s6(),w=W7(),X=w7(),B=Y7();switch(Z.tag){case 26:j1||U7(Z,J),n7(q,J,Z),Z.memoizedState?Z.memoizedState.count--:Z.stateNode&&(q=Z.stateNode,q.parentNode.removeChild(q));break;case 27:j1||U7(Z,J);var R=x1,I=u6;x9(Z.type)&&(x1=Z.stateNode,u6=!1),n7(q,J,Z),v0(Z,H$,Z.stateNode),x1=R,u6=I;break;case 5:j1||U7(Z,J);case 6:if(R=x1,I=u6,x1=null,n7(q,J,Z),x1=R,u6=I,x1!==null)if(u6)try{v0(Z,p3,x1,Z.stateNode)}catch(C){eF(Z,J,C)}else try{v0(Z,u3,x1,Z.stateNode)}catch(C){eF(Z,J,C)}break;case 18:x1!==null&&(u6?(q=x1,PR(q.nodeType===9?q.body:q.nodeName==="HTML"?q.ownerDocument.body:q,Z.stateNode),Q_(q)):PR(x1,Z.stateNode));break;case 4:R=x1,I=u6,x1=Z.stateNode.containerInfo,u6=!0,n7(q,J,Z),x1=R,u6=I;break;case 0:case 11:case 14:case 15:tJ(L6,Z,J),j1||aX(Z,J,Z8),n7(q,J,Z);break;case 1:j1||(U7(Z,J),R=Z.stateNode,typeof R.componentWillUnmount==="function"&&Rh(Z,J,R)),n7(q,J,Z);break;case 21:n7(q,J,Z);break;case 22:j1=(R=j1)||Z.memoizedState!==null,n7(q,J,Z),j1=R;break;default:n7(q,J,Z)}(Z.mode&IF)!==BF&&0<=WF&&0<=KF&&(I1||0.05<M1)&&$7(Z,WF,KF,M1,R1),o6(Q),H7(w),R1=X,I1=B}function Eh(q,J){if(J.memoizedState===null&&(q=J.alternate,q!==null&&(q=q.memoizedState,q!==null))){q=q.dehydrated;try{v0(J,t3,q)}catch(Z){eF(J,J.return,Z)}}}function Ch(q,J){if(J.memoizedState===null&&(q=J.alternate,q!==null&&(q=q.memoizedState,q!==null&&(q=q.dehydrated,q!==null))))try{v0(J,e3,q)}catch(Z){eF(J,J.return,Z)}}function B3(q){switch(q.tag){case 31:case 13:case 19:var J=q.stateNode;return J===null&&(J=q.stateNode=new FM),J;case 22:return q=q.stateNode,J=q._retryCache,J===null&&(J=q._retryCache=new FM),J;default:throw Error("Unexpected Suspense handler tag ("+q.tag+"). This is a bug in React.")}}function xW(q,J){var Z=B3(q);J.forEach(function(Q){if(!Z.has(Q)){if(Z.add(Q),O7)if(v_!==null&&b_!==null)_$(b_,v_);else throw Error("Expected finished root and lanes to be set. This is a bug in React.");var w=f3.bind(null,q,Q);Q.then(w,w)}})}function x6(q,J){var Z=J.deletions;if(Z!==null)for(var Q=0;Q<Z.length;Q++){var w=q,X=J,B=Z[Q],R=s6(),I=X;F:for(;I!==null;){switch(I.tag){case 27:if(x9(I.type)){x1=I.stateNode,u6=!1;break F}break;case 5:x1=I.stateNode,u6=!1;break F;case 3:case 4:x1=I.stateNode.containerInfo,u6=!0;break F}I=I.return}if(x1===null)throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");Lh(w,X,B),x1=null,u6=!1,(B.mode&IF)!==BF&&0<=WF&&0<=KF&&0.05<KF-WF&&Z7(B,WF,KF,"Unmount"),o6(R),w=B,X=w.alternate,X!==null&&(X.return=null),w.return=null}if(J.subtreeFlags&13886)for(J=J.child;J!==null;)Ph(J,q),J=J.sibling}function Ph(q,J){var Z=s6(),Q=W7(),w=w7(),X=Y7(),B=q.alternate,R=q.flags;switch(q.tag){case 0:case 11:case 14:case 15:x6(J,q),g6(q),R&4&&(tJ(L6|O8,q,q.return),tZ(L6|O8,q),aX(q,q.return,Z8|O8));break;case 1:if(x6(J,q),g6(q),R&512&&(j1||B===null||U7(B,B.return)),R&64&&$9&&(R=q.updateQueue,R!==null&&(B=R.callbacks,B!==null))){var I=R.shared.hiddenCallbacks;R.shared.hiddenCallbacks=I===null?B:I.concat(B)}break;case 26:if(I=d8,x6(J,q),g6(q),R&512&&(j1||B===null||U7(B,B.return)),R&4){var C=B!==null?B.memoizedState:null;if(R=q.memoizedState,B===null)if(R===null)if(q.stateNode===null){F:{R=q.type,B=q.memoizedProps,I=I.ownerDocument||I;q:switch(R){case"title":if(C=I.getElementsByTagName("title")[0],!C||C[B$]||C[H6]||C.namespaceURI===G_||C.hasAttribute("itemprop"))C=I.createElement(R),I.head.insertBefore(C,I.querySelector("head > title"));W6(C,R,B),C[H6]=q,Z0(C),R=C;break F;case"link":var e=pR("link","href",I).get(R+(B.href||""));if(e){for(var F0=0;F0<e.length;F0++)if(C=e[F0],C.getAttribute("href")===(B.href==null||B.href===""?null:B.href)&&C.getAttribute("rel")===(B.rel==null?null:B.rel)&&C.getAttribute("title")===(B.title==null?null:B.title)&&C.getAttribute("crossorigin")===(B.crossOrigin==null?null:B.crossOrigin)){e.splice(F0,1);break q}}C=I.createElement(R),W6(C,R,B),I.head.appendChild(C);break;case"meta":if(e=pR("meta","content",I).get(R+(B.content||""))){for(F0=0;F0<e.length;F0++)if(C=e[F0],XF(B.content,"content"),C.getAttribute("content")===(B.content==null?null:""+B.content)&&C.getAttribute("name")===(B.name==null?null:B.name)&&C.getAttribute("property")===(B.property==null?null:B.property)&&C.getAttribute("http-equiv")===(B.httpEquiv==null?null:B.httpEquiv)&&C.getAttribute("charset")===(B.charSet==null?null:B.charSet)){e.splice(F0,1);break q}}C=I.createElement(R),W6(C,R,B),I.head.appendChild(C);break;default:throw Error('getNodesForType encountered a type it did not expect: "'+R+'". This is a bug in React.')}C[H6]=q,Z0(C),R=C}q.stateNode=R}else mR(I,q.type,q.stateNode);else q.stateNode=uR(I,R,q.memoizedProps);else C!==R?(C===null?B.stateNode!==null&&(B=B.stateNode,B.parentNode.removeChild(B)):C.count--,R===null?mR(I,q.type,q.stateNode):uR(I,R,q.memoizedProps)):R===null&&q.stateNode!==null&&tX(q,q.memoizedProps,B.memoizedProps)}break;case 27:x6(J,q),g6(q),R&512&&(j1||B===null||U7(B,B.return)),B!==null&&R&4&&tX(q,q.memoizedProps,B.memoizedProps);break;case 5:if(x6(J,q),g6(q),R&512&&(j1||B===null||U7(B,B.return)),q.flags&32){I=q.stateNode;try{v0(q,ER,I)}catch(i0){eF(q,q.return,i0)}}R&4&&q.stateNode!=null&&(I=q.memoizedProps,tX(q,I,B!==null?B.memoizedProps:I)),R&1024&&(yK=!0,q.type!=="form"&&console.error("Unexpected host component type. Expected a form. This is a bug in React."));break;case 6:if(x6(J,q),g6(q),R&4){if(q.stateNode===null)throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");R=q.memoizedProps,B=B!==null?B.memoizedProps:R,I=q.stateNode;try{v0(q,g3,I,B,R)}catch(i0){eF(q,q.return,i0)}}break;case 3:if(I=l7(),Fw=null,C=d8,d8=nW(J.containerInfo),x6(J,q),d8=C,g6(q),R&4&&B!==null&&B.memoizedState.isDehydrated)try{v0(q,r3,J.containerInfo)}catch(i0){eF(q,q.return,i0)}yK&&(yK=!1,Vh(q)),J.effectDuration+=YW(I);break;case 4:R=d8,d8=nW(q.stateNode.containerInfo),x6(J,q),g6(q),d8=R;break;case 12:R=l7(),x6(J,q),g6(q),q.stateNode.effectDuration+=pZ(R);break;case 31:x6(J,q),g6(q),R&4&&(R=q.updateQueue,R!==null&&(q.updateQueue=null,xW(q,R)));break;case 13:x6(J,q),g6(q),q.child.flags&8192&&q.memoizedState!==null!==(B!==null&&B.memoizedState!==null)&&(gH=o1()),R&4&&(R=q.updateQueue,R!==null&&(q.updateQueue=null,xW(q,R)));break;case 22:I=q.memoizedState!==null;var i=B!==null&&B.memoizedState!==null,U0=$9,x0=j1;if($9=U0||I,j1=x0||i,x6(J,q),j1=x0,$9=U0,i&&!I&&!U0&&!x0&&(q.mode&IF)!==BF&&0<=WF&&0<=KF&&0.05<KF-WF&&FW(q,WF,KF),g6(q),R&8192)F:for(J=q.stateNode,J._visibility=I?J._visibility&~f$:J._visibility|f$,!I||B===null||i||$9||j1||(iq(q),(q.mode&IF)!==BF&&0<=WF&&0<=KF&&0.05<KF-WF&&Z7(q,WF,KF,"Disconnect")),B=null,J=q;;){if(J.tag===5||J.tag===26){if(B===null){i=B=J;try{C=i.stateNode,I?v0(i,l3,C):v0(i,n3,i.stateNode,i.memoizedProps)}catch(i0){eF(i,i.return,i0)}}}else if(J.tag===6){if(B===null){i=J;try{e=i.stateNode,I?v0(i,d3,e):v0(i,c3,e,i.memoizedProps)}catch(i0){eF(i,i.return,i0)}}}else if(J.tag===18){if(B===null){i=J;try{F0=i.stateNode,I?v0(i,m3,F0):v0(i,i3,i.stateNode)}catch(i0){eF(i,i.return,i0)}}}else if((J.tag!==22&&J.tag!==23||J.memoizedState===null||J===q)&&J.child!==null){J.child.return=J,J=J.child;continue}if(J===q)break F;for(;J.sibling===null;){if(J.return===null||J.return===q)break F;B===J&&(B=null),J=J.return}B===J&&(B=null),J.sibling.return=J.return,J=J.sibling}R&4&&(R=q.updateQueue,R!==null&&(B=R.retryQueue,B!==null&&(R.retryQueue=null,xW(q,B))));break;case 19:x6(J,q),g6(q),R&4&&(R=q.updateQueue,R!==null&&(q.updateQueue=null,xW(q,R)));break;case 30:break;case 21:break;default:x6(J,q),g6(q)}(q.mode&IF)!==BF&&0<=WF&&0<=KF&&((I1||0.05<M1)&&$7(q,WF,KF,M1,R1),q.alternate===null&&q.return!==null&&q.return.alternate!==null&&0.05<KF-WF&&(fh(q.return.alternate,q.return)||Z7(q,WF,KF,"Mount"))),o6(Z),H7(Q),R1=w,I1=X}function g6(q){var J=q.flags;if(J&2){try{v0(q,K3,q)}catch(Z){eF(q,q.return,Z)}q.flags&=-3}J&4096&&(q.flags&=-4097)}function Vh(q){if(q.subtreeFlags&1024)for(q=q.child;q!==null;){var J=q;Vh(J),J.tag===5&&J.flags&1024&&J.stateNode.reset(),q=q.sibling}}function B7(q,J){if(J.subtreeFlags&8772)for(J=J.child;J!==null;)Ih(q,J.alternate,J),J=J.sibling}function kh(q){var J=s6(),Z=W7(),Q=w7(),w=Y7();switch(q.tag){case 0:case 11:case 14:case 15:aX(q,q.return,Z8),iq(q);break;case 1:U7(q,q.return);var X=q.stateNode;typeof X.componentWillUnmount==="function"&&Rh(q,q.return,X),iq(q);break;case 27:v0(q,H$,q.stateNode);case 26:case 5:U7(q,q.return),iq(q);break;case 22:q.memoizedState===null&&iq(q);break;case 30:iq(q);break;default:iq(q)}(q.mode&IF)!==BF&&0<=WF&&0<=KF&&(I1||0.05<M1)&&$7(q,WF,KF,M1,R1),o6(J),H7(Z),R1=Q,I1=w}function iq(q){for(q=q.child;q!==null;)kh(q),q=q.sibling}function Sh(q,J,Z,Q){var w=s6(),X=W7(),B=w7(),R=Y7(),I=Z.flags;switch(Z.tag){case 0:case 11:case 15:z7(q,Z,Q),zh(Z,Z8);break;case 1:if(z7(q,Z,Q),J=Z.stateNode,typeof J.componentDidMount==="function"&&v0(Z,DK,Z,J),J=Z.updateQueue,J!==null){q=Z.stateNode;try{v0(Z,rI,J,q)}catch(C){eF(Z,Z.return,C)}}Q&&I&64&&hh(Z),eZ(Z,Z.return);break;case 27:Oh(Z);case 26:case 5:z7(q,Z,Q),Q&&J===null&&I&4&&Dh(Z),eZ(Z,Z.return);break;case 12:if(Q&&I&4){I=l7(),z7(q,Z,Q),Q=Z.stateNode,Q.effectDuration+=pZ(I);try{v0(Z,Nh,Z,J,s9,Q.effectDuration)}catch(C){eF(Z,Z.return,C)}}else z7(q,Z,Q);break;case 31:z7(q,Z,Q),Q&&I&4&&Eh(q,Z);break;case 13:z7(q,Z,Q),Q&&I&4&&Ch(q,Z);break;case 22:Z.memoizedState===null&&z7(q,Z,Q),eZ(Z,Z.return);break;case 30:break;default:z7(q,Z,Q)}(Z.mode&IF)!==BF&&0<=WF&&0<=KF&&(I1||0.05<M1)&&$7(Z,WF,KF,M1,R1),o6(w),H7(X),R1=B,I1=R}function z7(q,J,Z){Z=Z&&(J.subtreeFlags&8772)!==0;for(J=J.child;J!==null;)Sh(q,J.alternate,J,Z),J=J.sibling}function qG(q,J){var Z=null;q!==null&&q.memoizedState!==null&&q.memoizedState.cachePool!==null&&(Z=q.memoizedState.cachePool.pool),q=null,J.memoizedState!==null&&J.memoizedState.cachePool!==null&&(q=J.memoizedState.cachePool.pool),q!==Z&&(q!=null&&uq(q),Z!=null&&uZ(Z))}function JG(q,J){q=null,J.alternate!==null&&(q=J.alternate.memoizedState.cache),J=J.memoizedState.cache,J!==q&&(uq(J),q!=null&&uZ(q))}function x8(q,J,Z,Q,w){if(J.subtreeFlags&10256||J.actualDuration!==0&&(J.alternate===null||J.alternate.child!==J.child))for(J=J.child;J!==null;){var X=J.sibling;yh(q,J,Z,Q,X!==null?X.actualStartTime:w),J=X}}function yh(q,J,Z,Q,w){var X=s6(),B=W7(),R=w7(),I=Y7(),C=d9,e=J.flags;switch(J.tag){case 0:case 11:case 15:(J.mode&IF)!==BF&&0<J.actualStartTime&&(J.flags&1)!==0&&qW(J,J.actualStartTime,w,m1,Z),x8(q,J,Z,Q,w),e&2048&&Ah(J,E6|O8);break;case 1:(J.mode&IF)!==BF&&0<J.actualStartTime&&((J.flags&128)!==0?gY(J,J.actualStartTime,w,[]):(J.flags&1)!==0&&qW(J,J.actualStartTime,w,m1,Z)),x8(q,J,Z,Q,w);break;case 3:var F0=l7(),i=m1;m1=J.alternate!==null&&J.alternate.memoizedState.isDehydrated&&(J.flags&256)===0,x8(q,J,Z,Q,w),m1=i,e&2048&&(Z=null,J.alternate!==null&&(Z=J.alternate.memoizedState.cache),Q=J.memoizedState.cache,Q!==Z&&(uq(Q),Z!=null&&uZ(Z))),q.passiveEffectDuration+=YW(F0);break;case 12:if(e&2048){e=l7(),x8(q,J,Z,Q,w),q=J.stateNode,q.passiveEffectDuration+=pZ(e);try{v0(J,G3,J,J.alternate,s9,q.passiveEffectDuration)}catch(U0){eF(J,J.return,U0)}}else x8(q,J,Z,Q,w);break;case 31:e=m1,F0=J.alternate!==null?J.alternate.memoizedState:null,i=J.memoizedState,F0!==null&&i===null?(i=J.deletions,i!==null&&0<i.length&&i[0].tag===18?(m1=!1,F0=F0.hydrationErrors,F0!==null&&gY(J,J.actualStartTime,w,F0)):m1=!0):m1=!1,x8(q,J,Z,Q,w),m1=e;break;case 13:e=m1,F0=J.alternate!==null?J.alternate.memoizedState:null,i=J.memoizedState,F0===null||F0.dehydrated===null||i!==null&&i.dehydrated!==null?m1=!1:(i=J.deletions,i!==null&&0<i.length&&i[0].tag===18?(m1=!1,F0=F0.hydrationErrors,F0!==null&&gY(J,J.actualStartTime,w,F0)):m1=!0),x8(q,J,Z,Q,w),m1=e;break;case 23:break;case 22:i=J.stateNode,F0=J.alternate,J.memoizedState!==null?i._visibility&o7?x8(q,J,Z,Q,w):F$(q,J,Z,Q,w):i._visibility&o7?x8(q,J,Z,Q,w):(i._visibility|=o7,eJ(q,J,Z,Q,(J.subtreeFlags&10256)!==0||J.actualDuration!==0&&(J.alternate===null||J.alternate.child!==J.child),w),(J.mode&IF)===BF||m1||(q=J.actualStartTime,0<=q&&0.05<w-q&&FW(J,q,w),0<=WF&&0<=KF&&0.05<KF-WF&&FW(J,WF,KF))),e&2048&&qG(F0,J);break;case 24:x8(q,J,Z,Q,w),e&2048&&JG(J.alternate,J);break;default:x8(q,J,Z,Q,w)}if((J.mode&IF)!==BF){if(q=!m1&&J.alternate===null&&J.return!==null&&J.return.alternate!==null)Z=J.actualStartTime,0<=Z&&0.05<w-Z&&Z7(J,Z,w,"Mount");0<=WF&&0<=KF&&((I1||0.05<M1)&&$7(J,WF,KF,M1,R1),q&&0.05<KF-WF&&Z7(J,WF,KF,"Mount"))}o6(X),H7(B),R1=R,I1=I,d9=C}function eJ(q,J,Z,Q,w,X){w=w&&((J.subtreeFlags&10256)!==0||J.actualDuration!==0&&(J.alternate===null||J.alternate.child!==J.child));for(J=J.child;J!==null;){var B=J.sibling;vh(q,J,Z,Q,w,B!==null?B.actualStartTime:X),J=B}}function vh(q,J,Z,Q,w,X){var B=s6(),R=W7(),I=w7(),C=Y7(),e=d9;w&&(J.mode&IF)!==BF&&0<J.actualStartTime&&(J.flags&1)!==0&&qW(J,J.actualStartTime,X,m1,Z);var F0=J.flags;switch(J.tag){case 0:case 11:case 15:eJ(q,J,Z,Q,w,X),Ah(J,E6);break;case 23:break;case 22:var i=J.stateNode;J.memoizedState!==null?i._visibility&o7?eJ(q,J,Z,Q,w,X):F$(q,J,Z,Q,X):(i._visibility|=o7,eJ(q,J,Z,Q,w,X)),w&&F0&2048&&qG(J.alternate,J);break;case 24:eJ(q,J,Z,Q,w,X),w&&F0&2048&&JG(J.alternate,J);break;default:eJ(q,J,Z,Q,w,X)}(J.mode&IF)!==BF&&0<=WF&&0<=KF&&(I1||0.05<M1)&&$7(J,WF,KF,M1,R1),o6(B),H7(R),R1=I,I1=C,d9=e}function F$(q,J,Z,Q,w){if(J.subtreeFlags&10256||J.actualDuration!==0&&(J.alternate===null||J.alternate.child!==J.child))for(var X=J.child;X!==null;){J=X.sibling;var B=q,R=Z,I=Q,C=J!==null?J.actualStartTime:w,e=d9;(X.mode&IF)!==BF&&0<X.actualStartTime&&(X.flags&1)!==0&&qW(X,X.actualStartTime,C,m1,R);var F0=X.flags;switch(X.tag){case 22:F$(B,X,R,I,C),F0&2048&&qG(X.alternate,X);break;case 24:F$(B,X,R,I,C),F0&2048&&JG(X.alternate,X);break;default:F$(B,X,R,I,C)}d9=e,X=J}}function F_(q,J,Z){if(q.subtreeFlags&d$)for(q=q.child;q!==null;)bh(q,J,Z),q=q.sibling}function bh(q,J,Z){switch(q.tag){case 26:F_(q,J,Z),q.flags&d$&&q.memoizedState!==null&&_4(Z,d8,q.memoizedState,q.memoizedProps);break;case 5:F_(q,J,Z);break;case 3:case 4:var Q=d8;d8=nW(q.stateNode.containerInfo),F_(q,J,Z),d8=Q;break;case 22:q.memoizedState===null&&(Q=q.alternate,Q!==null&&Q.memoizedState!==null?(Q=d$,d$=16777216,F_(q,J,Z),d$=Q):F_(q,J,Z));break;default:F_(q,J,Z)}}function jh(q){var J=q.alternate;if(J!==null&&(q=J.child,q!==null)){J.child=null;do J=q.sibling,q.sibling=null,q=J;while(q!==null)}}function q$(q){var J=q.deletions;if((q.flags&16)!==0){if(J!==null)for(var Z=0;Z<J.length;Z++){var Q=J[Z],w=s6();r1=Q,uh(Q,q),(Q.mode&IF)!==BF&&0<=WF&&0<=KF&&0.05<KF-WF&&Z7(Q,WF,KF,"Unmount"),o6(w)}jh(q)}if(q.subtreeFlags&10256)for(q=q.child;q!==null;)xh(q),q=q.sibling}function xh(q){var J=s6(),Z=W7(),Q=w7(),w=Y7();switch(q.tag){case 0:case 11:case 15:q$(q),q.flags&2048&&rX(q,q.return,E6|O8);break;case 3:var X=l7();q$(q),q.stateNode.passiveEffectDuration+=YW(X);break;case 12:X=l7(),q$(q),q.stateNode.passiveEffectDuration+=pZ(X);break;case 22:X=q.stateNode,q.memoizedState!==null&&X._visibility&o7&&(q.return===null||q.return.tag!==13)?(X._visibility&=~o7,gW(q),(q.mode&IF)!==BF&&0<=WF&&0<=KF&&0.05<KF-WF&&Z7(q,WF,KF,"Disconnect")):q$(q);break;default:q$(q)}(q.mode&IF)!==BF&&0<=WF&&0<=KF&&(I1||0.05<M1)&&$7(q,WF,KF,M1,R1),o6(J),H7(Z),I1=w,R1=Q}function gW(q){var J=q.deletions;if((q.flags&16)!==0){if(J!==null)for(var Z=0;Z<J.length;Z++){var Q=J[Z],w=s6();r1=Q,uh(Q,q),(Q.mode&IF)!==BF&&0<=WF&&0<=KF&&0.05<KF-WF&&Z7(Q,WF,KF,"Unmount"),o6(w)}jh(q)}for(q=q.child;q!==null;)gh(q),q=q.sibling}function gh(q){var J=s6(),Z=W7(),Q=w7(),w=Y7();switch(q.tag){case 0:case 11:case 15:rX(q,q.return,E6),gW(q);break;case 22:var X=q.stateNode;X._visibility&o7&&(X._visibility&=~o7,gW(q));break;default:gW(q)}(q.mode&IF)!==BF&&0<=WF&&0<=KF&&(I1||0.05<M1)&&$7(q,WF,KF,M1,R1),o6(J),H7(Z),I1=w,R1=Q}function uh(q,J){for(;r1!==null;){var Z=r1,Q=Z,w=J,X=s6(),B=W7(),R=w7(),I=Y7();switch(Q.tag){case 0:case 11:case 15:rX(Q,w,E6);break;case 23:case 22:Q.memoizedState!==null&&Q.memoizedState.cachePool!==null&&(w=Q.memoizedState.cachePool.pool,w!=null&&uq(w));break;case 24:uZ(Q.memoizedState.cache)}if((Q.mode&IF)!==BF&&0<=WF&&0<=KF&&(I1||0.05<M1)&&$7(Q,WF,KF,M1,R1),o6(X),H7(B),I1=I,R1=R,Q=Z.child,Q!==null)Q.return=Z,r1=Q;else F:for(Z=q;r1!==null;){if(Q=r1,X=Q.sibling,B=Q.return,Th(Q),Q===Z){r1=null;break F}if(X!==null){X.return=B,r1=X;break F}r1=B}}}function z3(){jT.forEach(function(q){return q()})}function ph(){var q=typeof IS_REACT_ACT_ENVIRONMENT<"u"?IS_REACT_ACT_ENVIRONMENT:void 0;return q||R0.actQueue===null||console.error("The current testing environment is not configured to support act(...)"),q}function r6(q){if((cF&l1)!==t1&&LF!==0)return LF&-LF;var J=R0.T;return J!==null?(J._updatedFibers||(J._updatedFibers=new Set),J._updatedFibers.add(q),YG()):p()}function mh(){if(m6===0)if((LF&536870912)===0||gF){var q=ZH;ZH<<=1,(ZH&3932160)===0&&(ZH=262144),m6=q}else m6=536870912;return q=_8.current,q!==null&&(q.flags|=32),m6}function f1(q,J,Z){if(g_&&console.error("useInsertionEffect must not schedule updates."),iK&&(lH=!0),q===H1&&(_1===QJ||_1===WJ)||q.cancelPendingCommit!==null)J_(q,0),b9(q,LF,m6,!1);if(W0(q,Z),(cF&l1)!==t1&&q===H1){if(D7)switch(J.tag){case 0:case 11:case 15:q=VF&&V(VF)||"Unknown",BM.has(q)||(BM.add(q),J=V(J)||"Unknown",console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",J,q,q));break;case 1:UM||(console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."),UM=!0)}}else O7&&b0(q,J,Z),T3(J),q===H1&&((cF&l1)===t1&&(_q|=Z),O1===Fq&&b9(q,LF,m6,!1)),A7(q)}function lh(q,J,Z){if((cF&(l1|$8))!==t1)throw Error("Should not already be working.");if(LF!==0&&VF!==null){var Q=VF,w=o1();switch(WD){case c$:case QJ:var X=P$;B1&&((Q=Q._debugTask)?Q.run(console.timeStamp.bind(console,"Suspended",X,w,B8,void 0,"primary-light")):console.timeStamp("Suspended",X,w,B8,void 0,"primary-light"));break;case WJ:X=P$,B1&&((Q=Q._debugTask)?Q.run(console.timeStamp.bind(console,"Action",X,w,B8,void 0,"primary-light")):console.timeStamp("Action",X,w,B8,void 0,"primary-light"));break;default:B1&&(Q=w-P$,3>Q||console.timeStamp("Blocked",P$,w,B8,void 0,5>Q?"primary-light":10>Q?"primary":100>Q?"primary-dark":"error"))}}X=(Z=!Z&&(J&127)===0&&(J&q.expiredLanes)===0||E(q,J))?h3(q,J):ZG(q,J,!0);var B=Z;do{if(X===Q9){j_&&!Z&&b9(q,J,0,!1),J=_1,P$=y1(),WD=J;break}else{if(Q=o1(),w=q.current.alternate,B&&!A3(w)){n6(J),w=a1,X=Q,!B1||X<=w||(C1?C1.run(console.timeStamp.bind(console,"Teared Render",w,X,xF,vF,"error")):console.timeStamp("Teared Render",w,X,xF,vF,"error")),nq(J,Q),X=ZG(q,J,!1),B=!1;continue}if(X===$J){if(B=J,q.errorRecoveryDisabledLanes&B)var R=0;else R=q.pendingLanes&-536870913,R=R!==0?R:R&536870912?536870912:0;if(R!==0){n6(J),uY(a1,Q,J,C1),nq(J,Q),J=R;F:{Q=q,X=B,B=o$;var I=Q.current.memoizedState.isDehydrated;if(I&&(J_(Q,R).flags|=256),R=ZG(Q,R,!1),R!==$J){if(jK&&!I){Q.errorRecoveryDisabledLanes|=X,_q|=X,X=Fq;break F}Q=C6,C6=B,Q!==null&&(C6===null?C6=Q:C6.push.apply(C6,Q))}X=R}if(B=!1,X!==$J)continue;else Q=o1()}}if(X===n$){n6(J),uY(a1,Q,J,C1),nq(J,Q),J_(q,0),b9(q,J,0,!0);break}F:{switch(Z=q,X){case Q9:case n$:throw Error("Root did not complete. This is a bug in React.");case Fq:if((J&4194048)!==J)break;case vH:n6(J),lz(a1,Q,J,C1),nq(J,Q),w=J,(w&127)!==0?NH=Q:(w&4194048)!==0&&(DH=Q),b9(Z,J,m6,!qq);break F;case $J:C6=null;break;case yH:case qM:break;default:throw Error("Unknown root exit status.")}if(R0.actQueue!==null)$G(Z,w,J,C6,a$,xH,m6,_q,HJ,X,null,null,a1,Q);else{if((J&62914560)===J&&(B=gH+ZM-o1(),10<B)){if(b9(Z,J,m6,!qq),v(Z,0,!0)!==0)break F;i8=J,Z.timeoutHandle=OM(dh.bind(null,Z,w,C6,a$,xH,J,m6,_q,HJ,qq,X,"Throttled",a1,Q),B);break F}dh(Z,w,C6,a$,xH,J,m6,_q,HJ,qq,X,null,a1,Q)}}}break}while(1);A7(q)}function dh(q,J,Z,Q,w,X,B,R,I,C,e,F0,i,U0){q.timeoutHandle=KJ;var x0=J.subtreeFlags,i0=null;if(x0&8192||(x0&16785408)===16785408){if(i0={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:g7},bh(J,X,i0),x0=(X&62914560)===X?gH-o1():(X&4194048)===X?_M-o1():0,x0=Z4(i0,x0),x0!==null){i8=X,q.cancelPendingCommit=x0($G.bind(null,q,J,X,Z,Q,w,B,R,I,e,i0,i0.waitingForViewTransition?"Waiting for the previous Animation":0<i0.count?0<i0.imgCount?"Suspended on CSS and Images":"Suspended on CSS":i0.imgCount===1?"Suspended on an Image":0<i0.imgCount?"Suspended on Images":null,i,U0)),b9(q,X,B,!C);return}}$G(q,J,X,Z,Q,w,B,R,I,e,i0,F0,i,U0)}function A3(q){for(var J=q;;){var Z=J.tag;if((Z===0||Z===11||Z===15)&&J.flags&16384&&(Z=J.updateQueue,Z!==null&&(Z=Z.stores,Z!==null)))for(var Q=0;Q<Z.length;Q++){var w=Z[Q],X=w.getSnapshot;w=w.value;try{if(!I6(X(),w))return!1}catch(B){return!1}}if(Z=J.child,J.subtreeFlags&16384&&Z!==null)Z.return=J,J=Z;else{if(J===q)break;for(;J.sibling===null;){if(J.return===null||J.return===q)return!0;J=J.return}J.sibling.return=J.return,J=J.sibling}}return!0}function b9(q,J,Z,Q){J&=~xK,J&=~_q,q.suspendedLanes|=J,q.pingedLanes&=~J,Q&&(q.warmLanes|=J),Q=q.expirationTimes;for(var w=J;0<w;){var X=31-M6(w),B=1<<X;Q[X]=-1,w&=~B}Z!==0&&E0(q,Z,J)}function q_(){return(cF&(l1|$8))===t1?(Z$(0,!1),!1):!0}function _G(){if(VF!==null){if(_1===p6)var q=VF.return;else q=VF,WW(),UX(q),E_=null,g$=0,q=VF;for(;q!==null;)Bh(q.alternate,q),q=q.return;VF=null}}function nq(q,J){(q&127)!==0&&(o9=J),(q&4194048)!==0&&(E7=J),(q&62914560)!==0&&($D=J),(q&2080374784)!==0&&(QD=J)}function J_(q,J){B1&&(console.timeStamp("Blocking Track",0.003,0.003,"Blocking",vF,"primary-light"),console.timeStamp("Transition Track",0.003,0.003,"Transition",vF,"primary-light"),console.timeStamp("Suspense Track",0.003,0.003,"Suspense",vF,"primary-light"),console.timeStamp("Idle Track",0.003,0.003,"Idle",vF,"primary-light"));var Z=a1;if(a1=y1(),LF!==0&&0<Z){if(n6(LF),O1===yH||O1===Fq)lz(Z,a1,J,C1);else{var Q=a1,w=C1;if(B1&&!(Q<=Z)){var X=(J&738197653)===J?"tertiary-dark":"primary-dark",B=(J&536870912)===J?"Prewarm":(J&201326741)===J?"Interrupted Hydration":"Interrupted Render";w?w.run(console.timeStamp.bind(console,B,Z,Q,xF,vF,X)):console.timeStamp(B,Z,Q,xF,vF,X)}}nq(LF,a1)}if(Z=C1,C1=null,(J&127)!==0){C1=L$,w=0<=L7&&L7<o9?o9:L7,Q=0<=rq&&rq<o9?o9:rq,X=0<=Q?Q:0<=w?w:a1,0<=NH?(n6(2),dz(NH,X,J,Z)):(MH&127)!==0&&(n6(2),xZ(o9,X,q9)),Z=w;var R=Q,I=E$,C=0<I_,e=a9===T$,F0=a9===RH;if(w=a1,Q=L$,X=zK,B=AK,B1){if(xF="Blocking",0<Z?Z>w&&(Z=w):Z=w,0<R?R>Z&&(R=Z):R=Z,I!==null&&Z>R){var i=C?"secondary-light":"warning";Q?Q.run(console.timeStamp.bind(console,C?"Consecutive":"Event: "+I,R,Z,xF,vF,i)):console.timeStamp(C?"Consecutive":"Event: "+I,R,Z,xF,vF,i)}w>Z&&(R=e?"error":(J&738197653)===J?"tertiary-light":"primary-light",e=F0?"Promise Resolved":e?"Cascading Update":5<w-Z?"Update Blocked":"Update",F0=[],B!=null&&F0.push(["Component name",B]),X!=null&&F0.push(["Method name",X]),Z={start:Z,end:w,detail:{devtools:{properties:F0,track:xF,trackGroup:vF,color:R}}},Q?Q.run(performance.measure.bind(performance,e,Z)):performance.measure(e,Z))}L7=-1.1,a9=0,AK=zK=null,NH=-1.1,I_=rq,rq=-1.1,o9=y1()}if((J&4194048)!==0&&(C1=C$,w=0<=F9&&F9<E7?E7:F9,Z=0<=D8&&D8<E7?E7:D8,Q=0<=r9&&r9<E7?E7:r9,X=0<=Q?Q:0<=Z?Z:a1,0<=DH?(n6(256),dz(DH,X,J,C1)):(MH&4194048)!==0&&(n6(256),xZ(E7,X,q9)),F0=Q,R=tq,I=0<t9,C=hK===RH,X=a1,Q=C$,B=_D,e=ZD,B1&&(xF="Transition",0<Z?Z>X&&(Z=X):Z=X,0<w?w>Z&&(w=Z):w=Z,0<F0?F0>w&&(F0=w):F0=w,w>F0&&R!==null&&(i=I?"secondary-light":"warning",Q?Q.run(console.timeStamp.bind(console,I?"Consecutive":"Event: "+R,F0,w,xF,vF,i)):console.timeStamp(I?"Consecutive":"Event: "+R,F0,w,xF,vF,i)),Z>w&&(Q?Q.run(console.timeStamp.bind(console,"Action",w,Z,xF,vF,"primary-dark")):console.timeStamp("Action",w,Z,xF,vF,"primary-dark")),X>Z&&(w=C?"Promise Resolved":5<X-Z?"Update Blocked":"Update",F0=[],e!=null&&F0.push(["Component name",e]),B!=null&&F0.push(["Method name",B]),Z={start:Z,end:X,detail:{devtools:{properties:F0,track:xF,trackGroup:vF,color:"primary-light"}}},Q?Q.run(performance.measure.bind(performance,w,Z)):performance.measure(w,Z))),D8=F9=-1.1,hK=0,DH=-1.1,t9=r9,r9=-1.1,E7=y1()),(J&62914560)!==0&&(MH&62914560)!==0&&(n6(4194304),xZ($D,a1,q9)),(J&2080374784)!==0&&(MH&2080374784)!==0&&(n6(268435456),xZ(QD,a1,q9)),Z=q.timeoutHandle,Z!==KJ&&(q.timeoutHandle=KJ,aT(Z)),Z=q.cancelPendingCommit,Z!==null&&(q.cancelPendingCommit=null,Z()),i8=0,_G(),H1=q,VF=Z=u7(q.current,null),LF=J,_1=p6,Q8=null,qq=!1,j_=E(q,J),jK=!1,O1=Q9,HJ=m6=xK=_q=Jq=0,C6=o$=null,xH=!1,(J&8)!==0&&(J|=J&32),Q=q.entangledLanes,Q!==0)for(q=q.entanglements,Q&=J;0<Q;)w=31-M6(Q),X=1<<w,J|=q[w],Q&=~X;return P7=J,JW(),q=rN(),1000<q-aN&&(R0.recentlyCreatedOwnerStacks=0,aN=q),m8.discardPendingWarnings(),Z}function ih(q,J){RF=null,R0.H=l$,R0.getCurrentStack=null,D7=!1,F8=null,J===L_||J===TH?(J=GA(),_1=c$):J===MK?(J=GA(),_1=JM):_1=J===kK?bK:J!==null&&typeof J==="object"&&typeof J.then==="function"?s$:bH,Q8=J;var Z=VF;Z===null?(O1=n$,kW(q,c6(J,q.current))):Z.mode&IF&&qX(Z)}function nh(){var q=_8.current;return q===null?!0:(LF&4194048)===LF?M8===null?!0:!1:(LF&62914560)===LF||(LF&536870912)!==0?q===M8:!1}function ch(){var q=R0.H;return R0.H=l$,q===null?l$:q}function sh(){var q=R0.A;return R0.A=bT,q}function uW(q){C1===null&&(C1=q._debugTask==null?null:q._debugTask)}function pW(){O1=Fq,qq||(LF&4194048)!==LF&&_8.current!==null||(j_=!0),(Jq&134217727)===0&&(_q&134217727)===0||H1===null||b9(H1,LF,m6,!1)}function ZG(q,J,Z){var Q=cF;cF|=l1;var w=ch(),X=sh();if(H1!==q||LF!==J){if(O7){var B=q.memoizedUpdaters;0<B.size&&(_$(q,LF),B.clear()),a0(q,J)}a$=null,J_(q,J)}J=!1,B=O1;F:do try{if(_1!==p6&&VF!==null){var R=VF,I=Q8;switch(_1){case bK:_G(),B=vH;break F;case c$:case QJ:case WJ:case s$:_8.current===null&&(J=!0);var C=_1;if(_1=p6,Q8=null,__(q,R,I,C),Z&&j_){B=Q9;break F}break;default:C=_1,_1=p6,Q8=null,__(q,R,I,C)}}oh(),B=O1;break}catch(e){ih(q,e)}while(1);return J&&q.shellSuspendCounter++,WW(),cF=Q,R0.H=w,R0.A=X,VF===null&&(H1=null,LF=0,JW()),B}function oh(){for(;VF!==null;)ah(VF)}function h3(q,J){var Z=cF;cF|=l1;var Q=ch(),w=sh();if(H1!==q||LF!==J){if(O7){var X=q.memoizedUpdaters;0<X.size&&(_$(q,LF),X.clear()),a0(q,J)}a$=null,uH=o1()+$M,J_(q,J)}else j_=E(q,J);F:do try{if(_1!==p6&&VF!==null)q:switch(J=VF,X=Q8,_1){case bH:_1=p6,Q8=null,__(q,J,X,bH);break;case QJ:case WJ:if(YA(X)){_1=p6,Q8=null,rh(J);break}J=function(){_1!==QJ&&_1!==WJ||H1!==q||(_1=jH),A7(q)},X.then(J,J);break F;case c$:_1=jH;break F;case JM:_1=vK;break F;case jH:YA(X)?(_1=p6,Q8=null,rh(J)):(_1=p6,Q8=null,__(q,J,X,jH));break;case vK:var B=null;switch(VF.tag){case 26:B=VF.memoizedState;case 5:case 27:var R=VF;if(B?lR(B):R.stateNode.complete){_1=p6,Q8=null;var I=R.sibling;if(I!==null)VF=I;else{var C=R.return;C!==null?(VF=C,mW(C)):VF=null}break q}break;default:console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.")}_1=p6,Q8=null,__(q,J,X,vK);break;case s$:_1=p6,Q8=null,__(q,J,X,s$);break;case bK:_G(),O1=vH;break F;default:throw Error("Unexpected SuspendedReason. This is a bug in React.")}R0.actQueue!==null?oh():R3();break}catch(e){ih(q,e)}while(1);if(WW(),R0.H=Q,R0.A=w,cF=Z,VF!==null)return Q9;return H1=null,LF=0,JW(),O1}function R3(){for(;VF!==null&&!A4();)ah(VF)}function ah(q){var J=q.alternate;(q.mode&IF)!==BF?(FX(q),J=v0(q,sX,J,q,P7),qX(q)):J=v0(q,sX,J,q,P7),q.memoizedProps=q.pendingProps,J===null?mW(q):VF=J}function rh(q){var J=v0(q,N3,q);q.memoizedProps=q.pendingProps,J===null?mW(q):VF=J}function N3(q){var J=q.alternate,Z=(q.mode&IF)!==BF;switch(Z&&FX(q),q.tag){case 15:case 0:J=Hh(J,q,q.pendingProps,q.type,void 0,LF);break;case 11:J=Hh(J,q,q.pendingProps,q.type.render,q.ref,LF);break;case 5:UX(q);default:Bh(J,q),q=VF=az(q,P7),J=sX(J,q,P7)}return Z&&qX(q),J}function __(q,J,Z,Q){WW(),UX(J),E_=null,g$=0;var w=J.return;try{if(Z3(q,w,J,Z,LF)){O1=n$,kW(q,c6(Z,q.current)),VF=null;return}}catch(X){if(w!==null)throw VF=w,X;O1=n$,kW(q,c6(Z,q.current)),VF=null;return}if(J.flags&32768){if(gF||Q===bH)q=!0;else if(j_||(LF&536870912)!==0)q=!1;else if(qq=q=!0,Q===QJ||Q===WJ||Q===c$||Q===s$)Q=_8.current,Q!==null&&Q.tag===13&&(Q.flags|=16384);th(J,q)}else mW(J)}function mW(q){var J=q;do{if((J.flags&32768)!==0){th(J,qq);return}var Z=J.alternate;if(q=J.return,FX(J),Z=v0(J,W3,Z,J,P7),(J.mode&IF)!==BF&&$A(J),Z!==null){VF=Z;return}if(J=J.sibling,J!==null){VF=J;return}VF=J=q}while(J!==null);O1===Q9&&(O1=qM)}function th(q,J){do{var Z=H3(q.alternate,q);if(Z!==null){Z.flags&=32767,VF=Z;return}if((q.mode&IF)!==BF){$A(q),Z=q.actualDuration;for(var Q=q.child;Q!==null;)Z+=Q.actualDuration,Q=Q.sibling;q.actualDuration=Z}if(Z=q.return,Z!==null&&(Z.flags|=32768,Z.subtreeFlags=0,Z.deletions=null),!J&&(q=q.sibling,q!==null)){VF=q;return}VF=q=Z}while(q!==null);O1=vH,VF=null}function $G(q,J,Z,Q,w,X,B,R,I,C,e,F0,i,U0){q.cancelPendingCommit=null;do J$();while(g1!==$q);if(m8.flushLegacyContextWarning(),m8.flushPendingUnsafeLifecycleWarnings(),(cF&(l1|$8))!==t1)throw Error("Should not already be working.");if(n6(Z),C===$J?uY(i,U0,Z,C1):Q!==null?iI(i,U0,Z,Q,J!==null&&J.alternate!==null&&J.alternate.memoizedState.isDehydrated&&(J.flags&256)!==0,C1):dI(i,U0,Z,C1),J!==null){if(Z===0&&console.error("finishedLanes should not be empty during a commit. This is a bug in React."),J===q.current)throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");if(X=J.lanes|J.childLanes,X|=XK,y0(q,Z,X,B,R,I),q===H1&&(VF=H1=null,LF=0),x_=J,Qq=q,i8=Z,pK=X,lK=w,XM=Q,mK=U0,GM=F0,n8=pH,KM=null,J.actualDuration!==0||(J.subtreeFlags&10256)!==0||(J.flags&10256)!==0?(q.callbackNode=null,q.callbackPriority=0,I3(w_,function(){return JQ=window.event,n8===pH&&(n8=uK),_R(),null})):(q.callbackNode=null,q.callbackPriority=0),e7=null,s9=y1(),F0!==null&&nI(U0,s9,F0,C1),Q=(J.flags&13878)!==0,(J.subtreeFlags&13878)!==0||Q){Q=R0.T,R0.T=null,w=F1.p,F1.p=q8,B=cF,cF|=$8;try{U3(q,J,Z)}finally{cF=B,F1.p=w,R0.T=Q}}g1=WM,eh(),FR(),qR()}}function eh(){if(g1===WM){g1=$q;var q=Qq,J=x_,Z=i8,Q=(J.flags&13878)!==0;if((J.subtreeFlags&13878)!==0||Q){Q=R0.T,R0.T=null;var w=F1.p;F1.p=q8;var X=cF;cF|=$8;try{v_=Z,b_=q,XW(),Ph(J,q),b_=v_=null,Z=F5;var B=uz(q.containerInfo),R=Z.focusedElem,I=Z.selectionRange;if(B!==R&&R&&R.ownerDocument&&gz(R.ownerDocument.documentElement,R)){if(I!==null&&jY(R)){var{start:C,end:e}=I;if(e===void 0&&(e=C),"selectionStart"in R)R.selectionStart=C,R.selectionEnd=Math.min(e,R.value.length);else{var F0=R.ownerDocument||document,i=F0&&F0.defaultView||window;if(i.getSelection){var U0=i.getSelection(),x0=R.textContent.length,i0=Math.min(I.start,x0),X1=I.end===void 0?i0:Math.min(I.end,x0);!U0.extend&&i0>X1&&(B=X1,X1=i0,i0=B);var mF=xz(R,i0),l=xz(R,X1);if(mF&&l&&(U0.rangeCount!==1||U0.anchorNode!==mF.node||U0.anchorOffset!==mF.offset||U0.focusNode!==l.node||U0.focusOffset!==l.offset)){var c=F0.createRange();c.setStart(mF.node,mF.offset),U0.removeAllRanges(),i0>X1?(U0.addRange(c),U0.extend(l.node,l.offset)):(c.setEnd(l.node,l.offset),U0.addRange(c))}}}}F0=[];for(U0=R;U0=U0.parentNode;)U0.nodeType===1&&F0.push({element:U0,left:U0.scrollLeft,top:U0.scrollTop});typeof R.focus==="function"&&R.focus();for(R=0;R<F0.length;R++){var r=F0[R];r.element.scrollLeft=r.left,r.element.scrollTop=r.top}}_w=!!eK,F5=eK=null}finally{cF=X,F1.p=w,R0.T=Q}}q.current=J,g1=HM}}function FR(){if(g1===HM){g1=$q;var q=KM;if(q!==null){s9=y1();var J=t7,Z=s9;!B1||Z<=J||(q9?q9.run(console.timeStamp.bind(console,q,J,Z,xF,vF,"secondary-light")):console.timeStamp(q,J,Z,xF,vF,"secondary-light"))}q=Qq,J=x_,Z=i8;var Q=(J.flags&8772)!==0;if((J.subtreeFlags&8772)!==0||Q){Q=R0.T,R0.T=null;var w=F1.p;F1.p=q8;var X=cF;cF|=$8;try{v_=Z,b_=q,XW(),Ih(q,J.alternate,J),b_=v_=null}finally{cF=X,F1.p=w,R0.T=Q}}q=mK,J=GM,t7=y1(),q=J===null?q:s9,J=t7,Z=n8===gK,Q=C1,e7!==null?iz(q,J,e7,!1,Q):!B1||J<=q||(Q?Q.run(console.timeStamp.bind(console,Z?"Commit Interrupted View Transition":"Commit",q,J,xF,vF,Z?"error":"secondary-dark")):console.timeStamp(Z?"Commit Interrupted View Transition":"Commit",q,J,xF,vF,Z?"error":"secondary-dark")),g1=wM}}function qR(){if(g1===YM||g1===wM){if(g1===YM){var q=t7;t7=y1();var J=t7,Z=n8===gK;!B1||J<=q||(q9?q9.run(console.timeStamp.bind(console,Z?"Interrupted View Transition":"Starting Animation",q,J,xF,vF,Z?"error":"secondary-light")):console.timeStamp(Z?"Interrupted View Transition":"Starting Animation",q,J,xF,vF,Z?" error":"secondary-light")),n8!==gK&&(n8=QM)}g1=$q,h4(),q=Qq;var Q=x_;J=i8,Z=XM;var w=Q.actualDuration!==0||(Q.subtreeFlags&10256)!==0||(Q.flags&10256)!==0;w?g1=mH:(g1=$q,x_=Qq=null,JR(q,q.pendingLanes),wJ=0,t$=null);var X=q.pendingLanes;if(X===0&&(Zq=null),w||WR(q),X=L(J),Q=Q.stateNode,G6&&typeof G6.onCommitFiberRoot==="function")try{var B=(Q.current.flags&128)===128;switch(X){case q8:var R=lG;break;case u8:R=dG;break;case f7:R=w_;break;case QH:R=iG;break;default:R=w_}G6.onCommitFiberRoot(Y_,Q,R,B)}catch(F0){M7||(M7=!0,console.error("React instrumentation encountered an error: %o",F0))}if(O7&&q.memoizedUpdaters.clear(),z3(),Z!==null){B=R0.T,R=F1.p,F1.p=q8,R0.T=null;try{var I=q.onRecoverableError;for(Q=0;Q<Z.length;Q++){var C=Z[Q],e=D3(C.stack);v0(C.source,I,C.value,e)}}finally{R0.T=B,F1.p=R}}(i8&3)!==0&&J$(),A7(q),X=q.pendingLanes,(J&261930)!==0&&(X&42)!==0?(fH=!0,q===dK?r$++:(r$=0,dK=q)):r$=0,w||nq(J,t7),Z$(0,!1)}}function D3(q){return q={componentStack:q},Object.defineProperty(q,"digest",{get:function(){console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.')}}),q}function JR(q,J){(q.pooledCacheLanes&=J)===0&&(J=q.pooledCache,J!=null&&(q.pooledCache=null,uZ(J)))}function J$(){return eh(),FR(),qR(),_R()}function _R(){if(g1!==mH)return!1;var q=Qq,J=pK;pK=0;var Z=L(i8),Q=f7===0||f7>Z?f7:Z;Z=R0.T;var w=F1.p;try{F1.p=Q,R0.T=null;var X=lK;lK=null,Q=Qq;var B=i8;if(g1=$q,x_=Qq=null,i8=0,(cF&(l1|$8))!==t1)throw Error("Cannot flush passive effects while already rendering.");n6(B),iK=!0,lH=!1;var R=0;if(e7=null,R=o1(),n8===QM)xZ(t7,R,q9);else{var I=t7,C=R,e=n8===uK;!B1||C<=I||(C1?C1.run(console.timeStamp.bind(console,e?"Waiting for Paint":"Waiting",I,C,xF,vF,"secondary-light")):console.timeStamp(e?"Waiting for Paint":"Waiting",I,C,xF,vF,"secondary-light"))}I=cF,cF|=$8;var F0=Q.current;XW(),xh(F0);var i=Q.current;F0=mK,XW(),yh(Q,i,B,X,F0),WR(Q),cF=I;var U0=o1();if(i=R,F0=C1,e7!==null?iz(i,U0,e7,!0,F0):!B1||U0<=i||(F0?F0.run(console.timeStamp.bind(console,"Remaining Effects",i,U0,xF,vF,"secondary-dark")):console.timeStamp("Remaining Effects",i,U0,xF,vF,"secondary-dark")),nq(B,U0),Z$(0,!1),lH?Q===t$?wJ++:(wJ=0,t$=Q):wJ=0,lH=iK=!1,G6&&typeof G6.onPostCommitFiberRoot==="function")try{G6.onPostCommitFiberRoot(Y_,Q)}catch(i0){M7||(M7=!0,console.error("React instrumentation encountered an error: %o",i0))}var x0=Q.current.stateNode;return x0.effectDuration=0,x0.passiveEffectDuration=0,!0}finally{F1.p=w,R0.T=Z,JR(q,J)}}function ZR(q,J,Z){J=c6(Z,J),QA(J),J=jX(q.stateNode,J,2),q=k9(q,J,2),q!==null&&(W0(q,2),A7(q))}function eF(q,J,Z){if(g_=!1,q.tag===3)ZR(q,q,Z);else{for(;J!==null;){if(J.tag===3){ZR(J,q,Z);return}if(J.tag===1){var Q=J.stateNode;if(typeof J.type.getDerivedStateFromError==="function"||typeof Q.componentDidCatch==="function"&&(Zq===null||!Zq.has(Q))){q=c6(Z,q),QA(q),Z=xX(2),Q=k9(J,Z,2),Q!==null&&(gX(Z,Q,J,q),W0(Q,2),A7(Q));return}}J=J.return}console.error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,Z)}}function QG(q,J,Z){var Q=q.pingCache;if(Q===null){Q=q.pingCache=new xT;var w=new Set;Q.set(J,w)}else w=Q.get(J),w===void 0&&(w=new Set,Q.set(J,w));w.has(Z)||(jK=!0,w.add(Z),Q=M3.bind(null,q,J,Z),O7&&_$(q,Z),J.then(Q,Q))}function M3(q,J,Z){var Q=q.pingCache;Q!==null&&Q.delete(J),q.pingedLanes|=q.suspendedLanes&Z,q.warmLanes&=~Z,(Z&127)!==0?0>L7&&(o9=L7=y1(),L$=hH("Promise Resolved"),a9=RH):(Z&4194048)!==0&&0>D8&&(E7=D8=y1(),C$=hH("Promise Resolved"),hK=RH),ph()&&R0.actQueue===null&&console.error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`),H1===q&&(LF&Z)===Z&&(O1===Fq||O1===yH&&(LF&62914560)===LF&&o1()-gH<ZM?(cF&l1)===t1&&J_(q,0):xK|=Z,HJ===LF&&(HJ=0)),A7(q)}function $R(q,J){J===0&&(J=q0()),q=X6(q,J),q!==null&&(W0(q,J),A7(q))}function O3(q){var J=q.memoizedState,Z=0;J!==null&&(Z=J.retryLane),$R(q,Z)}function f3(q,J){var Z=0;switch(q.tag){case 31:case 13:var{stateNode:Q,memoizedState:w}=q;w!==null&&(Z=w.retryLane);break;case 19:Q=q.stateNode;break;case 22:Q=q.stateNode._retryCache;break;default:throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.")}Q!==null&&Q.delete(J),$R(q,Z)}function WG(q,J,Z){if((J.subtreeFlags&67117056)!==0)for(J=J.child;J!==null;){var Q=q,w=J,X=w.type===FH;X=Z||X,w.tag!==22?w.flags&67108864?X&&v0(w,QR,Q,w):WG(Q,w,X):w.memoizedState===null&&(X&&w.flags&8192?v0(w,QR,Q,w):w.subtreeFlags&67108864&&v0(w,WG,Q,w,X)),J=J.sibling}}function QR(q,J){s0(!0);try{kh(J),gh(J),Sh(q,J.alternate,J,!1),vh(q,J,0,null,!1,0)}finally{s0(!1)}}function WR(q){var J=!0;q.current.mode&(K6|p8)||(J=!1),WG(q,q.current,J)}function HR(q){if((cF&l1)===t1){var J=q.tag;if(J===3||J===1||J===0||J===11||J===14||J===15){if(J=V(q)||"ReactComponent",dH!==null){if(dH.has(J))return;dH.add(J)}else dH=new Set([J]);v0(q,function(){console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead.")})}}}function _$(q,J){O7&&q.memoizedUpdaters.forEach(function(Z){b0(q,Z,J)})}function I3(q,J){var Z=R0.actQueue;return Z!==null?(Z.push(J),pT):mG(q,J)}function T3(q){ph()&&R0.actQueue===null&&v0(q,function(){console.error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`,V(q))})}function A7(q){q!==u_&&q.next===null&&(u_===null?iH=u_=q:u_=u_.next=q),nH=!0,R0.actQueue!==null?cK||(cK=!0,GR()):nK||(nK=!0,GR())}function Z$(q,J){if(!sK&&nH){sK=!0;do{var Z=!1;for(var Q=iH;Q!==null;){if(!J)if(q!==0){var w=Q.pendingLanes;if(w===0)var X=0;else{var{suspendedLanes:B,pingedLanes:R}=Q;X=(1<<31-M6(42|q)+1)-1,X&=w&~(B&~R),X=X&201326741?X&201326741|1:X?X|2:0}X!==0&&(Z=!0,XR(Q,X))}else X=LF,X=v(Q,Q===H1?X:0,Q.cancelPendingCommit!==null||Q.timeoutHandle!==KJ),(X&3)===0||E(Q,X)||(Z=!0,XR(Q,X));Q=Q.next}}while(Z);sK=!1}}function L3(){JQ=window.event,HG()}function HG(){nH=cK=nK=!1;var q=0;Wq!==0&&y3()&&(q=Wq);for(var J=o1(),Z=null,Q=iH;Q!==null;){var w=Q.next,X=wR(Q,J);if(X===0)Q.next=null,Z===null?iH=w:Z.next=w,w===null&&(u_=Z);else if(Z=Q,q!==0||(X&3)!==0)nH=!0;Q=w}g1!==$q&&g1!==mH||Z$(q,!1),Wq!==0&&(Wq=0)}function wR(q,J){for(var{suspendedLanes:Z,pingedLanes:Q,expirationTimes:w}=q,X=q.pendingLanes&-62914561;0<X;){var B=31-M6(X),R=1<<B,I=w[B];if(I===-1){if((R&Z)===0||(R&Q)!==0)w[B]=Y0(R,J)}else I<=J&&(q.expiredLanes|=R);X&=~R}if(J=H1,Z=LF,Z=v(q,q===J?Z:0,q.cancelPendingCommit!==null||q.timeoutHandle!==KJ),Q=q.callbackNode,Z===0||q===J&&(_1===QJ||_1===WJ)||q.cancelPendingCommit!==null)return Q!==null&&wG(Q),q.callbackNode=null,q.callbackPriority=0;if((Z&3)===0||E(q,Z)){if(J=Z&-Z,J!==q.callbackPriority||R0.actQueue!==null&&Q!==oK)wG(Q);else return J;switch(L(Z)){case q8:case u8:Z=dG;break;case f7:Z=w_;break;case QH:Z=iG;break;default:Z=w_}return Q=YR.bind(null,q),R0.actQueue!==null?(R0.actQueue.push(Q),Z=oK):Z=mG(Z,Q),q.callbackPriority=J,q.callbackNode=Z,J}return Q!==null&&wG(Q),q.callbackPriority=2,q.callbackNode=null,2}function YR(q,J){if(fH=OH=!1,JQ=window.event,g1!==$q&&g1!==mH)return q.callbackNode=null,q.callbackPriority=0,null;var Z=q.callbackNode;if(n8===pH&&(n8=uK),J$()&&q.callbackNode!==Z)return null;var Q=LF;if(Q=v(q,q===H1?Q:0,q.cancelPendingCommit!==null||q.timeoutHandle!==KJ),Q===0)return null;return lh(q,Q,J),wR(q,o1()),q.callbackNode!=null&&q.callbackNode===Z?YR.bind(null,q):null}function XR(q,J){if(J$())return null;OH=fH,fH=!1,lh(q,J,!0)}function wG(q){q!==oK&&q!==null&&z4(q)}function GR(){R0.actQueue!==null&&R0.actQueue.push(function(){return HG(),null}),rT(function(){(cF&(l1|$8))!==t1?mG(lG,L3):HG()})}function YG(){if(Wq===0){var q=eq;q===0&&(q=_H,_H<<=1,(_H&261888)===0&&(_H=256)),Wq=q}return Wq}function KR(q){if(q==null||typeof q==="symbol"||typeof q==="boolean")return null;if(typeof q==="function")return q;return XF(q,"action"),vZ(""+q)}function UR(q,J){var Z=J.ownerDocument.createElement("input");return Z.name=J.name,Z.value=J.value,q.id&&Z.setAttribute("form",q.id),J.parentNode.insertBefore(Z,J),q=new FormData(q),Z.parentNode.removeChild(Z),q}function E3(q,J,Z,Q,w){if(J==="submit"&&Z&&Z.stateNode===w){var X=KR((w[O6]||null).action),B=Q.submitter;B&&(J=(J=B[O6]||null)?KR(J.formAction):B.getAttribute("formAction"),J!==null&&(X=J,B=null));var R=new XH("action","action",null,Q,w);q.push({event:R,listeners:[{instance:null,listener:function(){if(Q.defaultPrevented){if(Wq!==0){var I=B?UR(w,B):new FormData(w),C={pending:!0,data:I,method:w.method,action:X};Object.freeze(C),PX(Z,C,null,I)}}else typeof X==="function"&&(R.preventDefault(),I=B?UR(w,B):new FormData(w),C={pending:!0,data:I,method:w.method,action:X},Object.freeze(C),PX(Z,C,X,I))},currentTarget:w}]})}}function lW(q,J,Z){q.currentTarget=Z;try{J(q)}catch(Q){WK(Q)}q.currentTarget=null}function BR(q,J){J=(J&4)!==0;for(var Z=0;Z<q.length;Z++){var Q=q[Z];F:{var w=void 0,X=Q.event;if(Q=Q.listeners,J)for(var B=Q.length-1;0<=B;B--){var R=Q[B],I=R.instance,C=R.currentTarget;if(R=R.listener,I!==w&&X.isPropagationStopped())break F;I!==null?v0(I,lW,X,R,C):lW(X,R,C),w=I}else for(B=0;B<Q.length;B++){if(R=Q[B],I=R.instance,C=R.currentTarget,R=R.listener,I!==w&&X.isPropagationStopped())break F;I!==null?v0(I,lW,X,R,C):lW(X,R,C),w=I}}}}function pF(q,J){aK.has(q)||console.error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',q);var Z=J[nG];Z===void 0&&(Z=J[nG]=new Set);var Q=q+"__bubble";Z.has(Q)||(zR(J,q,2,!1),Z.add(Q))}function XG(q,J,Z){aK.has(q)&&!J&&console.error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',q);var Q=0;J&&(Q|=4),zR(Z,q,Q,J)}function GG(q){if(!q[cH]){q[cH]=!0,GN.forEach(function(Z){Z!=="selectionchange"&&(aK.has(Z)||XG(Z,!1,q),XG(Z,!0,q))});var J=q.nodeType===9?q:q.ownerDocument;J===null||J[cH]||(J[cH]=!0,XG("selectionchange",!1,J))}}function zR(q,J,Z,Q){switch(oR(J)){case q8:var w=H4;break;case u8:w=w4;break;default:w=EG}Z=w.bind(null,J,Z,q),w=void 0,!rG||J!=="touchstart"&&J!=="touchmove"&&J!=="wheel"||(w=!0),Q?w!==void 0?q.addEventListener(J,Z,{capture:!0,passive:w}):q.addEventListener(J,Z,!0):w!==void 0?q.addEventListener(J,Z,{passive:w}):q.addEventListener(J,Z,!1)}function KG(q,J,Z,Q,w){var X=Q;if((J&1)===0&&(J&2)===0&&Q!==null)F:for(;;){if(Q===null)return;var B=Q.tag;if(B===3||B===4){var R=Q.stateNode.containerInfo;if(R===w)break;if(B===4)for(B=Q.return;B!==null;){var I=B.tag;if((I===3||I===4)&&B.stateNode.containerInfo===w)return;B=B.return}for(;R!==null;){if(B=h0(R),B===null)return;if(I=B.tag,I===5||I===6||I===26||I===27){Q=X=B;continue F}R=R.parentNode}}Q=Q.return}Lz(function(){var C=X,e=vY(Z),F0=[];F:{var i=oN.get(q);if(i!==void 0){var U0=XH,x0=q;switch(q){case"keypress":if(rQ(Z)===0)break F;case"keydown":case"keyup":U0=_T;break;case"focusin":x0="focus",U0=qK;break;case"focusout":x0="blur",U0=qK;break;case"beforeblur":case"afterblur":U0=qK;break;case"click":if(Z.button===2)break F;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":U0=vN;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":U0=i4;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":U0=QT;break;case iN:case nN:case cN:U0=s4;break;case sN:U0=HT;break;case"scroll":case"scrollend":U0=l4;break;case"wheel":U0=YT;break;case"copy":case"cut":case"paste":U0=a4;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":U0=jN;break;case"toggle":case"beforetoggle":U0=GT}var i0=(J&4)!==0,X1=!i0&&(q==="scroll"||q==="scrollend"),mF=i0?i!==null?i+"Capture":null:i;i0=[];for(var l=C,c;l!==null;){var r=l;if(c=r.stateNode,r=r.tag,r!==5&&r!==26&&r!==27||c===null||mF===null||(r=bZ(l,mF),r!=null&&i0.push($$(l,r,c))),X1)break;l=l.return}0<i0.length&&(i=new U0(i,x0,null,Z,e),F0.push({event:i,listeners:i0}))}}if((J&7)===0){F:{if(i=q==="mouseover"||q==="pointerover",U0=q==="mouseout"||q==="pointerout",i&&Z!==z$&&(x0=Z.relatedTarget||Z.fromElement)&&(h0(x0)||x0[m9]))break F;if(U0||i){if(i=e.window===e?e:(i=e.ownerDocument)?i.defaultView||i.parentWindow:window,U0){if(x0=Z.relatedTarget||Z.toElement,U0=C,x0=x0?h0(x0):null,x0!==null&&(X1=O(x0),i0=x0.tag,x0!==X1||i0!==5&&i0!==27&&i0!==6))x0=null}else U0=null,x0=C;if(U0!==x0){if(i0=vN,r="onMouseLeave",mF="onMouseEnter",l="mouse",q==="pointerout"||q==="pointerover")i0=jN,r="onPointerLeave",mF="onPointerEnter",l="pointer";if(X1=U0==null?i:L0(U0),c=x0==null?i:L0(x0),i=new i0(r,l+"leave",U0,Z,e),i.target=X1,i.relatedTarget=c,r=null,h0(e)===C&&(i0=new i0(mF,l+"enter",x0,Z,e),i0.target=c,i0.relatedTarget=X1,r=i0),X1=r,U0&&x0)q:{i0=C3,mF=U0,l=x0,c=0;for(r=mF;r;r=i0(r))c++;r=0;for(var f0=l;f0;f0=i0(f0))r++;for(;0<c-r;)mF=i0(mF),c--;for(;0<r-c;)l=i0(l),r--;for(;c--;){if(mF===l||l!==null&&mF===l.alternate){i0=mF;break q}mF=i0(mF),l=i0(l)}i0=null}else i0=null;U0!==null&&AR(F0,i,U0,i0,!1),x0!==null&&X1!==null&&AR(F0,X1,x0,i0,!0)}}}F:{if(i=C?L0(C):window,U0=i.nodeName&&i.nodeName.toLowerCase(),U0==="select"||U0==="input"&&i.type==="file")var p0=yz;else if(kz(i))if(lN)p0=pI;else{p0=gI;var NF=xI}else U0=i.nodeName,!U0||U0.toLowerCase()!=="input"||i.type!=="checkbox"&&i.type!=="radio"?C&&P1(C.elementType)&&(p0=yz):p0=uI;if(p0&&(p0=p0(q,C))){Sz(F0,p0,Z,e);break F}NF&&NF(q,i,C),q==="focusout"&&C&&i.type==="number"&&C.memoizedProps.value!=null&&iJ(i,"number",i.value)}switch(NF=C?L0(C):window,q){case"focusin":if(kz(NF)||NF.contentEditable==="true")A_=NF,_K=C,O$=null;break;case"focusout":O$=_K=A_=null;break;case"mousedown":ZK=!0;break;case"contextmenu":case"mouseup":case"dragend":ZK=!1,pz(F0,Z,e);break;case"selectionchange":if(zT)break;case"keydown":case"keyup":pz(F0,Z,e)}var QF;if(JK)F:{switch(q){case"compositionstart":var qF="onCompositionStart";break F;case"compositionend":qF="onCompositionEnd";break F;case"compositionupdate":qF="onCompositionUpdate";break F}qF=void 0}else z_?Pz(q,Z)&&(qF="onCompositionEnd"):q==="keydown"&&Z.keyCode===xN&&(qF="onCompositionStart");if(qF&&(gN&&Z.locale!=="ko"&&(z_||qF!=="onCompositionStart"?qF==="onCompositionEnd"&&z_&&(QF=Ez()):(l9=e,tG=("value"in l9)?l9.value:l9.textContent,z_=!0)),NF=dW(C,qF),0<NF.length&&(qF=new bN(qF,q,null,Z,e),F0.push({event:qF,listeners:NF}),QF?qF.data=QF:(QF=Vz(Z),QF!==null&&(qF.data=QF)))),QF=UT?yI(q,Z):vI(q,Z))qF=dW(C,"onBeforeInput"),0<qF.length&&(NF=new t4("onBeforeInput","beforeinput",null,Z,e),F0.push({event:NF,listeners:qF}),NF.data=QF);E3(F0,q,C,Z,e)}BR(F0,J)})}function $$(q,J,Z){return{instance:q,listener:J,currentTarget:Z}}function dW(q,J){for(var Z=J+"Capture",Q=[];q!==null;){var w=q,X=w.stateNode;if(w=w.tag,w!==5&&w!==26&&w!==27||X===null||(w=bZ(q,Z),w!=null&&Q.unshift($$(q,w,X)),w=bZ(q,J),w!=null&&Q.push($$(q,w,X))),q.tag===3)return Q;q=q.return}return[]}function C3(q){if(q===null)return null;do q=q.return;while(q&&q.tag!==5&&q.tag!==27);return q?q:null}function AR(q,J,Z,Q,w){for(var X=J._reactName,B=[];Z!==null&&Z!==Q;){var R=Z,I=R.alternate,C=R.stateNode;if(R=R.tag,I!==null&&I===Q)break;R!==5&&R!==26&&R!==27||C===null||(I=C,w?(C=bZ(Z,X),C!=null&&B.unshift($$(Z,C,I))):w||(C=bZ(Z,X),C!=null&&B.push($$(Z,C,I)))),Z=Z.return}B.length!==0&&q.push({event:J,listeners:B})}function UG(q,J){x7(q,J),q!=="input"&&q!=="textarea"&&q!=="select"||J==null||J.value!==null||SN||(SN=!0,q==="select"&&J.multiple?console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",q):console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",q));var Z={registrationNameDependencies:cq,possibleRegistrationNames:cG};P1(q)||typeof J.is==="string"||kI(q,J,Z),J.contentEditable&&!J.suppressContentEditableWarning&&J.children!=null&&console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.")}function s1(q,J,Z,Q){J!==Z&&(Z=j9(Z),j9(J)!==Z&&(Q[q]=J))}function P3(q,J,Z){J.forEach(function(Q){Z[NR(Q)]=Q==="style"?zG(q):q.getAttribute(Q)})}function h7(q,J){J===!1?console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",q,q,q):console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.",q,typeof J)}function hR(q,J){return q=q.namespaceURI===HH||q.namespaceURI===G_?q.ownerDocument.createElementNS(q.namespaceURI,q.tagName):q.ownerDocument.createElement(q.tagName),q.innerHTML=J,q.innerHTML}function j9(q){return jF(q)&&(console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",OF(q)),t0(q)),(typeof q==="string"?q:""+q).replace(mT,`
`).replace(lT,"")}function RR(q,J){return J=j9(J),j9(q)===J?!0:!1}function Q1(q,J,Z,Q,w,X){switch(Z){case"children":if(typeof Q==="string")c1(Q,J,!1),J==="body"||J==="textarea"&&Q===""||v8(q,Q);else if(typeof Q==="number"||typeof Q==="bigint")c1(""+Q,J,!1),J!=="body"&&v8(q,""+Q);break;case"className":Cq(q,"class",Q);break;case"tabIndex":Cq(q,"tabindex",Q);break;case"dir":case"role":case"viewBox":case"width":case"height":Cq(q,Z,Q);break;case"style":N6(q,Q,X);break;case"data":if(J!=="object"){Cq(q,"data",Q);break}case"src":case"href":if(Q===""&&(J!=="a"||Z!=="href")){Z==="src"?console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',Z,Z):console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',Z,Z),q.removeAttribute(Z);break}if(Q==null||typeof Q==="function"||typeof Q==="symbol"||typeof Q==="boolean"){q.removeAttribute(Z);break}XF(Q,Z),Q=vZ(""+Q),q.setAttribute(Z,Q);break;case"action":case"formAction":if(Q!=null&&(J==="form"?Z==="formAction"?console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."):typeof Q==="function"&&(w.encType==null&&w.method==null||aH||(aH=!0,console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")),w.target==null||oH||(oH=!0,console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."))):J==="input"||J==="button"?Z==="action"?console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."):J!=="input"||w.type==="submit"||w.type==="image"||sH?J!=="button"||w.type==null||w.type==="submit"||sH?typeof Q==="function"&&(w.name==null||hM||(hM=!0,console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')),w.formEncType==null&&w.formMethod==null||aH||(aH=!0,console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")),w.formTarget==null||oH||(oH=!0,console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))):(sH=!0,console.error('A button can only specify a formAction along with type="submit" or no type.')):(sH=!0,console.error('An input can only specify a formAction along with type="submit" or type="image".')):Z==="action"?console.error("You can only pass the action prop to <form>."):console.error("You can only pass the formAction prop to <input> or <button>.")),typeof Q==="function"){q.setAttribute(Z,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof X==="function"&&(Z==="formAction"?(J!=="input"&&Q1(q,J,"name",w.name,w,null),Q1(q,J,"formEncType",w.formEncType,w,null),Q1(q,J,"formMethod",w.formMethod,w,null),Q1(q,J,"formTarget",w.formTarget,w,null)):(Q1(q,J,"encType",w.encType,w,null),Q1(q,J,"method",w.method,w,null),Q1(q,J,"target",w.target,w,null)));if(Q==null||typeof Q==="symbol"||typeof Q==="boolean"){q.removeAttribute(Z);break}XF(Q,Z),Q=vZ(""+Q),q.setAttribute(Z,Q);break;case"onClick":Q!=null&&(typeof Q!=="function"&&h7(Z,Q),q.onclick=g7);break;case"onScroll":Q!=null&&(typeof Q!=="function"&&h7(Z,Q),pF("scroll",q));break;case"onScrollEnd":Q!=null&&(typeof Q!=="function"&&h7(Z,Q),pF("scrollend",q));break;case"dangerouslySetInnerHTML":if(Q!=null){if(typeof Q!=="object"||!("__html"in Q))throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");if(Z=Q.__html,Z!=null){if(w.children!=null)throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");q.innerHTML=Z}}break;case"multiple":q.multiple=Q&&typeof Q!=="function"&&typeof Q!=="symbol";break;case"muted":q.muted=Q&&typeof Q!=="function"&&typeof Q!=="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(Q==null||typeof Q==="function"||typeof Q==="boolean"||typeof Q==="symbol"){q.removeAttribute("xlink:href");break}XF(Q,Z),Z=vZ(""+Q),q.setAttributeNS(YJ,"xlink:href",Z);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":Q!=null&&typeof Q!=="function"&&typeof Q!=="symbol"?(XF(Q,Z),q.setAttribute(Z,""+Q)):q.removeAttribute(Z);break;case"inert":Q!==""||rH[Z]||(rH[Z]=!0,console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",Z));case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":Q&&typeof Q!=="function"&&typeof Q!=="symbol"?q.setAttribute(Z,""):q.removeAttribute(Z);break;case"capture":case"download":Q===!0?q.setAttribute(Z,""):Q!==!1&&Q!=null&&typeof Q!=="function"&&typeof Q!=="symbol"?(XF(Q,Z),q.setAttribute(Z,Q)):q.removeAttribute(Z);break;case"cols":case"rows":case"size":case"span":Q!=null&&typeof Q!=="function"&&typeof Q!=="symbol"&&!isNaN(Q)&&1<=Q?(XF(Q,Z),q.setAttribute(Z,Q)):q.removeAttribute(Z);break;case"rowSpan":case"start":Q==null||typeof Q==="function"||typeof Q==="symbol"||isNaN(Q)?q.removeAttribute(Z):(XF(Q,Z),q.setAttribute(Z,Q));break;case"popover":pF("beforetoggle",q),pF("toggle",q),y6(q,"popover",Q);break;case"xlinkActuate":i6(q,YJ,"xlink:actuate",Q);break;case"xlinkArcrole":i6(q,YJ,"xlink:arcrole",Q);break;case"xlinkRole":i6(q,YJ,"xlink:role",Q);break;case"xlinkShow":i6(q,YJ,"xlink:show",Q);break;case"xlinkTitle":i6(q,YJ,"xlink:title",Q);break;case"xlinkType":i6(q,YJ,"xlink:type",Q);break;case"xmlBase":i6(q,rK,"xml:base",Q);break;case"xmlLang":i6(q,rK,"xml:lang",Q);break;case"xmlSpace":i6(q,rK,"xml:space",Q);break;case"is":X!=null&&console.error('Cannot update the "is" prop after it has been initialized.'),y6(q,"is",Q);break;case"innerText":case"textContent":break;case"popoverTarget":RM||Q==null||typeof Q!=="object"||(RM=!0,console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",Q));default:!(2<Z.length)||Z[0]!=="o"&&Z[0]!=="O"||Z[1]!=="n"&&Z[1]!=="N"?(Z=Z6(Z),y6(q,Z,Q)):cq.hasOwnProperty(Z)&&Q!=null&&typeof Q!=="function"&&h7(Z,Q)}}function BG(q,J,Z,Q,w,X){switch(Z){case"style":N6(q,Q,X);break;case"dangerouslySetInnerHTML":if(Q!=null){if(typeof Q!=="object"||!("__html"in Q))throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");if(Z=Q.__html,Z!=null){if(w.children!=null)throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");q.innerHTML=Z}}break;case"children":typeof Q==="string"?v8(q,Q):(typeof Q==="number"||typeof Q==="bigint")&&v8(q,""+Q);break;case"onScroll":Q!=null&&(typeof Q!=="function"&&h7(Z,Q),pF("scroll",q));break;case"onScrollEnd":Q!=null&&(typeof Q!=="function"&&h7(Z,Q),pF("scrollend",q));break;case"onClick":Q!=null&&(typeof Q!=="function"&&h7(Z,Q),q.onclick=g7);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(cq.hasOwnProperty(Z))Q!=null&&typeof Q!=="function"&&h7(Z,Q);else F:{if(Z[0]==="o"&&Z[1]==="n"&&(w=Z.endsWith("Capture"),J=Z.slice(2,w?Z.length-7:void 0),X=q[O6]||null,X=X!=null?X[Z]:null,typeof X==="function"&&q.removeEventListener(J,X,w),typeof Q==="function")){typeof X!=="function"&&X!==null&&(Z in q?q[Z]=null:q.hasAttribute(Z)&&q.removeAttribute(Z)),q.addEventListener(J,Q,w);break F}Z in q?q[Z]=Q:Q===!0?q.setAttribute(Z,""):y6(q,Z,Q)}}}function W6(q,J,Z){switch(UG(J,Z),J){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":pF("error",q),pF("load",q);var Q=!1,w=!1,X;for(X in Z)if(Z.hasOwnProperty(X)){var B=Z[X];if(B!=null)switch(X){case"src":Q=!0;break;case"srcSet":w=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(J+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");default:Q1(q,J,X,B,Z,null)}}w&&Q1(q,J,"srcSet",Z.srcSet,Z,null),Q&&Q1(q,J,"src",Z.src,Z,null);return;case"input":iF("input",Z),pF("invalid",q);var R=X=B=w=null,I=null,C=null;for(Q in Z)if(Z.hasOwnProperty(Q)){var e=Z[Q];if(e!=null)switch(Q){case"name":w=e;break;case"type":B=e;break;case"checked":I=e;break;case"defaultChecked":C=e;break;case"value":X=e;break;case"defaultValue":R=e;break;case"children":case"dangerouslySetInnerHTML":if(e!=null)throw Error(J+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");break;default:Q1(q,J,Q,e,Z,null)}}Vq(q,Z),kq(q,X,R,I,C,B,w,!1);return;case"select":iF("select",Z),pF("invalid",q),Q=B=X=null;for(w in Z)if(Z.hasOwnProperty(w)&&(R=Z[w],R!=null))switch(w){case"value":X=R;break;case"defaultValue":B=R;break;case"multiple":Q=R;default:Q1(q,J,w,R,Z,null)}cQ(q,Z),J=X,Z=B,q.multiple=!!Q,J!=null?T9(q,!!Q,J,!1):Z!=null&&T9(q,!!Q,Z,!0);return;case"textarea":iF("textarea",Z),pF("invalid",q),X=w=Q=null;for(B in Z)if(Z.hasOwnProperty(B)&&(R=Z[B],R!=null))switch(B){case"value":Q=R;break;case"defaultValue":w=R;break;case"children":X=R;break;case"dangerouslySetInnerHTML":if(R!=null)throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");break;default:Q1(q,J,B,R,Z,null)}sQ(q,Z),aQ(q,Q,w,X);return;case"option":SZ(q,Z);for(I in Z)if(Z.hasOwnProperty(I)&&(Q=Z[I],Q!=null))switch(I){case"selected":q.selected=Q&&typeof Q!=="function"&&typeof Q!=="symbol";break;default:Q1(q,J,I,Q,Z,null)}return;case"dialog":pF("beforetoggle",q),pF("toggle",q),pF("cancel",q),pF("close",q);break;case"iframe":case"object":pF("load",q);break;case"video":case"audio":for(Q=0;Q<e$.length;Q++)pF(e$[Q],q);break;case"image":pF("error",q),pF("load",q);break;case"details":pF("toggle",q);break;case"embed":case"source":case"link":pF("error",q),pF("load",q);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(C in Z)if(Z.hasOwnProperty(C)&&(Q=Z[C],Q!=null))switch(C){case"children":case"dangerouslySetInnerHTML":throw Error(J+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");default:Q1(q,J,C,Q,Z,null)}return;default:if(P1(J)){for(e in Z)Z.hasOwnProperty(e)&&(Q=Z[e],Q!==void 0&&BG(q,J,e,Q,Z,void 0));return}}for(R in Z)Z.hasOwnProperty(R)&&(Q=Z[R],Q!=null&&Q1(q,J,R,Q,Z,null))}function V3(q,J,Z,Q){switch(UG(J,Q),J){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var w=null,X=null,B=null,R=null,I=null,C=null,e=null;for(U0 in Z){var F0=Z[U0];if(Z.hasOwnProperty(U0)&&F0!=null)switch(U0){case"checked":break;case"value":break;case"defaultValue":I=F0;default:Q.hasOwnProperty(U0)||Q1(q,J,U0,null,Q,F0)}}for(var i in Q){var U0=Q[i];if(F0=Z[i],Q.hasOwnProperty(i)&&(U0!=null||F0!=null))switch(i){case"type":X=U0;break;case"name":w=U0;break;case"checked":C=U0;break;case"defaultChecked":e=U0;break;case"value":B=U0;break;case"defaultValue":R=U0;break;case"children":case"dangerouslySetInnerHTML":if(U0!=null)throw Error(J+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");break;default:U0!==F0&&Q1(q,J,i,U0,Q,F0)}}J=Z.type==="checkbox"||Z.type==="radio"?Z.checked!=null:Z.value!=null,Q=Q.type==="checkbox"||Q.type==="radio"?Q.checked!=null:Q.value!=null,J||!Q||AM||(console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"),AM=!0),!J||Q||zM||(console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"),zM=!0),dJ(q,B,R,I,C,e,X,w);return;case"select":U0=B=R=i=null;for(X in Z)if(I=Z[X],Z.hasOwnProperty(X)&&I!=null)switch(X){case"value":break;case"multiple":U0=I;default:Q.hasOwnProperty(X)||Q1(q,J,X,null,Q,I)}for(w in Q)if(X=Q[w],I=Z[w],Q.hasOwnProperty(w)&&(X!=null||I!=null))switch(w){case"value":i=X;break;case"defaultValue":R=X;break;case"multiple":B=X;default:X!==I&&Q1(q,J,w,X,Q,I)}Q=R,J=B,Z=U0,i!=null?T9(q,!!J,i,!1):!!Z!==!!J&&(Q!=null?T9(q,!!J,Q,!0):T9(q,!!J,J?[]:"",!1));return;case"textarea":U0=i=null;for(R in Z)if(w=Z[R],Z.hasOwnProperty(R)&&w!=null&&!Q.hasOwnProperty(R))switch(R){case"value":break;case"children":break;default:Q1(q,J,R,null,Q,w)}for(B in Q)if(w=Q[B],X=Z[B],Q.hasOwnProperty(B)&&(w!=null||X!=null))switch(B){case"value":i=w;break;case"defaultValue":U0=w;break;case"children":break;case"dangerouslySetInnerHTML":if(w!=null)throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");break;default:w!==X&&Q1(q,J,B,w,Q,X)}oQ(q,i,U0);return;case"option":for(var x0 in Z)if(i=Z[x0],Z.hasOwnProperty(x0)&&i!=null&&!Q.hasOwnProperty(x0))switch(x0){case"selected":q.selected=!1;break;default:Q1(q,J,x0,null,Q,i)}for(I in Q)if(i=Q[I],U0=Z[I],Q.hasOwnProperty(I)&&i!==U0&&(i!=null||U0!=null))switch(I){case"selected":q.selected=i&&typeof i!=="function"&&typeof i!=="symbol";break;default:Q1(q,J,I,i,Q,U0)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var i0 in Z)i=Z[i0],Z.hasOwnProperty(i0)&&i!=null&&!Q.hasOwnProperty(i0)&&Q1(q,J,i0,null,Q,i);for(C in Q)if(i=Q[C],U0=Z[C],Q.hasOwnProperty(C)&&i!==U0&&(i!=null||U0!=null))switch(C){case"children":case"dangerouslySetInnerHTML":if(i!=null)throw Error(J+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");break;default:Q1(q,J,C,i,Q,U0)}return;default:if(P1(J)){for(var X1 in Z)i=Z[X1],Z.hasOwnProperty(X1)&&i!==void 0&&!Q.hasOwnProperty(X1)&&BG(q,J,X1,void 0,Q,i);for(e in Q)i=Q[e],U0=Z[e],!Q.hasOwnProperty(e)||i===U0||i===void 0&&U0===void 0||BG(q,J,e,i,Q,U0);return}}for(var mF in Z)i=Z[mF],Z.hasOwnProperty(mF)&&i!=null&&!Q.hasOwnProperty(mF)&&Q1(q,J,mF,null,Q,i);for(F0 in Q)i=Q[F0],U0=Z[F0],!Q.hasOwnProperty(F0)||i===U0||i==null&&U0==null||Q1(q,J,F0,i,Q,U0)}function NR(q){switch(q){case"class":return"className";case"for":return"htmlFor";default:return q}}function zG(q){var J={};q=q.style;for(var Z=0;Z<q.length;Z++){var Q=q[Z];J[Q]=q.getPropertyValue(Q)}return J}function DR(q,J,Z){if(J!=null&&typeof J!=="object")console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");else{var Q,w=Q="",X;for(X in J)if(J.hasOwnProperty(X)){var B=J[X];B!=null&&typeof B!=="boolean"&&B!==""&&(X.indexOf("--")===0?(a(B,X),Q+=w+X+":"+(""+B).trim()):typeof B!=="number"||B===0||VN.has(X)?(a(B,X),Q+=w+X.replace(TN,"-$1").toLowerCase().replace(LN,"-ms-")+":"+(""+B).trim()):Q+=w+X.replace(TN,"-$1").toLowerCase().replace(LN,"-ms-")+":"+B+"px",w=";")}Q=Q||null,J=q.getAttribute("style"),J!==Q&&(Q=j9(Q),j9(J)!==Q&&(Z.style=zG(q)))}}function U8(q,J,Z,Q,w,X){if(w.delete(Z),q=q.getAttribute(Z),q===null)switch(typeof Q){case"undefined":case"function":case"symbol":case"boolean":return}else if(Q!=null)switch(typeof Q){case"function":case"symbol":case"boolean":break;default:if(XF(Q,J),q===""+Q)return}s1(J,q,Q,X)}function MR(q,J,Z,Q,w,X){if(w.delete(Z),q=q.getAttribute(Z),q===null){switch(typeof Q){case"function":case"symbol":return}if(!Q)return}else switch(typeof Q){case"function":case"symbol":break;default:if(Q)return}s1(J,q,Q,X)}function AG(q,J,Z,Q,w,X){if(w.delete(Z),q=q.getAttribute(Z),q===null)switch(typeof Q){case"undefined":case"function":case"symbol":return}else if(Q!=null)switch(typeof Q){case"function":case"symbol":break;default:if(XF(Q,Z),q===""+Q)return}s1(J,q,Q,X)}function OR(q,J,Z,Q,w,X){if(w.delete(Z),q=q.getAttribute(Z),q===null)switch(typeof Q){case"undefined":case"function":case"symbol":case"boolean":return;default:if(isNaN(Q))return}else if(Q!=null)switch(typeof Q){case"function":case"symbol":case"boolean":break;default:if(!isNaN(Q)&&(XF(Q,J),q===""+Q))return}s1(J,q,Q,X)}function hG(q,J,Z,Q,w,X){if(w.delete(Z),q=q.getAttribute(Z),q===null)switch(typeof Q){case"undefined":case"function":case"symbol":case"boolean":return}else if(Q!=null)switch(typeof Q){case"function":case"symbol":case"boolean":break;default:if(XF(Q,J),Z=vZ(""+Q),q===Z)return}s1(J,q,Q,X)}function fR(q,J,Z,Q){for(var w={},X=new Set,B=q.attributes,R=0;R<B.length;R++)switch(B[R].name.toLowerCase()){case"value":break;case"checked":break;case"selected":break;default:X.add(B[R].name)}if(P1(J)){for(var I in Z)if(Z.hasOwnProperty(I)){var C=Z[I];if(C!=null){if(cq.hasOwnProperty(I))typeof C!=="function"&&h7(I,C);else if(Z.suppressHydrationWarning!==!0)switch(I){case"children":typeof C!=="string"&&typeof C!=="number"||s1("children",q.textContent,C,w);continue;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":continue;case"dangerouslySetInnerHTML":B=q.innerHTML,C=C?C.__html:void 0,C!=null&&(C=hR(q,C),s1(I,B,C,w));continue;case"style":X.delete(I),DR(q,C,w);continue;case"offsetParent":case"offsetTop":case"offsetLeft":case"offsetWidth":case"offsetHeight":case"isContentEditable":case"outerText":case"outerHTML":X.delete(I.toLowerCase()),console.error("Assignment to read-only property will result in a no-op: `%s`",I);continue;case"className":X.delete("class"),B=K8(q,"class",C),s1("className",B,C,w);continue;default:Q.context===W9&&J!=="svg"&&J!=="math"?X.delete(I.toLowerCase()):X.delete(I),B=K8(q,I,C),s1(I,B,C,w)}}}}else for(C in Z)if(Z.hasOwnProperty(C)&&(I=Z[C],I!=null)){if(cq.hasOwnProperty(C))typeof I!=="function"&&h7(C,I);else if(Z.suppressHydrationWarning!==!0)switch(C){case"children":typeof I!=="string"&&typeof I!=="number"||s1("children",q.textContent,I,w);continue;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"value":case"checked":case"selected":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":continue;case"dangerouslySetInnerHTML":B=q.innerHTML,I=I?I.__html:void 0,I!=null&&(I=hR(q,I),B!==I&&(w[C]={__html:B}));continue;case"className":U8(q,C,"class",I,X,w);continue;case"tabIndex":U8(q,C,"tabindex",I,X,w);continue;case"style":X.delete(C),DR(q,I,w);continue;case"multiple":X.delete(C),s1(C,q.multiple,I,w);continue;case"muted":X.delete(C),s1(C,q.muted,I,w);continue;case"autoFocus":X.delete("autofocus"),s1(C,q.autofocus,I,w);continue;case"data":if(J!=="object"){X.delete(C),B=q.getAttribute("data"),s1(C,B,I,w);continue}case"src":case"href":if(!(I!==""||J==="a"&&C==="href"||J==="object"&&C==="data")){C==="src"?console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',C,C):console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',C,C);continue}hG(q,C,C,I,X,w);continue;case"action":case"formAction":if(B=q.getAttribute(C),typeof I==="function"){X.delete(C.toLowerCase()),C==="formAction"?(X.delete("name"),X.delete("formenctype"),X.delete("formmethod"),X.delete("formtarget")):(X.delete("enctype"),X.delete("method"),X.delete("target"));continue}else if(B===dT){X.delete(C.toLowerCase()),s1(C,"function",I,w);continue}hG(q,C,C.toLowerCase(),I,X,w);continue;case"xlinkHref":hG(q,C,"xlink:href",I,X,w);continue;case"contentEditable":AG(q,C,"contenteditable",I,X,w);continue;case"spellCheck":AG(q,C,"spellcheck",I,X,w);continue;case"draggable":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":AG(q,C,C,I,X,w);continue;case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":MR(q,C,C.toLowerCase(),I,X,w);continue;case"capture":case"download":F:{R=q;var e=B=C,F0=w;if(X.delete(e),R=R.getAttribute(e),R===null)switch(typeof I){case"undefined":case"function":case"symbol":break F;default:if(I===!1)break F}else if(I!=null)switch(typeof I){case"function":case"symbol":break;case"boolean":if(I===!0&&R==="")break F;break;default:if(XF(I,B),R===""+I)break F}s1(B,R,I,F0)}continue;case"cols":case"rows":case"size":case"span":F:{if(R=q,e=B=C,F0=w,X.delete(e),R=R.getAttribute(e),R===null)switch(typeof I){case"undefined":case"function":case"symbol":case"boolean":break F;default:if(isNaN(I)||1>I)break F}else if(I!=null)switch(typeof I){case"function":case"symbol":case"boolean":break;default:if(!(isNaN(I)||1>I)&&(XF(I,B),R===""+I))break F}s1(B,R,I,F0)}continue;case"rowSpan":OR(q,C,"rowspan",I,X,w);continue;case"start":OR(q,C,C,I,X,w);continue;case"xHeight":U8(q,C,"x-height",I,X,w);continue;case"xlinkActuate":U8(q,C,"xlink:actuate",I,X,w);continue;case"xlinkArcrole":U8(q,C,"xlink:arcrole",I,X,w);continue;case"xlinkRole":U8(q,C,"xlink:role",I,X,w);continue;case"xlinkShow":U8(q,C,"xlink:show",I,X,w);continue;case"xlinkTitle":U8(q,C,"xlink:title",I,X,w);continue;case"xlinkType":U8(q,C,"xlink:type",I,X,w);continue;case"xmlBase":U8(q,C,"xml:base",I,X,w);continue;case"xmlLang":U8(q,C,"xml:lang",I,X,w);continue;case"xmlSpace":U8(q,C,"xml:space",I,X,w);continue;case"inert":I!==""||rH[C]||(rH[C]=!0,console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",C)),MR(q,C,C,I,X,w);continue;default:if(!(2<C.length)||C[0]!=="o"&&C[0]!=="O"||C[1]!=="n"&&C[1]!=="N"){R=Z6(C),B=!1,Q.context===W9&&J!=="svg"&&J!=="math"?X.delete(R.toLowerCase()):(e=C.toLowerCase(),e=wH.hasOwnProperty(e)?wH[e]||null:null,e!==null&&e!==C&&(B=!0,X.delete(e)),X.delete(R));F:if(e=q,F0=R,R=I,nF(F0))if(e.hasAttribute(F0))e=e.getAttribute(F0),XF(R,F0),R=e===""+R?R:e;else{switch(typeof R){case"function":case"symbol":break F;case"boolean":if(e=F0.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-")break F}R=R===void 0?void 0:null}else R=void 0;B||s1(C,R,I,w)}}}return 0<X.size&&Z.suppressHydrationWarning!==!0&&P3(q,X,w),Object.keys(w).length===0?null:w}function k3(q,J){switch(q.length){case 0:return"";case 1:return q[0];case 2:return q[0]+" "+J+" "+q[1];default:return q.slice(0,-1).join(", ")+", "+J+" "+q[q.length-1]}}function IR(q){switch(q){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function S3(){if(typeof performance.getEntriesByType==="function"){for(var q=0,J=0,Z=performance.getEntriesByType("resource"),Q=0;Q<Z.length;Q++){var w=Z[Q],X=w.transferSize,B=w.initiatorType,R=w.duration;if(X&&R&&IR(B)){B=0,R=w.responseEnd;for(Q+=1;Q<Z.length;Q++){var I=Z[Q],C=I.startTime;if(C>R)break;var{transferSize:e,initiatorType:F0}=I;e&&IR(F0)&&(I=I.responseEnd,B+=e*(I<R?1:(R-C)/(I-C)))}if(--Q,J+=8*(X+B)/(w.duration/1000),q++,10<q)break}}if(0<q)return J/q/1e6}return navigator.connection&&(q=navigator.connection.downlink,typeof q==="number")?q:5}function iW(q){return q.nodeType===9?q:q.ownerDocument}function TR(q){switch(q){case G_:return m_;case HH:return eH;default:return W9}}function LR(q,J){if(q===W9)switch(J){case"svg":return m_;case"math":return eH;default:return W9}return q===m_&&J==="foreignObject"?W9:q}function RG(q,J){return q==="textarea"||q==="noscript"||typeof J.children==="string"||typeof J.children==="number"||typeof J.children==="bigint"||typeof J.dangerouslySetInnerHTML==="object"&&J.dangerouslySetInnerHTML!==null&&J.dangerouslySetInnerHTML.__html!=null}function y3(){var q=window.event;if(q&&q.type==="popstate"){if(q===q5)return!1;return q5=q,!0}return q5=null,!1}function Q$(){var q=window.event;return q&&q!==JQ?q.type:null}function W$(){var q=window.event;return q&&q!==JQ?q.timeStamp:-1.1}function v3(q){setTimeout(function(){throw q})}function b3(q,J,Z){switch(J){case"button":case"input":case"select":case"textarea":Z.autoFocus&&q.focus();break;case"img":Z.src?q.src=Z.src:Z.srcSet&&(q.srcset=Z.srcSet)}}function j3(){}function x3(q,J,Z,Q){V3(q,J,Z,Q),q[O6]=Q}function ER(q){v8(q,"")}function g3(q,J,Z){q.nodeValue=Z}function CR(q){if(!q.__reactWarnedAboutChildrenConflict){var J=q[O6]||null;if(J!==null){var Z=M0(q);Z!==null&&(typeof J.children==="string"||typeof J.children==="number"?(q.__reactWarnedAboutChildrenConflict=!0,v0(Z,function(){console.error('Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.')})):J.dangerouslySetInnerHTML!=null&&(q.__reactWarnedAboutChildrenConflict=!0,v0(Z,function(){console.error('Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.')})))}}}function x9(q){return q==="head"}function u3(q,J){q.removeChild(J)}function p3(q,J){(q.nodeType===9?q.body:q.nodeName==="HTML"?q.ownerDocument.body:q).removeChild(J)}function PR(q,J){var Z=J,Q=0;do{var w=Z.nextSibling;if(q.removeChild(Z),w&&w.nodeType===8)if(Z=w.data,Z===qQ||Z===tH){if(Q===0){q.removeChild(w),Q_(J);return}Q--}else if(Z===FQ||Z===Hq||Z===GJ||Z===p_||Z===XJ)Q++;else if(Z===nT)H$(q.ownerDocument.documentElement);else if(Z===sT){Z=q.ownerDocument.head,H$(Z);for(var X=Z.firstChild;X;){var{nextSibling:B,nodeName:R}=X;X[B$]||R==="SCRIPT"||R==="STYLE"||R==="LINK"&&X.rel.toLowerCase()==="stylesheet"||Z.removeChild(X),X=B}}else Z===cT&&H$(q.ownerDocument.body);Z=w}while(Z);Q_(J)}function VR(q,J){var Z=q;q=0;do{var Q=Z.nextSibling;if(Z.nodeType===1?J?(Z._stashedDisplay=Z.style.display,Z.style.display="none"):(Z.style.display=Z._stashedDisplay||"",Z.getAttribute("style")===""&&Z.removeAttribute("style")):Z.nodeType===3&&(J?(Z._stashedText=Z.nodeValue,Z.nodeValue=""):Z.nodeValue=Z._stashedText||""),Q&&Q.nodeType===8)if(Z=Q.data,Z===qQ)if(q===0)break;else q--;else Z!==FQ&&Z!==Hq&&Z!==GJ&&Z!==p_||q++;Z=Q}while(Z)}function m3(q){VR(q,!0)}function l3(q){q=q.style,typeof q.setProperty==="function"?q.setProperty("display","none","important"):q.display="none"}function d3(q){q.nodeValue=""}function i3(q){VR(q,!1)}function n3(q,J){J=J[oT],J=J!==void 0&&J!==null&&J.hasOwnProperty("display")?J.display:null,q.style.display=J==null||typeof J==="boolean"?"":(""+J).trim()}function c3(q,J){q.nodeValue=J}function NG(q){var J=q.firstChild;J&&J.nodeType===10&&(J=J.nextSibling);for(;J;){var Z=J;switch(J=J.nextSibling,Z.nodeName){case"HTML":case"HEAD":case"BODY":NG(Z),g(Z);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(Z.rel.toLowerCase()==="stylesheet")continue}q.removeChild(Z)}}function s3(q,J,Z,Q){for(;q.nodeType===1;){var w=Z;if(q.nodeName.toLowerCase()!==J.toLowerCase()){if(!Q&&(q.nodeName!=="INPUT"||q.type!=="hidden"))break}else if(!Q)if(J==="input"&&q.type==="hidden"){XF(w.name,"name");var X=w.name==null?null:""+w.name;if(w.type==="hidden"&&q.getAttribute("name")===X)return q}else return q;else if(!q[B$])switch(J){case"meta":if(!q.hasAttribute("itemprop"))break;return q;case"link":if(X=q.getAttribute("rel"),X==="stylesheet"&&q.hasAttribute("data-precedence"))break;else if(X!==w.rel||q.getAttribute("href")!==(w.href==null||w.href===""?null:w.href)||q.getAttribute("crossorigin")!==(w.crossOrigin==null?null:w.crossOrigin)||q.getAttribute("title")!==(w.title==null?null:w.title))break;return q;case"style":if(q.hasAttribute("data-precedence"))break;return q;case"script":if(X=q.getAttribute("src"),(X!==(w.src==null?null:w.src)||q.getAttribute("type")!==(w.type==null?null:w.type)||q.getAttribute("crossorigin")!==(w.crossOrigin==null?null:w.crossOrigin))&&X&&q.hasAttribute("async")&&!q.hasAttribute("itemprop"))break;return q;default:return q}if(q=t6(q.nextSibling),q===null)break}return null}function o3(q,J,Z){if(J==="")return null;for(;q.nodeType!==3;){if((q.nodeType!==1||q.nodeName!=="INPUT"||q.type!=="hidden")&&!Z)return null;if(q=t6(q.nextSibling),q===null)return null}return q}function kR(q,J){for(;q.nodeType!==8;){if((q.nodeType!==1||q.nodeName!=="INPUT"||q.type!=="hidden")&&!J)return null;if(q=t6(q.nextSibling),q===null)return null}return q}function DG(q){return q.data===Hq||q.data===GJ}function MG(q){return q.data===p_||q.data===Hq&&q.ownerDocument.readyState!==DM}function a3(q,J){var Z=q.ownerDocument;if(q.data===GJ)q._reactRetry=J;else if(q.data!==Hq||Z.readyState!==DM)J();else{var Q=function(){J(),Z.removeEventListener("DOMContentLoaded",Q)};Z.addEventListener("DOMContentLoaded",Q),q._reactRetry=Q}}function t6(q){for(;q!=null;q=q.nextSibling){var J=q.nodeType;if(J===1||J===3)break;if(J===8){if(J=q.data,J===FQ||J===p_||J===Hq||J===GJ||J===XJ||J===tK||J===NM)break;if(J===qQ||J===tH)return null}}return q}function SR(q){if(q.nodeType===1){for(var J=q.nodeName.toLowerCase(),Z={},Q=q.attributes,w=0;w<Q.length;w++){var X=Q[w];Z[NR(X.name)]=X.name.toLowerCase()==="style"?zG(q):X.value}return{type:J,props:Z}}return q.nodeType===8?q.data===XJ?{type:"Activity",props:{}}:{type:"Suspense",props:{}}:q.nodeValue}function yR(q,J,Z){return Z===null||Z[iT]!==!0?(q.nodeValue===J?q=null:(J=j9(J),q=j9(q.nodeValue)===J?null:q.nodeValue),q):null}function OG(q){q=q.nextSibling;for(var J=0;q;){if(q.nodeType===8){var Z=q.data;if(Z===qQ||Z===tH){if(J===0)return t6(q.nextSibling);J--}else Z!==FQ&&Z!==p_&&Z!==Hq&&Z!==GJ&&Z!==XJ||J++}q=q.nextSibling}return null}function vR(q){q=q.previousSibling;for(var J=0;q;){if(q.nodeType===8){var Z=q.data;if(Z===FQ||Z===p_||Z===Hq||Z===GJ||Z===XJ){if(J===0)return q;J--}else Z!==qQ&&Z!==tH||J++}q=q.previousSibling}return null}function r3(q){Q_(q)}function t3(q){Q_(q)}function e3(q){Q_(q)}function bR(q,J,Z,Q,w){switch(w&&J7(q,Q.ancestorInfo),J=iW(Z),q){case"html":if(q=J.documentElement,!q)throw Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");return q;case"head":if(q=J.head,!q)throw Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");return q;case"body":if(q=J.body,!q)throw Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");return q;default:throw Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.")}}function F4(q,J,Z,Q){if(!Z[m9]&&M0(Z)){var w=Z.tagName.toLowerCase();console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",w,w,w)}switch(q){case"html":case"head":case"body":break;default:console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.")}for(w=Z.attributes;w.length;)Z.removeAttributeNode(w[0]);W6(Z,q,J),Z[H6]=Q,Z[O6]=J}function H$(q){for(var J=q.attributes;J.length;)q.removeAttributeNode(J[0]);g(q)}function nW(q){return typeof q.getRootNode==="function"?q.getRootNode():q.nodeType===9?q:q.ownerDocument}function jR(q,J,Z){var Q=l_;if(Q&&typeof J==="string"&&J){var w=R6(J);w='link[rel="'+q+'"][href="'+w+'"]',typeof Z==="string"&&(w+='[crossorigin="'+Z+'"]'),LM.has(w)||(LM.add(w),q={rel:q,crossOrigin:Z,href:J},Q.querySelector(w)===null&&(J=Q.createElement("link"),W6(J,"link",q),Z0(J),Q.head.appendChild(J)))}}function xR(q,J,Z,Q){var w=(w=u9.current)?nW(w):null;if(!w)throw Error('"resourceRoot" was expected to exist. This is a bug in React.');switch(q){case"meta":case"title":return null;case"style":return typeof Z.precedence==="string"&&typeof Z.href==="string"?(Z=Z_(Z.href),J=I0(w).hoistableStyles,Q=J.get(Z),Q||(Q={type:"style",instance:null,count:0,state:null},J.set(Z,Q)),Q):{type:"void",instance:null,count:0,state:null};case"link":if(Z.rel==="stylesheet"&&typeof Z.href==="string"&&typeof Z.precedence==="string"){q=Z_(Z.href);var X=I0(w).hoistableStyles,B=X.get(q);if(!B&&(w=w.ownerDocument||w,B={type:"stylesheet",instance:null,count:0,state:{loading:UJ,preload:null}},X.set(q,B),(X=w.querySelector(w$(q)))&&!X._p&&(B.instance=X,B.state.loading=_Q|I8),!T8.has(q))){var R={rel:"preload",as:"style",href:Z.href,crossOrigin:Z.crossOrigin,integrity:Z.integrity,media:Z.media,hrefLang:Z.hrefLang,referrerPolicy:Z.referrerPolicy};T8.set(q,R),X||q4(w,q,R,B.state)}if(J&&Q===null)throw Z=`

  - `+cW(J)+`
  + `+cW(Z),Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key."+Z);return B}if(J&&Q!==null)throw Z=`

  - `+cW(J)+`
  + `+cW(Z),Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key."+Z);return null;case"script":return J=Z.async,Z=Z.src,typeof Z==="string"&&J&&typeof J!=="function"&&typeof J!=="symbol"?(Z=$_(Z),J=I0(w).hoistableScripts,Q=J.get(Z),Q||(Q={type:"script",instance:null,count:0,state:null},J.set(Z,Q)),Q):{type:"void",instance:null,count:0,state:null};default:throw Error('getResource encountered a type it did not expect: "'+q+'". this is a bug in React.')}}function cW(q){var J=0,Z="<link";return typeof q.rel==="string"?(J++,Z+=' rel="'+q.rel+'"'):g8.call(q,"rel")&&(J++,Z+=' rel="'+(q.rel===null?"null":"invalid type "+typeof q.rel)+'"'),typeof q.href==="string"?(J++,Z+=' href="'+q.href+'"'):g8.call(q,"href")&&(J++,Z+=' href="'+(q.href===null?"null":"invalid type "+typeof q.href)+'"'),typeof q.precedence==="string"?(J++,Z+=' precedence="'+q.precedence+'"'):g8.call(q,"precedence")&&(J++,Z+=" precedence={"+(q.precedence===null?"null":"invalid type "+typeof q.precedence)+"}"),Object.getOwnPropertyNames(q).length>J&&(Z+=" ..."),Z+" />"}function Z_(q){return'href="'+R6(q)+'"'}function w$(q){return'link[rel="stylesheet"]['+q+"]"}function gR(q){return yF({},q,{"data-precedence":q.precedence,precedence:null})}function q4(q,J,Z,Q){q.querySelector('link[rel="preload"][as="style"]['+J+"]")?Q.loading=_Q:(J=q.createElement("link"),Q.preload=J,J.addEventListener("load",function(){return Q.loading|=_Q}),J.addEventListener("error",function(){return Q.loading|=IM}),W6(J,"link",Z),Z0(J),q.head.appendChild(J))}function $_(q){return'[src="'+R6(q)+'"]'}function Y$(q){return"script[async]"+q}function uR(q,J,Z){if(J.count++,J.instance===null)switch(J.type){case"style":var Q=q.querySelector('style[data-href~="'+R6(Z.href)+'"]');if(Q)return J.instance=Q,Z0(Q),Q;var w=yF({},Z,{"data-href":Z.href,"data-precedence":Z.precedence,href:null,precedence:null});return Q=(q.ownerDocument||q).createElement("style"),Z0(Q),W6(Q,"style",w),sW(Q,Z.precedence,q),J.instance=Q;case"stylesheet":w=Z_(Z.href);var X=q.querySelector(w$(w));if(X)return J.state.loading|=I8,J.instance=X,Z0(X),X;Q=gR(Z),(w=T8.get(w))&&fG(Q,w),X=(q.ownerDocument||q).createElement("link"),Z0(X);var B=X;return B._p=new Promise(function(R,I){B.onload=R,B.onerror=I}),W6(X,"link",Q),J.state.loading|=I8,sW(X,Z.precedence,q),J.instance=X;case"script":if(X=$_(Z.src),w=q.querySelector(Y$(X)))return J.instance=w,Z0(w),w;if(Q=Z,w=T8.get(X))Q=yF({},Z),IG(Q,w);return q=q.ownerDocument||q,w=q.createElement("script"),Z0(w),W6(w,"link",Q),q.head.appendChild(w),J.instance=w;case"void":return null;default:throw Error('acquireResource encountered a resource type it did not expect: "'+J.type+'". this is a bug in React.')}else J.type==="stylesheet"&&(J.state.loading&I8)===UJ&&(Q=J.instance,J.state.loading|=I8,sW(Q,Z.precedence,q));return J.instance}function sW(q,J,Z){for(var Q=Z.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),w=Q.length?Q[Q.length-1]:null,X=w,B=0;B<Q.length;B++){var R=Q[B];if(R.dataset.precedence===J)X=R;else if(X!==w)break}X?X.parentNode.insertBefore(q,X.nextSibling):(J=Z.nodeType===9?Z.head:Z,J.insertBefore(q,J.firstChild))}function fG(q,J){q.crossOrigin==null&&(q.crossOrigin=J.crossOrigin),q.referrerPolicy==null&&(q.referrerPolicy=J.referrerPolicy),q.title==null&&(q.title=J.title)}function IG(q,J){q.crossOrigin==null&&(q.crossOrigin=J.crossOrigin),q.referrerPolicy==null&&(q.referrerPolicy=J.referrerPolicy),q.integrity==null&&(q.integrity=J.integrity)}function pR(q,J,Z){if(Fw===null){var Q=new Map,w=Fw=new Map;w.set(Z,Q)}else w=Fw,Q=w.get(Z),Q||(Q=new Map,w.set(Z,Q));if(Q.has(q))return Q;Q.set(q,null),Z=Z.getElementsByTagName(q);for(w=0;w<Z.length;w++){var X=Z[w];if(!(X[B$]||X[H6]||q==="link"&&X.getAttribute("rel")==="stylesheet")&&X.namespaceURI!==G_){var B=X.getAttribute(J)||"";B=q+B;var R=Q.get(B);R?R.push(X):Q.set(B,[X])}}return Q}function mR(q,J,Z){q=q.ownerDocument||q,q.head.insertBefore(Z,J==="title"?q.querySelector("head > title"):null)}function J4(q,J,Z){var Q=!Z.ancestorInfo.containerTagInScope;if(Z.context===m_||J.itemProp!=null)return!Q||J.itemProp==null||q!=="meta"&&q!=="title"&&q!=="style"&&q!=="link"&&q!=="script"||console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",q,q),!1;switch(q){case"meta":case"title":return!0;case"style":if(typeof J.precedence!=="string"||typeof J.href!=="string"||J.href===""){Q&&console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.');break}return!0;case"link":if(typeof J.rel!=="string"||typeof J.href!=="string"||J.href===""||J.onLoad||J.onError){if(J.rel==="stylesheet"&&typeof J.precedence==="string"){q=J.href;var{onError:w,disabled:X}=J;Z=[],J.onLoad&&Z.push("`onLoad`"),w&&Z.push("`onError`"),X!=null&&Z.push("`disabled`"),w=k3(Z,"and"),w+=Z.length===1?" prop":" props",X=Z.length===1?"an "+w:"the "+w,Z.length&&console.error('React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',q,X,w)}Q&&(typeof J.rel!=="string"||typeof J.href!=="string"||J.href===""?console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"):(J.onError||J.onLoad)&&console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));break}switch(J.rel){case"stylesheet":return q=J.precedence,J=J.disabled,typeof q!=="string"&&Q&&console.error('Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'),typeof q==="string"&&J==null;default:return!0}case"script":if(q=J.async&&typeof J.async!=="function"&&typeof J.async!=="symbol",!q||J.onLoad||J.onError||!J.src||typeof J.src!=="string"){Q&&(q?J.onLoad||J.onError?console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."):console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."):console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'));break}return!0;case"noscript":case"template":Q&&console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",q)}return!1}function lR(q){return q.type==="stylesheet"&&(q.state.loading&TM)===UJ?!1:!0}function _4(q,J,Z,Q){if(Z.type==="stylesheet"&&(typeof Q.media!=="string"||matchMedia(Q.media).matches!==!1)&&(Z.state.loading&I8)===UJ){if(Z.instance===null){var w=Z_(Q.href),X=J.querySelector(w$(w));if(X){J=X._p,J!==null&&typeof J==="object"&&typeof J.then==="function"&&(q.count++,q=oW.bind(q),J.then(q,q)),Z.state.loading|=I8,Z.instance=X,Z0(X);return}X=J.ownerDocument||J,Q=gR(Q),(w=T8.get(w))&&fG(Q,w),X=X.createElement("link"),Z0(X);var B=X;B._p=new Promise(function(R,I){B.onload=R,B.onerror=I}),W6(X,"link",Q),Z.instance=X}q.stylesheets===null&&(q.stylesheets=new Map),q.stylesheets.set(Z,J),(J=Z.state.preload)&&(Z.state.loading&TM)===UJ&&(q.count++,Z=oW.bind(q),J.addEventListener("load",Z),J.addEventListener("error",Z))}}function Z4(q,J){return q.stylesheets&&q.count===0&&aW(q,q.stylesheets),0<q.count||0<q.imgCount?function(Z){var Q=setTimeout(function(){if(q.stylesheets&&aW(q,q.stylesheets),q.unsuspend){var X=q.unsuspend;q.unsuspend=null,X()}},tT+J);0<q.imgBytes&&_5===0&&(_5=125*S3()*FL);var w=setTimeout(function(){if(q.waitingForImages=!1,q.count===0&&(q.stylesheets&&aW(q,q.stylesheets),q.unsuspend)){var X=q.unsuspend;q.unsuspend=null,X()}},(q.imgBytes>_5?50:eT)+J);return q.unsuspend=Z,function(){q.unsuspend=null,clearTimeout(Q),clearTimeout(w)}}:null}function oW(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)aW(this,this.stylesheets);else if(this.unsuspend){var q=this.unsuspend;this.unsuspend=null,q()}}}function aW(q,J){q.stylesheets=null,q.unsuspend!==null&&(q.count++,qw=new Map,J.forEach($4,q),qw=null,oW.call(q))}function $4(q,J){if(!(J.state.loading&I8)){var Z=qw.get(q);if(Z)var Q=Z.get(Z5);else{Z=new Map,qw.set(q,Z);for(var w=q.querySelectorAll("link[data-precedence],style[data-precedence]"),X=0;X<w.length;X++){var B=w[X];if(B.nodeName==="LINK"||B.getAttribute("media")!=="not all")Z.set(B.dataset.precedence,B),Q=B}Q&&Z.set(Z5,Q)}w=J.instance,B=w.getAttribute("data-precedence"),X=Z.get(B)||Q,X===Q&&Z.set(Z5,w),Z.set(B,w),this.count++,Q=oW.bind(this),w.addEventListener("load",Q),w.addEventListener("error",Q),X?X.parentNode.insertBefore(w,X.nextSibling):(q=q.nodeType===9?q.head:q,q.insertBefore(w,q.firstChild)),J.state.loading|=I8}}function Q4(q,J,Z,Q,w,X,B,R,I){this.tag=1,this.containerInfo=q,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=KJ,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=H0(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=H0(0),this.hiddenUpdates=H0(null),this.identifierPrefix=Q,this.onUncaughtError=w,this.onCaughtError=X,this.onRecoverableError=B,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=I,this.incompleteTransitions=new Map,this.passiveEffectDuration=this.effectDuration=-0,this.memoizedUpdaters=new Set,q=this.pendingUpdatersLaneMap=[];for(J=0;31>J;J++)q.push(new Set);this._debugRootType=Z?"hydrateRoot()":"createRoot()"}function dR(q,J,Z,Q,w,X,B,R,I,C,e,F0){return q=new Q4(q,J,Z,B,I,C,e,F0,R),J=IT,X===!0&&(J|=K6|p8),J|=IF,X=N(3,null,null,J),q.current=X,X.stateNode=q,J=eY(),uq(J),q.pooledCache=J,uq(J),X.memoizedState={element:Q,isDehydrated:Z,cache:J},ZX(X),q}function iR(q){if(!q)return n9;return q=n9,q}function TG(q,J,Z,Q,w,X){if(G6&&typeof G6.onScheduleFiberRoot==="function")try{G6.onScheduleFiberRoot(Y_,Q,Z)}catch(B){M7||(M7=!0,console.error("React instrumentation encountered an error: %o",B))}w=iR(w),Q.context===null?Q.context=w:Q.pendingContext=w,D7&&F8!==null&&!VM&&(VM=!0,console.error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,V(F8)||"Unknown")),Q=V9(J),Q.payload={element:Z},X=X===void 0?null:X,X!==null&&(typeof X!=="function"&&console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.",X),Q.callback=X),Z=k9(q,Q,J),Z!==null&&(Q7(J,"root.render()",null),f1(Z,q,J),dZ(Z,q,J))}function nR(q,J){if(q=q.memoizedState,q!==null&&q.dehydrated!==null){var Z=q.retryLane;q.retryLane=Z!==0&&Z<J?Z:J}}function LG(q,J){nR(q,J),(q=q.alternate)&&nR(q,J)}function cR(q){if(q.tag===13||q.tag===31){var J=X6(q,67108864);J!==null&&f1(J,q,67108864),LG(q,67108864)}}function sR(q){if(q.tag===13||q.tag===31){var J=r6(q);J=V0(J);var Z=X6(q,J);Z!==null&&f1(Z,q,J),LG(q,J)}}function W4(){return F8}function H4(q,J,Z,Q){var w=R0.T;R0.T=null;var X=F1.p;try{F1.p=q8,EG(q,J,Z,Q)}finally{F1.p=X,R0.T=w}}function w4(q,J,Z,Q){var w=R0.T;R0.T=null;var X=F1.p;try{F1.p=u8,EG(q,J,Z,Q)}finally{F1.p=X,R0.T=w}}function EG(q,J,Z,Q){if(_w){var w=CG(Q);if(w===null)KG(q,J,Q,Zw,Z),aR(q,Q);else if(Y4(w,q,J,Z,Q))Q.stopPropagation();else if(aR(q,Q),J&4&&-1<JL.indexOf(q)){for(;w!==null;){var X=M0(w);if(X!==null)switch(X.tag){case 3:if(X=X.stateNode,X.current.memoizedState.isDehydrated){var B=fF(X.pendingLanes);if(B!==0){var R=X;R.pendingLanes|=2;for(R.entangledLanes|=2;B;){var I=1<<31-M6(B);R.entanglements[1]|=I,B&=~I}A7(X),(cF&(l1|$8))===t1&&(uH=o1()+$M,Z$(0,!1))}}break;case 31:case 13:R=X6(X,2),R!==null&&f1(R,X,2),q_(),LG(X,2)}if(X=CG(Q),X===null&&KG(q,J,Q,Zw,Z),X===w)break;w=X}w!==null&&Q.stopPropagation()}else KG(q,J,Q,null,Z)}}function CG(q){return q=vY(q),PG(q)}function PG(q){if(Zw=null,q=h0(q),q!==null){var J=O(q);if(J===null)q=null;else{var Z=J.tag;if(Z===13){if(q=b(J),q!==null)return q;q=null}else if(Z===31){if(q=k(J),q!==null)return q;q=null}else if(Z===3){if(J.stateNode.current.memoizedState.isDehydrated)return J.tag===3?J.stateNode.containerInfo:null;q=null}else J!==q&&(q=null)}}return Zw=q,null}function oR(q){switch(q){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return q8;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return u8;case"message":switch(R4()){case lG:return q8;case dG:return u8;case w_:case N4:return f7;case iG:return QH;default:return f7}default:return f7}}function aR(q,J){switch(q){case"focusin":case"focusout":wq=null;break;case"dragenter":case"dragleave":Yq=null;break;case"mouseover":case"mouseout":Xq=null;break;case"pointerover":case"pointerout":$Q.delete(J.pointerId);break;case"gotpointercapture":case"lostpointercapture":QQ.delete(J.pointerId)}}function X$(q,J,Z,Q,w,X){if(q===null||q.nativeEvent!==X)return q={blockedOn:J,domEventName:Z,eventSystemFlags:Q,nativeEvent:X,targetContainers:[w]},J!==null&&(J=M0(J),J!==null&&cR(J)),q;return q.eventSystemFlags|=Q,J=q.targetContainers,w!==null&&J.indexOf(w)===-1&&J.push(w),q}function Y4(q,J,Z,Q,w){switch(J){case"focusin":return wq=X$(wq,q,J,Z,Q,w),!0;case"dragenter":return Yq=X$(Yq,q,J,Z,Q,w),!0;case"mouseover":return Xq=X$(Xq,q,J,Z,Q,w),!0;case"pointerover":var X=w.pointerId;return $Q.set(X,X$($Q.get(X)||null,q,J,Z,Q,w)),!0;case"gotpointercapture":return X=w.pointerId,QQ.set(X,X$(QQ.get(X)||null,q,J,Z,Q,w)),!0}return!1}function rR(q){var J=h0(q.target);if(J!==null){var Z=O(J);if(Z!==null){if(J=Z.tag,J===13){if(J=b(Z),J!==null){q.blockedOn=J,N0(q.priority,function(){sR(Z)});return}}else if(J===31){if(J=k(Z),J!==null){q.blockedOn=J,N0(q.priority,function(){sR(Z)});return}}else if(J===3&&Z.stateNode.current.memoizedState.isDehydrated){q.blockedOn=Z.tag===3?Z.stateNode.containerInfo:null;return}}}q.blockedOn=null}function rW(q){if(q.blockedOn!==null)return!1;for(var J=q.targetContainers;0<J.length;){var Z=CG(q.nativeEvent);if(Z===null){Z=q.nativeEvent;var Q=new Z.constructor(Z.type,Z),w=Q;z$!==null&&console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."),z$=w,Z.target.dispatchEvent(Q),z$===null&&console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."),z$=null}else return J=M0(Z),J!==null&&cR(J),q.blockedOn=Z,!1;J.shift()}return!0}function tR(q,J,Z){rW(q)&&Z.delete(J)}function X4(){$5=!1,wq!==null&&rW(wq)&&(wq=null),Yq!==null&&rW(Yq)&&(Yq=null),Xq!==null&&rW(Xq)&&(Xq=null),$Q.forEach(tR),QQ.forEach(tR)}function tW(q,J){q.blockedOn===J&&(q.blockedOn=null,$5||($5=!0,oF.unstable_scheduleCallback(oF.unstable_NormalPriority,X4)))}function eR(q){$w!==q&&($w=q,oF.unstable_scheduleCallback(oF.unstable_NormalPriority,function(){$w===q&&($w=null);for(var J=0;J<q.length;J+=3){var Z=q[J],Q=q[J+1],w=q[J+2];if(typeof Q!=="function")if(PG(Q||Z)===null)continue;else break;var X=M0(Z);X!==null&&(q.splice(J,3),J-=3,Z={pending:!0,data:w,method:Z.method,action:Q},Object.freeze(Z),PX(X,Z,Q,w))}}))}function Q_(q){function J(I){return tW(I,q)}wq!==null&&tW(wq,q),Yq!==null&&tW(Yq,q),Xq!==null&&tW(Xq,q),$Q.forEach(J),QQ.forEach(J);for(var Z=0;Z<Gq.length;Z++){var Q=Gq[Z];Q.blockedOn===q&&(Q.blockedOn=null)}for(;0<Gq.length&&(Z=Gq[0],Z.blockedOn===null);)rR(Z),Z.blockedOn===null&&Gq.shift();if(Z=(q.ownerDocument||q).$$reactFormReplay,Z!=null)for(Q=0;Q<Z.length;Q+=3){var w=Z[Q],X=Z[Q+1],B=w[O6]||null;if(typeof X==="function")B||eR(Z);else if(B){var R=null;if(X&&X.hasAttribute("formAction")){if(w=X,B=X[O6]||null)R=B.formAction;else if(PG(w)!==null)continue}else R=B.action;typeof R==="function"?Z[Q+1]=R:(Z.splice(Q,3),Q-=3),eR(Z)}}}function FN(){function q(X){X.canIntercept&&X.info==="react-transition"&&X.intercept({handler:function(){return new Promise(function(B){return w=B})},focusReset:"manual",scroll:"manual"})}function J(){w!==null&&(w(),w=null),Q||setTimeout(Z,20)}function Z(){if(!Q&&!navigation.transition){var X=navigation.currentEntry;X&&X.url!=null&&navigation.navigate(X.url,{state:X.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation==="object"){var Q=!1,w=null;return navigation.addEventListener("navigate",q),navigation.addEventListener("navigatesuccess",J),navigation.addEventListener("navigateerror",J),setTimeout(Z,100),function(){Q=!0,navigation.removeEventListener("navigate",q),navigation.removeEventListener("navigatesuccess",J),navigation.removeEventListener("navigateerror",J),w!==null&&(w(),w=null)}}}function VG(q){this._internalRoot=q}function eW(q){this._internalRoot=q}function qN(q){q[m9]&&(q._reactRootContainer?console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."):console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."))}typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());var yF=Object.assign,G4=Symbol.for("react.element"),R7=Symbol.for("react.transitional.element"),W_=Symbol.for("react.portal"),H_=Symbol.for("react.fragment"),FH=Symbol.for("react.strict_mode"),kG=Symbol.for("react.profiler"),SG=Symbol.for("react.consumer"),N7=Symbol.for("react.context"),G$=Symbol.for("react.forward_ref"),yG=Symbol.for("react.suspense"),vG=Symbol.for("react.suspense_list"),qH=Symbol.for("react.memo"),e6=Symbol.for("react.lazy"),bG=Symbol.for("react.activity"),K4=Symbol.for("react.memo_cache_sentinel"),JN=Symbol.iterator,U4=Symbol.for("react.client.reference"),p1=Array.isArray,R0=i_.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,F1=H5.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,B4=Object.freeze({pending:!1,data:null,method:null,action:null}),jG=[],xG=[],c7=-1,g9=d(null),K$=d(null),u9=d(null),JH=d(null),U$=0,_N,ZN,$N,QN,WN,HN,wN;t.__reactDisabledLog=!0;var gG,YN,uG=!1,pG=new(typeof WeakMap==="function"?WeakMap:Map),F8=null,D7=!1,g8=Object.prototype.hasOwnProperty,mG=oF.unstable_scheduleCallback,z4=oF.unstable_cancelCallback,A4=oF.unstable_shouldYield,h4=oF.unstable_requestPaint,o1=oF.unstable_now,R4=oF.unstable_getCurrentPriorityLevel,lG=oF.unstable_ImmediatePriority,dG=oF.unstable_UserBlockingPriority,w_=oF.unstable_NormalPriority,N4=oF.unstable_LowPriority,iG=oF.unstable_IdlePriority,D4=oF.log,M4=oF.unstable_setDisableYieldValue,Y_=null,G6=null,M7=!1,O7=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u",M6=Math.clz32?Math.clz32:j0,O4=Math.log,f4=Math.LN2,_H=256,ZH=262144,$H=4194304,q8=2,u8=8,f7=32,QH=268435456,p9=Math.random().toString(36).slice(2),H6="__reactFiber$"+p9,O6="__reactProps$"+p9,m9="__reactContainer$"+p9,nG="__reactEvents$"+p9,I4="__reactListeners$"+p9,T4="__reactHandles$"+p9,XN="__reactResources$"+p9,B$="__reactMarker$"+p9,GN=new Set,cq={},cG={},L4={button:!0,checkbox:!0,image:!0,hidden:!0,radio:!0,reset:!0,submit:!0},E4=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),KN={},UN={},C4=/[\n"\\]/g,BN=!1,zN=!1,AN=!1,hN=!1,RN=!1,NN=!1,DN=["value","defaultValue"],MN=!1,ON=/["'&<>\n\t]|^\s|\s$/,P4="address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "),fN="applet caption html table td th marquee object template foreignObject desc title".split(" "),V4=fN.concat(["button"]),k4="dd dt li option optgroup p rp rt".split(" "),IN={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null,containerTagInScope:null,implicitRootScope:!1},WH={},sG={animation:"animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),background:"backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),backgroundPosition:["backgroundPositionX","backgroundPositionY"],border:"borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),borderBlockEnd:["borderBlockEndColor","borderBlockEndStyle","borderBlockEndWidth"],borderBlockStart:["borderBlockStartColor","borderBlockStartStyle","borderBlockStartWidth"],borderBottom:["borderBottomColor","borderBottomStyle","borderBottomWidth"],borderColor:["borderBottomColor","borderLeftColor","borderRightColor","borderTopColor"],borderImage:["borderImageOutset","borderImageRepeat","borderImageSlice","borderImageSource","borderImageWidth"],borderInlineEnd:["borderInlineEndColor","borderInlineEndStyle","borderInlineEndWidth"],borderInlineStart:["borderInlineStartColor","borderInlineStartStyle","borderInlineStartWidth"],borderLeft:["borderLeftColor","borderLeftStyle","borderLeftWidth"],borderRadius:["borderBottomLeftRadius","borderBottomRightRadius","borderTopLeftRadius","borderTopRightRadius"],borderRight:["borderRightColor","borderRightStyle","borderRightWidth"],borderStyle:["borderBottomStyle","borderLeftStyle","borderRightStyle","borderTopStyle"],borderTop:["borderTopColor","borderTopStyle","borderTopWidth"],borderWidth:["borderBottomWidth","borderLeftWidth","borderRightWidth","borderTopWidth"],columnRule:["columnRuleColor","columnRuleStyle","columnRuleWidth"],columns:["columnCount","columnWidth"],flex:["flexBasis","flexGrow","flexShrink"],flexFlow:["flexDirection","flexWrap"],font:"fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),fontVariant:"fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),gap:["columnGap","rowGap"],grid:"gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),gridArea:["gridColumnEnd","gridColumnStart","gridRowEnd","gridRowStart"],gridColumn:["gridColumnEnd","gridColumnStart"],gridColumnGap:["columnGap"],gridGap:["columnGap","rowGap"],gridRow:["gridRowEnd","gridRowStart"],gridRowGap:["rowGap"],gridTemplate:["gridTemplateAreas","gridTemplateColumns","gridTemplateRows"],listStyle:["listStyleImage","listStylePosition","listStyleType"],margin:["marginBottom","marginLeft","marginRight","marginTop"],marker:["markerEnd","markerMid","markerStart"],mask:"maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),maskPosition:["maskPositionX","maskPositionY"],outline:["outlineColor","outlineStyle","outlineWidth"],overflow:["overflowX","overflowY"],padding:["paddingBottom","paddingLeft","paddingRight","paddingTop"],placeContent:["alignContent","justifyContent"],placeItems:["alignItems","justifyItems"],placeSelf:["alignSelf","justifySelf"],textDecoration:["textDecorationColor","textDecorationLine","textDecorationStyle"],textEmphasis:["textEmphasisColor","textEmphasisStyle"],transition:["transitionDelay","transitionDuration","transitionProperty","transitionTimingFunction"],wordWrap:["overflowWrap"]},TN=/([A-Z])/g,LN=/^ms-/,S4=/^(?:webkit|moz|o)[A-Z]/,y4=/^-ms-/,v4=/-(.)/g,EN=/;\s*$/,X_={},oG={},CN=!1,PN=!1,VN=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")),HH="http://www.w3.org/1998/Math/MathML",G_="http://www.w3.org/2000/svg",b4=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),wH={accept:"accept",acceptcharset:"acceptCharset","accept-charset":"acceptCharset",accesskey:"accessKey",action:"action",allowfullscreen:"allowFullScreen",alt:"alt",as:"as",async:"async",autocapitalize:"autoCapitalize",autocomplete:"autoComplete",autocorrect:"autoCorrect",autofocus:"autoFocus",autoplay:"autoPlay",autosave:"autoSave",capture:"capture",cellpadding:"cellPadding",cellspacing:"cellSpacing",challenge:"challenge",charset:"charSet",checked:"checked",children:"children",cite:"cite",class:"className",classid:"classID",classname:"className",cols:"cols",colspan:"colSpan",content:"content",contenteditable:"contentEditable",contextmenu:"contextMenu",controls:"controls",controlslist:"controlsList",coords:"coords",crossorigin:"crossOrigin",dangerouslysetinnerhtml:"dangerouslySetInnerHTML",data:"data",datetime:"dateTime",default:"default",defaultchecked:"defaultChecked",defaultvalue:"defaultValue",defer:"defer",dir:"dir",disabled:"disabled",disablepictureinpicture:"disablePictureInPicture",disableremoteplayback:"disableRemotePlayback",download:"download",draggable:"draggable",enctype:"encType",enterkeyhint:"enterKeyHint",fetchpriority:"fetchPriority",for:"htmlFor",form:"form",formmethod:"formMethod",formaction:"formAction",formenctype:"formEncType",formnovalidate:"formNoValidate",formtarget:"formTarget",frameborder:"frameBorder",headers:"headers",height:"height",hidden:"hidden",high:"high",href:"href",hreflang:"hrefLang",htmlfor:"htmlFor",httpequiv:"httpEquiv","http-equiv":"httpEquiv",icon:"icon",id:"id",imagesizes:"imageSizes",imagesrcset:"imageSrcSet",inert:"inert",innerhtml:"innerHTML",inputmode:"inputMode",integrity:"integrity",is:"is",itemid:"itemID",itemprop:"itemProp",itemref:"itemRef",itemscope:"itemScope",itemtype:"itemType",keyparams:"keyParams",keytype:"keyType",kind:"kind",label:"label",lang:"lang",list:"list",loop:"loop",low:"low",manifest:"manifest",marginwidth:"marginWidth",marginheight:"marginHeight",max:"max",maxlength:"maxLength",media:"media",mediagroup:"mediaGroup",method:"method",min:"min",minlength:"minLength",multiple:"multiple",muted:"muted",name:"name",nomodule:"noModule",nonce:"nonce",novalidate:"noValidate",open:"open",optimum:"optimum",pattern:"pattern",placeholder:"placeholder",playsinline:"playsInline",poster:"poster",preload:"preload",profile:"profile",radiogroup:"radioGroup",readonly:"readOnly",referrerpolicy:"referrerPolicy",rel:"rel",required:"required",reversed:"reversed",role:"role",rows:"rows",rowspan:"rowSpan",sandbox:"sandbox",scope:"scope",scoped:"scoped",scrolling:"scrolling",seamless:"seamless",selected:"selected",shape:"shape",size:"size",sizes:"sizes",span:"span",spellcheck:"spellCheck",src:"src",srcdoc:"srcDoc",srclang:"srcLang",srcset:"srcSet",start:"start",step:"step",style:"style",summary:"summary",tabindex:"tabIndex",target:"target",title:"title",type:"type",usemap:"useMap",value:"value",width:"width",wmode:"wmode",wrap:"wrap",about:"about",accentheight:"accentHeight","accent-height":"accentHeight",accumulate:"accumulate",additive:"additive",alignmentbaseline:"alignmentBaseline","alignment-baseline":"alignmentBaseline",allowreorder:"allowReorder",alphabetic:"alphabetic",amplitude:"amplitude",arabicform:"arabicForm","arabic-form":"arabicForm",ascent:"ascent",attributename:"attributeName",attributetype:"attributeType",autoreverse:"autoReverse",azimuth:"azimuth",basefrequency:"baseFrequency",baselineshift:"baselineShift","baseline-shift":"baselineShift",baseprofile:"baseProfile",bbox:"bbox",begin:"begin",bias:"bias",by:"by",calcmode:"calcMode",capheight:"capHeight","cap-height":"capHeight",clip:"clip",clippath:"clipPath","clip-path":"clipPath",clippathunits:"clipPathUnits",cliprule:"clipRule","clip-rule":"clipRule",color:"color",colorinterpolation:"colorInterpolation","color-interpolation":"colorInterpolation",colorinterpolationfilters:"colorInterpolationFilters","color-interpolation-filters":"colorInterpolationFilters",colorprofile:"colorProfile","color-profile":"colorProfile",colorrendering:"colorRendering","color-rendering":"colorRendering",contentscripttype:"contentScriptType",contentstyletype:"contentStyleType",cursor:"cursor",cx:"cx",cy:"cy",d:"d",datatype:"datatype",decelerate:"decelerate",descent:"descent",diffuseconstant:"diffuseConstant",direction:"direction",display:"display",divisor:"divisor",dominantbaseline:"dominantBaseline","dominant-baseline":"dominantBaseline",dur:"dur",dx:"dx",dy:"dy",edgemode:"edgeMode",elevation:"elevation",enablebackground:"enableBackground","enable-background":"enableBackground",end:"end",exponent:"exponent",externalresourcesrequired:"externalResourcesRequired",fill:"fill",fillopacity:"fillOpacity","fill-opacity":"fillOpacity",fillrule:"fillRule","fill-rule":"fillRule",filter:"filter",filterres:"filterRes",filterunits:"filterUnits",floodopacity:"floodOpacity","flood-opacity":"floodOpacity",floodcolor:"floodColor","flood-color":"floodColor",focusable:"focusable",fontfamily:"fontFamily","font-family":"fontFamily",fontsize:"fontSize","font-size":"fontSize",fontsizeadjust:"fontSizeAdjust","font-size-adjust":"fontSizeAdjust",fontstretch:"fontStretch","font-stretch":"fontStretch",fontstyle:"fontStyle","font-style":"fontStyle",fontvariant:"fontVariant","font-variant":"fontVariant",fontweight:"fontWeight","font-weight":"fontWeight",format:"format",from:"from",fx:"fx",fy:"fy",g1:"g1",g2:"g2",glyphname:"glyphName","glyph-name":"glyphName",glyphorientationhorizontal:"glyphOrientationHorizontal","glyph-orientation-horizontal":"glyphOrientationHorizontal",glyphorientationvertical:"glyphOrientationVertical","glyph-orientation-vertical":"glyphOrientationVertical",glyphref:"glyphRef",gradienttransform:"gradientTransform",gradientunits:"gradientUnits",hanging:"hanging",horizadvx:"horizAdvX","horiz-adv-x":"horizAdvX",horizoriginx:"horizOriginX","horiz-origin-x":"horizOriginX",ideographic:"ideographic",imagerendering:"imageRendering","image-rendering":"imageRendering",in2:"in2",in:"in",inlist:"inlist",intercept:"intercept",k1:"k1",k2:"k2",k3:"k3",k4:"k4",k:"k",kernelmatrix:"kernelMatrix",kernelunitlength:"kernelUnitLength",kerning:"kerning",keypoints:"keyPoints",keysplines:"keySplines",keytimes:"keyTimes",lengthadjust:"lengthAdjust",letterspacing:"letterSpacing","letter-spacing":"letterSpacing",lightingcolor:"lightingColor","lighting-color":"lightingColor",limitingconeangle:"limitingConeAngle",local:"local",markerend:"markerEnd","marker-end":"markerEnd",markerheight:"markerHeight",markermid:"markerMid","marker-mid":"markerMid",markerstart:"markerStart","marker-start":"markerStart",markerunits:"markerUnits",markerwidth:"markerWidth",mask:"mask",maskcontentunits:"maskContentUnits",maskunits:"maskUnits",mathematical:"mathematical",mode:"mode",numoctaves:"numOctaves",offset:"offset",opacity:"opacity",operator:"operator",order:"order",orient:"orient",orientation:"orientation",origin:"origin",overflow:"overflow",overlineposition:"overlinePosition","overline-position":"overlinePosition",overlinethickness:"overlineThickness","overline-thickness":"overlineThickness",paintorder:"paintOrder","paint-order":"paintOrder",panose1:"panose1","panose-1":"panose1",pathlength:"pathLength",patterncontentunits:"patternContentUnits",patterntransform:"patternTransform",patternunits:"patternUnits",pointerevents:"pointerEvents","pointer-events":"pointerEvents",points:"points",pointsatx:"pointsAtX",pointsaty:"pointsAtY",pointsatz:"pointsAtZ",popover:"popover",popovertarget:"popoverTarget",popovertargetaction:"popoverTargetAction",prefix:"prefix",preservealpha:"preserveAlpha",preserveaspectratio:"preserveAspectRatio",primitiveunits:"primitiveUnits",property:"property",r:"r",radius:"radius",refx:"refX",refy:"refY",renderingintent:"renderingIntent","rendering-intent":"renderingIntent",repeatcount:"repeatCount",repeatdur:"repeatDur",requiredextensions:"requiredExtensions",requiredfeatures:"requiredFeatures",resource:"resource",restart:"restart",result:"result",results:"results",rotate:"rotate",rx:"rx",ry:"ry",scale:"scale",security:"security",seed:"seed",shaperendering:"shapeRendering","shape-rendering":"shapeRendering",slope:"slope",spacing:"spacing",specularconstant:"specularConstant",specularexponent:"specularExponent",speed:"speed",spreadmethod:"spreadMethod",startoffset:"startOffset",stddeviation:"stdDeviation",stemh:"stemh",stemv:"stemv",stitchtiles:"stitchTiles",stopcolor:"stopColor","stop-color":"stopColor",stopopacity:"stopOpacity","stop-opacity":"stopOpacity",strikethroughposition:"strikethroughPosition","strikethrough-position":"strikethroughPosition",strikethroughthickness:"strikethroughThickness","strikethrough-thickness":"strikethroughThickness",string:"string",stroke:"stroke",strokedasharray:"strokeDasharray","stroke-dasharray":"strokeDasharray",strokedashoffset:"strokeDashoffset","stroke-dashoffset":"strokeDashoffset",strokelinecap:"strokeLinecap","stroke-linecap":"strokeLinecap",strokelinejoin:"strokeLinejoin","stroke-linejoin":"strokeLinejoin",strokemiterlimit:"strokeMiterlimit","stroke-miterlimit":"strokeMiterlimit",strokewidth:"strokeWidth","stroke-width":"strokeWidth",strokeopacity:"strokeOpacity","stroke-opacity":"strokeOpacity",suppresscontenteditablewarning:"suppressContentEditableWarning",suppresshydrationwarning:"suppressHydrationWarning",surfacescale:"surfaceScale",systemlanguage:"systemLanguage",tablevalues:"tableValues",targetx:"targetX",targety:"targetY",textanchor:"textAnchor","text-anchor":"textAnchor",textdecoration:"textDecoration","text-decoration":"textDecoration",textlength:"textLength",textrendering:"textRendering","text-rendering":"textRendering",to:"to",transform:"transform",transformorigin:"transformOrigin","transform-origin":"transformOrigin",typeof:"typeof",u1:"u1",u2:"u2",underlineposition:"underlinePosition","underline-position":"underlinePosition",underlinethickness:"underlineThickness","underline-thickness":"underlineThickness",unicode:"unicode",unicodebidi:"unicodeBidi","unicode-bidi":"unicodeBidi",unicoderange:"unicodeRange","unicode-range":"unicodeRange",unitsperem:"unitsPerEm","units-per-em":"unitsPerEm",unselectable:"unselectable",valphabetic:"vAlphabetic","v-alphabetic":"vAlphabetic",values:"values",vectoreffect:"vectorEffect","vector-effect":"vectorEffect",version:"version",vertadvy:"vertAdvY","vert-adv-y":"vertAdvY",vertoriginx:"vertOriginX","vert-origin-x":"vertOriginX",vertoriginy:"vertOriginY","vert-origin-y":"vertOriginY",vhanging:"vHanging","v-hanging":"vHanging",videographic:"vIdeographic","v-ideographic":"vIdeographic",viewbox:"viewBox",viewtarget:"viewTarget",visibility:"visibility",vmathematical:"vMathematical","v-mathematical":"vMathematical",vocab:"vocab",widths:"widths",wordspacing:"wordSpacing","word-spacing":"wordSpacing",writingmode:"writingMode","writing-mode":"writingMode",x1:"x1",x2:"x2",x:"x",xchannelselector:"xChannelSelector",xheight:"xHeight","x-height":"xHeight",xlinkactuate:"xlinkActuate","xlink:actuate":"xlinkActuate",xlinkarcrole:"xlinkArcrole","xlink:arcrole":"xlinkArcrole",xlinkhref:"xlinkHref","xlink:href":"xlinkHref",xlinkrole:"xlinkRole","xlink:role":"xlinkRole",xlinkshow:"xlinkShow","xlink:show":"xlinkShow",xlinktitle:"xlinkTitle","xlink:title":"xlinkTitle",xlinktype:"xlinkType","xlink:type":"xlinkType",xmlbase:"xmlBase","xml:base":"xmlBase",xmllang:"xmlLang","xml:lang":"xmlLang",xmlns:"xmlns","xml:space":"xmlSpace",xmlnsxlink:"xmlnsXlink","xmlns:xlink":"xmlnsXlink",xmlspace:"xmlSpace",y1:"y1",y2:"y2",y:"y",ychannelselector:"yChannelSelector",z:"z",zoomandpan:"zoomAndPan"},kN={"aria-current":0,"aria-description":0,"aria-details":0,"aria-disabled":0,"aria-hidden":0,"aria-invalid":0,"aria-keyshortcuts":0,"aria-label":0,"aria-roledescription":0,"aria-autocomplete":0,"aria-checked":0,"aria-expanded":0,"aria-haspopup":0,"aria-level":0,"aria-modal":0,"aria-multiline":0,"aria-multiselectable":0,"aria-orientation":0,"aria-placeholder":0,"aria-pressed":0,"aria-readonly":0,"aria-required":0,"aria-selected":0,"aria-sort":0,"aria-valuemax":0,"aria-valuemin":0,"aria-valuenow":0,"aria-valuetext":0,"aria-atomic":0,"aria-busy":0,"aria-live":0,"aria-relevant":0,"aria-dropeffect":0,"aria-grabbed":0,"aria-activedescendant":0,"aria-colcount":0,"aria-colindex":0,"aria-colspan":0,"aria-controls":0,"aria-describedby":0,"aria-errormessage":0,"aria-flowto":0,"aria-labelledby":0,"aria-owns":0,"aria-posinset":0,"aria-rowcount":0,"aria-rowindex":0,"aria-rowspan":0,"aria-setsize":0,"aria-braillelabel":0,"aria-brailleroledescription":0,"aria-colindextext":0,"aria-rowindextext":0},K_={},j4=RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),x4=RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),SN=!1,f6={},yN=/^on./,g4=/^on[^A-Z]/,u4=RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),p4=RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),m4=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,z$=null,U_=null,B_=null,aG=!1,I7=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),rG=!1;if(I7)try{var A$={};Object.defineProperty(A$,"passive",{get:function(){rG=!0}}),window.addEventListener("test",A$,A$),window.removeEventListener("test",A$,A$)}catch(q){rG=!1}var l9=null,tG=null,YH=null,sq={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(q){return q.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},XH=b6(sq),h$=yF({},sq,{view:0,detail:0}),l4=b6(h$),eG,FK,R$,GH=yF({},h$,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:bY,button:0,buttons:0,relatedTarget:function(q){return q.relatedTarget===void 0?q.fromElement===q.srcElement?q.toElement:q.fromElement:q.relatedTarget},movementX:function(q){if("movementX"in q)return q.movementX;return q!==R$&&(R$&&q.type==="mousemove"?(eG=q.screenX-R$.screenX,FK=q.screenY-R$.screenY):FK=eG=0,R$=q),eG},movementY:function(q){return"movementY"in q?q.movementY:FK}}),vN=b6(GH),d4=yF({},GH,{dataTransfer:0}),i4=b6(d4),n4=yF({},h$,{relatedTarget:0}),qK=b6(n4),c4=yF({},sq,{animationName:0,elapsedTime:0,pseudoElement:0}),s4=b6(c4),o4=yF({},sq,{clipboardData:function(q){return"clipboardData"in q?q.clipboardData:window.clipboardData}}),a4=b6(o4),r4=yF({},sq,{data:0}),bN=b6(r4),t4=bN,e4={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},FT={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},qT={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},JT=yF({},h$,{key:function(q){if(q.key){var J=e4[q.key]||q.key;if(J!=="Unidentified")return J}return q.type==="keypress"?(q=rQ(q),q===13?"Enter":String.fromCharCode(q)):q.type==="keydown"||q.type==="keyup"?FT[q.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:bY,charCode:function(q){return q.type==="keypress"?rQ(q):0},keyCode:function(q){return q.type==="keydown"||q.type==="keyup"?q.keyCode:0},which:function(q){return q.type==="keypress"?rQ(q):q.type==="keydown"||q.type==="keyup"?q.keyCode:0}}),_T=b6(JT),ZT=yF({},GH,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),jN=b6(ZT),$T=yF({},h$,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:bY}),QT=b6($T),WT=yF({},sq,{propertyName:0,elapsedTime:0,pseudoElement:0}),HT=b6(WT),wT=yF({},GH,{deltaX:function(q){return"deltaX"in q?q.deltaX:("wheelDeltaX"in q)?-q.wheelDeltaX:0},deltaY:function(q){return"deltaY"in q?q.deltaY:("wheelDeltaY"in q)?-q.wheelDeltaY:("wheelDelta"in q)?-q.wheelDelta:0},deltaZ:0,deltaMode:0}),YT=b6(wT),XT=yF({},sq,{newState:0,oldState:0}),GT=b6(XT),KT=[9,13,27,32],xN=229,JK=I7&&"CompositionEvent"in window,N$=null;I7&&"documentMode"in document&&(N$=document.documentMode);var UT=I7&&"TextEvent"in window&&!N$,gN=I7&&(!JK||N$&&8<N$&&11>=N$),uN=32,pN=String.fromCharCode(uN),mN=!1,z_=!1,BT={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},D$=null,M$=null,lN=!1;I7&&(lN=bI("input")&&(!document.documentMode||9<document.documentMode));var I6=typeof Object.is==="function"?Object.is:mI,zT=I7&&"documentMode"in document&&11>=document.documentMode,A_=null,_K=null,O$=null,ZK=!1,h_={animationend:Sq("Animation","AnimationEnd"),animationiteration:Sq("Animation","AnimationIteration"),animationstart:Sq("Animation","AnimationStart"),transitionrun:Sq("Transition","TransitionRun"),transitionstart:Sq("Transition","TransitionStart"),transitioncancel:Sq("Transition","TransitionCancel"),transitionend:Sq("Transition","TransitionEnd")},$K={},dN={};I7&&(dN=document.createElement("div").style,("AnimationEvent"in window)||(delete h_.animationend.animation,delete h_.animationiteration.animation,delete h_.animationstart.animation),("TransitionEvent"in window)||delete h_.transitionend.transition);var iN=yq("animationend"),nN=yq("animationiteration"),cN=yq("animationstart"),AT=yq("transitionrun"),hT=yq("transitionstart"),RT=yq("transitioncancel"),sN=yq("transitionend"),oN=new Map,QK="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");QK.push("scrollEnd");var aN=0;if(typeof performance==="object"&&typeof performance.now==="function")var NT=performance,rN=function(){return NT.now()};else{var DT=Date;rN=function(){return DT.now()}}var WK=typeof reportError==="function"?reportError:function(q){if(typeof window==="object"&&typeof window.ErrorEvent==="function"){var J=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof q==="object"&&q!==null&&typeof q.message==="string"?String(q.message):String(q),error:q});if(!window.dispatchEvent(J))return}else if(typeof process==="object"&&typeof process.emit==="function"){process.emit("uncaughtException",q);return}console.error(q)},MT="This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.",KH=0,HK=1,wK=2,YK=3,UH="",BH="+",tN="",B1=typeof console<"u"&&typeof console.timeStamp==="function"&&typeof performance<"u"&&typeof performance.measure==="function",B8="Components ",vF="Scheduler ",xF="Blocking",d9=!1,s7={color:"primary",properties:null,tooltipText:"",track:B8},i9={start:-0,end:-0,detail:{devtools:s7}},OT=["Changed Props",""],eN="This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.",fT=["Changed Props",eN],f$=1,o7=2,z8=[],R_=0,XK=0,n9={};Object.freeze(n9);var A8=null,N_=null,BF=0,IT=1,IF=2,K6=8,p8=16,TT=32,FD=!1;try{var qD=Object.preventExtensions({})}catch(q){FD=!0}var GK=new WeakMap,D_=[],M_=0,zH=null,I$=0,h8=[],R8=0,oq=null,a7=1,r7="",w6=null,z1=null,gF=!1,T7=!1,J8=null,c9=null,N8=!1,KK=Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),UK=d(null),BK=d(null),JD={},AH=null,O_=null,f_=!1,LT=typeof AbortController<"u"?AbortController:function(){var q=[],J=this.signal={aborted:!1,addEventListener:function(Z,Q){q.push(Q)}};this.abort=function(){J.aborted=!0,q.forEach(function(Z){return Z()})}},ET=oF.unstable_scheduleCallback,CT=oF.unstable_NormalPriority,S1={$$typeof:N7,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0,_currentRenderer:null,_currentRenderer2:null},y1=oF.unstable_now,hH=console.createTask?console.createTask:function(){return null},T$=1,RH=2,a1=-0,s9=-0,t7=-0,e7=null,T6=-1.1,aq=-0,M1=-0,WF=-1.1,KF=-1.1,R1=null,I1=!1,o9=-0,L7=-1.1,L$=null,a9=0,zK=null,AK=null,rq=-1.1,E$=null,I_=-1.1,NH=-1.1,E7=-0,F9=-1.1,D8=-1.1,hK=0,C$=null,_D=null,ZD=null,r9=-1.1,tq=null,t9=-1.1,DH=-1.1,$D=-0,QD=-0,MH=0,q9=null,WD=0,P$=-1.1,OH=!1,fH=!1,V$=null,RK=0,eq=0,T_=null,HD=R0.S;R0.S=function(q,J){if(_M=o1(),typeof J==="object"&&J!==null&&typeof J.then==="function"){if(0>F9&&0>D8){F9=y1();var Z=W$(),Q=Q$();if(Z!==t9||Q!==tq)t9=-1.1;r9=Z,tq=Q}oI(q,J)}HD!==null&&HD(q,J)};var FJ=d(null),m8={recordUnsafeLifecycleWarnings:function(){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}},k$=[],S$=[],y$=[],v$=[],b$=[],j$=[],qJ=new Set;m8.recordUnsafeLifecycleWarnings=function(q,J){qJ.has(q.type)||(typeof J.componentWillMount==="function"&&J.componentWillMount.__suppressDeprecationWarning!==!0&&k$.push(q),q.mode&K6&&typeof J.UNSAFE_componentWillMount==="function"&&S$.push(q),typeof J.componentWillReceiveProps==="function"&&J.componentWillReceiveProps.__suppressDeprecationWarning!==!0&&y$.push(q),q.mode&K6&&typeof J.UNSAFE_componentWillReceiveProps==="function"&&v$.push(q),typeof J.componentWillUpdate==="function"&&J.componentWillUpdate.__suppressDeprecationWarning!==!0&&b$.push(q),q.mode&K6&&typeof J.UNSAFE_componentWillUpdate==="function"&&j$.push(q))},m8.flushPendingUnsafeLifecycleWarnings=function(){var q=new Set;0<k$.length&&(k$.forEach(function(R){q.add(V(R)||"Component"),qJ.add(R.type)}),k$=[]);var J=new Set;0<S$.length&&(S$.forEach(function(R){J.add(V(R)||"Component"),qJ.add(R.type)}),S$=[]);var Z=new Set;0<y$.length&&(y$.forEach(function(R){Z.add(V(R)||"Component"),qJ.add(R.type)}),y$=[]);var Q=new Set;0<v$.length&&(v$.forEach(function(R){Q.add(V(R)||"Component"),qJ.add(R.type)}),v$=[]);var w=new Set;0<b$.length&&(b$.forEach(function(R){w.add(V(R)||"Component"),qJ.add(R.type)}),b$=[]);var X=new Set;if(0<j$.length&&(j$.forEach(function(R){X.add(V(R)||"Component"),qJ.add(R.type)}),j$=[]),0<J.size){var B=A(J);console.error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,B)}0<Q.size&&(B=A(Q),console.error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`,B)),0<X.size&&(B=A(X),console.error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,B)),0<q.size&&(B=A(q),console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,B)),0<Z.size&&(B=A(Z),console.warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,B)),0<w.size&&(B=A(w),console.warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,B))};var IH=new Map,wD=new Set;m8.recordLegacyContextWarning=function(q,J){var Z=null;for(var Q=q;Q!==null;)Q.mode&K6&&(Z=Q),Q=Q.return;Z===null?console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."):!wD.has(q.type)&&(Q=IH.get(Z),q.type.contextTypes!=null||q.type.childContextTypes!=null||J!==null&&typeof J.getChildContext==="function")&&(Q===void 0&&(Q=[],IH.set(Z,Q)),Q.push(q))},m8.flushLegacyContextWarning=function(){IH.forEach(function(q){if(q.length!==0){var J=q[0],Z=new Set;q.forEach(function(w){Z.add(V(w)||"Component"),wD.add(w.type)});var Q=A(Z);v0(J,function(){console.error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`,Q)})}})},m8.discardPendingWarnings=function(){k$=[],S$=[],y$=[],v$=[],b$=[],j$=[],IH=new Map};var YD={react_stack_bottom_frame:function(q,J,Z){var Q=D7;D7=!0;try{return q(J,Z)}finally{D7=Q}}},NK=YD.react_stack_bottom_frame.bind(YD),XD={react_stack_bottom_frame:function(q){var J=D7;D7=!0;try{return q.render()}finally{D7=J}}},GD=XD.react_stack_bottom_frame.bind(XD),KD={react_stack_bottom_frame:function(q,J){try{J.componentDidMount()}catch(Z){eF(q,q.return,Z)}}},DK=KD.react_stack_bottom_frame.bind(KD),UD={react_stack_bottom_frame:function(q,J,Z,Q,w){try{J.componentDidUpdate(Z,Q,w)}catch(X){eF(q,q.return,X)}}},BD=UD.react_stack_bottom_frame.bind(UD),zD={react_stack_bottom_frame:function(q,J){var Z=J.stack;q.componentDidCatch(J.value,{componentStack:Z!==null?Z:""})}},PT=zD.react_stack_bottom_frame.bind(zD),AD={react_stack_bottom_frame:function(q,J,Z){try{Z.componentWillUnmount()}catch(Q){eF(q,J,Q)}}},hD=AD.react_stack_bottom_frame.bind(AD),RD={react_stack_bottom_frame:function(q){var J=q.create;return q=q.inst,J=J(),q.destroy=J}},VT=RD.react_stack_bottom_frame.bind(RD),ND={react_stack_bottom_frame:function(q,J,Z){try{Z()}catch(Q){eF(q,J,Q)}}},kT=ND.react_stack_bottom_frame.bind(ND),DD={react_stack_bottom_frame:function(q){var J=q._init;return J(q._payload)}},ST=DD.react_stack_bottom_frame.bind(DD),L_=Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."),MK=Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),TH=Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."),LH={then:function(){console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.')}},JJ=null,x$=!1,E_=null,g$=0,TF=null,OK,MD=OK=!1,OD={},fD={},ID={};h=function(q,J,Z){if(Z!==null&&typeof Z==="object"&&Z._store&&(!Z._store.validated&&Z.key==null||Z._store.validated===2)){if(typeof Z._store!=="object")throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");Z._store.validated=1;var Q=V(q),w=Q||"null";if(!OD[w]){OD[w]=!0,Z=Z._owner,q=q._debugOwner;var X="";q&&typeof q.tag==="number"&&(w=V(q))&&(X=`

Check the render method of \``+w+"`."),X||Q&&(X=`

Check the top-level render call using <`+Q+">.");var B="";Z!=null&&q!==Z&&(Q=null,typeof Z.tag==="number"?Q=V(Z):typeof Z.name==="string"&&(Q=Z.name),Q&&(B=" It was passed a child from "+Q+".")),v0(J,function(){console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',X,B)})}}};var _J=AA(!0),TD=AA(!1),LD=0,ED=1,CD=2,fK=3,e9=!1,PD=!1,IK=null,TK=!1,C_=d(null),EH=d(0),_8=d(null),M8=null,P_=1,u$=2,V1=d(0),CH=0,O8=1,L6=2,Z8=4,E6=8,V_,VD=new Set,kD=new Set,LK=new Set,SD=new Set,J9=0,RF=null,W1=null,v1=null,PH=!1,k_=!1,ZJ=!1,VH=0,p$=0,_9=null,yT=0,vT=25,A0=null,f8=null,Z9=-1,m$=!1,l$={readContext:h1,use:v9,useCallback:E1,useContext:E1,useEffect:E1,useImperativeHandle:E1,useLayoutEffect:E1,useInsertionEffect:E1,useMemo:E1,useReducer:E1,useRef:E1,useState:E1,useDebugValue:E1,useDeferredValue:E1,useTransition:E1,useSyncExternalStore:E1,useId:E1,useHostTransitionStatus:E1,useFormState:E1,useActionState:E1,useOptimistic:E1,useMemoCache:E1,useCacheRefresh:E1};l$.useEffectEvent=E1;var EK=null,yD=null,CK=null,vD=null,C7=null,l8=null,kH=null;EK={readContext:function(q){return h1(q)},use:v9,useCallback:function(q,J){return A0="useCallback",SF(),sJ(J),TX(q,J)},useContext:function(q){return A0="useContext",SF(),h1(q)},useEffect:function(q,J){return A0="useEffect",SF(),sJ(J),IW(q,J)},useImperativeHandle:function(q,J,Z){return A0="useImperativeHandle",SF(),sJ(Z),IX(q,J,Z)},useInsertionEffect:function(q,J){A0="useInsertionEffect",SF(),sJ(J),mq(4,L6,q,J)},useLayoutEffect:function(q,J){return A0="useLayoutEffect",SF(),sJ(J),fX(q,J)},useMemo:function(q,J){A0="useMemo",SF(),sJ(J);var Z=R0.H;R0.H=C7;try{return LX(q,J)}finally{R0.H=Z}},useReducer:function(q,J,Z){A0="useReducer",SF();var Q=R0.H;R0.H=C7;try{return BX(q,J,Z)}finally{R0.H=Q}},useRef:function(q){return A0="useRef",SF(),MX(q)},useState:function(q){A0="useState",SF();var J=R0.H;R0.H=C7;try{return RX(q)}finally{R0.H=J}},useDebugValue:function(){A0="useDebugValue",SF()},useDeferredValue:function(q,J){return A0="useDeferredValue",SF(),EX(q,J)},useTransition:function(){return A0="useTransition",SF(),VX()},useSyncExternalStore:function(q,J,Z){return A0="useSyncExternalStore",SF(),AX(q,J,Z)},useId:function(){return A0="useId",SF(),kX()},useFormState:function(q,J){return A0="useFormState",SF(),NW(),aJ(q,J)},useActionState:function(q,J){return A0="useActionState",SF(),aJ(q,J)},useOptimistic:function(q){return A0="useOptimistic",SF(),NX(q)},useHostTransitionStatus:lq,useMemoCache:pq,useCacheRefresh:function(){return A0="useCacheRefresh",SF(),SX()},useEffectEvent:function(q){return A0="useEffectEvent",SF(),OX(q)}},yD={readContext:function(q){return h1(q)},use:v9,useCallback:function(q,J){return A0="useCallback",k0(),TX(q,J)},useContext:function(q){return A0="useContext",k0(),h1(q)},useEffect:function(q,J){return A0="useEffect",k0(),IW(q,J)},useImperativeHandle:function(q,J,Z){return A0="useImperativeHandle",k0(),IX(q,J,Z)},useInsertionEffect:function(q,J){A0="useInsertionEffect",k0(),mq(4,L6,q,J)},useLayoutEffect:function(q,J){return A0="useLayoutEffect",k0(),fX(q,J)},useMemo:function(q,J){A0="useMemo",k0();var Z=R0.H;R0.H=C7;try{return LX(q,J)}finally{R0.H=Z}},useReducer:function(q,J,Z){A0="useReducer",k0();var Q=R0.H;R0.H=C7;try{return BX(q,J,Z)}finally{R0.H=Q}},useRef:function(q){return A0="useRef",k0(),MX(q)},useState:function(q){A0="useState",k0();var J=R0.H;R0.H=C7;try{return RX(q)}finally{R0.H=J}},useDebugValue:function(){A0="useDebugValue",k0()},useDeferredValue:function(q,J){return A0="useDeferredValue",k0(),EX(q,J)},useTransition:function(){return A0="useTransition",k0(),VX()},useSyncExternalStore:function(q,J,Z){return A0="useSyncExternalStore",k0(),AX(q,J,Z)},useId:function(){return A0="useId",k0(),kX()},useActionState:function(q,J){return A0="useActionState",k0(),aJ(q,J)},useFormState:function(q,J){return A0="useFormState",k0(),NW(),aJ(q,J)},useOptimistic:function(q){return A0="useOptimistic",k0(),NX(q)},useHostTransitionStatus:lq,useMemoCache:pq,useCacheRefresh:function(){return A0="useCacheRefresh",k0(),SX()},useEffectEvent:function(q){return A0="useEffectEvent",k0(),OX(q)}},CK={readContext:function(q){return h1(q)},use:v9,useCallback:function(q,J){return A0="useCallback",k0(),EW(q,J)},useContext:function(q){return A0="useContext",k0(),h1(q)},useEffect:function(q,J){A0="useEffect",k0(),j6(2048,E6,q,J)},useImperativeHandle:function(q,J,Z){return A0="useImperativeHandle",k0(),LW(q,J,Z)},useInsertionEffect:function(q,J){return A0="useInsertionEffect",k0(),j6(4,L6,q,J)},useLayoutEffect:function(q,J){return A0="useLayoutEffect",k0(),j6(4,Z8,q,J)},useMemo:function(q,J){A0="useMemo",k0();var Z=R0.H;R0.H=l8;try{return CW(q,J)}finally{R0.H=Z}},useReducer:function(q,J,Z){A0="useReducer",k0();var Q=R0.H;R0.H=l8;try{return oJ(q,J,Z)}finally{R0.H=Q}},useRef:function(){return A0="useRef",k0(),J1().memoizedState},useState:function(){A0="useState",k0();var q=R0.H;R0.H=l8;try{return oJ(j8)}finally{R0.H=q}},useDebugValue:function(){A0="useDebugValue",k0()},useDeferredValue:function(q,J){return A0="useDeferredValue",k0(),gA(q,J)},useTransition:function(){return A0="useTransition",k0(),iA()},useSyncExternalStore:function(q,J,Z){return A0="useSyncExternalStore",k0(),MW(q,J,Z)},useId:function(){return A0="useId",k0(),J1().memoizedState},useFormState:function(q){return A0="useFormState",k0(),NW(),OW(q)},useActionState:function(q){return A0="useActionState",k0(),OW(q)},useOptimistic:function(q,J){return A0="useOptimistic",k0(),CA(q,J)},useHostTransitionStatus:lq,useMemoCache:pq,useCacheRefresh:function(){return A0="useCacheRefresh",k0(),J1().memoizedState},useEffectEvent:function(q){return A0="useEffectEvent",k0(),TW(q)}},vD={readContext:function(q){return h1(q)},use:v9,useCallback:function(q,J){return A0="useCallback",k0(),EW(q,J)},useContext:function(q){return A0="useContext",k0(),h1(q)},useEffect:function(q,J){A0="useEffect",k0(),j6(2048,E6,q,J)},useImperativeHandle:function(q,J,Z){return A0="useImperativeHandle",k0(),LW(q,J,Z)},useInsertionEffect:function(q,J){return A0="useInsertionEffect",k0(),j6(4,L6,q,J)},useLayoutEffect:function(q,J){return A0="useLayoutEffect",k0(),j6(4,Z8,q,J)},useMemo:function(q,J){A0="useMemo",k0();var Z=R0.H;R0.H=kH;try{return CW(q,J)}finally{R0.H=Z}},useReducer:function(q,J,Z){A0="useReducer",k0();var Q=R0.H;R0.H=kH;try{return sZ(q,J,Z)}finally{R0.H=Q}},useRef:function(){return A0="useRef",k0(),J1().memoizedState},useState:function(){A0="useState",k0();var q=R0.H;R0.H=kH;try{return sZ(j8)}finally{R0.H=q}},useDebugValue:function(){A0="useDebugValue",k0()},useDeferredValue:function(q,J){return A0="useDeferredValue",k0(),uA(q,J)},useTransition:function(){return A0="useTransition",k0(),nA()},useSyncExternalStore:function(q,J,Z){return A0="useSyncExternalStore",k0(),MW(q,J,Z)},useId:function(){return A0="useId",k0(),J1().memoizedState},useFormState:function(q){return A0="useFormState",k0(),NW(),fW(q)},useActionState:function(q){return A0="useActionState",k0(),fW(q)},useOptimistic:function(q,J){return A0="useOptimistic",k0(),VA(q,J)},useHostTransitionStatus:lq,useMemoCache:pq,useCacheRefresh:function(){return A0="useCacheRefresh",k0(),J1().memoizedState},useEffectEvent:function(q){return A0="useEffectEvent",k0(),TW(q)}},C7={readContext:function(q){return U(),h1(q)},use:function(q){return G(),v9(q)},useCallback:function(q,J){return A0="useCallback",G(),SF(),TX(q,J)},useContext:function(q){return A0="useContext",G(),SF(),h1(q)},useEffect:function(q,J){return A0="useEffect",G(),SF(),IW(q,J)},useImperativeHandle:function(q,J,Z){return A0="useImperativeHandle",G(),SF(),IX(q,J,Z)},useInsertionEffect:function(q,J){A0="useInsertionEffect",G(),SF(),mq(4,L6,q,J)},useLayoutEffect:function(q,J){return A0="useLayoutEffect",G(),SF(),fX(q,J)},useMemo:function(q,J){A0="useMemo",G(),SF();var Z=R0.H;R0.H=C7;try{return LX(q,J)}finally{R0.H=Z}},useReducer:function(q,J,Z){A0="useReducer",G(),SF();var Q=R0.H;R0.H=C7;try{return BX(q,J,Z)}finally{R0.H=Q}},useRef:function(q){return A0="useRef",G(),SF(),MX(q)},useState:function(q){A0="useState",G(),SF();var J=R0.H;R0.H=C7;try{return RX(q)}finally{R0.H=J}},useDebugValue:function(){A0="useDebugValue",G(),SF()},useDeferredValue:function(q,J){return A0="useDeferredValue",G(),SF(),EX(q,J)},useTransition:function(){return A0="useTransition",G(),SF(),VX()},useSyncExternalStore:function(q,J,Z){return A0="useSyncExternalStore",G(),SF(),AX(q,J,Z)},useId:function(){return A0="useId",G(),SF(),kX()},useFormState:function(q,J){return A0="useFormState",G(),SF(),aJ(q,J)},useActionState:function(q,J){return A0="useActionState",G(),SF(),aJ(q,J)},useOptimistic:function(q){return A0="useOptimistic",G(),SF(),NX(q)},useMemoCache:function(q){return G(),pq(q)},useHostTransitionStatus:lq,useCacheRefresh:function(){return A0="useCacheRefresh",SF(),SX()},useEffectEvent:function(q){return A0="useEffectEvent",G(),SF(),OX(q)}},l8={readContext:function(q){return U(),h1(q)},use:function(q){return G(),v9(q)},useCallback:function(q,J){return A0="useCallback",G(),k0(),EW(q,J)},useContext:function(q){return A0="useContext",G(),k0(),h1(q)},useEffect:function(q,J){A0="useEffect",G(),k0(),j6(2048,E6,q,J)},useImperativeHandle:function(q,J,Z){return A0="useImperativeHandle",G(),k0(),LW(q,J,Z)},useInsertionEffect:function(q,J){return A0="useInsertionEffect",G(),k0(),j6(4,L6,q,J)},useLayoutEffect:function(q,J){return A0="useLayoutEffect",G(),k0(),j6(4,Z8,q,J)},useMemo:function(q,J){A0="useMemo",G(),k0();var Z=R0.H;R0.H=l8;try{return CW(q,J)}finally{R0.H=Z}},useReducer:function(q,J,Z){A0="useReducer",G(),k0();var Q=R0.H;R0.H=l8;try{return oJ(q,J,Z)}finally{R0.H=Q}},useRef:function(){return A0="useRef",G(),k0(),J1().memoizedState},useState:function(){A0="useState",G(),k0();var q=R0.H;R0.H=l8;try{return oJ(j8)}finally{R0.H=q}},useDebugValue:function(){A0="useDebugValue",G(),k0()},useDeferredValue:function(q,J){return A0="useDeferredValue",G(),k0(),gA(q,J)},useTransition:function(){return A0="useTransition",G(),k0(),iA()},useSyncExternalStore:function(q,J,Z){return A0="useSyncExternalStore",G(),k0(),MW(q,J,Z)},useId:function(){return A0="useId",G(),k0(),J1().memoizedState},useFormState:function(q){return A0="useFormState",G(),k0(),OW(q)},useActionState:function(q){return A0="useActionState",G(),k0(),OW(q)},useOptimistic:function(q,J){return A0="useOptimistic",G(),k0(),CA(q,J)},useMemoCache:function(q){return G(),pq(q)},useHostTransitionStatus:lq,useCacheRefresh:function(){return A0="useCacheRefresh",k0(),J1().memoizedState},useEffectEvent:function(q){return A0="useEffectEvent",G(),k0(),TW(q)}},kH={readContext:function(q){return U(),h1(q)},use:function(q){return G(),v9(q)},useCallback:function(q,J){return A0="useCallback",G(),k0(),EW(q,J)},useContext:function(q){return A0="useContext",G(),k0(),h1(q)},useEffect:function(q,J){A0="useEffect",G(),k0(),j6(2048,E6,q,J)},useImperativeHandle:function(q,J,Z){return A0="useImperativeHandle",G(),k0(),LW(q,J,Z)},useInsertionEffect:function(q,J){return A0="useInsertionEffect",G(),k0(),j6(4,L6,q,J)},useLayoutEffect:function(q,J){return A0="useLayoutEffect",G(),k0(),j6(4,Z8,q,J)},useMemo:function(q,J){A0="useMemo",G(),k0();var Z=R0.H;R0.H=l8;try{return CW(q,J)}finally{R0.H=Z}},useReducer:function(q,J,Z){A0="useReducer",G(),k0();var Q=R0.H;R0.H=l8;try{return sZ(q,J,Z)}finally{R0.H=Q}},useRef:function(){return A0="useRef",G(),k0(),J1().memoizedState},useState:function(){A0="useState",G(),k0();var q=R0.H;R0.H=l8;try{return sZ(j8)}finally{R0.H=q}},useDebugValue:function(){A0="useDebugValue",G(),k0()},useDeferredValue:function(q,J){return A0="useDeferredValue",G(),k0(),uA(q,J)},useTransition:function(){return A0="useTransition",G(),k0(),nA()},useSyncExternalStore:function(q,J,Z){return A0="useSyncExternalStore",G(),k0(),MW(q,J,Z)},useId:function(){return A0="useId",G(),k0(),J1().memoizedState},useFormState:function(q){return A0="useFormState",G(),k0(),fW(q)},useActionState:function(q){return A0="useActionState",G(),k0(),fW(q)},useOptimistic:function(q,J){return A0="useOptimistic",G(),k0(),VA(q,J)},useMemoCache:function(q){return G(),pq(q)},useHostTransitionStatus:lq,useCacheRefresh:function(){return A0="useCacheRefresh",k0(),J1().memoizedState},useEffectEvent:function(q){return A0="useEffectEvent",G(),k0(),TW(q)}};var bD={},jD=new Set,xD=new Set,gD=new Set,uD=new Set,pD=new Set,mD=new Set,lD=new Set,dD=new Set,iD=new Set,nD=new Set;Object.freeze(bD);var PK={enqueueSetState:function(q,J,Z){q=q._reactInternals;var Q=r6(q),w=V9(Q);w.payload=J,Z!==void 0&&Z!==null&&(vX(Z),w.callback=Z),J=k9(q,w,Q),J!==null&&(Q7(Q,"this.setState()",q),f1(J,q,Q),dZ(J,q,Q))},enqueueReplaceState:function(q,J,Z){q=q._reactInternals;var Q=r6(q),w=V9(Q);w.tag=ED,w.payload=J,Z!==void 0&&Z!==null&&(vX(Z),w.callback=Z),J=k9(q,w,Q),J!==null&&(Q7(Q,"this.replaceState()",q),f1(J,q,Q),dZ(J,q,Q))},enqueueForceUpdate:function(q,J){q=q._reactInternals;var Z=r6(q),Q=V9(Z);Q.tag=CD,J!==void 0&&J!==null&&(vX(J),Q.callback=J),J=k9(q,Q,Z),J!==null&&(Q7(Z,"this.forceUpdate()",q),f1(J,q,Z),dZ(J,q,Z))}},S_=null,VK=null,kK=Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."),b1=!1,cD={},sD={},oD={},aD={},y_=!1,rD={},SH={},SK={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null},tD=!1,eD=null;eD=new Set;var $9=!1,j1=!1,yK=!1,FM=typeof WeakSet==="function"?WeakSet:Set,r1=null,v_=null,b_=null,x1=null,u6=!1,d8=null,m1=!1,d$=8192,bT={getCacheForType:function(q){var J=h1(S1),Z=J.data.get(q);return Z===void 0&&(Z=q(),J.data.set(q,Z)),Z},cacheSignal:function(){return h1(S1).controller.signal},getOwner:function(){return F8}};if(typeof Symbol==="function"&&Symbol.for){var i$=Symbol.for;i$("selector.component"),i$("selector.has_pseudo_class"),i$("selector.role"),i$("selector.test_id"),i$("selector.text")}var jT=[],xT=typeof WeakMap==="function"?WeakMap:Map,t1=0,l1=2,$8=4,Q9=0,n$=1,$J=2,yH=3,Fq=4,vH=6,qM=5,cF=t1,H1=null,VF=null,LF=0,p6=0,bH=1,QJ=2,c$=3,JM=4,vK=5,s$=6,jH=7,bK=8,WJ=9,_1=p6,Q8=null,qq=!1,j_=!1,jK=!1,P7=0,O1=Q9,Jq=0,_q=0,xK=0,m6=0,HJ=0,o$=null,C6=null,xH=!1,gH=0,_M=0,ZM=300,uH=1/0,$M=500,a$=null,C1=null,Zq=null,pH=0,gK=1,uK=2,QM=3,$q=0,WM=1,HM=2,wM=3,YM=4,mH=5,g1=0,Qq=null,x_=null,i8=0,pK=0,mK=-0,lK=null,XM=null,GM=null,n8=pH,KM=null,gT=50,r$=0,dK=null,iK=!1,lH=!1,uT=50,wJ=0,t$=null,g_=!1,dH=null,UM=!1,BM=new Set,pT={},iH=null,u_=null,nK=!1,cK=!1,nH=!1,sK=!1,Wq=0,oK={};(function(){for(var q=0;q<QK.length;q++){var J=QK[q],Z=J.toLowerCase();J=J[0].toUpperCase()+J.slice(1),b8(Z,"on"+J)}b8(iN,"onAnimationEnd"),b8(nN,"onAnimationIteration"),b8(cN,"onAnimationStart"),b8("dblclick","onDoubleClick"),b8("focusin","onFocus"),b8("focusout","onBlur"),b8(AT,"onTransitionRun"),b8(hT,"onTransitionStart"),b8(RT,"onTransitionCancel"),b8(sN,"onTransitionEnd")})(),$F("onMouseEnter",["mouseout","mouseover"]),$F("onMouseLeave",["mouseout","mouseover"]),$F("onPointerEnter",["pointerout","pointerover"]),$F("onPointerLeave",["pointerout","pointerover"]),m0("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),m0("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),m0("onBeforeInput",["compositionend","keypress","textInput","paste"]),m0("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),m0("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),m0("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var e$="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),aK=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(e$)),cH="_reactListening"+Math.random().toString(36).slice(2),zM=!1,AM=!1,sH=!1,hM=!1,oH=!1,aH=!1,RM=!1,rH={},mT=/\r\n?/g,lT=/\u0000|\uFFFD/g,YJ="http://www.w3.org/1999/xlink",rK="http://www.w3.org/XML/1998/namespace",dT="javascript:throw new Error('React form unexpectedly submitted.')",iT="suppressHydrationWarning",XJ="&",tH="/&",FQ="$",qQ="/$",Hq="$?",GJ="$~",p_="$!",nT="html",cT="body",sT="head",tK="F!",NM="F",DM="loading",oT="style",W9=0,m_=1,eH=2,eK=null,F5=null,MM={dialog:!0,webview:!0},q5=null,JQ=void 0,OM=typeof setTimeout==="function"?setTimeout:void 0,aT=typeof clearTimeout==="function"?clearTimeout:void 0,KJ=-1,fM=typeof Promise==="function"?Promise:void 0,rT=typeof queueMicrotask==="function"?queueMicrotask:typeof fM<"u"?function(q){return fM.resolve(null).then(q).catch(v3)}:OM,J5=null,UJ=0,_Q=1,IM=2,TM=3,I8=4,T8=new Map,LM=new Set,H9=F1.d;F1.d={f:function(){var q=H9.f(),J=q_();return q||J},r:function(q){var J=M0(q);J!==null&&J.tag===5&&J.type==="form"?dA(J):H9.r(q)},D:function(q){H9.D(q),jR("dns-prefetch",q,null)},C:function(q,J){H9.C(q,J),jR("preconnect",q,J)},L:function(q,J,Z){H9.L(q,J,Z);var Q=l_;if(Q&&q&&J){var w='link[rel="preload"][as="'+R6(J)+'"]';J==="image"?Z&&Z.imageSrcSet?(w+='[imagesrcset="'+R6(Z.imageSrcSet)+'"]',typeof Z.imageSizes==="string"&&(w+='[imagesizes="'+R6(Z.imageSizes)+'"]')):w+='[href="'+R6(q)+'"]':w+='[href="'+R6(q)+'"]';var X=w;switch(J){case"style":X=Z_(q);break;case"script":X=$_(q)}T8.has(X)||(q=yF({rel:"preload",href:J==="image"&&Z&&Z.imageSrcSet?void 0:q,as:J},Z),T8.set(X,q),Q.querySelector(w)!==null||J==="style"&&Q.querySelector(w$(X))||J==="script"&&Q.querySelector(Y$(X))||(J=Q.createElement("link"),W6(J,"link",q),Z0(J),Q.head.appendChild(J)))}},m:function(q,J){H9.m(q,J);var Z=l_;if(Z&&q){var Q=J&&typeof J.as==="string"?J.as:"script",w='link[rel="modulepreload"][as="'+R6(Q)+'"][href="'+R6(q)+'"]',X=w;switch(Q){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":X=$_(q)}if(!T8.has(X)&&(q=yF({rel:"modulepreload",href:q},J),T8.set(X,q),Z.querySelector(w)===null)){switch(Q){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(Z.querySelector(Y$(X)))return}Q=Z.createElement("link"),W6(Q,"link",q),Z0(Q),Z.head.appendChild(Q)}}},X:function(q,J){H9.X(q,J);var Z=l_;if(Z&&q){var Q=I0(Z).hoistableScripts,w=$_(q),X=Q.get(w);X||(X=Z.querySelector(Y$(w)),X||(q=yF({src:q,async:!0},J),(J=T8.get(w))&&IG(q,J),X=Z.createElement("script"),Z0(X),W6(X,"link",q),Z.head.appendChild(X)),X={type:"script",instance:X,count:1,state:null},Q.set(w,X))}},S:function(q,J,Z){H9.S(q,J,Z);var Q=l_;if(Q&&q){var w=I0(Q).hoistableStyles,X=Z_(q);J=J||"default";var B=w.get(X);if(!B){var R={loading:UJ,preload:null};if(B=Q.querySelector(w$(X)))R.loading=_Q|I8;else{q=yF({rel:"stylesheet",href:q,"data-precedence":J},Z),(Z=T8.get(X))&&fG(q,Z);var I=B=Q.createElement("link");Z0(I),W6(I,"link",q),I._p=new Promise(function(C,e){I.onload=C,I.onerror=e}),I.addEventListener("load",function(){R.loading|=_Q}),I.addEventListener("error",function(){R.loading|=IM}),R.loading|=I8,sW(B,J,Q)}B={type:"stylesheet",instance:B,count:1,state:R},w.set(X,B)}}},M:function(q,J){H9.M(q,J);var Z=l_;if(Z&&q){var Q=I0(Z).hoistableScripts,w=$_(q),X=Q.get(w);X||(X=Z.querySelector(Y$(w)),X||(q=yF({src:q,async:!0,type:"module"},J),(J=T8.get(w))&&IG(q,J),X=Z.createElement("script"),Z0(X),W6(X,"link",q),Z.head.appendChild(X)),X={type:"script",instance:X,count:1,state:null},Q.set(w,X))}}};var l_=typeof document>"u"?null:document,Fw=null,tT=60000,eT=800,FL=500,_5=0,Z5=null,qw=null,BJ=B4,ZQ={$$typeof:N7,Provider:null,Consumer:null,_currentValue:BJ,_currentValue2:BJ,_threadCount:0},EM="%c%s%c",CM="background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",PM="",Jw=" ",qL=Function.prototype.bind,VM=!1,kM=null,SM=null,yM=null,vM=null,bM=null,jM=null,xM=null,gM=null,uM=null,pM=null;kM=function(q,J,Z,Q){J=F(q,J),J!==null&&(Z=_(J.memoizedState,Z,0,Q),J.memoizedState=Z,J.baseState=Z,q.memoizedProps=yF({},q.memoizedProps),Z=X6(q,2),Z!==null&&f1(Z,q,2))},SM=function(q,J,Z){J=F(q,J),J!==null&&(Z=H(J.memoizedState,Z,0),J.memoizedState=Z,J.baseState=Z,q.memoizedProps=yF({},q.memoizedProps),Z=X6(q,2),Z!==null&&f1(Z,q,2))},yM=function(q,J,Z,Q){J=F(q,J),J!==null&&(Z=$(J.memoizedState,Z,Q),J.memoizedState=Z,J.baseState=Z,q.memoizedProps=yF({},q.memoizedProps),Z=X6(q,2),Z!==null&&f1(Z,q,2))},vM=function(q,J,Z){q.pendingProps=_(q.memoizedProps,J,0,Z),q.alternate&&(q.alternate.pendingProps=q.pendingProps),J=X6(q,2),J!==null&&f1(J,q,2)},bM=function(q,J){q.pendingProps=H(q.memoizedProps,J,0),q.alternate&&(q.alternate.pendingProps=q.pendingProps),J=X6(q,2),J!==null&&f1(J,q,2)},jM=function(q,J,Z){q.pendingProps=$(q.memoizedProps,J,Z),q.alternate&&(q.alternate.pendingProps=q.pendingProps),J=X6(q,2),J!==null&&f1(J,q,2)},xM=function(q){var J=X6(q,2);J!==null&&f1(J,q,2)},gM=function(q){var J=q0(),Z=X6(q,J);Z!==null&&f1(Z,q,J)},uM=function(q){K=q},pM=function(q){Y=q};var _w=!0,Zw=null,$5=!1,wq=null,Yq=null,Xq=null,$Q=new Map,QQ=new Map,Gq=[],JL="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "),$w=null;if(eW.prototype.render=VG.prototype.render=function(q){var J=this._internalRoot;if(J===null)throw Error("Cannot update an unmounted root.");var Z=arguments;typeof Z[1]==="function"?console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."):D(Z[1])?console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."):typeof Z[1]<"u"&&console.error("You passed a second argument to root.render(...) but it only accepts one argument."),Z=q;var Q=J.current,w=r6(Q);TG(Q,w,Z,J,null,null)},eW.prototype.unmount=VG.prototype.unmount=function(){var q=arguments;if(typeof q[0]==="function"&&console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."),q=this._internalRoot,q!==null){this._internalRoot=null;var J=q.containerInfo;(cF&(l1|$8))!==t1&&console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."),TG(q.current,2,null,q,null,null),q_(),J[m9]=null}},eW.prototype.unstable_scheduleHydration=function(q){if(q){var J=p();q={blockedOn:null,target:q,priority:J};for(var Z=0;Z<Gq.length&&J!==0&&J<Gq[Z].priority;Z++);Gq.splice(Z,0,q),Z===0&&rR(q)}},function(){var q=i_.version;if(q!=="19.2.3")throw Error(`Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      `+(q+`
  - react-dom:  19.2.3
Learn more: https://react.dev/warnings/version-mismatch`))}(),typeof Map==="function"&&Map.prototype!=null&&typeof Map.prototype.forEach==="function"&&typeof Set==="function"&&Set.prototype!=null&&typeof Set.prototype.clear==="function"&&typeof Set.prototype.forEach==="function"||console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"),F1.findDOMNode=function(q){var J=q._reactInternals;if(J===void 0){if(typeof q.render==="function")throw Error("Unable to find node on an unmounted component.");throw q=Object.keys(q).join(","),Error("Argument appears to not be a ReactComponent. Keys: "+q)}return q=m(J),q=q!==null?x(q):null,q=q===null?null:q.stateNode,q},!function(){var q={bundleType:1,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:R0,reconcilerVersion:"19.2.3"};return q.overrideHookState=kM,q.overrideHookStateDeletePath=SM,q.overrideHookStateRenamePath=yM,q.overrideProps=vM,q.overridePropsDeletePath=bM,q.overridePropsRenamePath=jM,q.scheduleUpdate=xM,q.scheduleRetry=gM,q.setErrorHandler=uM,q.setSuspenseHandler=pM,q.scheduleRefresh=T,q.scheduleRoot=M,q.setRefreshHandler=P,q.getCurrentFiber=W4,AF(q)}()&&I7&&window.top===window.self&&(-1<navigator.userAgent.indexOf("Chrome")&&navigator.userAgent.indexOf("Edge")===-1||-1<navigator.userAgent.indexOf("Firefox"))){var mM=window.location.protocol;/^(https?|file):$/.test(mM)&&console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools"+(mM==="file:"?`
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq`:""),"font-weight:bold")}GL.createRoot=function(q,J){if(!D(q))throw Error("Target container is not a DOM element.");qN(q);var Z=!1,Q="",w=tA,X=eA,B=Fh;return J!==null&&J!==void 0&&(J.hydrate?console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."):typeof J==="object"&&J!==null&&J.$$typeof===R7&&console.error(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`),J.unstable_strictMode===!0&&(Z=!0),J.identifierPrefix!==void 0&&(Q=J.identifierPrefix),J.onUncaughtError!==void 0&&(w=J.onUncaughtError),J.onCaughtError!==void 0&&(X=J.onCaughtError),J.onRecoverableError!==void 0&&(B=J.onRecoverableError)),J=dR(q,1,!1,null,null,Z,Q,null,w,X,B,FN),q[m9]=J.current,GG(q),new VG(J)},GL.hydrateRoot=function(q,J,Z){if(!D(q))throw Error("Target container is not a DOM element.");qN(q),J===void 0&&console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");var Q=!1,w="",X=tA,B=eA,R=Fh,I=null;return Z!==null&&Z!==void 0&&(Z.unstable_strictMode===!0&&(Q=!0),Z.identifierPrefix!==void 0&&(w=Z.identifierPrefix),Z.onUncaughtError!==void 0&&(X=Z.onUncaughtError),Z.onCaughtError!==void 0&&(B=Z.onCaughtError),Z.onRecoverableError!==void 0&&(R=Z.onRecoverableError),Z.formState!==void 0&&(I=Z.formState)),J=dR(q,1,!0,J,Z!=null?Z:null,Q,w,I,X,B,R,FN),J.context=iR(null),Z=J.current,Q=r6(Z),Q=V0(Q),w=V9(Q),w.callback=null,k9(Z,w,Q),Q7(Q,"hydrateRoot()",null),Z=Q,J.current.lanes=Z,W0(J,Z),A7(J),q[m9]=J.current,GG(q),new eW(J)},GL.version="19.2.3",typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error())})()});var oM=Y9((vj,sM)=>{var KL=U6(cM());sM.exports=KL});var fI=Y9((Td,OI)=>{function HI(F){if(F instanceof Map)F.clear=F.delete=F.set=function(){throw Error("map is read-only")};else if(F instanceof Set)F.add=F.clear=F.delete=function(){throw Error("set is read-only")};return Object.freeze(F),Object.getOwnPropertyNames(F).forEach((_)=>{let $=F[_],W=typeof $;if((W==="object"||W==="function")&&!Object.isFrozen($))HI($)}),F}class hz{constructor(F){if(F.data===void 0)F.data={};this.data=F.data,this.isMatchIgnored=!1}ignoreMatch(){this.isMatchIgnored=!0}}function wI(F){return F.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")}function Lq(F,..._){let $=Object.create(null);for(let W in F)$[W]=F[W];return _.forEach(function(W){for(let H in W)$[H]=W[H]}),$}var dy="</span>",JI=(F)=>{return!!F.scope},iy=(F,{prefix:_})=>{if(F.startsWith("language:"))return F.replace("language:","language-");if(F.includes(".")){let $=F.split(".");return[`${_}${$.shift()}`,...$.map((W,H)=>`${W}${"_".repeat(H+1)}`)].join(" ")}return`${_}${F}`};class YI{constructor(F,_){this.buffer="",this.classPrefix=_.classPrefix,F.walk(this)}addText(F){this.buffer+=wI(F)}openNode(F){if(!JI(F))return;let _=iy(F.scope,{prefix:this.classPrefix});this.span(_)}closeNode(F){if(!JI(F))return;this.buffer+=dy}value(){return this.buffer}span(F){this.buffer+=`<span class="${F}">`}}var _I=(F={})=>{let _={children:[]};return Object.assign(_,F),_};class Rz{constructor(){this.rootNode=_I(),this.stack=[this.rootNode]}get top(){return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(F){this.top.children.push(F)}openNode(F){let _=_I({scope:F});this.add(_),this.stack.push(_)}closeNode(){if(this.stack.length>1)return this.stack.pop();return}closeAllNodes(){while(this.closeNode());}toJSON(){return JSON.stringify(this.rootNode,null,4)}walk(F){return this.constructor._walk(F,this.rootNode)}static _walk(F,_){if(typeof _==="string")F.addText(_);else if(_.children)F.openNode(_),_.children.forEach(($)=>this._walk(F,$)),F.closeNode(_);return F}static _collapse(F){if(typeof F==="string")return;if(!F.children)return;if(F.children.every((_)=>typeof _==="string"))F.children=[F.children.join("")];else F.children.forEach((_)=>{Rz._collapse(_)})}}class XI extends Rz{constructor(F){super();this.options=F}addText(F){if(F==="")return;this.add(F)}startScope(F){this.openNode(F)}endScope(){this.closeNode()}__addSublanguage(F,_){let $=F.root;if(_)$.scope=`language:${_}`;this.add($)}toHTML(){return new YI(this,this.options).value()}finalize(){return this.closeAllNodes(),!0}}function uQ(F){if(!F)return null;if(typeof F==="string")return F;return F.source}function GI(F){return pJ("(?=",F,")")}function ny(F){return pJ("(?:",F,")*")}function cy(F){return pJ("(?:",F,")?")}function pJ(...F){return F.map(($)=>uQ($)).join("")}function sy(F){let _=F[F.length-1];if(typeof _==="object"&&_.constructor===Object)return F.splice(F.length-1,1),_;else return{}}function Nz(...F){return"("+(sy(F).capture?"":"?:")+F.map((W)=>uQ(W)).join("|")+")"}function KI(F){return new RegExp(F.toString()+"|").exec("").length-1}function oy(F,_){let $=F&&F.exec(_);return $&&$.index===0}var ay=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;function Dz(F,{joinWith:_}){let $=0;return F.map((W)=>{$+=1;let H=$,Y=uQ(W),K="";while(Y.length>0){let G=ay.exec(Y);if(!G){K+=Y;break}if(K+=Y.substring(0,G.index),Y=Y.substring(G.index+G[0].length),G[0][0]==="\\"&&G[1])K+="\\"+String(Number(G[1])+H);else if(K+=G[0],G[0]==="(")$++}return K}).map((W)=>`(${W})`).join(_)}var ry=/\b\B/,UI="[a-zA-Z]\\w*",Mz="[a-zA-Z_]\\w*",BI="\\b\\d+(\\.\\d+)?",zI="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",AI="\\b(0b[01]+)",ty="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",ey=(F={})=>{let _=/^#![ ]*\//;if(F.binary)F.begin=pJ(_,/.*\b/,F.binary,/\b.*/);return Lq({scope:"meta",begin:_,end:/$/,relevance:0,"on:begin":($,W)=>{if($.index!==0)W.ignoreMatch()}},F)},pQ={begin:"\\\\[\\s\\S]",relevance:0},Fv={scope:"string",begin:"'",end:"'",illegal:"\\n",contains:[pQ]},qv={scope:"string",begin:'"',end:'"',illegal:"\\n",contains:[pQ]},Jv={begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},SY=function(F,_,$={}){let W=Lq({scope:"comment",begin:F,end:_,contains:[]},$);W.contains.push({scope:"doctag",begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0});let H=Nz("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/);return W.contains.push({begin:pJ(/[ ]+/,"(",H,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),W},_v=SY("//","$"),Zv=SY("/\\*","\\*/"),$v=SY("#","$"),Qv={scope:"number",begin:BI,relevance:0},Wv={scope:"number",begin:zI,relevance:0},Hv={scope:"number",begin:AI,relevance:0},wv={scope:"regexp",begin:/\/(?=[^/\n]*\/)/,end:/\/[gimuy]*/,contains:[pQ,{begin:/\[/,end:/\]/,relevance:0,contains:[pQ]}]},Yv={scope:"title",begin:UI,relevance:0},Xv={scope:"title",begin:Mz,relevance:0},Gv={begin:"\\.\\s*"+Mz,relevance:0},Kv=function(F){return Object.assign(F,{"on:begin":(_,$)=>{$.data._beginMatch=_[1]},"on:end":(_,$)=>{if($.data._beginMatch!==_[1])$.ignoreMatch()}})},VY=Object.freeze({__proto__:null,APOS_STRING_MODE:Fv,BACKSLASH_ESCAPE:pQ,BINARY_NUMBER_MODE:Hv,BINARY_NUMBER_RE:AI,COMMENT:SY,C_BLOCK_COMMENT_MODE:Zv,C_LINE_COMMENT_MODE:_v,C_NUMBER_MODE:Wv,C_NUMBER_RE:zI,END_SAME_AS_BEGIN:Kv,HASH_COMMENT_MODE:$v,IDENT_RE:UI,MATCH_NOTHING_RE:ry,METHOD_GUARD:Gv,NUMBER_MODE:Qv,NUMBER_RE:BI,PHRASAL_WORDS_MODE:Jv,QUOTE_STRING_MODE:qv,REGEXP_MODE:wv,RE_STARTERS_RE:ty,SHEBANG:ey,TITLE_MODE:Yv,UNDERSCORE_IDENT_RE:Mz,UNDERSCORE_TITLE_MODE:Xv});function Uv(F,_){if(F.input[F.index-1]===".")_.ignoreMatch()}function Bv(F,_){if(F.className!==void 0)F.scope=F.className,delete F.className}function zv(F,_){if(!_)return;if(!F.beginKeywords)return;if(F.begin="\\b("+F.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",F.__beforeBegin=Uv,F.keywords=F.keywords||F.beginKeywords,delete F.beginKeywords,F.relevance===void 0)F.relevance=0}function Av(F,_){if(!Array.isArray(F.illegal))return;F.illegal=Nz(...F.illegal)}function hv(F,_){if(!F.match)return;if(F.begin||F.end)throw Error("begin & end are not supported with match");F.begin=F.match,delete F.match}function Rv(F,_){if(F.relevance===void 0)F.relevance=1}var Nv=(F,_)=>{if(!F.beforeMatch)return;if(F.starts)throw Error("beforeMatch cannot be used with starts");let $=Object.assign({},F);Object.keys(F).forEach((W)=>{delete F[W]}),F.keywords=$.keywords,F.begin=pJ($.beforeMatch,GI($.begin)),F.starts={relevance:0,contains:[Object.assign($,{endsParent:!0})]},F.relevance=0,delete $.beforeMatch},Dv=["of","and","for","in","not","or","if","then","parent","list","value"],Mv="keyword";function hI(F,_,$=Mv){let W=Object.create(null);if(typeof F==="string")H($,F.split(" "));else if(Array.isArray(F))H($,F);else Object.keys(F).forEach(function(Y){Object.assign(W,hI(F[Y],_,Y))});return W;function H(Y,K){if(_)K=K.map((G)=>G.toLowerCase());K.forEach(function(G){let U=G.split("|");W[U[0]]=[Y,Ov(U[0],U[1])]})}}function Ov(F,_){if(_)return Number(_);return fv(F)?0:1}function fv(F){return Dv.includes(F.toLowerCase())}var ZI={},uJ=(F)=>{console.error(F)},$I=(F,..._)=>{console.log(`WARN: ${F}`,..._)},CZ=(F,_)=>{if(ZI[`${F}/${_}`])return;console.log(`Deprecated as of ${F}. ${_}`),ZI[`${F}/${_}`]=!0},kY=Error();function RI(F,_,{key:$}){let W=0,H=F[$],Y={},K={};for(let G=1;G<=_.length;G++)K[G+W]=H[G],Y[G+W]=!0,W+=KI(_[G-1]);F[$]=K,F[$]._emit=Y,F[$]._multi=!0}function Iv(F){if(!Array.isArray(F.begin))return;if(F.skip||F.excludeBegin||F.returnBegin)throw uJ("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),kY;if(typeof F.beginScope!=="object"||F.beginScope===null)throw uJ("beginScope must be object"),kY;RI(F,F.begin,{key:"beginScope"}),F.begin=Dz(F.begin,{joinWith:""})}function Tv(F){if(!Array.isArray(F.end))return;if(F.skip||F.excludeEnd||F.returnEnd)throw uJ("skip, excludeEnd, returnEnd not compatible with endScope: {}"),kY;if(typeof F.endScope!=="object"||F.endScope===null)throw uJ("endScope must be object"),kY;RI(F,F.end,{key:"endScope"}),F.end=Dz(F.end,{joinWith:""})}function Lv(F){if(F.scope&&typeof F.scope==="object"&&F.scope!==null)F.beginScope=F.scope,delete F.scope}function Ev(F){if(Lv(F),typeof F.beginScope==="string")F.beginScope={_wrap:F.beginScope};if(typeof F.endScope==="string")F.endScope={_wrap:F.endScope};Iv(F),Tv(F)}function Cv(F){function _(K,G){return new RegExp(uQ(K),"m"+(F.case_insensitive?"i":"")+(F.unicodeRegex?"u":"")+(G?"g":""))}class ${constructor(){this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}addRule(K,G){G.position=this.position++,this.matchIndexes[this.matchAt]=G,this.regexes.push([G,K]),this.matchAt+=KI(K)+1}compile(){if(this.regexes.length===0)this.exec=()=>null;let K=this.regexes.map((G)=>G[1]);this.matcherRe=_(Dz(K,{joinWith:"|"}),!0),this.lastIndex=0}exec(K){this.matcherRe.lastIndex=this.lastIndex;let G=this.matcherRe.exec(K);if(!G)return null;let U=G.findIndex((h,A)=>A>0&&h!==void 0),z=this.matchIndexes[U];return G.splice(0,U),Object.assign(G,z)}}class W{constructor(){this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(K){if(this.multiRegexes[K])return this.multiRegexes[K];let G=new $;return this.rules.slice(K).forEach(([U,z])=>G.addRule(U,z)),G.compile(),this.multiRegexes[K]=G,G}resumingScanAtSamePosition(){return this.regexIndex!==0}considerAll(){this.regexIndex=0}addRule(K,G){if(this.rules.push([K,G]),G.type==="begin")this.count++}exec(K){let G=this.getMatcher(this.regexIndex);G.lastIndex=this.lastIndex;let U=G.exec(K);if(this.resumingScanAtSamePosition())if(U&&U.index===this.lastIndex);else{let z=this.getMatcher(0);z.lastIndex=this.lastIndex+1,U=z.exec(K)}if(U){if(this.regexIndex+=U.position+1,this.regexIndex===this.count)this.considerAll()}return U}}function H(K){let G=new W;if(K.contains.forEach((U)=>G.addRule(U.begin,{rule:U,type:"begin"})),K.terminatorEnd)G.addRule(K.terminatorEnd,{type:"end"});if(K.illegal)G.addRule(K.illegal,{type:"illegal"});return G}function Y(K,G){let U=K;if(K.isCompiled)return U;[Bv,hv,Ev,Nv].forEach((h)=>h(K,G)),F.compilerExtensions.forEach((h)=>h(K,G)),K.__beforeBegin=null,[zv,Av,Rv].forEach((h)=>h(K,G)),K.isCompiled=!0;let z=null;if(typeof K.keywords==="object"&&K.keywords.$pattern)K.keywords=Object.assign({},K.keywords),z=K.keywords.$pattern,delete K.keywords.$pattern;if(z=z||/\w+/,K.keywords)K.keywords=hI(K.keywords,F.case_insensitive);if(U.keywordPatternRe=_(z,!0),G){if(!K.begin)K.begin=/\B|\b/;if(U.beginRe=_(U.begin),!K.end&&!K.endsWithParent)K.end=/\B|\b/;if(K.end)U.endRe=_(U.end);if(U.terminatorEnd=uQ(U.end)||"",K.endsWithParent&&G.terminatorEnd)U.terminatorEnd+=(K.end?"|":"")+G.terminatorEnd}if(K.illegal)U.illegalRe=_(K.illegal);if(!K.contains)K.contains=[];if(K.contains=[].concat(...K.contains.map(function(h){return Pv(h==="self"?K:h)})),K.contains.forEach(function(h){Y(h,U)}),K.starts)Y(K.starts,G);return U.matcher=H(U),U}if(!F.compilerExtensions)F.compilerExtensions=[];if(F.contains&&F.contains.includes("self"))throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");return F.classNameAliases=Lq(F.classNameAliases||{}),Y(F)}function NI(F){if(!F)return!1;return F.endsWithParent||NI(F.starts)}function Pv(F){if(F.variants&&!F.cachedVariants)F.cachedVariants=F.variants.map(function(_){return Lq(F,{variants:null},_)});if(F.cachedVariants)return F.cachedVariants;if(NI(F))return Lq(F,{starts:F.starts?Lq(F.starts):null});if(Object.isFrozen(F))return Lq(F);return F}var Vv="11.11.1";class DI extends Error{constructor(F,_){super(F);this.name="HTMLInjectionError",this.html=_}}var Az=wI,QI=Lq,WI=Symbol("nomatch"),kv=7,MI=function(F){let _=Object.create(null),$=Object.create(null),W=[],H=!0,Y="Could not find the language '{}', did you forget to load/include a language module?",K={disableAutodetect:!0,name:"Plain text",contains:[]},G={ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",cssSelector:"pre code",languages:null,__emitter:XI};function U(u){return G.noHighlightRe.test(u)}function z(u){let n=u.className+" ";n+=u.parentNode?u.parentNode.className:"";let Q0=G.languageDetectRe.exec(n);if(Q0){let O0=s(Q0[1]);if(!O0)$I(Y.replace("{}",Q0[1])),$I("Falling back to no-highlight mode for this block.",u);return O0?Q0[1]:"no-highlight"}return n.split(/\s+/).find((O0)=>U(O0)||s(O0))}function h(u,n,Q0){let O0="",t="";if(typeof n==="object")O0=u,Q0=n.ignoreIllegals,t=n.language;else CZ("10.7.0","highlight(lang, code, ...args) has been deprecated."),CZ("10.7.0",`Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`),t=u,O0=n;if(Q0===void 0)Q0=!0;let T0={code:O0,language:t};K0("before:highlight",T0);let g0=T0.result?T0.result:A(T0.language,T0.code,Q0);return g0.code=T0.code,K0("after:highlight",g0),g0}function A(u,n,Q0,O0){let t=Object.create(null);function T0(q0,H0){return q0.keywords[H0]}function g0(){if(!C0.keywords){s0.addText(j0);return}let q0=0;C0.keywordPatternRe.lastIndex=0;let H0=C0.keywordPatternRe.exec(j0),W0="";while(H0){W0+=j0.substring(q0,H0.index);let y0=t0.case_insensitive?H0[0].toLowerCase():H0[0],E0=T0(C0,y0);if(E0){let[n0,ZF]=E0;if(s0.addText(W0),W0="",t[y0]=(t[y0]||0)+1,t[y0]<=kv)fF+=ZF;if(n0.startsWith("_"))W0+=H0[0];else{let V0=t0.classNameAliases[n0]||n0;D0(H0[0],V0)}}else W0+=H0[0];q0=C0.keywordPatternRe.lastIndex,H0=C0.keywordPatternRe.exec(j0)}W0+=j0.substring(q0),s0.addText(W0)}function _F(){if(j0==="")return;let q0=null;if(typeof C0.subLanguage==="string"){if(!_[C0.subLanguage]){s0.addText(j0);return}q0=A(C0.subLanguage,j0,!0,AF[C0.subLanguage]),AF[C0.subLanguage]=q0._top}else q0=M(j0,C0.subLanguage.length?C0.subLanguage:null);if(C0.relevance>0)fF+=q0.relevance;s0.__addSublanguage(q0._emitter,q0.language)}function c0(){if(C0.subLanguage!=null)_F();else g0();j0=""}function D0(q0,H0){if(q0==="")return;s0.startScope(H0),s0.addText(q0),s0.endScope()}function P0(q0,H0){let W0=1,y0=H0.length-1;while(W0<=y0){if(!q0._emit[W0]){W0++;continue}let E0=t0.classNameAliases[q0[W0]]||q0[W0],n0=H0[W0];if(E0)D0(n0,E0);else j0=n0,g0(),j0="";W0++}}function S0(q0,H0){if(q0.scope&&typeof q0.scope==="string")s0.openNode(t0.classNameAliases[q0.scope]||q0.scope);if(q0.beginScope){if(q0.beginScope._wrap)D0(j0,t0.classNameAliases[q0.beginScope._wrap]||q0.beginScope._wrap),j0="";else if(q0.beginScope._multi)P0(q0.beginScope,H0),j0=""}return C0=Object.create(q0,{parent:{value:C0}}),C0}function e0(q0,H0,W0){let y0=oy(q0.endRe,W0);if(y0){if(q0["on:end"]){let E0=new hz(q0);if(q0["on:end"](H0,E0),E0.isMatchIgnored)y0=!1}if(y0){while(q0.endsParent&&q0.parent)q0=q0.parent;return q0}}if(q0.endsWithParent)return e0(q0.parent,H0,W0)}function JF(q0){if(C0.matcher.regexIndex===0)return j0+=q0[0],1;else return Y0=!0,0}function UF(q0){let H0=q0[0],W0=q0.rule,y0=new hz(W0),E0=[W0.__beforeBegin,W0["on:begin"]];for(let n0 of E0){if(!n0)continue;if(n0(q0,y0),y0.isMatchIgnored)return JF(H0)}if(W0.skip)j0+=H0;else{if(W0.excludeBegin)j0+=H0;if(c0(),!W0.returnBegin&&!W0.excludeBegin)j0=H0}return S0(W0,q0),W0.returnBegin?0:H0.length}function v0(q0){let H0=q0[0],W0=n.substring(q0.index),y0=e0(C0,q0,W0);if(!y0)return WI;let E0=C0;if(C0.endScope&&C0.endScope._wrap)c0(),D0(H0,C0.endScope._wrap);else if(C0.endScope&&C0.endScope._multi)c0(),P0(C0.endScope,q0);else if(E0.skip)j0+=H0;else{if(!(E0.returnEnd||E0.excludeEnd))j0+=H0;if(c0(),E0.excludeEnd)j0=H0}do{if(C0.scope)s0.closeNode();if(!C0.skip&&!C0.subLanguage)fF+=C0.relevance;C0=C0.parent}while(C0!==y0.parent);if(y0.starts)S0(y0.starts,q0);return E0.returnEnd?0:H0.length}function PF(){let q0=[];for(let H0=C0;H0!==t0;H0=H0.parent)if(H0.scope)q0.unshift(H0.scope);q0.forEach((H0)=>s0.openNode(H0))}let OF={};function jF(q0,H0){let W0=H0&&H0[0];if(j0+=q0,W0==null)return c0(),0;if(OF.type==="begin"&&H0.type==="end"&&OF.index===H0.index&&W0===""){if(j0+=n.slice(H0.index,H0.index+1),!H){let y0=Error(`0 width match regex (${u})`);throw y0.languageName=u,y0.badRule=OF.rule,y0}return 1}if(OF=H0,H0.type==="begin")return UF(H0);else if(H0.type==="illegal"&&!Q0){let y0=Error('Illegal lexeme "'+W0+'" for mode "'+(C0.scope||"<unnamed>")+'"');throw y0.mode=C0,y0}else if(H0.type==="end"){let y0=v0(H0);if(y0!==WI)return y0}if(H0.type==="illegal"&&W0==="")return j0+=`
`,1;if(E>1e5&&E>H0.index*3)throw Error("potential infinite loop, way more iterations than matches");return j0+=W0,W0.length}let t0=s(u);if(!t0)throw uJ(Y.replace("{}",u)),Error('Unknown language: "'+u+'"');let XF=Cv(t0),a="",C0=O0||XF,AF={},s0=new G.__emitter(G);PF();let j0="",fF=0,v=0,E=0,Y0=!1;try{if(!t0.__emitTokens){C0.matcher.considerAll();for(;;){if(E++,Y0)Y0=!1;else C0.matcher.considerAll();C0.matcher.lastIndex=v;let q0=C0.matcher.exec(n);if(!q0)break;let H0=n.substring(v,q0.index),W0=jF(H0,q0);v=q0.index+W0}jF(n.substring(v))}else t0.__emitTokens(n,s0);return s0.finalize(),a=s0.toHTML(),{language:u,value:a,relevance:fF,illegal:!1,_emitter:s0,_top:C0}}catch(q0){if(q0.message&&q0.message.includes("Illegal"))return{language:u,value:Az(n),illegal:!0,relevance:0,_illegalBy:{message:q0.message,index:v,context:n.slice(v-100,v+100),mode:q0.mode,resultSoFar:a},_emitter:s0};else if(H)return{language:u,value:Az(n),illegal:!1,relevance:0,errorRaised:q0,_emitter:s0,_top:C0};else throw q0}}function N(u){let n={value:Az(u),illegal:!1,relevance:0,_top:K,_emitter:new G.__emitter(G)};return n._emitter.addText(u),n}function M(u,n){n=n||G.languages||Object.keys(_);let Q0=N(u),O0=n.filter(s).filter(V).map((c0)=>A(c0,u,!1));O0.unshift(Q0);let t=O0.sort((c0,D0)=>{if(c0.relevance!==D0.relevance)return D0.relevance-c0.relevance;if(c0.language&&D0.language){if(s(c0.language).supersetOf===D0.language)return 1;else if(s(D0.language).supersetOf===c0.language)return-1}return 0}),[T0,g0]=t,_F=T0;return _F.secondBest=g0,_F}function T(u,n,Q0){let O0=n&&$[n]||Q0;u.classList.add("hljs"),u.classList.add(`language-${O0}`)}function P(u){let n=null,Q0=z(u);if(U(Q0))return;if(K0("before:highlightElement",{el:u,language:Q0}),u.dataset.highlighted){console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",u);return}if(u.children.length>0){if(!G.ignoreUnescapedHTML)console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),console.warn("The element with unescaped HTML:"),console.warn(u);if(G.throwUnescapedHTML)throw new DI("One of your code blocks includes unescaped HTML.",u.innerHTML)}n=u;let O0=n.textContent,t=Q0?h(O0,{language:Q0,ignoreIllegals:!0}):M(O0);if(u.innerHTML=t.value,u.dataset.highlighted="yes",T(u,Q0,t.language),u.result={language:t.language,re:t.relevance,relevance:t.relevance},t.secondBest)u.secondBest={language:t.secondBest.language,relevance:t.secondBest.relevance};K0("after:highlightElement",{el:u,result:t,text:O0})}function D(u){G=QI(G,u)}let O=()=>{y(),CZ("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")};function b(){y(),CZ("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")}let k=!1;function y(){function u(){y()}if(document.readyState==="loading"){if(!k)window.addEventListener("DOMContentLoaded",u,!1);k=!0;return}document.querySelectorAll(G.cssSelector).forEach(P)}function m(u,n){let Q0=null;try{Q0=n(F)}catch(O0){if(uJ("Language definition for '{}' could not be registered.".replace("{}",u)),!H)throw O0;else uJ(O0);Q0=K}if(!Q0.name)Q0.name=u;if(_[u]=Q0,Q0.rawDefinition=n.bind(null,F),Q0.aliases)j(Q0.aliases,{languageName:u})}function x(u){delete _[u];for(let n of Object.keys($))if($[n]===u)delete $[n]}function o(){return Object.keys(_)}function s(u){return u=(u||"").toLowerCase(),_[u]||_[$[u]]}function j(u,{languageName:n}){if(typeof u==="string")u=[u];u.forEach((Q0)=>{$[Q0.toLowerCase()]=n})}function V(u){let n=s(u);return n&&!n.disableAutodetect}function d(u){if(u["before:highlightBlock"]&&!u["before:highlightElement"])u["before:highlightElement"]=(n)=>{u["before:highlightBlock"](Object.assign({block:n.el},n))};if(u["after:highlightBlock"]&&!u["after:highlightElement"])u["after:highlightElement"]=(n)=>{u["after:highlightBlock"](Object.assign({block:n.el},n))}}function $0(u){d(u),W.push(u)}function X0(u){let n=W.indexOf(u);if(n!==-1)W.splice(n,1)}function K0(u,n){let Q0=u;W.forEach(function(O0){if(O0[Q0])O0[Q0](n)})}function J0(u){return CZ("10.7.0","highlightBlock will be removed entirely in v12.0"),CZ("10.7.0","Please use highlightElement now."),P(u)}Object.assign(F,{highlight:h,highlightAuto:M,highlightAll:y,highlightElement:P,highlightBlock:J0,configure:D,initHighlighting:O,initHighlightingOnLoad:b,registerLanguage:m,unregisterLanguage:x,listLanguages:o,getLanguage:s,registerAliases:j,autoDetection:V,inherit:QI,addPlugin:$0,removePlugin:X0}),F.debugMode=function(){H=!1},F.safeMode=function(){H=!0},F.versionString=Vv,F.regex={concat:pJ,lookahead:GI,either:Nz,optional:cy,anyNumberOfTimes:ny};for(let u in VY)if(typeof VY[u]==="object")HI(VY[u]);return Object.assign(F,VY),F},PZ=MI({});PZ.newInstance=()=>MI({});OI.exports=PZ;PZ.HighlightJS=PZ;PZ.default=PZ});var LI=Y9((Ed,TI)=>{TI.exports=function(F){var _={$pattern:/\w+|||||:=?/u,keyword:"theorem|10 lemma|10 definition def class structure instance example inductive coinductive axiom axioms hypothesis constant constants universe universes variable variables parameter parameters begin end infix infixr import open theory prelude renaming hiding exposing calc  match do  by let in extends fun assume #check #eval #reduce #print "+"    ",built_in:"Type Prop|10 Sort rw|10 rewrite rwa erw subst substs simp dsimp simpa simp_intros finish unfold unfold1 dunfold unfold_projs unfold_coes delta cc ac_reflexivity ac_refl existsi|10 cases rcases with intro intros introv by_cases refl rfl funext propext exact exacts refine apply eapply fapply apply_with apply_instance induction rename assumption revert generalize specialize clear contradiction by_contradiction by_contra trivial exfalso symmetry transitivity destruct constructor econstructor left right split injection injections repeat try continue skip swap solve1 abstract all_goals any_goals done fail_if_success success_if_fail guard_target guard_hyp have replace at suffices show from congr congr_n congr_arg norm_num ring ",literal:"tt ff",meta:"noncomputable|10 private protected meta mutual",section:"section namespace end",sorry:"sorry admit",symbol:":="},$=/[A-Za-z_][\w\u207F-\u209C\u1D62-\u1D6A\u2079\']*/,W=F.COMMENT("--","$"),H=F.COMMENT("/-[^-]","-/"),Y={className:"doctag",begin:"/-[-!]",end:"-/"},K={className:"meta",begin:"@\\[",end:"\\]"},G={className:"meta",begin:"^attribute",end:"$"},U={className:"theorem",beginKeywords:"def theorem lemma class instance structure",end:/:=/,excludeEnd:!0,contains:[{className:"keyword",begin:/extends/,contains:[{className:"symbol",begin:/:=/,endsParent:!0}]},F.inherit(F.TITLE_MODE,{begin:$}),{className:"params",begin:/[([{]/,end:/[)\]}]/,endsParent:!1,keywords:_},{className:"symbol",begin:/:=/,endsParent:!0},{className:"symbol",begin:/:/,endsParent:!0}],keywords:_};return{name:"lean",keywords:_,contains:[F.QUOTE_STRING_MODE,F.NUMBER_MODE,W,H,Y,U,K,G,{begin://}]}}});var lQ=Y9((Sv)=>{var mJ=U6(d_());(function(){function F(t){if(t==null)return null;if(typeof t==="function")return t.$$typeof===V?null:t.displayName||t.name||null;if(typeof t==="string")return t;switch(t){case P:return"Fragment";case O:return"Profiler";case D:return"StrictMode";case m:return"Suspense";case x:return"SuspenseList";case j:return"Activity"}if(typeof t==="object")switch(typeof t.tag==="number"&&console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),t.$$typeof){case T:return"Portal";case k:return t.displayName||"Context";case b:return(t._context.displayName||"Context")+".Consumer";case y:var T0=t.render;return t=t.displayName,t||(t=T0.displayName||T0.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case o:return T0=t.displayName||null,T0!==null?T0:F(t.type)||"Memo";case s:T0=t._payload,t=t._init;try{return F(t(T0))}catch(g0){}}return null}function _(t){return""+t}function $(t){try{_(t);var T0=!1}catch(c0){T0=!0}if(T0){T0=console;var g0=T0.error,_F=typeof Symbol==="function"&&Symbol.toStringTag&&t[Symbol.toStringTag]||t.constructor.name||"Object";return g0.call(T0,"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",_F),_(t)}}function W(t){if(t===P)return"<>";if(typeof t==="object"&&t!==null&&t.$$typeof===s)return"<...>";try{var T0=F(t);return T0?"<"+T0+">":"<...>"}catch(g0){return"<...>"}}function H(){var t=d.A;return t===null?null:t.getOwner()}function Y(){return Error("react-stack-top-frame")}function K(t){if($0.call(t,"key")){var T0=Object.getOwnPropertyDescriptor(t,"key").get;if(T0&&T0.isReactWarning)return!1}return t.key!==void 0}function G(t,T0){function g0(){J0||(J0=!0,console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",T0))}g0.isReactWarning=!0,Object.defineProperty(t,"key",{get:g0,configurable:!0})}function U(){var t=F(this.type);return u[t]||(u[t]=!0,console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")),t=this.props.ref,t!==void 0?t:null}function z(t,T0,g0,_F,c0,D0){var P0=g0.ref;return t={$$typeof:M,type:t,key:T0,props:g0,_owner:_F},(P0!==void 0?P0:null)!==null?Object.defineProperty(t,"ref",{enumerable:!1,get:U}):Object.defineProperty(t,"ref",{enumerable:!1,value:null}),t._store={},Object.defineProperty(t._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:0}),Object.defineProperty(t,"_debugInfo",{configurable:!1,enumerable:!1,writable:!0,value:null}),Object.defineProperty(t,"_debugStack",{configurable:!1,enumerable:!1,writable:!0,value:c0}),Object.defineProperty(t,"_debugTask",{configurable:!1,enumerable:!1,writable:!0,value:D0}),Object.freeze&&(Object.freeze(t.props),Object.freeze(t)),t}function h(t,T0,g0,_F,c0,D0){var P0=T0.children;if(P0!==void 0)if(_F)if(X0(P0)){for(_F=0;_F<P0.length;_F++)A(P0[_F]);Object.freeze&&Object.freeze(P0)}else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");else A(P0);if($0.call(T0,"key")){P0=F(t);var S0=Object.keys(T0).filter(function(JF){return JF!=="key"});_F=0<S0.length?"{key: someKey, "+S0.join(": ..., ")+": ...}":"{key: someKey}",O0[P0+_F]||(S0=0<S0.length?"{"+S0.join(": ..., ")+": ...}":"{}",console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,_F,P0,S0,P0),O0[P0+_F]=!0)}if(P0=null,g0!==void 0&&($(g0),P0=""+g0),K(T0)&&($(T0.key),P0=""+T0.key),"key"in T0){g0={};for(var e0 in T0)e0!=="key"&&(g0[e0]=T0[e0])}else g0=T0;return P0&&G(g0,typeof t==="function"?t.displayName||t.name||"Unknown":t),z(t,P0,g0,H(),c0,D0)}function A(t){N(t)?t._store&&(t._store.validated=1):typeof t==="object"&&t!==null&&t.$$typeof===s&&(t._payload.status==="fulfilled"?N(t._payload.value)&&t._payload.value._store&&(t._payload.value._store.validated=1):t._store&&(t._store.validated=1))}function N(t){return typeof t==="object"&&t!==null&&t.$$typeof===M}var M=Symbol.for("react.transitional.element"),T=Symbol.for("react.portal"),P=Symbol.for("react.fragment"),D=Symbol.for("react.strict_mode"),O=Symbol.for("react.profiler"),b=Symbol.for("react.consumer"),k=Symbol.for("react.context"),y=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),x=Symbol.for("react.suspense_list"),o=Symbol.for("react.memo"),s=Symbol.for("react.lazy"),j=Symbol.for("react.activity"),V=Symbol.for("react.client.reference"),d=mJ.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,$0=Object.prototype.hasOwnProperty,X0=Array.isArray,K0=console.createTask?console.createTask:function(){return null};mJ={react_stack_bottom_frame:function(t){return t()}};var J0,u={},n=mJ.react_stack_bottom_frame.bind(mJ,Y)(),Q0=K0(W(Y)),O0={};Sv.Fragment=P,Sv.jsxDEV=function(t,T0,g0,_F){var c0=1e4>d.recentlyCreatedOwnerStacks++;return h(t,T0,g0,_F,c0?Error("react-stack-top-frame"):n,c0?K0(W(t)):Q0)}})()});var CF=U6(d_(),1),PI=U6(oM(),1);var NO="182",Rq={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Nq={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},DO=0,S5=1,MO=2;var BQ=1,OO=2,YZ=3,XZ=0,w8=1,V7=2,A9=0,zQ=1,y5=2,v5=3,b5=4,fO=5,GZ=100,IO=101,TO=102,LO=103,EO=104,CO=200,PO=201,VO=202,kO=203,SO=204,yO=205,vO=206,bO=207,jO=208,xO=209,gO=210,uO=211,pO=212,mO=213,lO=214,Pw=0,Vw=1,kw=2,AQ=3,Sw=4,yw=5,vw=6,bw=7,dO=0,iO=1,nO=2,t8=0,j5=1,x5=2,g5=3,u5=4,p5=5,m5=6,l5=7;var KZ=301,DJ=302,jw=303,xw=304,hQ=306,cO=1000,gw=1001,sO=1002,Dq=1003,oO=1004;var RQ=1005;var Y8=1006,uw=1007;var UZ=1008;var e8=1009,aO=1010,rO=1011,NQ=1012,d5=1013,Mq=1014,h9=1015,R9=1016,i5=1017,n5=1018,BZ=1020,tO=35902,eO=35899,Ff=1021,qf=1022,k7=1023,MJ=1026,OJ=1027,Jf=1028,c5=1029,zZ=1030,s5=1031;var o5=1033,pw=33776,mw=33777,lw=33778,dw=33779,a5=35840,r5=35841,t5=35842,e5=35843,FU=36196,qU=37492,JU=37496,_U=37488,ZU=37489,$U=37490,QU=37491,WU=37808,HU=37809,wU=37810,YU=37811,XU=37812,GU=37813,KU=37814,UU=37815,BU=37816,zU=37817,AU=37818,hU=37819,RU=37820,NU=37821,DU=36492,MU=36494,OU=36495,fU=36283,IU=36284,TU=36285,LU=36286;var _f=0,Zf=1,fJ="",$f="srgb",DQ="srgb-linear",EU="linear",G1="srgb";var Qf=512,Wf=513,Hf=514,iw=515,wf=516,Yf=517,nw=518,Xf=519;var CU="300 es",PU=2000;function VU(F){for(let _=F.length-1;_>=0;--_)if(F[_]>=65535)return!0;return!1}function UL(F){return ArrayBuffer.isView(F)&&!(F instanceof DataView)}function UQ(F){return document.createElementNS("http://www.w3.org/1999/xhtml",F)}function Gf(){let F=UQ("canvas");return F.style.display="block",F}var aM={},WZ=null;function kU(...F){let _="THREE."+F.shift();if(WZ)WZ("log",_,...F);else console.log(_,...F)}function zF(...F){let _="THREE."+F.shift();if(WZ)WZ("warn",_,...F);else console.warn(_,...F)}function hF(...F){let _="THREE."+F.shift();if(WZ)WZ("error",_,...F);else console.error(_,...F)}function HZ(...F){let _=F.join(" ");if(_ in aM)return;aM[_]=!0,zF(...F)}function Kf(F,_,$){return new Promise(function(W,H){function Y(){switch(F.clientWaitSync(_,F.SYNC_FLUSH_COMMANDS_BIT,0)){case F.WAIT_FAILED:H();break;case F.TIMEOUT_EXPIRED:setTimeout(Y,$);break;default:W()}}setTimeout(Y,$)})}class N9{addEventListener(F,_){if(this._listeners===void 0)this._listeners={};let $=this._listeners;if($[F]===void 0)$[F]=[];if($[F].indexOf(_)===-1)$[F].push(_)}hasEventListener(F,_){let $=this._listeners;if($===void 0)return!1;return $[F]!==void 0&&$[F].indexOf(_)!==-1}removeEventListener(F,_){let $=this._listeners;if($===void 0)return;let W=$[F];if(W!==void 0){let H=W.indexOf(_);if(H!==-1)W.splice(H,1)}}dispatchEvent(F){let _=this._listeners;if(_===void 0)return;let $=_[F.type];if($!==void 0){F.target=this;let W=$.slice(0);for(let H=0,Y=W.length;H<Y;H++)W[H].call(this,F);F.target=null}}}var B6=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],rM=1234567,GQ=Math.PI/180,wZ=180/Math.PI;function AZ(){let F=Math.random()*4294967295|0,_=Math.random()*4294967295|0,$=Math.random()*4294967295|0,W=Math.random()*4294967295|0;return(B6[F&255]+B6[F>>8&255]+B6[F>>16&255]+B6[F>>24&255]+"-"+B6[_&255]+B6[_>>8&255]+"-"+B6[_>>16&15|64]+B6[_>>24&255]+"-"+B6[$&63|128]+B6[$>>8&255]+"-"+B6[$>>16&255]+B6[$>>24&255]+B6[W&255]+B6[W>>8&255]+B6[W>>16&255]+B6[W>>24&255]).toLowerCase()}function uF(F,_,$){return Math.max(_,Math.min($,F))}function SU(F,_){return(F%_+_)%_}function BL(F,_,$,W,H){return W+(F-_)*(H-W)/($-_)}function zL(F,_,$){if(F!==_)return($-F)/(_-F);else return 0}function KQ(F,_,$){return(1-$)*F+$*_}function AL(F,_,$,W){return KQ(F,_,1-Math.exp(-$*W))}function hL(F,_=1){return _-Math.abs(SU(F,_*2)-_)}function RL(F,_,$){if(F<=_)return 0;if(F>=$)return 1;return F=(F-_)/($-_),F*F*(3-2*F)}function NL(F,_,$){if(F<=_)return 0;if(F>=$)return 1;return F=(F-_)/($-_),F*F*F*(F*(F*6-15)+10)}function DL(F,_){return F+Math.floor(Math.random()*(_-F+1))}function ML(F,_){return F+Math.random()*(_-F)}function OL(F){return F*(0.5-Math.random())}function fL(F){if(F!==void 0)rM=F;let _=rM+=1831565813;return _=Math.imul(_^_>>>15,_|1),_^=_+Math.imul(_^_>>>7,_|61),((_^_>>>14)>>>0)/4294967296}function IL(F){return F*GQ}function TL(F){return F*wZ}function LL(F){return(F&F-1)===0&&F!==0}function EL(F){return Math.pow(2,Math.ceil(Math.log(F)/Math.LN2))}function CL(F){return Math.pow(2,Math.floor(Math.log(F)/Math.LN2))}function PL(F,_,$,W,H){let{cos:Y,sin:K}=Math,G=Y($/2),U=K($/2),z=Y((_+W)/2),h=K((_+W)/2),A=Y((_-W)/2),N=K((_-W)/2),M=Y((W-_)/2),T=K((W-_)/2);switch(H){case"XYX":F.set(G*h,U*A,U*N,G*z);break;case"YZY":F.set(U*N,G*h,U*A,G*z);break;case"ZXZ":F.set(U*A,U*N,G*h,G*z);break;case"XZX":F.set(G*h,U*T,U*M,G*z);break;case"YXY":F.set(U*M,G*h,U*T,G*z);break;case"ZYZ":F.set(U*T,U*M,G*h,G*z);break;default:zF("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+H)}}function ZZ(F,_){switch(_.constructor){case Float32Array:return F;case Uint32Array:return F/4294967295;case Uint16Array:return F/65535;case Uint8Array:return F/255;case Int32Array:return Math.max(F/2147483647,-1);case Int16Array:return Math.max(F/32767,-1);case Int8Array:return Math.max(F/127,-1);default:throw Error("Invalid component type.")}}function P6(F,_){switch(_.constructor){case Float32Array:return F;case Uint32Array:return Math.round(F*4294967295);case Uint16Array:return Math.round(F*65535);case Uint8Array:return Math.round(F*255);case Int32Array:return Math.round(F*2147483647);case Int16Array:return Math.round(F*32767);case Int8Array:return Math.round(F*127);default:throw Error("Invalid component type.")}}var yU={DEG2RAD:GQ,RAD2DEG:wZ,generateUUID:AZ,clamp:uF,euclideanModulo:SU,mapLinear:BL,inverseLerp:zL,lerp:KQ,damp:AL,pingpong:hL,smoothstep:RL,smootherstep:NL,randInt:DL,randFloat:ML,randFloatSpread:OL,seededRandom:fL,degToRad:IL,radToDeg:TL,isPowerOfTwo:LL,ceilPowerOfTwo:EL,floorPowerOfTwo:CL,setQuaternionFromProperEuler:PL,normalize:P6,denormalize:ZZ};class DF{constructor(F=0,_=0){DF.prototype.isVector2=!0,this.x=F,this.y=_}get width(){return this.x}set width(F){this.x=F}get height(){return this.y}set height(F){this.y=F}set(F,_){return this.x=F,this.y=_,this}setScalar(F){return this.x=F,this.y=F,this}setX(F){return this.x=F,this}setY(F){return this.y=F,this}setComponent(F,_){switch(F){case 0:this.x=_;break;case 1:this.y=_;break;default:throw Error("index is out of range: "+F)}return this}getComponent(F){switch(F){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+F)}}clone(){return new this.constructor(this.x,this.y)}copy(F){return this.x=F.x,this.y=F.y,this}add(F){return this.x+=F.x,this.y+=F.y,this}addScalar(F){return this.x+=F,this.y+=F,this}addVectors(F,_){return this.x=F.x+_.x,this.y=F.y+_.y,this}addScaledVector(F,_){return this.x+=F.x*_,this.y+=F.y*_,this}sub(F){return this.x-=F.x,this.y-=F.y,this}subScalar(F){return this.x-=F,this.y-=F,this}subVectors(F,_){return this.x=F.x-_.x,this.y=F.y-_.y,this}multiply(F){return this.x*=F.x,this.y*=F.y,this}multiplyScalar(F){return this.x*=F,this.y*=F,this}divide(F){return this.x/=F.x,this.y/=F.y,this}divideScalar(F){return this.multiplyScalar(1/F)}applyMatrix3(F){let _=this.x,$=this.y,W=F.elements;return this.x=W[0]*_+W[3]*$+W[6],this.y=W[1]*_+W[4]*$+W[7],this}min(F){return this.x=Math.min(this.x,F.x),this.y=Math.min(this.y,F.y),this}max(F){return this.x=Math.max(this.x,F.x),this.y=Math.max(this.y,F.y),this}clamp(F,_){return this.x=uF(this.x,F.x,_.x),this.y=uF(this.y,F.y,_.y),this}clampScalar(F,_){return this.x=uF(this.x,F,_),this.y=uF(this.y,F,_),this}clampLength(F,_){let $=this.length();return this.divideScalar($||1).multiplyScalar(uF($,F,_))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(F){return this.x*F.x+this.y*F.y}cross(F){return this.x*F.y-this.y*F.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(F){let _=Math.sqrt(this.lengthSq()*F.lengthSq());if(_===0)return Math.PI/2;let $=this.dot(F)/_;return Math.acos(uF($,-1,1))}distanceTo(F){return Math.sqrt(this.distanceToSquared(F))}distanceToSquared(F){let _=this.x-F.x,$=this.y-F.y;return _*_+$*$}manhattanDistanceTo(F){return Math.abs(this.x-F.x)+Math.abs(this.y-F.y)}setLength(F){return this.normalize().multiplyScalar(F)}lerp(F,_){return this.x+=(F.x-this.x)*_,this.y+=(F.y-this.y)*_,this}lerpVectors(F,_,$){return this.x=F.x+(_.x-F.x)*$,this.y=F.y+(_.y-F.y)*$,this}equals(F){return F.x===this.x&&F.y===this.y}fromArray(F,_=0){return this.x=F[_],this.y=F[_+1],this}toArray(F=[],_=0){return F[_]=this.x,F[_+1]=this.y,F}fromBufferAttribute(F,_){return this.x=F.getX(_),this.y=F.getY(_),this}rotateAround(F,_){let $=Math.cos(_),W=Math.sin(_),H=this.x-F.x,Y=this.y-F.y;return this.x=H*$-Y*W+F.x,this.y=H*W+Y*$+F.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class F7{constructor(F=0,_=0,$=0,W=1){this.isQuaternion=!0,this._x=F,this._y=_,this._z=$,this._w=W}static slerpFlat(F,_,$,W,H,Y,K){let G=$[W+0],U=$[W+1],z=$[W+2],h=$[W+3],A=H[Y+0],N=H[Y+1],M=H[Y+2],T=H[Y+3];if(K<=0){F[_+0]=G,F[_+1]=U,F[_+2]=z,F[_+3]=h;return}if(K>=1){F[_+0]=A,F[_+1]=N,F[_+2]=M,F[_+3]=T;return}if(h!==T||G!==A||U!==N||z!==M){let P=G*A+U*N+z*M+h*T;if(P<0)A=-A,N=-N,M=-M,T=-T,P=-P;let D=1-K;if(P<0.9995){let O=Math.acos(P),b=Math.sin(O);D=Math.sin(D*O)/b,K=Math.sin(K*O)/b,G=G*D+A*K,U=U*D+N*K,z=z*D+M*K,h=h*D+T*K}else{G=G*D+A*K,U=U*D+N*K,z=z*D+M*K,h=h*D+T*K;let O=1/Math.sqrt(G*G+U*U+z*z+h*h);G*=O,U*=O,z*=O,h*=O}}F[_]=G,F[_+1]=U,F[_+2]=z,F[_+3]=h}static multiplyQuaternionsFlat(F,_,$,W,H,Y){let K=$[W],G=$[W+1],U=$[W+2],z=$[W+3],h=H[Y],A=H[Y+1],N=H[Y+2],M=H[Y+3];return F[_]=K*M+z*h+G*N-U*A,F[_+1]=G*M+z*A+U*h-K*N,F[_+2]=U*M+z*N+K*A-G*h,F[_+3]=z*M-K*h-G*A-U*N,F}get x(){return this._x}set x(F){this._x=F,this._onChangeCallback()}get y(){return this._y}set y(F){this._y=F,this._onChangeCallback()}get z(){return this._z}set z(F){this._z=F,this._onChangeCallback()}get w(){return this._w}set w(F){this._w=F,this._onChangeCallback()}set(F,_,$,W){return this._x=F,this._y=_,this._z=$,this._w=W,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(F){return this._x=F.x,this._y=F.y,this._z=F.z,this._w=F.w,this._onChangeCallback(),this}setFromEuler(F,_=!0){let{_x:$,_y:W,_z:H,_order:Y}=F,K=Math.cos,G=Math.sin,U=K($/2),z=K(W/2),h=K(H/2),A=G($/2),N=G(W/2),M=G(H/2);switch(Y){case"XYZ":this._x=A*z*h+U*N*M,this._y=U*N*h-A*z*M,this._z=U*z*M+A*N*h,this._w=U*z*h-A*N*M;break;case"YXZ":this._x=A*z*h+U*N*M,this._y=U*N*h-A*z*M,this._z=U*z*M-A*N*h,this._w=U*z*h+A*N*M;break;case"ZXY":this._x=A*z*h-U*N*M,this._y=U*N*h+A*z*M,this._z=U*z*M+A*N*h,this._w=U*z*h-A*N*M;break;case"ZYX":this._x=A*z*h-U*N*M,this._y=U*N*h+A*z*M,this._z=U*z*M-A*N*h,this._w=U*z*h+A*N*M;break;case"YZX":this._x=A*z*h+U*N*M,this._y=U*N*h+A*z*M,this._z=U*z*M-A*N*h,this._w=U*z*h-A*N*M;break;case"XZY":this._x=A*z*h-U*N*M,this._y=U*N*h-A*z*M,this._z=U*z*M+A*N*h,this._w=U*z*h+A*N*M;break;default:zF("Quaternion: .setFromEuler() encountered an unknown order: "+Y)}if(_===!0)this._onChangeCallback();return this}setFromAxisAngle(F,_){let $=_/2,W=Math.sin($);return this._x=F.x*W,this._y=F.y*W,this._z=F.z*W,this._w=Math.cos($),this._onChangeCallback(),this}setFromRotationMatrix(F){let _=F.elements,$=_[0],W=_[4],H=_[8],Y=_[1],K=_[5],G=_[9],U=_[2],z=_[6],h=_[10],A=$+K+h;if(A>0){let N=0.5/Math.sqrt(A+1);this._w=0.25/N,this._x=(z-G)*N,this._y=(H-U)*N,this._z=(Y-W)*N}else if($>K&&$>h){let N=2*Math.sqrt(1+$-K-h);this._w=(z-G)/N,this._x=0.25*N,this._y=(W+Y)/N,this._z=(H+U)/N}else if(K>h){let N=2*Math.sqrt(1+K-$-h);this._w=(H-U)/N,this._x=(W+Y)/N,this._y=0.25*N,this._z=(G+z)/N}else{let N=2*Math.sqrt(1+h-$-K);this._w=(Y-W)/N,this._x=(H+U)/N,this._y=(G+z)/N,this._z=0.25*N}return this._onChangeCallback(),this}setFromUnitVectors(F,_){let $=F.dot(_)+1;if($<0.00000001)if($=0,Math.abs(F.x)>Math.abs(F.z))this._x=-F.y,this._y=F.x,this._z=0,this._w=$;else this._x=0,this._y=-F.z,this._z=F.y,this._w=$;else this._x=F.y*_.z-F.z*_.y,this._y=F.z*_.x-F.x*_.z,this._z=F.x*_.y-F.y*_.x,this._w=$;return this.normalize()}angleTo(F){return 2*Math.acos(Math.abs(uF(this.dot(F),-1,1)))}rotateTowards(F,_){let $=this.angleTo(F);if($===0)return this;let W=Math.min(1,_/$);return this.slerp(F,W),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(F){return this._x*F._x+this._y*F._y+this._z*F._z+this._w*F._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let F=this.length();if(F===0)this._x=0,this._y=0,this._z=0,this._w=1;else F=1/F,this._x=this._x*F,this._y=this._y*F,this._z=this._z*F,this._w=this._w*F;return this._onChangeCallback(),this}multiply(F){return this.multiplyQuaternions(this,F)}premultiply(F){return this.multiplyQuaternions(F,this)}multiplyQuaternions(F,_){let{_x:$,_y:W,_z:H,_w:Y}=F,K=_._x,G=_._y,U=_._z,z=_._w;return this._x=$*z+Y*K+W*U-H*G,this._y=W*z+Y*G+H*K-$*U,this._z=H*z+Y*U+$*G-W*K,this._w=Y*z-$*K-W*G-H*U,this._onChangeCallback(),this}slerp(F,_){if(_<=0)return this;if(_>=1)return this.copy(F);let{_x:$,_y:W,_z:H,_w:Y}=F,K=this.dot(F);if(K<0)$=-$,W=-W,H=-H,Y=-Y,K=-K;let G=1-_;if(K<0.9995){let U=Math.acos(K),z=Math.sin(U);G=Math.sin(G*U)/z,_=Math.sin(_*U)/z,this._x=this._x*G+$*_,this._y=this._y*G+W*_,this._z=this._z*G+H*_,this._w=this._w*G+Y*_,this._onChangeCallback()}else this._x=this._x*G+$*_,this._y=this._y*G+W*_,this._z=this._z*G+H*_,this._w=this._w*G+Y*_,this.normalize();return this}slerpQuaternions(F,_,$){return this.copy(F).slerp(_,$)}random(){let F=2*Math.PI*Math.random(),_=2*Math.PI*Math.random(),$=Math.random(),W=Math.sqrt(1-$),H=Math.sqrt($);return this.set(W*Math.sin(F),W*Math.cos(F),H*Math.sin(_),H*Math.cos(_))}equals(F){return F._x===this._x&&F._y===this._y&&F._z===this._z&&F._w===this._w}fromArray(F,_=0){return this._x=F[_],this._y=F[_+1],this._z=F[_+2],this._w=F[_+3],this._onChangeCallback(),this}toArray(F=[],_=0){return F[_]=this._x,F[_+1]=this._y,F[_+2]=this._z,F[_+3]=this._w,F}fromBufferAttribute(F,_){return this._x=F.getX(_),this._y=F.getY(_),this._z=F.getZ(_),this._w=F.getW(_),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(F){return this._onChangeCallback=F,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class w0{constructor(F=0,_=0,$=0){w0.prototype.isVector3=!0,this.x=F,this.y=_,this.z=$}set(F,_,$){if($===void 0)$=this.z;return this.x=F,this.y=_,this.z=$,this}setScalar(F){return this.x=F,this.y=F,this.z=F,this}setX(F){return this.x=F,this}setY(F){return this.y=F,this}setZ(F){return this.z=F,this}setComponent(F,_){switch(F){case 0:this.x=_;break;case 1:this.y=_;break;case 2:this.z=_;break;default:throw Error("index is out of range: "+F)}return this}getComponent(F){switch(F){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+F)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(F){return this.x=F.x,this.y=F.y,this.z=F.z,this}add(F){return this.x+=F.x,this.y+=F.y,this.z+=F.z,this}addScalar(F){return this.x+=F,this.y+=F,this.z+=F,this}addVectors(F,_){return this.x=F.x+_.x,this.y=F.y+_.y,this.z=F.z+_.z,this}addScaledVector(F,_){return this.x+=F.x*_,this.y+=F.y*_,this.z+=F.z*_,this}sub(F){return this.x-=F.x,this.y-=F.y,this.z-=F.z,this}subScalar(F){return this.x-=F,this.y-=F,this.z-=F,this}subVectors(F,_){return this.x=F.x-_.x,this.y=F.y-_.y,this.z=F.z-_.z,this}multiply(F){return this.x*=F.x,this.y*=F.y,this.z*=F.z,this}multiplyScalar(F){return this.x*=F,this.y*=F,this.z*=F,this}multiplyVectors(F,_){return this.x=F.x*_.x,this.y=F.y*_.y,this.z=F.z*_.z,this}applyEuler(F){return this.applyQuaternion(tM.setFromEuler(F))}applyAxisAngle(F,_){return this.applyQuaternion(tM.setFromAxisAngle(F,_))}applyMatrix3(F){let _=this.x,$=this.y,W=this.z,H=F.elements;return this.x=H[0]*_+H[3]*$+H[6]*W,this.y=H[1]*_+H[4]*$+H[7]*W,this.z=H[2]*_+H[5]*$+H[8]*W,this}applyNormalMatrix(F){return this.applyMatrix3(F).normalize()}applyMatrix4(F){let _=this.x,$=this.y,W=this.z,H=F.elements,Y=1/(H[3]*_+H[7]*$+H[11]*W+H[15]);return this.x=(H[0]*_+H[4]*$+H[8]*W+H[12])*Y,this.y=(H[1]*_+H[5]*$+H[9]*W+H[13])*Y,this.z=(H[2]*_+H[6]*$+H[10]*W+H[14])*Y,this}applyQuaternion(F){let _=this.x,$=this.y,W=this.z,H=F.x,Y=F.y,K=F.z,G=F.w,U=2*(Y*W-K*$),z=2*(K*_-H*W),h=2*(H*$-Y*_);return this.x=_+G*U+Y*h-K*z,this.y=$+G*z+K*U-H*h,this.z=W+G*h+H*z-Y*U,this}project(F){return this.applyMatrix4(F.matrixWorldInverse).applyMatrix4(F.projectionMatrix)}unproject(F){return this.applyMatrix4(F.projectionMatrixInverse).applyMatrix4(F.matrixWorld)}transformDirection(F){let _=this.x,$=this.y,W=this.z,H=F.elements;return this.x=H[0]*_+H[4]*$+H[8]*W,this.y=H[1]*_+H[5]*$+H[9]*W,this.z=H[2]*_+H[6]*$+H[10]*W,this.normalize()}divide(F){return this.x/=F.x,this.y/=F.y,this.z/=F.z,this}divideScalar(F){return this.multiplyScalar(1/F)}min(F){return this.x=Math.min(this.x,F.x),this.y=Math.min(this.y,F.y),this.z=Math.min(this.z,F.z),this}max(F){return this.x=Math.max(this.x,F.x),this.y=Math.max(this.y,F.y),this.z=Math.max(this.z,F.z),this}clamp(F,_){return this.x=uF(this.x,F.x,_.x),this.y=uF(this.y,F.y,_.y),this.z=uF(this.z,F.z,_.z),this}clampScalar(F,_){return this.x=uF(this.x,F,_),this.y=uF(this.y,F,_),this.z=uF(this.z,F,_),this}clampLength(F,_){let $=this.length();return this.divideScalar($||1).multiplyScalar(uF($,F,_))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(F){return this.x*F.x+this.y*F.y+this.z*F.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(F){return this.normalize().multiplyScalar(F)}lerp(F,_){return this.x+=(F.x-this.x)*_,this.y+=(F.y-this.y)*_,this.z+=(F.z-this.z)*_,this}lerpVectors(F,_,$){return this.x=F.x+(_.x-F.x)*$,this.y=F.y+(_.y-F.y)*$,this.z=F.z+(_.z-F.z)*$,this}cross(F){return this.crossVectors(this,F)}crossVectors(F,_){let{x:$,y:W,z:H}=F,Y=_.x,K=_.y,G=_.z;return this.x=W*G-H*K,this.y=H*Y-$*G,this.z=$*K-W*Y,this}projectOnVector(F){let _=F.lengthSq();if(_===0)return this.set(0,0,0);let $=F.dot(this)/_;return this.copy(F).multiplyScalar($)}projectOnPlane(F){return w5.copy(this).projectOnVector(F),this.sub(w5)}reflect(F){return this.sub(w5.copy(F).multiplyScalar(2*this.dot(F)))}angleTo(F){let _=Math.sqrt(this.lengthSq()*F.lengthSq());if(_===0)return Math.PI/2;let $=this.dot(F)/_;return Math.acos(uF($,-1,1))}distanceTo(F){return Math.sqrt(this.distanceToSquared(F))}distanceToSquared(F){let _=this.x-F.x,$=this.y-F.y,W=this.z-F.z;return _*_+$*$+W*W}manhattanDistanceTo(F){return Math.abs(this.x-F.x)+Math.abs(this.y-F.y)+Math.abs(this.z-F.z)}setFromSpherical(F){return this.setFromSphericalCoords(F.radius,F.phi,F.theta)}setFromSphericalCoords(F,_,$){let W=Math.sin(_)*F;return this.x=W*Math.sin($),this.y=Math.cos(_)*F,this.z=W*Math.cos($),this}setFromCylindrical(F){return this.setFromCylindricalCoords(F.radius,F.theta,F.y)}setFromCylindricalCoords(F,_,$){return this.x=F*Math.sin(_),this.y=$,this.z=F*Math.cos(_),this}setFromMatrixPosition(F){let _=F.elements;return this.x=_[12],this.y=_[13],this.z=_[14],this}setFromMatrixScale(F){let _=this.setFromMatrixColumn(F,0).length(),$=this.setFromMatrixColumn(F,1).length(),W=this.setFromMatrixColumn(F,2).length();return this.x=_,this.y=$,this.z=W,this}setFromMatrixColumn(F,_){return this.fromArray(F.elements,_*4)}setFromMatrix3Column(F,_){return this.fromArray(F.elements,_*3)}setFromEuler(F){return this.x=F._x,this.y=F._y,this.z=F._z,this}setFromColor(F){return this.x=F.r,this.y=F.g,this.z=F.b,this}equals(F){return F.x===this.x&&F.y===this.y&&F.z===this.z}fromArray(F,_=0){return this.x=F[_],this.y=F[_+1],this.z=F[_+2],this}toArray(F=[],_=0){return F[_]=this.x,F[_+1]=this.y,F[_+2]=this.z,F}fromBufferAttribute(F,_){return this.x=F.getX(_),this.y=F.getY(_),this.z=F.getZ(_),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){let F=Math.random()*Math.PI*2,_=Math.random()*2-1,$=Math.sqrt(1-_*_);return this.x=$*Math.cos(F),this.y=_,this.z=$*Math.sin(F),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}var w5=new w0,tM=new F7;class EF{constructor(F,_,$,W,H,Y,K,G,U){if(EF.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],F!==void 0)this.set(F,_,$,W,H,Y,K,G,U)}set(F,_,$,W,H,Y,K,G,U){let z=this.elements;return z[0]=F,z[1]=W,z[2]=K,z[3]=_,z[4]=H,z[5]=G,z[6]=$,z[7]=Y,z[8]=U,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(F){let _=this.elements,$=F.elements;return _[0]=$[0],_[1]=$[1],_[2]=$[2],_[3]=$[3],_[4]=$[4],_[5]=$[5],_[6]=$[6],_[7]=$[7],_[8]=$[8],this}extractBasis(F,_,$){return F.setFromMatrix3Column(this,0),_.setFromMatrix3Column(this,1),$.setFromMatrix3Column(this,2),this}setFromMatrix4(F){let _=F.elements;return this.set(_[0],_[4],_[8],_[1],_[5],_[9],_[2],_[6],_[10]),this}multiply(F){return this.multiplyMatrices(this,F)}premultiply(F){return this.multiplyMatrices(F,this)}multiplyMatrices(F,_){let $=F.elements,W=_.elements,H=this.elements,Y=$[0],K=$[3],G=$[6],U=$[1],z=$[4],h=$[7],A=$[2],N=$[5],M=$[8],T=W[0],P=W[3],D=W[6],O=W[1],b=W[4],k=W[7],y=W[2],m=W[5],x=W[8];return H[0]=Y*T+K*O+G*y,H[3]=Y*P+K*b+G*m,H[6]=Y*D+K*k+G*x,H[1]=U*T+z*O+h*y,H[4]=U*P+z*b+h*m,H[7]=U*D+z*k+h*x,H[2]=A*T+N*O+M*y,H[5]=A*P+N*b+M*m,H[8]=A*D+N*k+M*x,this}multiplyScalar(F){let _=this.elements;return _[0]*=F,_[3]*=F,_[6]*=F,_[1]*=F,_[4]*=F,_[7]*=F,_[2]*=F,_[5]*=F,_[8]*=F,this}determinant(){let F=this.elements,_=F[0],$=F[1],W=F[2],H=F[3],Y=F[4],K=F[5],G=F[6],U=F[7],z=F[8];return _*Y*z-_*K*U-$*H*z+$*K*G+W*H*U-W*Y*G}invert(){let F=this.elements,_=F[0],$=F[1],W=F[2],H=F[3],Y=F[4],K=F[5],G=F[6],U=F[7],z=F[8],h=z*Y-K*U,A=K*G-z*H,N=U*H-Y*G,M=_*h+$*A+W*N;if(M===0)return this.set(0,0,0,0,0,0,0,0,0);let T=1/M;return F[0]=h*T,F[1]=(W*U-z*$)*T,F[2]=(K*$-W*Y)*T,F[3]=A*T,F[4]=(z*_-W*G)*T,F[5]=(W*H-K*_)*T,F[6]=N*T,F[7]=($*G-U*_)*T,F[8]=(Y*_-$*H)*T,this}transpose(){let F,_=this.elements;return F=_[1],_[1]=_[3],_[3]=F,F=_[2],_[2]=_[6],_[6]=F,F=_[5],_[5]=_[7],_[7]=F,this}getNormalMatrix(F){return this.setFromMatrix4(F).invert().transpose()}transposeIntoArray(F){let _=this.elements;return F[0]=_[0],F[1]=_[3],F[2]=_[6],F[3]=_[1],F[4]=_[4],F[5]=_[7],F[6]=_[2],F[7]=_[5],F[8]=_[8],this}setUvTransform(F,_,$,W,H,Y,K){let G=Math.cos(H),U=Math.sin(H);return this.set($*G,$*U,-$*(G*Y+U*K)+Y+F,-W*U,W*G,-W*(-U*Y+G*K)+K+_,0,0,1),this}scale(F,_){return this.premultiply(Y5.makeScale(F,_)),this}rotate(F){return this.premultiply(Y5.makeRotation(-F)),this}translate(F,_){return this.premultiply(Y5.makeTranslation(F,_)),this}makeTranslation(F,_){if(F.isVector2)this.set(1,0,F.x,0,1,F.y,0,0,1);else this.set(1,0,F,0,1,_,0,0,1);return this}makeRotation(F){let _=Math.cos(F),$=Math.sin(F);return this.set(_,-$,0,$,_,0,0,0,1),this}makeScale(F,_){return this.set(F,0,0,0,_,0,0,0,1),this}equals(F){let _=this.elements,$=F.elements;for(let W=0;W<9;W++)if(_[W]!==$[W])return!1;return!0}fromArray(F,_=0){for(let $=0;$<9;$++)this.elements[$]=F[$+_];return this}toArray(F=[],_=0){let $=this.elements;return F[_]=$[0],F[_+1]=$[1],F[_+2]=$[2],F[_+3]=$[3],F[_+4]=$[4],F[_+5]=$[5],F[_+6]=$[6],F[_+7]=$[7],F[_+8]=$[8],F}clone(){return new this.constructor().fromArray(this.elements)}}var Y5=new EF,eM=new EF().set(0.4123908,0.3575843,0.1804808,0.212639,0.7151687,0.0721923,0.0193308,0.1191948,0.9505322),FO=new EF().set(3.2409699,-1.5373832,-0.4986108,-0.9692436,1.8759675,0.0415551,0.0556301,-0.203977,1.0569715);function VL(){let F={enabled:!0,workingColorSpace:"srgb-linear",spaces:{},convert:function(H,Y,K){if(this.enabled===!1||Y===K||!Y||!K)return H;if(this.spaces[Y].transfer==="srgb")H.r=z9(H.r),H.g=z9(H.g),H.b=z9(H.b);if(this.spaces[Y].primaries!==this.spaces[K].primaries)H.applyMatrix3(this.spaces[Y].toXYZ),H.applyMatrix3(this.spaces[K].fromXYZ);if(this.spaces[K].transfer==="srgb")H.r=QZ(H.r),H.g=QZ(H.g),H.b=QZ(H.b);return H},workingToColorSpace:function(H,Y){return this.convert(H,this.workingColorSpace,Y)},colorSpaceToWorking:function(H,Y){return this.convert(H,Y,this.workingColorSpace)},getPrimaries:function(H){return this.spaces[H].primaries},getTransfer:function(H){if(H==="")return"linear";return this.spaces[H].transfer},getToneMappingMode:function(H){return this.spaces[H].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(H,Y=this.workingColorSpace){return H.fromArray(this.spaces[Y].luminanceCoefficients)},define:function(H){Object.assign(this.spaces,H)},_getMatrix:function(H,Y,K){return H.copy(this.spaces[Y].toXYZ).multiply(this.spaces[K].fromXYZ)},_getDrawingBufferColorSpace:function(H){return this.spaces[H].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(H=this.workingColorSpace){return this.spaces[H].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(H,Y){return HZ("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),F.workingToColorSpace(H,Y)},toWorkingColorSpace:function(H,Y){return HZ("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),F.colorSpaceToWorking(H,Y)}},_=[0.64,0.33,0.3,0.6,0.15,0.06],$=[0.2126,0.7152,0.0722],W=[0.3127,0.329];return F.define({["srgb-linear"]:{primaries:_,whitePoint:W,transfer:"linear",toXYZ:eM,fromXYZ:FO,luminanceCoefficients:$,workingColorSpaceConfig:{unpackColorSpace:"srgb"},outputColorSpaceConfig:{drawingBufferColorSpace:"srgb"}},["srgb"]:{primaries:_,whitePoint:W,transfer:"srgb",toXYZ:eM,fromXYZ:FO,luminanceCoefficients:$,outputColorSpaceConfig:{drawingBufferColorSpace:"srgb"}}}),F}var aF=VL();function z9(F){return F<0.04045?F*0.0773993808:Math.pow(F*0.9478672986+0.0521327014,2.4)}function QZ(F){return F<0.0031308?F*12.92:1.055*Math.pow(F,0.41666)-0.055}var n_;class vU{static getDataURL(F,_="image/png"){if(/^data:/i.test(F.src))return F.src;if(typeof HTMLCanvasElement>"u")return F.src;let $;if(F instanceof HTMLCanvasElement)$=F;else{if(n_===void 0)n_=UQ("canvas");n_.width=F.width,n_.height=F.height;let W=n_.getContext("2d");if(F instanceof ImageData)W.putImageData(F,0,0);else W.drawImage(F,0,0,F.width,F.height);$=n_}return $.toDataURL(_)}static sRGBToLinear(F){if(typeof HTMLImageElement<"u"&&F instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&F instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&F instanceof ImageBitmap){let _=UQ("canvas");_.width=F.width,_.height=F.height;let $=_.getContext("2d");$.drawImage(F,0,0,F.width,F.height);let W=$.getImageData(0,0,F.width,F.height),H=W.data;for(let Y=0;Y<H.length;Y++)H[Y]=z9(H[Y]/255)*255;return $.putImageData(W,0,0),_}else if(F.data){let _=F.data.slice(0);for(let $=0;$<_.length;$++)if(_ instanceof Uint8Array||_ instanceof Uint8ClampedArray)_[$]=Math.floor(z9(_[$]/255)*255);else _[$]=z9(_[$]);return{data:_,width:F.width,height:F.height}}else return zF("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),F}}var kL=0;class MQ{constructor(F=null){this.isSource=!0,Object.defineProperty(this,"id",{value:kL++}),this.uuid=AZ(),this.data=F,this.dataReady=!0,this.version=0}getSize(F){let _=this.data;if(typeof HTMLVideoElement<"u"&&_ instanceof HTMLVideoElement)F.set(_.videoWidth,_.videoHeight,0);else if(typeof VideoFrame<"u"&&_ instanceof VideoFrame)F.set(_.displayHeight,_.displayWidth,0);else if(_!==null)F.set(_.width,_.height,_.depth||0);else F.set(0,0,0);return F}set needsUpdate(F){if(F===!0)this.version++}toJSON(F){let _=F===void 0||typeof F==="string";if(!_&&F.images[this.uuid]!==void 0)return F.images[this.uuid];let $={uuid:this.uuid,url:""},W=this.data;if(W!==null){let H;if(Array.isArray(W)){H=[];for(let Y=0,K=W.length;Y<K;Y++)if(W[Y].isDataTexture)H.push(X5(W[Y].image));else H.push(X5(W[Y]))}else H=X5(W);$.url=H}if(!_)F.images[this.uuid]=$;return $}}function X5(F){if(typeof HTMLImageElement<"u"&&F instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&F instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&F instanceof ImageBitmap)return vU.getDataURL(F);else if(F.data)return{data:Array.from(F.data),width:F.width,height:F.height,type:F.data.constructor.name};else return zF("Texture: Unable to serialize Texture."),{}}var SL=0,G5=new w0;class A6 extends N9{constructor(F=A6.DEFAULT_IMAGE,_=A6.DEFAULT_MAPPING,$=1001,W=1001,H=1006,Y=1008,K=1023,G=1009,U=A6.DEFAULT_ANISOTROPY,z=""){super();this.isTexture=!0,Object.defineProperty(this,"id",{value:SL++}),this.uuid=AZ(),this.name="",this.source=new MQ(F),this.mipmaps=[],this.mapping=_,this.channel=0,this.wrapS=$,this.wrapT=W,this.magFilter=H,this.minFilter=Y,this.anisotropy=U,this.format=K,this.internalFormat=null,this.type=G,this.offset=new DF(0,0),this.repeat=new DF(1,1),this.center=new DF(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new EF,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=z,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=F&&F.depth&&F.depth>1?!0:!1,this.pmremVersion=0}get width(){return this.source.getSize(G5).x}get height(){return this.source.getSize(G5).y}get depth(){return this.source.getSize(G5).z}get image(){return this.source.data}set image(F=null){this.source.data=F}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(F,_){this.updateRanges.push({start:F,count:_})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(F){return this.name=F.name,this.source=F.source,this.mipmaps=F.mipmaps.slice(0),this.mapping=F.mapping,this.channel=F.channel,this.wrapS=F.wrapS,this.wrapT=F.wrapT,this.magFilter=F.magFilter,this.minFilter=F.minFilter,this.anisotropy=F.anisotropy,this.format=F.format,this.internalFormat=F.internalFormat,this.type=F.type,this.offset.copy(F.offset),this.repeat.copy(F.repeat),this.center.copy(F.center),this.rotation=F.rotation,this.matrixAutoUpdate=F.matrixAutoUpdate,this.matrix.copy(F.matrix),this.generateMipmaps=F.generateMipmaps,this.premultiplyAlpha=F.premultiplyAlpha,this.flipY=F.flipY,this.unpackAlignment=F.unpackAlignment,this.colorSpace=F.colorSpace,this.renderTarget=F.renderTarget,this.isRenderTargetTexture=F.isRenderTargetTexture,this.isArrayTexture=F.isArrayTexture,this.userData=JSON.parse(JSON.stringify(F.userData)),this.needsUpdate=!0,this}setValues(F){for(let _ in F){let $=F[_];if($===void 0){zF(`Texture.setValues(): parameter '${_}' has value of undefined.`);continue}let W=this[_];if(W===void 0){zF(`Texture.setValues(): property '${_}' does not exist.`);continue}if(W&&$&&(W.isVector2&&$.isVector2))W.copy($);else if(W&&$&&(W.isVector3&&$.isVector3))W.copy($);else if(W&&$&&(W.isMatrix3&&$.isMatrix3))W.copy($);else this[_]=$}}toJSON(F){let _=F===void 0||typeof F==="string";if(!_&&F.textures[this.uuid]!==void 0)return F.textures[this.uuid];let $={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(F).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(Object.keys(this.userData).length>0)$.userData=this.userData;if(!_)F.textures[this.uuid]=$;return $}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(F){if(this.mapping!==300)return F;if(F.applyMatrix3(this.matrix),F.x<0||F.x>1)switch(this.wrapS){case 1000:F.x=F.x-Math.floor(F.x);break;case 1001:F.x=F.x<0?0:1;break;case 1002:if(Math.abs(Math.floor(F.x)%2)===1)F.x=Math.ceil(F.x)-F.x;else F.x=F.x-Math.floor(F.x);break}if(F.y<0||F.y>1)switch(this.wrapT){case 1000:F.y=F.y-Math.floor(F.y);break;case 1001:F.y=F.y<0?0:1;break;case 1002:if(Math.abs(Math.floor(F.y)%2)===1)F.y=Math.ceil(F.y)-F.y;else F.y=F.y-Math.floor(F.y);break}if(this.flipY)F.y=1-F.y;return F}set needsUpdate(F){if(F===!0)this.version++,this.source.needsUpdate=!0}set needsPMREMUpdate(F){if(F===!0)this.pmremVersion++}}A6.DEFAULT_IMAGE=null;A6.DEFAULT_MAPPING=300;A6.DEFAULT_ANISOTROPY=1;class T1{constructor(F=0,_=0,$=0,W=1){T1.prototype.isVector4=!0,this.x=F,this.y=_,this.z=$,this.w=W}get width(){return this.z}set width(F){this.z=F}get height(){return this.w}set height(F){this.w=F}set(F,_,$,W){return this.x=F,this.y=_,this.z=$,this.w=W,this}setScalar(F){return this.x=F,this.y=F,this.z=F,this.w=F,this}setX(F){return this.x=F,this}setY(F){return this.y=F,this}setZ(F){return this.z=F,this}setW(F){return this.w=F,this}setComponent(F,_){switch(F){case 0:this.x=_;break;case 1:this.y=_;break;case 2:this.z=_;break;case 3:this.w=_;break;default:throw Error("index is out of range: "+F)}return this}getComponent(F){switch(F){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+F)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(F){return this.x=F.x,this.y=F.y,this.z=F.z,this.w=F.w!==void 0?F.w:1,this}add(F){return this.x+=F.x,this.y+=F.y,this.z+=F.z,this.w+=F.w,this}addScalar(F){return this.x+=F,this.y+=F,this.z+=F,this.w+=F,this}addVectors(F,_){return this.x=F.x+_.x,this.y=F.y+_.y,this.z=F.z+_.z,this.w=F.w+_.w,this}addScaledVector(F,_){return this.x+=F.x*_,this.y+=F.y*_,this.z+=F.z*_,this.w+=F.w*_,this}sub(F){return this.x-=F.x,this.y-=F.y,this.z-=F.z,this.w-=F.w,this}subScalar(F){return this.x-=F,this.y-=F,this.z-=F,this.w-=F,this}subVectors(F,_){return this.x=F.x-_.x,this.y=F.y-_.y,this.z=F.z-_.z,this.w=F.w-_.w,this}multiply(F){return this.x*=F.x,this.y*=F.y,this.z*=F.z,this.w*=F.w,this}multiplyScalar(F){return this.x*=F,this.y*=F,this.z*=F,this.w*=F,this}applyMatrix4(F){let _=this.x,$=this.y,W=this.z,H=this.w,Y=F.elements;return this.x=Y[0]*_+Y[4]*$+Y[8]*W+Y[12]*H,this.y=Y[1]*_+Y[5]*$+Y[9]*W+Y[13]*H,this.z=Y[2]*_+Y[6]*$+Y[10]*W+Y[14]*H,this.w=Y[3]*_+Y[7]*$+Y[11]*W+Y[15]*H,this}divide(F){return this.x/=F.x,this.y/=F.y,this.z/=F.z,this.w/=F.w,this}divideScalar(F){return this.multiplyScalar(1/F)}setAxisAngleFromQuaternion(F){this.w=2*Math.acos(F.w);let _=Math.sqrt(1-F.w*F.w);if(_<0.0001)this.x=1,this.y=0,this.z=0;else this.x=F.x/_,this.y=F.y/_,this.z=F.z/_;return this}setAxisAngleFromRotationMatrix(F){let _,$,W,H,Y=0.01,K=0.1,G=F.elements,U=G[0],z=G[4],h=G[8],A=G[1],N=G[5],M=G[9],T=G[2],P=G[6],D=G[10];if(Math.abs(z-A)<0.01&&Math.abs(h-T)<0.01&&Math.abs(M-P)<0.01){if(Math.abs(z+A)<0.1&&Math.abs(h+T)<0.1&&Math.abs(M+P)<0.1&&Math.abs(U+N+D-3)<0.1)return this.set(1,0,0,0),this;_=Math.PI;let b=(U+1)/2,k=(N+1)/2,y=(D+1)/2,m=(z+A)/4,x=(h+T)/4,o=(M+P)/4;if(b>k&&b>y)if(b<0.01)$=0,W=0.707106781,H=0.707106781;else $=Math.sqrt(b),W=m/$,H=x/$;else if(k>y)if(k<0.01)$=0.707106781,W=0,H=0.707106781;else W=Math.sqrt(k),$=m/W,H=o/W;else if(y<0.01)$=0.707106781,W=0.707106781,H=0;else H=Math.sqrt(y),$=x/H,W=o/H;return this.set($,W,H,_),this}let O=Math.sqrt((P-M)*(P-M)+(h-T)*(h-T)+(A-z)*(A-z));if(Math.abs(O)<0.001)O=1;return this.x=(P-M)/O,this.y=(h-T)/O,this.z=(A-z)/O,this.w=Math.acos((U+N+D-1)/2),this}setFromMatrixPosition(F){let _=F.elements;return this.x=_[12],this.y=_[13],this.z=_[14],this.w=_[15],this}min(F){return this.x=Math.min(this.x,F.x),this.y=Math.min(this.y,F.y),this.z=Math.min(this.z,F.z),this.w=Math.min(this.w,F.w),this}max(F){return this.x=Math.max(this.x,F.x),this.y=Math.max(this.y,F.y),this.z=Math.max(this.z,F.z),this.w=Math.max(this.w,F.w),this}clamp(F,_){return this.x=uF(this.x,F.x,_.x),this.y=uF(this.y,F.y,_.y),this.z=uF(this.z,F.z,_.z),this.w=uF(this.w,F.w,_.w),this}clampScalar(F,_){return this.x=uF(this.x,F,_),this.y=uF(this.y,F,_),this.z=uF(this.z,F,_),this.w=uF(this.w,F,_),this}clampLength(F,_){let $=this.length();return this.divideScalar($||1).multiplyScalar(uF($,F,_))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(F){return this.x*F.x+this.y*F.y+this.z*F.z+this.w*F.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(F){return this.normalize().multiplyScalar(F)}lerp(F,_){return this.x+=(F.x-this.x)*_,this.y+=(F.y-this.y)*_,this.z+=(F.z-this.z)*_,this.w+=(F.w-this.w)*_,this}lerpVectors(F,_,$){return this.x=F.x+(_.x-F.x)*$,this.y=F.y+(_.y-F.y)*$,this.z=F.z+(_.z-F.z)*$,this.w=F.w+(_.w-F.w)*$,this}equals(F){return F.x===this.x&&F.y===this.y&&F.z===this.z&&F.w===this.w}fromArray(F,_=0){return this.x=F[_],this.y=F[_+1],this.z=F[_+2],this.w=F[_+3],this}toArray(F=[],_=0){return F[_]=this.x,F[_+1]=this.y,F[_+2]=this.z,F[_+3]=this.w,F}fromBufferAttribute(F,_){return this.x=F.getX(_),this.y=F.getY(_),this.z=F.getZ(_),this.w=F.getW(_),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class bU extends N9{constructor(F=1,_=1,$={}){super();$=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:1006,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},$),this.isRenderTarget=!0,this.width=F,this.height=_,this.depth=$.depth,this.scissor=new T1(0,0,F,_),this.scissorTest=!1,this.viewport=new T1(0,0,F,_);let W={width:F,height:_,depth:$.depth},H=new A6(W);this.textures=[];let Y=$.count;for(let K=0;K<Y;K++)this.textures[K]=H.clone(),this.textures[K].isRenderTargetTexture=!0,this.textures[K].renderTarget=this;this._setTextureOptions($),this.depthBuffer=$.depthBuffer,this.stencilBuffer=$.stencilBuffer,this.resolveDepthBuffer=$.resolveDepthBuffer,this.resolveStencilBuffer=$.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=$.depthTexture,this.samples=$.samples,this.multiview=$.multiview}_setTextureOptions(F={}){let _={minFilter:1006,generateMipmaps:!1,flipY:!1,internalFormat:null};if(F.mapping!==void 0)_.mapping=F.mapping;if(F.wrapS!==void 0)_.wrapS=F.wrapS;if(F.wrapT!==void 0)_.wrapT=F.wrapT;if(F.wrapR!==void 0)_.wrapR=F.wrapR;if(F.magFilter!==void 0)_.magFilter=F.magFilter;if(F.minFilter!==void 0)_.minFilter=F.minFilter;if(F.format!==void 0)_.format=F.format;if(F.type!==void 0)_.type=F.type;if(F.anisotropy!==void 0)_.anisotropy=F.anisotropy;if(F.colorSpace!==void 0)_.colorSpace=F.colorSpace;if(F.flipY!==void 0)_.flipY=F.flipY;if(F.generateMipmaps!==void 0)_.generateMipmaps=F.generateMipmaps;if(F.internalFormat!==void 0)_.internalFormat=F.internalFormat;for(let $=0;$<this.textures.length;$++)this.textures[$].setValues(_)}get texture(){return this.textures[0]}set texture(F){this.textures[0]=F}set depthTexture(F){if(this._depthTexture!==null)this._depthTexture.renderTarget=null;if(F!==null)F.renderTarget=this;this._depthTexture=F}get depthTexture(){return this._depthTexture}setSize(F,_,$=1){if(this.width!==F||this.height!==_||this.depth!==$){this.width=F,this.height=_,this.depth=$;for(let W=0,H=this.textures.length;W<H;W++)if(this.textures[W].image.width=F,this.textures[W].image.height=_,this.textures[W].image.depth=$,this.textures[W].isData3DTexture!==!0)this.textures[W].isArrayTexture=this.textures[W].image.depth>1;this.dispose()}this.viewport.set(0,0,F,_),this.scissor.set(0,0,F,_)}clone(){return new this.constructor().copy(this)}copy(F){this.width=F.width,this.height=F.height,this.depth=F.depth,this.scissor.copy(F.scissor),this.scissorTest=F.scissorTest,this.viewport.copy(F.viewport),this.textures.length=0;for(let _=0,$=F.textures.length;_<$;_++){this.textures[_]=F.textures[_].clone(),this.textures[_].isRenderTargetTexture=!0,this.textures[_].renderTarget=this;let W=Object.assign({},F.textures[_].image);this.textures[_].source=new MQ(W)}if(this.depthBuffer=F.depthBuffer,this.stencilBuffer=F.stencilBuffer,this.resolveDepthBuffer=F.resolveDepthBuffer,this.resolveStencilBuffer=F.resolveStencilBuffer,F.depthTexture!==null)this.depthTexture=F.depthTexture.clone();return this.samples=F.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class P8 extends bU{constructor(F=1,_=1,$={}){super(F,_,$);this.isWebGLRenderTarget=!0}}class cw extends A6{constructor(F=null,_=1,$=1,W=1){super(null);this.isDataArrayTexture=!0,this.image={data:F,width:_,height:$,depth:W},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(F){this.layerUpdates.add(F)}clearLayerUpdates(){this.layerUpdates.clear()}}class jU extends A6{constructor(F=null,_=1,$=1,W=1){super(null);this.isData3DTexture=!0,this.image={data:F,width:_,height:$,depth:W},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class IJ{constructor(F=new w0(1/0,1/0,1/0),_=new w0(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=F,this.max=_}set(F,_){return this.min.copy(F),this.max.copy(_),this}setFromArray(F){this.makeEmpty();for(let _=0,$=F.length;_<$;_+=3)this.expandByPoint(c8.fromArray(F,_));return this}setFromBufferAttribute(F){this.makeEmpty();for(let _=0,$=F.count;_<$;_++)this.expandByPoint(c8.fromBufferAttribute(F,_));return this}setFromPoints(F){this.makeEmpty();for(let _=0,$=F.length;_<$;_++)this.expandByPoint(F[_]);return this}setFromCenterAndSize(F,_){let $=c8.copy(_).multiplyScalar(0.5);return this.min.copy(F).sub($),this.max.copy(F).add($),this}setFromObject(F,_=!1){return this.makeEmpty(),this.expandByObject(F,_)}clone(){return new this.constructor().copy(this)}copy(F){return this.min.copy(F.min),this.max.copy(F.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(F){return this.isEmpty()?F.set(0,0,0):F.addVectors(this.min,this.max).multiplyScalar(0.5)}getSize(F){return this.isEmpty()?F.set(0,0,0):F.subVectors(this.max,this.min)}expandByPoint(F){return this.min.min(F),this.max.max(F),this}expandByVector(F){return this.min.sub(F),this.max.add(F),this}expandByScalar(F){return this.min.addScalar(-F),this.max.addScalar(F),this}expandByObject(F,_=!1){F.updateWorldMatrix(!1,!1);let $=F.geometry;if($!==void 0){let H=$.getAttribute("position");if(_===!0&&H!==void 0&&F.isInstancedMesh!==!0)for(let Y=0,K=H.count;Y<K;Y++){if(F.isMesh===!0)F.getVertexPosition(Y,c8);else c8.fromBufferAttribute(H,Y);c8.applyMatrix4(F.matrixWorld),this.expandByPoint(c8)}else{if(F.boundingBox!==void 0){if(F.boundingBox===null)F.computeBoundingBox();Hw.copy(F.boundingBox)}else{if($.boundingBox===null)$.computeBoundingBox();Hw.copy($.boundingBox)}Hw.applyMatrix4(F.matrixWorld),this.union(Hw)}}let W=F.children;for(let H=0,Y=W.length;H<Y;H++)this.expandByObject(W[H],_);return this}containsPoint(F){return F.x>=this.min.x&&F.x<=this.max.x&&F.y>=this.min.y&&F.y<=this.max.y&&F.z>=this.min.z&&F.z<=this.max.z}containsBox(F){return this.min.x<=F.min.x&&F.max.x<=this.max.x&&this.min.y<=F.min.y&&F.max.y<=this.max.y&&this.min.z<=F.min.z&&F.max.z<=this.max.z}getParameter(F,_){return _.set((F.x-this.min.x)/(this.max.x-this.min.x),(F.y-this.min.y)/(this.max.y-this.min.y),(F.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(F){return F.max.x>=this.min.x&&F.min.x<=this.max.x&&F.max.y>=this.min.y&&F.min.y<=this.max.y&&F.max.z>=this.min.z&&F.min.z<=this.max.z}intersectsSphere(F){return this.clampPoint(F.center,c8),c8.distanceToSquared(F.center)<=F.radius*F.radius}intersectsPlane(F){let _,$;if(F.normal.x>0)_=F.normal.x*this.min.x,$=F.normal.x*this.max.x;else _=F.normal.x*this.max.x,$=F.normal.x*this.min.x;if(F.normal.y>0)_+=F.normal.y*this.min.y,$+=F.normal.y*this.max.y;else _+=F.normal.y*this.max.y,$+=F.normal.y*this.min.y;if(F.normal.z>0)_+=F.normal.z*this.min.z,$+=F.normal.z*this.max.z;else _+=F.normal.z*this.max.z,$+=F.normal.z*this.min.z;return _<=-F.constant&&$>=-F.constant}intersectsTriangle(F){if(this.isEmpty())return!1;this.getCenter(WQ),ww.subVectors(this.max,WQ),c_.subVectors(F.a,WQ),s_.subVectors(F.b,WQ),o_.subVectors(F.c,WQ),Kq.subVectors(s_,c_),Uq.subVectors(o_,s_),AJ.subVectors(c_,o_);let _=[0,-Kq.z,Kq.y,0,-Uq.z,Uq.y,0,-AJ.z,AJ.y,Kq.z,0,-Kq.x,Uq.z,0,-Uq.x,AJ.z,0,-AJ.x,-Kq.y,Kq.x,0,-Uq.y,Uq.x,0,-AJ.y,AJ.x,0];if(!K5(_,c_,s_,o_,ww))return!1;if(_=[1,0,0,0,1,0,0,0,1],!K5(_,c_,s_,o_,ww))return!1;return Yw.crossVectors(Kq,Uq),_=[Yw.x,Yw.y,Yw.z],K5(_,c_,s_,o_,ww)}clampPoint(F,_){return _.copy(F).clamp(this.min,this.max)}distanceToPoint(F){return this.clampPoint(F,c8).distanceTo(F)}getBoundingSphere(F){if(this.isEmpty())F.makeEmpty();else this.getCenter(F.center),F.radius=this.getSize(c8).length()*0.5;return F}intersect(F){if(this.min.max(F.min),this.max.min(F.max),this.isEmpty())this.makeEmpty();return this}union(F){return this.min.min(F.min),this.max.max(F.max),this}applyMatrix4(F){if(this.isEmpty())return this;return X9[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(F),X9[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(F),X9[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(F),X9[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(F),X9[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(F),X9[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(F),X9[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(F),X9[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(F),this.setFromPoints(X9),this}translate(F){return this.min.add(F),this.max.add(F),this}equals(F){return F.min.equals(this.min)&&F.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(F){return this.min.fromArray(F.min),this.max.fromArray(F.max),this}}var X9=[new w0,new w0,new w0,new w0,new w0,new w0,new w0,new w0],c8=new w0,Hw=new IJ,c_=new w0,s_=new w0,o_=new w0,Kq=new w0,Uq=new w0,AJ=new w0,WQ=new w0,ww=new w0,Yw=new w0,hJ=new w0;function K5(F,_,$,W,H){for(let Y=0,K=F.length-3;Y<=K;Y+=3){hJ.fromArray(F,Y);let G=H.x*Math.abs(hJ.x)+H.y*Math.abs(hJ.y)+H.z*Math.abs(hJ.z),U=_.dot(hJ),z=$.dot(hJ),h=W.dot(hJ);if(Math.max(-Math.max(U,z,h),Math.min(U,z,h))>G)return!1}return!0}var yL=new IJ,HQ=new w0,U5=new w0;class hZ{constructor(F=new w0,_=-1){this.isSphere=!0,this.center=F,this.radius=_}set(F,_){return this.center.copy(F),this.radius=_,this}setFromPoints(F,_){let $=this.center;if(_!==void 0)$.copy(_);else yL.setFromPoints(F).getCenter($);let W=0;for(let H=0,Y=F.length;H<Y;H++)W=Math.max(W,$.distanceToSquared(F[H]));return this.radius=Math.sqrt(W),this}copy(F){return this.center.copy(F.center),this.radius=F.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(F){return F.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(F){return F.distanceTo(this.center)-this.radius}intersectsSphere(F){let _=this.radius+F.radius;return F.center.distanceToSquared(this.center)<=_*_}intersectsBox(F){return F.intersectsSphere(this)}intersectsPlane(F){return Math.abs(F.distanceToPoint(this.center))<=this.radius}clampPoint(F,_){let $=this.center.distanceToSquared(F);if(_.copy(F),$>this.radius*this.radius)_.sub(this.center).normalize(),_.multiplyScalar(this.radius).add(this.center);return _}getBoundingBox(F){if(this.isEmpty())return F.makeEmpty(),F;return F.set(this.center,this.center),F.expandByScalar(this.radius),F}applyMatrix4(F){return this.center.applyMatrix4(F),this.radius=this.radius*F.getMaxScaleOnAxis(),this}translate(F){return this.center.add(F),this}expandByPoint(F){if(this.isEmpty())return this.center.copy(F),this.radius=0,this;HQ.subVectors(F,this.center);let _=HQ.lengthSq();if(_>this.radius*this.radius){let $=Math.sqrt(_),W=($-this.radius)*0.5;this.center.addScaledVector(HQ,W/$),this.radius+=W}return this}union(F){if(F.isEmpty())return this;if(this.isEmpty())return this.copy(F),this;if(this.center.equals(F.center)===!0)this.radius=Math.max(this.radius,F.radius);else U5.subVectors(F.center,this.center).setLength(F.radius),this.expandByPoint(HQ.copy(F.center).add(U5)),this.expandByPoint(HQ.copy(F.center).sub(U5));return this}equals(F){return F.center.equals(this.center)&&F.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(F){return this.radius=F.radius,this.center.fromArray(F.center),this}}var G9=new w0,B5=new w0,Xw=new w0,Bq=new w0,z5=new w0,Gw=new w0,A5=new w0;class TJ{constructor(F=new w0,_=new w0(0,0,-1)){this.origin=F,this.direction=_}set(F,_){return this.origin.copy(F),this.direction.copy(_),this}copy(F){return this.origin.copy(F.origin),this.direction.copy(F.direction),this}at(F,_){return _.copy(this.origin).addScaledVector(this.direction,F)}lookAt(F){return this.direction.copy(F).sub(this.origin).normalize(),this}recast(F){return this.origin.copy(this.at(F,G9)),this}closestPointToPoint(F,_){_.subVectors(F,this.origin);let $=_.dot(this.direction);if($<0)return _.copy(this.origin);return _.copy(this.origin).addScaledVector(this.direction,$)}distanceToPoint(F){return Math.sqrt(this.distanceSqToPoint(F))}distanceSqToPoint(F){let _=G9.subVectors(F,this.origin).dot(this.direction);if(_<0)return this.origin.distanceToSquared(F);return G9.copy(this.origin).addScaledVector(this.direction,_),G9.distanceToSquared(F)}distanceSqToSegment(F,_,$,W){B5.copy(F).add(_).multiplyScalar(0.5),Xw.copy(_).sub(F).normalize(),Bq.copy(this.origin).sub(B5);let H=F.distanceTo(_)*0.5,Y=-this.direction.dot(Xw),K=Bq.dot(this.direction),G=-Bq.dot(Xw),U=Bq.lengthSq(),z=Math.abs(1-Y*Y),h,A,N,M;if(z>0)if(h=Y*G-K,A=Y*K-G,M=H*z,h>=0)if(A>=-M)if(A<=M){let T=1/z;h*=T,A*=T,N=h*(h+Y*A+2*K)+A*(Y*h+A+2*G)+U}else A=H,h=Math.max(0,-(Y*A+K)),N=-h*h+A*(A+2*G)+U;else A=-H,h=Math.max(0,-(Y*A+K)),N=-h*h+A*(A+2*G)+U;else if(A<=-M)h=Math.max(0,-(-Y*H+K)),A=h>0?-H:Math.min(Math.max(-H,-G),H),N=-h*h+A*(A+2*G)+U;else if(A<=M)h=0,A=Math.min(Math.max(-H,-G),H),N=A*(A+2*G)+U;else h=Math.max(0,-(Y*H+K)),A=h>0?H:Math.min(Math.max(-H,-G),H),N=-h*h+A*(A+2*G)+U;else A=Y>0?-H:H,h=Math.max(0,-(Y*A+K)),N=-h*h+A*(A+2*G)+U;if($)$.copy(this.origin).addScaledVector(this.direction,h);if(W)W.copy(B5).addScaledVector(Xw,A);return N}intersectSphere(F,_){G9.subVectors(F.center,this.origin);let $=G9.dot(this.direction),W=G9.dot(G9)-$*$,H=F.radius*F.radius;if(W>H)return null;let Y=Math.sqrt(H-W),K=$-Y,G=$+Y;if(G<0)return null;if(K<0)return this.at(G,_);return this.at(K,_)}intersectsSphere(F){if(F.radius<0)return!1;return this.distanceSqToPoint(F.center)<=F.radius*F.radius}distanceToPlane(F){let _=F.normal.dot(this.direction);if(_===0){if(F.distanceToPoint(this.origin)===0)return 0;return null}let $=-(this.origin.dot(F.normal)+F.constant)/_;return $>=0?$:null}intersectPlane(F,_){let $=this.distanceToPlane(F);if($===null)return null;return this.at($,_)}intersectsPlane(F){let _=F.distanceToPoint(this.origin);if(_===0)return!0;if(F.normal.dot(this.direction)*_<0)return!0;return!1}intersectBox(F,_){let $,W,H,Y,K,G,U=1/this.direction.x,z=1/this.direction.y,h=1/this.direction.z,A=this.origin;if(U>=0)$=(F.min.x-A.x)*U,W=(F.max.x-A.x)*U;else $=(F.max.x-A.x)*U,W=(F.min.x-A.x)*U;if(z>=0)H=(F.min.y-A.y)*z,Y=(F.max.y-A.y)*z;else H=(F.max.y-A.y)*z,Y=(F.min.y-A.y)*z;if($>Y||H>W)return null;if(H>$||isNaN($))$=H;if(Y<W||isNaN(W))W=Y;if(h>=0)K=(F.min.z-A.z)*h,G=(F.max.z-A.z)*h;else K=(F.max.z-A.z)*h,G=(F.min.z-A.z)*h;if($>G||K>W)return null;if(K>$||$!==$)$=K;if(G<W||W!==W)W=G;if(W<0)return null;return this.at($>=0?$:W,_)}intersectsBox(F){return this.intersectBox(F,G9)!==null}intersectTriangle(F,_,$,W,H){z5.subVectors(_,F),Gw.subVectors($,F),A5.crossVectors(z5,Gw);let Y=this.direction.dot(A5),K;if(Y>0){if(W)return null;K=1}else if(Y<0)K=-1,Y=-Y;else return null;Bq.subVectors(this.origin,F);let G=K*this.direction.dot(Gw.crossVectors(Bq,Gw));if(G<0)return null;let U=K*this.direction.dot(z5.cross(Bq));if(U<0)return null;if(G+U>Y)return null;let z=-K*Bq.dot(A5);if(z<0)return null;return this.at(z/Y,H)}applyMatrix4(F){return this.origin.applyMatrix4(F),this.direction.transformDirection(F),this}equals(F){return F.origin.equals(this.origin)&&F.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class N1{constructor(F,_,$,W,H,Y,K,G,U,z,h,A,N,M,T,P){if(N1.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],F!==void 0)this.set(F,_,$,W,H,Y,K,G,U,z,h,A,N,M,T,P)}set(F,_,$,W,H,Y,K,G,U,z,h,A,N,M,T,P){let D=this.elements;return D[0]=F,D[4]=_,D[8]=$,D[12]=W,D[1]=H,D[5]=Y,D[9]=K,D[13]=G,D[2]=U,D[6]=z,D[10]=h,D[14]=A,D[3]=N,D[7]=M,D[11]=T,D[15]=P,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new N1().fromArray(this.elements)}copy(F){let _=this.elements,$=F.elements;return _[0]=$[0],_[1]=$[1],_[2]=$[2],_[3]=$[3],_[4]=$[4],_[5]=$[5],_[6]=$[6],_[7]=$[7],_[8]=$[8],_[9]=$[9],_[10]=$[10],_[11]=$[11],_[12]=$[12],_[13]=$[13],_[14]=$[14],_[15]=$[15],this}copyPosition(F){let _=this.elements,$=F.elements;return _[12]=$[12],_[13]=$[13],_[14]=$[14],this}setFromMatrix3(F){let _=F.elements;return this.set(_[0],_[3],_[6],0,_[1],_[4],_[7],0,_[2],_[5],_[8],0,0,0,0,1),this}extractBasis(F,_,$){if(this.determinant()===0)return F.set(1,0,0),_.set(0,1,0),$.set(0,0,1),this;return F.setFromMatrixColumn(this,0),_.setFromMatrixColumn(this,1),$.setFromMatrixColumn(this,2),this}makeBasis(F,_,$){return this.set(F.x,_.x,$.x,0,F.y,_.y,$.y,0,F.z,_.z,$.z,0,0,0,0,1),this}extractRotation(F){if(F.determinant()===0)return this.identity();let _=this.elements,$=F.elements,W=1/a_.setFromMatrixColumn(F,0).length(),H=1/a_.setFromMatrixColumn(F,1).length(),Y=1/a_.setFromMatrixColumn(F,2).length();return _[0]=$[0]*W,_[1]=$[1]*W,_[2]=$[2]*W,_[3]=0,_[4]=$[4]*H,_[5]=$[5]*H,_[6]=$[6]*H,_[7]=0,_[8]=$[8]*Y,_[9]=$[9]*Y,_[10]=$[10]*Y,_[11]=0,_[12]=0,_[13]=0,_[14]=0,_[15]=1,this}makeRotationFromEuler(F){let _=this.elements,$=F.x,W=F.y,H=F.z,Y=Math.cos($),K=Math.sin($),G=Math.cos(W),U=Math.sin(W),z=Math.cos(H),h=Math.sin(H);if(F.order==="XYZ"){let A=Y*z,N=Y*h,M=K*z,T=K*h;_[0]=G*z,_[4]=-G*h,_[8]=U,_[1]=N+M*U,_[5]=A-T*U,_[9]=-K*G,_[2]=T-A*U,_[6]=M+N*U,_[10]=Y*G}else if(F.order==="YXZ"){let A=G*z,N=G*h,M=U*z,T=U*h;_[0]=A+T*K,_[4]=M*K-N,_[8]=Y*U,_[1]=Y*h,_[5]=Y*z,_[9]=-K,_[2]=N*K-M,_[6]=T+A*K,_[10]=Y*G}else if(F.order==="ZXY"){let A=G*z,N=G*h,M=U*z,T=U*h;_[0]=A-T*K,_[4]=-Y*h,_[8]=M+N*K,_[1]=N+M*K,_[5]=Y*z,_[9]=T-A*K,_[2]=-Y*U,_[6]=K,_[10]=Y*G}else if(F.order==="ZYX"){let A=Y*z,N=Y*h,M=K*z,T=K*h;_[0]=G*z,_[4]=M*U-N,_[8]=A*U+T,_[1]=G*h,_[5]=T*U+A,_[9]=N*U-M,_[2]=-U,_[6]=K*G,_[10]=Y*G}else if(F.order==="YZX"){let A=Y*G,N=Y*U,M=K*G,T=K*U;_[0]=G*z,_[4]=T-A*h,_[8]=M*h+N,_[1]=h,_[5]=Y*z,_[9]=-K*z,_[2]=-U*z,_[6]=N*h+M,_[10]=A-T*h}else if(F.order==="XZY"){let A=Y*G,N=Y*U,M=K*G,T=K*U;_[0]=G*z,_[4]=-h,_[8]=U*z,_[1]=A*h+T,_[5]=Y*z,_[9]=N*h-M,_[2]=M*h-N,_[6]=K*z,_[10]=T*h+A}return _[3]=0,_[7]=0,_[11]=0,_[12]=0,_[13]=0,_[14]=0,_[15]=1,this}makeRotationFromQuaternion(F){return this.compose(vL,F,bL)}lookAt(F,_,$){let W=this.elements;if(W8.subVectors(F,_),W8.lengthSq()===0)W8.z=1;if(W8.normalize(),zq.crossVectors($,W8),zq.lengthSq()===0){if(Math.abs($.z)===1)W8.x+=0.0001;else W8.z+=0.0001;W8.normalize(),zq.crossVectors($,W8)}return zq.normalize(),Kw.crossVectors(W8,zq),W[0]=zq.x,W[4]=Kw.x,W[8]=W8.x,W[1]=zq.y,W[5]=Kw.y,W[9]=W8.y,W[2]=zq.z,W[6]=Kw.z,W[10]=W8.z,this}multiply(F){return this.multiplyMatrices(this,F)}premultiply(F){return this.multiplyMatrices(F,this)}multiplyMatrices(F,_){let $=F.elements,W=_.elements,H=this.elements,Y=$[0],K=$[4],G=$[8],U=$[12],z=$[1],h=$[5],A=$[9],N=$[13],M=$[2],T=$[6],P=$[10],D=$[14],O=$[3],b=$[7],k=$[11],y=$[15],m=W[0],x=W[4],o=W[8],s=W[12],j=W[1],V=W[5],d=W[9],$0=W[13],X0=W[2],K0=W[6],J0=W[10],u=W[14],n=W[3],Q0=W[7],O0=W[11],t=W[15];return H[0]=Y*m+K*j+G*X0+U*n,H[4]=Y*x+K*V+G*K0+U*Q0,H[8]=Y*o+K*d+G*J0+U*O0,H[12]=Y*s+K*$0+G*u+U*t,H[1]=z*m+h*j+A*X0+N*n,H[5]=z*x+h*V+A*K0+N*Q0,H[9]=z*o+h*d+A*J0+N*O0,H[13]=z*s+h*$0+A*u+N*t,H[2]=M*m+T*j+P*X0+D*n,H[6]=M*x+T*V+P*K0+D*Q0,H[10]=M*o+T*d+P*J0+D*O0,H[14]=M*s+T*$0+P*u+D*t,H[3]=O*m+b*j+k*X0+y*n,H[7]=O*x+b*V+k*K0+y*Q0,H[11]=O*o+b*d+k*J0+y*O0,H[15]=O*s+b*$0+k*u+y*t,this}multiplyScalar(F){let _=this.elements;return _[0]*=F,_[4]*=F,_[8]*=F,_[12]*=F,_[1]*=F,_[5]*=F,_[9]*=F,_[13]*=F,_[2]*=F,_[6]*=F,_[10]*=F,_[14]*=F,_[3]*=F,_[7]*=F,_[11]*=F,_[15]*=F,this}determinant(){let F=this.elements,_=F[0],$=F[4],W=F[8],H=F[12],Y=F[1],K=F[5],G=F[9],U=F[13],z=F[2],h=F[6],A=F[10],N=F[14],M=F[3],T=F[7],P=F[11],D=F[15],O=G*N-U*A,b=K*N-U*h,k=K*A-G*h,y=Y*N-U*z,m=Y*A-G*z,x=Y*h-K*z;return _*(T*O-P*b+D*k)-$*(M*O-P*y+D*m)+W*(M*b-T*y+D*x)-H*(M*k-T*m+P*x)}transpose(){let F=this.elements,_;return _=F[1],F[1]=F[4],F[4]=_,_=F[2],F[2]=F[8],F[8]=_,_=F[6],F[6]=F[9],F[9]=_,_=F[3],F[3]=F[12],F[12]=_,_=F[7],F[7]=F[13],F[13]=_,_=F[11],F[11]=F[14],F[14]=_,this}setPosition(F,_,$){let W=this.elements;if(F.isVector3)W[12]=F.x,W[13]=F.y,W[14]=F.z;else W[12]=F,W[13]=_,W[14]=$;return this}invert(){let F=this.elements,_=F[0],$=F[1],W=F[2],H=F[3],Y=F[4],K=F[5],G=F[6],U=F[7],z=F[8],h=F[9],A=F[10],N=F[11],M=F[12],T=F[13],P=F[14],D=F[15],O=h*P*U-T*A*U+T*G*N-K*P*N-h*G*D+K*A*D,b=M*A*U-z*P*U-M*G*N+Y*P*N+z*G*D-Y*A*D,k=z*T*U-M*h*U+M*K*N-Y*T*N-z*K*D+Y*h*D,y=M*h*G-z*T*G-M*K*A+Y*T*A+z*K*P-Y*h*P,m=_*O+$*b+W*k+H*y;if(m===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let x=1/m;return F[0]=O*x,F[1]=(T*A*H-h*P*H-T*W*N+$*P*N+h*W*D-$*A*D)*x,F[2]=(K*P*H-T*G*H+T*W*U-$*P*U-K*W*D+$*G*D)*x,F[3]=(h*G*H-K*A*H-h*W*U+$*A*U+K*W*N-$*G*N)*x,F[4]=b*x,F[5]=(z*P*H-M*A*H+M*W*N-_*P*N-z*W*D+_*A*D)*x,F[6]=(M*G*H-Y*P*H-M*W*U+_*P*U+Y*W*D-_*G*D)*x,F[7]=(Y*A*H-z*G*H+z*W*U-_*A*U-Y*W*N+_*G*N)*x,F[8]=k*x,F[9]=(M*h*H-z*T*H-M*$*N+_*T*N+z*$*D-_*h*D)*x,F[10]=(Y*T*H-M*K*H+M*$*U-_*T*U-Y*$*D+_*K*D)*x,F[11]=(z*K*H-Y*h*H-z*$*U+_*h*U+Y*$*N-_*K*N)*x,F[12]=y*x,F[13]=(z*T*W-M*h*W+M*$*A-_*T*A-z*$*P+_*h*P)*x,F[14]=(M*K*W-Y*T*W-M*$*G+_*T*G+Y*$*P-_*K*P)*x,F[15]=(Y*h*W-z*K*W+z*$*G-_*h*G-Y*$*A+_*K*A)*x,this}scale(F){let _=this.elements,$=F.x,W=F.y,H=F.z;return _[0]*=$,_[4]*=W,_[8]*=H,_[1]*=$,_[5]*=W,_[9]*=H,_[2]*=$,_[6]*=W,_[10]*=H,_[3]*=$,_[7]*=W,_[11]*=H,this}getMaxScaleOnAxis(){let F=this.elements,_=F[0]*F[0]+F[1]*F[1]+F[2]*F[2],$=F[4]*F[4]+F[5]*F[5]+F[6]*F[6],W=F[8]*F[8]+F[9]*F[9]+F[10]*F[10];return Math.sqrt(Math.max(_,$,W))}makeTranslation(F,_,$){if(F.isVector3)this.set(1,0,0,F.x,0,1,0,F.y,0,0,1,F.z,0,0,0,1);else this.set(1,0,0,F,0,1,0,_,0,0,1,$,0,0,0,1);return this}makeRotationX(F){let _=Math.cos(F),$=Math.sin(F);return this.set(1,0,0,0,0,_,-$,0,0,$,_,0,0,0,0,1),this}makeRotationY(F){let _=Math.cos(F),$=Math.sin(F);return this.set(_,0,$,0,0,1,0,0,-$,0,_,0,0,0,0,1),this}makeRotationZ(F){let _=Math.cos(F),$=Math.sin(F);return this.set(_,-$,0,0,$,_,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(F,_){let $=Math.cos(_),W=Math.sin(_),H=1-$,Y=F.x,K=F.y,G=F.z,U=H*Y,z=H*K;return this.set(U*Y+$,U*K-W*G,U*G+W*K,0,U*K+W*G,z*K+$,z*G-W*Y,0,U*G-W*K,z*G+W*Y,H*G*G+$,0,0,0,0,1),this}makeScale(F,_,$){return this.set(F,0,0,0,0,_,0,0,0,0,$,0,0,0,0,1),this}makeShear(F,_,$,W,H,Y){return this.set(1,$,H,0,F,1,Y,0,_,W,1,0,0,0,0,1),this}compose(F,_,$){let W=this.elements,H=_._x,Y=_._y,K=_._z,G=_._w,U=H+H,z=Y+Y,h=K+K,A=H*U,N=H*z,M=H*h,T=Y*z,P=Y*h,D=K*h,O=G*U,b=G*z,k=G*h,y=$.x,m=$.y,x=$.z;return W[0]=(1-(T+D))*y,W[1]=(N+k)*y,W[2]=(M-b)*y,W[3]=0,W[4]=(N-k)*m,W[5]=(1-(A+D))*m,W[6]=(P+O)*m,W[7]=0,W[8]=(M+b)*x,W[9]=(P-O)*x,W[10]=(1-(A+T))*x,W[11]=0,W[12]=F.x,W[13]=F.y,W[14]=F.z,W[15]=1,this}decompose(F,_,$){let W=this.elements;if(F.x=W[12],F.y=W[13],F.z=W[14],this.determinant()===0)return $.set(1,1,1),_.identity(),this;let H=a_.set(W[0],W[1],W[2]).length(),Y=a_.set(W[4],W[5],W[6]).length(),K=a_.set(W[8],W[9],W[10]).length();if(this.determinant()<0)H=-H;s8.copy(this);let U=1/H,z=1/Y,h=1/K;return s8.elements[0]*=U,s8.elements[1]*=U,s8.elements[2]*=U,s8.elements[4]*=z,s8.elements[5]*=z,s8.elements[6]*=z,s8.elements[8]*=h,s8.elements[9]*=h,s8.elements[10]*=h,_.setFromRotationMatrix(s8),$.x=H,$.y=Y,$.z=K,this}makePerspective(F,_,$,W,H,Y,K=2000,G=!1){let U=this.elements,z=2*H/(_-F),h=2*H/($-W),A=(_+F)/(_-F),N=($+W)/($-W),M,T;if(G)M=H/(Y-H),T=Y*H/(Y-H);else if(K===2000)M=-(Y+H)/(Y-H),T=-2*Y*H/(Y-H);else if(K===2001)M=-Y/(Y-H),T=-Y*H/(Y-H);else throw Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+K);return U[0]=z,U[4]=0,U[8]=A,U[12]=0,U[1]=0,U[5]=h,U[9]=N,U[13]=0,U[2]=0,U[6]=0,U[10]=M,U[14]=T,U[3]=0,U[7]=0,U[11]=-1,U[15]=0,this}makeOrthographic(F,_,$,W,H,Y,K=2000,G=!1){let U=this.elements,z=2/(_-F),h=2/($-W),A=-(_+F)/(_-F),N=-($+W)/($-W),M,T;if(G)M=1/(Y-H),T=Y/(Y-H);else if(K===2000)M=-2/(Y-H),T=-(Y+H)/(Y-H);else if(K===2001)M=-1/(Y-H),T=-H/(Y-H);else throw Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+K);return U[0]=z,U[4]=0,U[8]=0,U[12]=A,U[1]=0,U[5]=h,U[9]=0,U[13]=N,U[2]=0,U[6]=0,U[10]=M,U[14]=T,U[3]=0,U[7]=0,U[11]=0,U[15]=1,this}equals(F){let _=this.elements,$=F.elements;for(let W=0;W<16;W++)if(_[W]!==$[W])return!1;return!0}fromArray(F,_=0){for(let $=0;$<16;$++)this.elements[$]=F[$+_];return this}toArray(F=[],_=0){let $=this.elements;return F[_]=$[0],F[_+1]=$[1],F[_+2]=$[2],F[_+3]=$[3],F[_+4]=$[4],F[_+5]=$[5],F[_+6]=$[6],F[_+7]=$[7],F[_+8]=$[8],F[_+9]=$[9],F[_+10]=$[10],F[_+11]=$[11],F[_+12]=$[12],F[_+13]=$[13],F[_+14]=$[14],F[_+15]=$[15],F}}var a_=new w0,s8=new N1,vL=new w0(0,0,0),bL=new w0(1,1,1),zq=new w0,Kw=new w0,W8=new w0,qO=new N1,JO=new F7;class r8{constructor(F=0,_=0,$=0,W=r8.DEFAULT_ORDER){this.isEuler=!0,this._x=F,this._y=_,this._z=$,this._order=W}get x(){return this._x}set x(F){this._x=F,this._onChangeCallback()}get y(){return this._y}set y(F){this._y=F,this._onChangeCallback()}get z(){return this._z}set z(F){this._z=F,this._onChangeCallback()}get order(){return this._order}set order(F){this._order=F,this._onChangeCallback()}set(F,_,$,W=this._order){return this._x=F,this._y=_,this._z=$,this._order=W,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(F){return this._x=F._x,this._y=F._y,this._z=F._z,this._order=F._order,this._onChangeCallback(),this}setFromRotationMatrix(F,_=this._order,$=!0){let W=F.elements,H=W[0],Y=W[4],K=W[8],G=W[1],U=W[5],z=W[9],h=W[2],A=W[6],N=W[10];switch(_){case"XYZ":if(this._y=Math.asin(uF(K,-1,1)),Math.abs(K)<0.9999999)this._x=Math.atan2(-z,N),this._z=Math.atan2(-Y,H);else this._x=Math.atan2(A,U),this._z=0;break;case"YXZ":if(this._x=Math.asin(-uF(z,-1,1)),Math.abs(z)<0.9999999)this._y=Math.atan2(K,N),this._z=Math.atan2(G,U);else this._y=Math.atan2(-h,H),this._z=0;break;case"ZXY":if(this._x=Math.asin(uF(A,-1,1)),Math.abs(A)<0.9999999)this._y=Math.atan2(-h,N),this._z=Math.atan2(-Y,U);else this._y=0,this._z=Math.atan2(G,H);break;case"ZYX":if(this._y=Math.asin(-uF(h,-1,1)),Math.abs(h)<0.9999999)this._x=Math.atan2(A,N),this._z=Math.atan2(G,H);else this._x=0,this._z=Math.atan2(-Y,U);break;case"YZX":if(this._z=Math.asin(uF(G,-1,1)),Math.abs(G)<0.9999999)this._x=Math.atan2(-z,U),this._y=Math.atan2(-h,H);else this._x=0,this._y=Math.atan2(K,N);break;case"XZY":if(this._z=Math.asin(-uF(Y,-1,1)),Math.abs(Y)<0.9999999)this._x=Math.atan2(A,U),this._y=Math.atan2(K,H);else this._x=Math.atan2(-z,N),this._y=0;break;default:zF("Euler: .setFromRotationMatrix() encountered an unknown order: "+_)}if(this._order=_,$===!0)this._onChangeCallback();return this}setFromQuaternion(F,_,$){return qO.makeRotationFromQuaternion(F),this.setFromRotationMatrix(qO,_,$)}setFromVector3(F,_=this._order){return this.set(F.x,F.y,F.z,_)}reorder(F){return JO.setFromEuler(this),this.setFromQuaternion(JO,F)}equals(F){return F._x===this._x&&F._y===this._y&&F._z===this._z&&F._order===this._order}fromArray(F){if(this._x=F[0],this._y=F[1],this._z=F[2],F[3]!==void 0)this._order=F[3];return this._onChangeCallback(),this}toArray(F=[],_=0){return F[_]=this._x,F[_+1]=this._y,F[_+2]=this._z,F[_+3]=this._order,F}_onChange(F){return this._onChangeCallback=F,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}r8.DEFAULT_ORDER="XYZ";class OQ{constructor(){this.mask=1}set(F){this.mask=(1<<F|0)>>>0}enable(F){this.mask|=1<<F|0}enableAll(){this.mask=-1}toggle(F){this.mask^=1<<F|0}disable(F){this.mask&=~(1<<F|0)}disableAll(){this.mask=0}test(F){return(this.mask&F.mask)!==0}isEnabled(F){return(this.mask&(1<<F|0))!==0}}var jL=0,_O=new w0,r_=new F7,K9=new N1,Uw=new w0,wQ=new w0,xL=new w0,gL=new F7,ZO=new w0(1,0,0),$O=new w0(0,1,0),QO=new w0(0,0,1),WO={type:"added"},uL={type:"removed"},t_={type:"childadded",child:null},h5={type:"childremoved",child:null};class F6 extends N9{constructor(){super();this.isObject3D=!0,Object.defineProperty(this,"id",{value:jL++}),this.uuid=AZ(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=F6.DEFAULT_UP.clone();let F=new w0,_=new r8,$=new F7,W=new w0(1,1,1);function H(){$.setFromEuler(_,!1)}function Y(){_.setFromQuaternion($,void 0,!1)}_._onChange(H),$._onChange(Y),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:F},rotation:{configurable:!0,enumerable:!0,value:_},quaternion:{configurable:!0,enumerable:!0,value:$},scale:{configurable:!0,enumerable:!0,value:W},modelViewMatrix:{value:new N1},normalMatrix:{value:new EF}}),this.matrix=new N1,this.matrixWorld=new N1,this.matrixAutoUpdate=F6.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=F6.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new OQ,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(F){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(F),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(F){return this.quaternion.premultiply(F),this}setRotationFromAxisAngle(F,_){this.quaternion.setFromAxisAngle(F,_)}setRotationFromEuler(F){this.quaternion.setFromEuler(F,!0)}setRotationFromMatrix(F){this.quaternion.setFromRotationMatrix(F)}setRotationFromQuaternion(F){this.quaternion.copy(F)}rotateOnAxis(F,_){return r_.setFromAxisAngle(F,_),this.quaternion.multiply(r_),this}rotateOnWorldAxis(F,_){return r_.setFromAxisAngle(F,_),this.quaternion.premultiply(r_),this}rotateX(F){return this.rotateOnAxis(ZO,F)}rotateY(F){return this.rotateOnAxis($O,F)}rotateZ(F){return this.rotateOnAxis(QO,F)}translateOnAxis(F,_){return _O.copy(F).applyQuaternion(this.quaternion),this.position.add(_O.multiplyScalar(_)),this}translateX(F){return this.translateOnAxis(ZO,F)}translateY(F){return this.translateOnAxis($O,F)}translateZ(F){return this.translateOnAxis(QO,F)}localToWorld(F){return this.updateWorldMatrix(!0,!1),F.applyMatrix4(this.matrixWorld)}worldToLocal(F){return this.updateWorldMatrix(!0,!1),F.applyMatrix4(K9.copy(this.matrixWorld).invert())}lookAt(F,_,$){if(F.isVector3)Uw.copy(F);else Uw.set(F,_,$);let W=this.parent;if(this.updateWorldMatrix(!0,!1),wQ.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight)K9.lookAt(wQ,Uw,this.up);else K9.lookAt(Uw,wQ,this.up);if(this.quaternion.setFromRotationMatrix(K9),W)K9.extractRotation(W.matrixWorld),r_.setFromRotationMatrix(K9),this.quaternion.premultiply(r_.invert())}add(F){if(arguments.length>1){for(let _=0;_<arguments.length;_++)this.add(arguments[_]);return this}if(F===this)return hF("Object3D.add: object can't be added as a child of itself.",F),this;if(F&&F.isObject3D)F.removeFromParent(),F.parent=this,this.children.push(F),F.dispatchEvent(WO),t_.child=F,this.dispatchEvent(t_),t_.child=null;else hF("Object3D.add: object not an instance of THREE.Object3D.",F);return this}remove(F){if(arguments.length>1){for(let $=0;$<arguments.length;$++)this.remove(arguments[$]);return this}let _=this.children.indexOf(F);if(_!==-1)F.parent=null,this.children.splice(_,1),F.dispatchEvent(uL),h5.child=F,this.dispatchEvent(h5),h5.child=null;return this}removeFromParent(){let F=this.parent;if(F!==null)F.remove(this);return this}clear(){return this.remove(...this.children)}attach(F){if(this.updateWorldMatrix(!0,!1),K9.copy(this.matrixWorld).invert(),F.parent!==null)F.parent.updateWorldMatrix(!0,!1),K9.multiply(F.parent.matrixWorld);return F.applyMatrix4(K9),F.removeFromParent(),F.parent=this,this.children.push(F),F.updateWorldMatrix(!1,!0),F.dispatchEvent(WO),t_.child=F,this.dispatchEvent(t_),t_.child=null,this}getObjectById(F){return this.getObjectByProperty("id",F)}getObjectByName(F){return this.getObjectByProperty("name",F)}getObjectByProperty(F,_){if(this[F]===_)return this;for(let $=0,W=this.children.length;$<W;$++){let Y=this.children[$].getObjectByProperty(F,_);if(Y!==void 0)return Y}return}getObjectsByProperty(F,_,$=[]){if(this[F]===_)$.push(this);let W=this.children;for(let H=0,Y=W.length;H<Y;H++)W[H].getObjectsByProperty(F,_,$);return $}getWorldPosition(F){return this.updateWorldMatrix(!0,!1),F.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(F){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(wQ,F,xL),F}getWorldScale(F){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(wQ,gL,F),F}getWorldDirection(F){this.updateWorldMatrix(!0,!1);let _=this.matrixWorld.elements;return F.set(_[8],_[9],_[10]).normalize()}raycast(){}traverse(F){F(this);let _=this.children;for(let $=0,W=_.length;$<W;$++)_[$].traverse(F)}traverseVisible(F){if(this.visible===!1)return;F(this);let _=this.children;for(let $=0,W=_.length;$<W;$++)_[$].traverseVisible(F)}traverseAncestors(F){let _=this.parent;if(_!==null)F(_),_.traverseAncestors(F)}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(F){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||F){if(this.matrixWorldAutoUpdate===!0)if(this.parent===null)this.matrixWorld.copy(this.matrix);else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);this.matrixWorldNeedsUpdate=!1,F=!0}let _=this.children;for(let $=0,W=_.length;$<W;$++)_[$].updateMatrixWorld(F)}updateWorldMatrix(F,_){let $=this.parent;if(F===!0&&$!==null)$.updateWorldMatrix(!0,!1);if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldAutoUpdate===!0)if(this.parent===null)this.matrixWorld.copy(this.matrix);else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);if(_===!0){let W=this.children;for(let H=0,Y=W.length;H<Y;H++)W[H].updateWorldMatrix(!1,!0)}}toJSON(F){let _=F===void 0||typeof F==="string",$={};if(_)F={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},$.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"};let W={};if(W.uuid=this.uuid,W.type=this.type,this.name!=="")W.name=this.name;if(this.castShadow===!0)W.castShadow=!0;if(this.receiveShadow===!0)W.receiveShadow=!0;if(this.visible===!1)W.visible=!1;if(this.frustumCulled===!1)W.frustumCulled=!1;if(this.renderOrder!==0)W.renderOrder=this.renderOrder;if(Object.keys(this.userData).length>0)W.userData=this.userData;if(W.layers=this.layers.mask,W.matrix=this.matrix.toArray(),W.up=this.up.toArray(),this.matrixAutoUpdate===!1)W.matrixAutoUpdate=!1;if(this.isInstancedMesh){if(W.type="InstancedMesh",W.count=this.count,W.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null)W.instanceColor=this.instanceColor.toJSON()}if(this.isBatchedMesh){if(W.type="BatchedMesh",W.perObjectFrustumCulled=this.perObjectFrustumCulled,W.sortObjects=this.sortObjects,W.drawRanges=this._drawRanges,W.reservedRanges=this._reservedRanges,W.geometryInfo=this._geometryInfo.map((K)=>({...K,boundingBox:K.boundingBox?K.boundingBox.toJSON():void 0,boundingSphere:K.boundingSphere?K.boundingSphere.toJSON():void 0})),W.instanceInfo=this._instanceInfo.map((K)=>({...K})),W.availableInstanceIds=this._availableInstanceIds.slice(),W.availableGeometryIds=this._availableGeometryIds.slice(),W.nextIndexStart=this._nextIndexStart,W.nextVertexStart=this._nextVertexStart,W.geometryCount=this._geometryCount,W.maxInstanceCount=this._maxInstanceCount,W.maxVertexCount=this._maxVertexCount,W.maxIndexCount=this._maxIndexCount,W.geometryInitialized=this._geometryInitialized,W.matricesTexture=this._matricesTexture.toJSON(F),W.indirectTexture=this._indirectTexture.toJSON(F),this._colorsTexture!==null)W.colorsTexture=this._colorsTexture.toJSON(F);if(this.boundingSphere!==null)W.boundingSphere=this.boundingSphere.toJSON();if(this.boundingBox!==null)W.boundingBox=this.boundingBox.toJSON()}function H(K,G){if(K[G.uuid]===void 0)K[G.uuid]=G.toJSON(F);return G.uuid}if(this.isScene){if(this.background){if(this.background.isColor)W.background=this.background.toJSON();else if(this.background.isTexture)W.background=this.background.toJSON(F).uuid}if(this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0)W.environment=this.environment.toJSON(F).uuid}else if(this.isMesh||this.isLine||this.isPoints){W.geometry=H(F.geometries,this.geometry);let K=this.geometry.parameters;if(K!==void 0&&K.shapes!==void 0){let G=K.shapes;if(Array.isArray(G))for(let U=0,z=G.length;U<z;U++){let h=G[U];H(F.shapes,h)}else H(F.shapes,G)}}if(this.isSkinnedMesh){if(W.bindMode=this.bindMode,W.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0)H(F.skeletons,this.skeleton),W.skeleton=this.skeleton.uuid}if(this.material!==void 0)if(Array.isArray(this.material)){let K=[];for(let G=0,U=this.material.length;G<U;G++)K.push(H(F.materials,this.material[G]));W.material=K}else W.material=H(F.materials,this.material);if(this.children.length>0){W.children=[];for(let K=0;K<this.children.length;K++)W.children.push(this.children[K].toJSON(F).object)}if(this.animations.length>0){W.animations=[];for(let K=0;K<this.animations.length;K++){let G=this.animations[K];W.animations.push(H(F.animations,G))}}if(_){let K=Y(F.geometries),G=Y(F.materials),U=Y(F.textures),z=Y(F.images),h=Y(F.shapes),A=Y(F.skeletons),N=Y(F.animations),M=Y(F.nodes);if(K.length>0)$.geometries=K;if(G.length>0)$.materials=G;if(U.length>0)$.textures=U;if(z.length>0)$.images=z;if(h.length>0)$.shapes=h;if(A.length>0)$.skeletons=A;if(N.length>0)$.animations=N;if(M.length>0)$.nodes=M}return $.object=W,$;function Y(K){let G=[];for(let U in K){let z=K[U];delete z.metadata,G.push(z)}return G}}clone(F){return new this.constructor().copy(this,F)}copy(F,_=!0){if(this.name=F.name,this.up.copy(F.up),this.position.copy(F.position),this.rotation.order=F.rotation.order,this.quaternion.copy(F.quaternion),this.scale.copy(F.scale),this.matrix.copy(F.matrix),this.matrixWorld.copy(F.matrixWorld),this.matrixAutoUpdate=F.matrixAutoUpdate,this.matrixWorldAutoUpdate=F.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=F.matrixWorldNeedsUpdate,this.layers.mask=F.layers.mask,this.visible=F.visible,this.castShadow=F.castShadow,this.receiveShadow=F.receiveShadow,this.frustumCulled=F.frustumCulled,this.renderOrder=F.renderOrder,this.animations=F.animations.slice(),this.userData=JSON.parse(JSON.stringify(F.userData)),_===!0)for(let $=0;$<F.children.length;$++){let W=F.children[$];this.add(W.clone())}return this}}F6.DEFAULT_UP=new w0(0,1,0);F6.DEFAULT_MATRIX_AUTO_UPDATE=!0;F6.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;var o8=new w0,U9=new w0,R5=new w0,B9=new w0,e_=new w0,FZ=new w0,HO=new w0,N5=new w0,D5=new w0,M5=new w0,O5=new T1,f5=new T1,I5=new T1;class E8{constructor(F=new w0,_=new w0,$=new w0){this.a=F,this.b=_,this.c=$}static getNormal(F,_,$,W){W.subVectors($,_),o8.subVectors(F,_),W.cross(o8);let H=W.lengthSq();if(H>0)return W.multiplyScalar(1/Math.sqrt(H));return W.set(0,0,0)}static getBarycoord(F,_,$,W,H){o8.subVectors(W,_),U9.subVectors($,_),R5.subVectors(F,_);let Y=o8.dot(o8),K=o8.dot(U9),G=o8.dot(R5),U=U9.dot(U9),z=U9.dot(R5),h=Y*U-K*K;if(h===0)return H.set(0,0,0),null;let A=1/h,N=(U*G-K*z)*A,M=(Y*z-K*G)*A;return H.set(1-N-M,M,N)}static containsPoint(F,_,$,W){if(this.getBarycoord(F,_,$,W,B9)===null)return!1;return B9.x>=0&&B9.y>=0&&B9.x+B9.y<=1}static getInterpolation(F,_,$,W,H,Y,K,G){if(this.getBarycoord(F,_,$,W,B9)===null){if(G.x=0,G.y=0,"z"in G)G.z=0;if("w"in G)G.w=0;return null}return G.setScalar(0),G.addScaledVector(H,B9.x),G.addScaledVector(Y,B9.y),G.addScaledVector(K,B9.z),G}static getInterpolatedAttribute(F,_,$,W,H,Y){return O5.setScalar(0),f5.setScalar(0),I5.setScalar(0),O5.fromBufferAttribute(F,_),f5.fromBufferAttribute(F,$),I5.fromBufferAttribute(F,W),Y.setScalar(0),Y.addScaledVector(O5,H.x),Y.addScaledVector(f5,H.y),Y.addScaledVector(I5,H.z),Y}static isFrontFacing(F,_,$,W){return o8.subVectors($,_),U9.subVectors(F,_),o8.cross(U9).dot(W)<0?!0:!1}set(F,_,$){return this.a.copy(F),this.b.copy(_),this.c.copy($),this}setFromPointsAndIndices(F,_,$,W){return this.a.copy(F[_]),this.b.copy(F[$]),this.c.copy(F[W]),this}setFromAttributeAndIndices(F,_,$,W){return this.a.fromBufferAttribute(F,_),this.b.fromBufferAttribute(F,$),this.c.fromBufferAttribute(F,W),this}clone(){return new this.constructor().copy(this)}copy(F){return this.a.copy(F.a),this.b.copy(F.b),this.c.copy(F.c),this}getArea(){return o8.subVectors(this.c,this.b),U9.subVectors(this.a,this.b),o8.cross(U9).length()*0.5}getMidpoint(F){return F.addVectors(this.a,this.b).add(this.c).multiplyScalar(0.3333333333333333)}getNormal(F){return E8.getNormal(this.a,this.b,this.c,F)}getPlane(F){return F.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(F,_){return E8.getBarycoord(F,this.a,this.b,this.c,_)}getInterpolation(F,_,$,W,H){return E8.getInterpolation(F,this.a,this.b,this.c,_,$,W,H)}containsPoint(F){return E8.containsPoint(F,this.a,this.b,this.c)}isFrontFacing(F){return E8.isFrontFacing(this.a,this.b,this.c,F)}intersectsBox(F){return F.intersectsTriangle(this)}closestPointToPoint(F,_){let $=this.a,W=this.b,H=this.c,Y,K;e_.subVectors(W,$),FZ.subVectors(H,$),N5.subVectors(F,$);let G=e_.dot(N5),U=FZ.dot(N5);if(G<=0&&U<=0)return _.copy($);D5.subVectors(F,W);let z=e_.dot(D5),h=FZ.dot(D5);if(z>=0&&h<=z)return _.copy(W);let A=G*h-z*U;if(A<=0&&G>=0&&z<=0)return Y=G/(G-z),_.copy($).addScaledVector(e_,Y);M5.subVectors(F,H);let N=e_.dot(M5),M=FZ.dot(M5);if(M>=0&&N<=M)return _.copy(H);let T=N*U-G*M;if(T<=0&&U>=0&&M<=0)return K=U/(U-M),_.copy($).addScaledVector(FZ,K);let P=z*M-N*h;if(P<=0&&h-z>=0&&N-M>=0)return HO.subVectors(H,W),K=(h-z)/(h-z+(N-M)),_.copy(W).addScaledVector(HO,K);let D=1/(P+T+A);return Y=T*D,K=A*D,_.copy($).addScaledVector(e_,Y).addScaledVector(FZ,K)}equals(F){return F.a.equals(this.a)&&F.b.equals(this.b)&&F.c.equals(this.c)}}var Uf={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Aq={h:0,s:0,l:0},Bw={h:0,s:0,l:0};function T5(F,_,$){if($<0)$+=1;if($>1)$-=1;if($<0.16666666666666666)return F+(_-F)*6*$;if($<0.5)return _;if($<0.6666666666666666)return F+(_-F)*6*(0.6666666666666666-$);return F}class lF{constructor(F,_,$){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(F,_,$)}set(F,_,$){if(_===void 0&&$===void 0){let W=F;if(W&&W.isColor)this.copy(W);else if(typeof W==="number")this.setHex(W);else if(typeof W==="string")this.setStyle(W)}else this.setRGB(F,_,$);return this}setScalar(F){return this.r=F,this.g=F,this.b=F,this}setHex(F,_="srgb"){return F=Math.floor(F),this.r=(F>>16&255)/255,this.g=(F>>8&255)/255,this.b=(F&255)/255,aF.colorSpaceToWorking(this,_),this}setRGB(F,_,$,W=aF.workingColorSpace){return this.r=F,this.g=_,this.b=$,aF.colorSpaceToWorking(this,W),this}setHSL(F,_,$,W=aF.workingColorSpace){if(F=SU(F,1),_=uF(_,0,1),$=uF($,0,1),_===0)this.r=this.g=this.b=$;else{let H=$<=0.5?$*(1+_):$+_-$*_,Y=2*$-H;this.r=T5(Y,H,F+0.3333333333333333),this.g=T5(Y,H,F),this.b=T5(Y,H,F-0.3333333333333333)}return aF.colorSpaceToWorking(this,W),this}setStyle(F,_="srgb"){function $(H){if(H===void 0)return;if(parseFloat(H)<1)zF("Color: Alpha component of "+F+" will be ignored.")}let W;if(W=/^(\w+)\(([^\)]*)\)/.exec(F)){let H,Y=W[1],K=W[2];switch(Y){case"rgb":case"rgba":if(H=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(K))return $(H[4]),this.setRGB(Math.min(255,parseInt(H[1],10))/255,Math.min(255,parseInt(H[2],10))/255,Math.min(255,parseInt(H[3],10))/255,_);if(H=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(K))return $(H[4]),this.setRGB(Math.min(100,parseInt(H[1],10))/100,Math.min(100,parseInt(H[2],10))/100,Math.min(100,parseInt(H[3],10))/100,_);break;case"hsl":case"hsla":if(H=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(K))return $(H[4]),this.setHSL(parseFloat(H[1])/360,parseFloat(H[2])/100,parseFloat(H[3])/100,_);break;default:zF("Color: Unknown color model "+F)}}else if(W=/^\#([A-Fa-f\d]+)$/.exec(F)){let H=W[1],Y=H.length;if(Y===3)return this.setRGB(parseInt(H.charAt(0),16)/15,parseInt(H.charAt(1),16)/15,parseInt(H.charAt(2),16)/15,_);else if(Y===6)return this.setHex(parseInt(H,16),_);else zF("Color: Invalid hex color "+F)}else if(F&&F.length>0)return this.setColorName(F,_);return this}setColorName(F,_="srgb"){let $=Uf[F.toLowerCase()];if($!==void 0)this.setHex($,_);else zF("Color: Unknown color "+F);return this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(F){return this.r=F.r,this.g=F.g,this.b=F.b,this}copySRGBToLinear(F){return this.r=z9(F.r),this.g=z9(F.g),this.b=z9(F.b),this}copyLinearToSRGB(F){return this.r=QZ(F.r),this.g=QZ(F.g),this.b=QZ(F.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(F="srgb"){return aF.workingToColorSpace(z6.copy(this),F),Math.round(uF(z6.r*255,0,255))*65536+Math.round(uF(z6.g*255,0,255))*256+Math.round(uF(z6.b*255,0,255))}getHexString(F="srgb"){return("000000"+this.getHex(F).toString(16)).slice(-6)}getHSL(F,_=aF.workingColorSpace){aF.workingToColorSpace(z6.copy(this),_);let{r:$,g:W,b:H}=z6,Y=Math.max($,W,H),K=Math.min($,W,H),G,U,z=(K+Y)/2;if(K===Y)G=0,U=0;else{let h=Y-K;switch(U=z<=0.5?h/(Y+K):h/(2-Y-K),Y){case $:G=(W-H)/h+(W<H?6:0);break;case W:G=(H-$)/h+2;break;case H:G=($-W)/h+4;break}G/=6}return F.h=G,F.s=U,F.l=z,F}getRGB(F,_=aF.workingColorSpace){return aF.workingToColorSpace(z6.copy(this),_),F.r=z6.r,F.g=z6.g,F.b=z6.b,F}getStyle(F="srgb"){aF.workingToColorSpace(z6.copy(this),F);let{r:_,g:$,b:W}=z6;if(F!=="srgb")return`color(${F} ${_.toFixed(3)} ${$.toFixed(3)} ${W.toFixed(3)})`;return`rgb(${Math.round(_*255)},${Math.round($*255)},${Math.round(W*255)})`}offsetHSL(F,_,$){return this.getHSL(Aq),this.setHSL(Aq.h+F,Aq.s+_,Aq.l+$)}add(F){return this.r+=F.r,this.g+=F.g,this.b+=F.b,this}addColors(F,_){return this.r=F.r+_.r,this.g=F.g+_.g,this.b=F.b+_.b,this}addScalar(F){return this.r+=F,this.g+=F,this.b+=F,this}sub(F){return this.r=Math.max(0,this.r-F.r),this.g=Math.max(0,this.g-F.g),this.b=Math.max(0,this.b-F.b),this}multiply(F){return this.r*=F.r,this.g*=F.g,this.b*=F.b,this}multiplyScalar(F){return this.r*=F,this.g*=F,this.b*=F,this}lerp(F,_){return this.r+=(F.r-this.r)*_,this.g+=(F.g-this.g)*_,this.b+=(F.b-this.b)*_,this}lerpColors(F,_,$){return this.r=F.r+(_.r-F.r)*$,this.g=F.g+(_.g-F.g)*$,this.b=F.b+(_.b-F.b)*$,this}lerpHSL(F,_){this.getHSL(Aq),F.getHSL(Bw);let $=KQ(Aq.h,Bw.h,_),W=KQ(Aq.s,Bw.s,_),H=KQ(Aq.l,Bw.l,_);return this.setHSL($,W,H),this}setFromVector3(F){return this.r=F.x,this.g=F.y,this.b=F.z,this}applyMatrix3(F){let _=this.r,$=this.g,W=this.b,H=F.elements;return this.r=H[0]*_+H[3]*$+H[6]*W,this.g=H[1]*_+H[4]*$+H[7]*W,this.b=H[2]*_+H[5]*$+H[8]*W,this}equals(F){return F.r===this.r&&F.g===this.g&&F.b===this.b}fromArray(F,_=0){return this.r=F[_],this.g=F[_+1],this.b=F[_+2],this}toArray(F=[],_=0){return F[_]=this.r,F[_+1]=this.g,F[_+2]=this.b,F}fromBufferAttribute(F,_){return this.r=F.getX(_),this.g=F.getY(_),this.b=F.getZ(_),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}var z6=new lF;lF.NAMES=Uf;var pL=0;class Oq extends N9{constructor(){super();this.isMaterial=!0,Object.defineProperty(this,"id",{value:pL++}),this.uuid=AZ(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new lF(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(F){if(this._alphaTest>0!==F>0)this.version++;this._alphaTest=F}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(F){if(F===void 0)return;for(let _ in F){let $=F[_];if($===void 0){zF(`Material: parameter '${_}' has value of undefined.`);continue}let W=this[_];if(W===void 0){zF(`Material: '${_}' is not a property of THREE.${this.type}.`);continue}if(W&&W.isColor)W.set($);else if(W&&W.isVector3&&($&&$.isVector3))W.copy($);else this[_]=$}}toJSON(F){let _=F===void 0||typeof F==="string";if(_)F={textures:{},images:{}};let $={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};if($.uuid=this.uuid,$.type=this.type,this.name!=="")$.name=this.name;if(this.color&&this.color.isColor)$.color=this.color.getHex();if(this.roughness!==void 0)$.roughness=this.roughness;if(this.metalness!==void 0)$.metalness=this.metalness;if(this.sheen!==void 0)$.sheen=this.sheen;if(this.sheenColor&&this.sheenColor.isColor)$.sheenColor=this.sheenColor.getHex();if(this.sheenRoughness!==void 0)$.sheenRoughness=this.sheenRoughness;if(this.emissive&&this.emissive.isColor)$.emissive=this.emissive.getHex();if(this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1)$.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)$.specular=this.specular.getHex();if(this.specularIntensity!==void 0)$.specularIntensity=this.specularIntensity;if(this.specularColor&&this.specularColor.isColor)$.specularColor=this.specularColor.getHex();if(this.shininess!==void 0)$.shininess=this.shininess;if(this.clearcoat!==void 0)$.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==void 0)$.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture)$.clearcoatMap=this.clearcoatMap.toJSON(F).uuid;if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture)$.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(F).uuid;if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture)$.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(F).uuid,$.clearcoatNormalScale=this.clearcoatNormalScale.toArray();if(this.sheenColorMap&&this.sheenColorMap.isTexture)$.sheenColorMap=this.sheenColorMap.toJSON(F).uuid;if(this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture)$.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(F).uuid;if(this.dispersion!==void 0)$.dispersion=this.dispersion;if(this.iridescence!==void 0)$.iridescence=this.iridescence;if(this.iridescenceIOR!==void 0)$.iridescenceIOR=this.iridescenceIOR;if(this.iridescenceThicknessRange!==void 0)$.iridescenceThicknessRange=this.iridescenceThicknessRange;if(this.iridescenceMap&&this.iridescenceMap.isTexture)$.iridescenceMap=this.iridescenceMap.toJSON(F).uuid;if(this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture)$.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(F).uuid;if(this.anisotropy!==void 0)$.anisotropy=this.anisotropy;if(this.anisotropyRotation!==void 0)$.anisotropyRotation=this.anisotropyRotation;if(this.anisotropyMap&&this.anisotropyMap.isTexture)$.anisotropyMap=this.anisotropyMap.toJSON(F).uuid;if(this.map&&this.map.isTexture)$.map=this.map.toJSON(F).uuid;if(this.matcap&&this.matcap.isTexture)$.matcap=this.matcap.toJSON(F).uuid;if(this.alphaMap&&this.alphaMap.isTexture)$.alphaMap=this.alphaMap.toJSON(F).uuid;if(this.lightMap&&this.lightMap.isTexture)$.lightMap=this.lightMap.toJSON(F).uuid,$.lightMapIntensity=this.lightMapIntensity;if(this.aoMap&&this.aoMap.isTexture)$.aoMap=this.aoMap.toJSON(F).uuid,$.aoMapIntensity=this.aoMapIntensity;if(this.bumpMap&&this.bumpMap.isTexture)$.bumpMap=this.bumpMap.toJSON(F).uuid,$.bumpScale=this.bumpScale;if(this.normalMap&&this.normalMap.isTexture)$.normalMap=this.normalMap.toJSON(F).uuid,$.normalMapType=this.normalMapType,$.normalScale=this.normalScale.toArray();if(this.displacementMap&&this.displacementMap.isTexture)$.displacementMap=this.displacementMap.toJSON(F).uuid,$.displacementScale=this.displacementScale,$.displacementBias=this.displacementBias;if(this.roughnessMap&&this.roughnessMap.isTexture)$.roughnessMap=this.roughnessMap.toJSON(F).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)$.metalnessMap=this.metalnessMap.toJSON(F).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)$.emissiveMap=this.emissiveMap.toJSON(F).uuid;if(this.specularMap&&this.specularMap.isTexture)$.specularMap=this.specularMap.toJSON(F).uuid;if(this.specularIntensityMap&&this.specularIntensityMap.isTexture)$.specularIntensityMap=this.specularIntensityMap.toJSON(F).uuid;if(this.specularColorMap&&this.specularColorMap.isTexture)$.specularColorMap=this.specularColorMap.toJSON(F).uuid;if(this.envMap&&this.envMap.isTexture){if($.envMap=this.envMap.toJSON(F).uuid,this.combine!==void 0)$.combine=this.combine}if(this.envMapRotation!==void 0)$.envMapRotation=this.envMapRotation.toArray();if(this.envMapIntensity!==void 0)$.envMapIntensity=this.envMapIntensity;if(this.reflectivity!==void 0)$.reflectivity=this.reflectivity;if(this.refractionRatio!==void 0)$.refractionRatio=this.refractionRatio;if(this.gradientMap&&this.gradientMap.isTexture)$.gradientMap=this.gradientMap.toJSON(F).uuid;if(this.transmission!==void 0)$.transmission=this.transmission;if(this.transmissionMap&&this.transmissionMap.isTexture)$.transmissionMap=this.transmissionMap.toJSON(F).uuid;if(this.thickness!==void 0)$.thickness=this.thickness;if(this.thicknessMap&&this.thicknessMap.isTexture)$.thicknessMap=this.thicknessMap.toJSON(F).uuid;if(this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0)$.attenuationDistance=this.attenuationDistance;if(this.attenuationColor!==void 0)$.attenuationColor=this.attenuationColor.getHex();if(this.size!==void 0)$.size=this.size;if(this.shadowSide!==null)$.shadowSide=this.shadowSide;if(this.sizeAttenuation!==void 0)$.sizeAttenuation=this.sizeAttenuation;if(this.blending!==1)$.blending=this.blending;if(this.side!==0)$.side=this.side;if(this.vertexColors===!0)$.vertexColors=!0;if(this.opacity<1)$.opacity=this.opacity;if(this.transparent===!0)$.transparent=!0;if(this.blendSrc!==204)$.blendSrc=this.blendSrc;if(this.blendDst!==205)$.blendDst=this.blendDst;if(this.blendEquation!==100)$.blendEquation=this.blendEquation;if(this.blendSrcAlpha!==null)$.blendSrcAlpha=this.blendSrcAlpha;if(this.blendDstAlpha!==null)$.blendDstAlpha=this.blendDstAlpha;if(this.blendEquationAlpha!==null)$.blendEquationAlpha=this.blendEquationAlpha;if(this.blendColor&&this.blendColor.isColor)$.blendColor=this.blendColor.getHex();if(this.blendAlpha!==0)$.blendAlpha=this.blendAlpha;if(this.depthFunc!==3)$.depthFunc=this.depthFunc;if(this.depthTest===!1)$.depthTest=this.depthTest;if(this.depthWrite===!1)$.depthWrite=this.depthWrite;if(this.colorWrite===!1)$.colorWrite=this.colorWrite;if(this.stencilWriteMask!==255)$.stencilWriteMask=this.stencilWriteMask;if(this.stencilFunc!==519)$.stencilFunc=this.stencilFunc;if(this.stencilRef!==0)$.stencilRef=this.stencilRef;if(this.stencilFuncMask!==255)$.stencilFuncMask=this.stencilFuncMask;if(this.stencilFail!==7680)$.stencilFail=this.stencilFail;if(this.stencilZFail!==7680)$.stencilZFail=this.stencilZFail;if(this.stencilZPass!==7680)$.stencilZPass=this.stencilZPass;if(this.stencilWrite===!0)$.stencilWrite=this.stencilWrite;if(this.rotation!==void 0&&this.rotation!==0)$.rotation=this.rotation;if(this.polygonOffset===!0)$.polygonOffset=!0;if(this.polygonOffsetFactor!==0)$.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)$.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth!==void 0&&this.linewidth!==1)$.linewidth=this.linewidth;if(this.dashSize!==void 0)$.dashSize=this.dashSize;if(this.gapSize!==void 0)$.gapSize=this.gapSize;if(this.scale!==void 0)$.scale=this.scale;if(this.dithering===!0)$.dithering=!0;if(this.alphaTest>0)$.alphaTest=this.alphaTest;if(this.alphaHash===!0)$.alphaHash=!0;if(this.alphaToCoverage===!0)$.alphaToCoverage=!0;if(this.premultipliedAlpha===!0)$.premultipliedAlpha=!0;if(this.forceSinglePass===!0)$.forceSinglePass=!0;if(this.allowOverride===!1)$.allowOverride=!1;if(this.wireframe===!0)$.wireframe=!0;if(this.wireframeLinewidth>1)$.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=="round")$.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=="round")$.wireframeLinejoin=this.wireframeLinejoin;if(this.flatShading===!0)$.flatShading=!0;if(this.visible===!1)$.visible=!1;if(this.toneMapped===!1)$.toneMapped=!1;if(this.fog===!1)$.fog=!1;if(Object.keys(this.userData).length>0)$.userData=this.userData;function W(H){let Y=[];for(let K in H){let G=H[K];delete G.metadata,Y.push(G)}return Y}if(_){let H=W(F.textures),Y=W(F.images);if(H.length>0)$.textures=H;if(Y.length>0)$.images=Y}return $}clone(){return new this.constructor().copy(this)}copy(F){this.name=F.name,this.blending=F.blending,this.side=F.side,this.vertexColors=F.vertexColors,this.opacity=F.opacity,this.transparent=F.transparent,this.blendSrc=F.blendSrc,this.blendDst=F.blendDst,this.blendEquation=F.blendEquation,this.blendSrcAlpha=F.blendSrcAlpha,this.blendDstAlpha=F.blendDstAlpha,this.blendEquationAlpha=F.blendEquationAlpha,this.blendColor.copy(F.blendColor),this.blendAlpha=F.blendAlpha,this.depthFunc=F.depthFunc,this.depthTest=F.depthTest,this.depthWrite=F.depthWrite,this.stencilWriteMask=F.stencilWriteMask,this.stencilFunc=F.stencilFunc,this.stencilRef=F.stencilRef,this.stencilFuncMask=F.stencilFuncMask,this.stencilFail=F.stencilFail,this.stencilZFail=F.stencilZFail,this.stencilZPass=F.stencilZPass,this.stencilWrite=F.stencilWrite;let _=F.clippingPlanes,$=null;if(_!==null){let W=_.length;$=Array(W);for(let H=0;H!==W;++H)$[H]=_[H].clone()}return this.clippingPlanes=$,this.clipIntersection=F.clipIntersection,this.clipShadows=F.clipShadows,this.shadowSide=F.shadowSide,this.colorWrite=F.colorWrite,this.precision=F.precision,this.polygonOffset=F.polygonOffset,this.polygonOffsetFactor=F.polygonOffsetFactor,this.polygonOffsetUnits=F.polygonOffsetUnits,this.dithering=F.dithering,this.alphaTest=F.alphaTest,this.alphaHash=F.alphaHash,this.alphaToCoverage=F.alphaToCoverage,this.premultipliedAlpha=F.premultipliedAlpha,this.forceSinglePass=F.forceSinglePass,this.allowOverride=F.allowOverride,this.visible=F.visible,this.toneMapped=F.toneMapped,this.userData=JSON.parse(JSON.stringify(F.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(F){if(F===!0)this.version++}}class sw extends Oq{constructor(F){super();this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new lF(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new r8,this.combine=0,this.reflectivity=1,this.refractionRatio=0.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(F)}copy(F){return super.copy(F),this.color.copy(F.color),this.map=F.map,this.lightMap=F.lightMap,this.lightMapIntensity=F.lightMapIntensity,this.aoMap=F.aoMap,this.aoMapIntensity=F.aoMapIntensity,this.specularMap=F.specularMap,this.alphaMap=F.alphaMap,this.envMap=F.envMap,this.envMapRotation.copy(F.envMapRotation),this.combine=F.combine,this.reflectivity=F.reflectivity,this.refractionRatio=F.refractionRatio,this.wireframe=F.wireframe,this.wireframeLinewidth=F.wireframeLinewidth,this.wireframeLinecap=F.wireframeLinecap,this.wireframeLinejoin=F.wireframeLinejoin,this.fog=F.fog,this}}var u1=new w0,zw=new DF,mL=0;class C8{constructor(F,_,$=!1){if(Array.isArray(F))throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:mL++}),this.name="",this.array=F,this.itemSize=_,this.count=F!==void 0?F.length/_:0,this.normalized=$,this.usage=35044,this.updateRanges=[],this.gpuType=1015,this.version=0}onUploadCallback(){}set needsUpdate(F){if(F===!0)this.version++}setUsage(F){return this.usage=F,this}addUpdateRange(F,_){this.updateRanges.push({start:F,count:_})}clearUpdateRanges(){this.updateRanges.length=0}copy(F){return this.name=F.name,this.array=new F.array.constructor(F.array),this.itemSize=F.itemSize,this.count=F.count,this.normalized=F.normalized,this.usage=F.usage,this.gpuType=F.gpuType,this}copyAt(F,_,$){F*=this.itemSize,$*=_.itemSize;for(let W=0,H=this.itemSize;W<H;W++)this.array[F+W]=_.array[$+W];return this}copyArray(F){return this.array.set(F),this}applyMatrix3(F){if(this.itemSize===2)for(let _=0,$=this.count;_<$;_++)zw.fromBufferAttribute(this,_),zw.applyMatrix3(F),this.setXY(_,zw.x,zw.y);else if(this.itemSize===3)for(let _=0,$=this.count;_<$;_++)u1.fromBufferAttribute(this,_),u1.applyMatrix3(F),this.setXYZ(_,u1.x,u1.y,u1.z);return this}applyMatrix4(F){for(let _=0,$=this.count;_<$;_++)u1.fromBufferAttribute(this,_),u1.applyMatrix4(F),this.setXYZ(_,u1.x,u1.y,u1.z);return this}applyNormalMatrix(F){for(let _=0,$=this.count;_<$;_++)u1.fromBufferAttribute(this,_),u1.applyNormalMatrix(F),this.setXYZ(_,u1.x,u1.y,u1.z);return this}transformDirection(F){for(let _=0,$=this.count;_<$;_++)u1.fromBufferAttribute(this,_),u1.transformDirection(F),this.setXYZ(_,u1.x,u1.y,u1.z);return this}set(F,_=0){return this.array.set(F,_),this}getComponent(F,_){let $=this.array[F*this.itemSize+_];if(this.normalized)$=ZZ($,this.array);return $}setComponent(F,_,$){if(this.normalized)$=P6($,this.array);return this.array[F*this.itemSize+_]=$,this}getX(F){let _=this.array[F*this.itemSize];if(this.normalized)_=ZZ(_,this.array);return _}setX(F,_){if(this.normalized)_=P6(_,this.array);return this.array[F*this.itemSize]=_,this}getY(F){let _=this.array[F*this.itemSize+1];if(this.normalized)_=ZZ(_,this.array);return _}setY(F,_){if(this.normalized)_=P6(_,this.array);return this.array[F*this.itemSize+1]=_,this}getZ(F){let _=this.array[F*this.itemSize+2];if(this.normalized)_=ZZ(_,this.array);return _}setZ(F,_){if(this.normalized)_=P6(_,this.array);return this.array[F*this.itemSize+2]=_,this}getW(F){let _=this.array[F*this.itemSize+3];if(this.normalized)_=ZZ(_,this.array);return _}setW(F,_){if(this.normalized)_=P6(_,this.array);return this.array[F*this.itemSize+3]=_,this}setXY(F,_,$){if(F*=this.itemSize,this.normalized)_=P6(_,this.array),$=P6($,this.array);return this.array[F+0]=_,this.array[F+1]=$,this}setXYZ(F,_,$,W){if(F*=this.itemSize,this.normalized)_=P6(_,this.array),$=P6($,this.array),W=P6(W,this.array);return this.array[F+0]=_,this.array[F+1]=$,this.array[F+2]=W,this}setXYZW(F,_,$,W,H){if(F*=this.itemSize,this.normalized)_=P6(_,this.array),$=P6($,this.array),W=P6(W,this.array),H=P6(H,this.array);return this.array[F+0]=_,this.array[F+1]=$,this.array[F+2]=W,this.array[F+3]=H,this}onUpload(F){return this.onUploadCallback=F,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){let F={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};if(this.name!=="")F.name=this.name;if(this.usage!==35044)F.usage=this.usage;return F}}class ow extends C8{constructor(F,_,$){super(new Uint16Array(F),_,$)}}class aw extends C8{constructor(F,_,$){super(new Uint32Array(F),_,$)}}class k6 extends C8{constructor(F,_,$){super(new Float32Array(F),_,$)}}var lL=0,L8=new N1,L5=new F6,qZ=new w0,H8=new IJ,YQ=new IJ,e1=new w0;class l6 extends N9{constructor(){super();this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:lL++}),this.uuid=AZ(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.indirectOffset=0,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(F){if(Array.isArray(F))this.index=new((VU(F))?aw:ow)(F,1);else this.index=F;return this}setIndirect(F,_=0){return this.indirect=F,this.indirectOffset=_,this}getIndirect(){return this.indirect}getAttribute(F){return this.attributes[F]}setAttribute(F,_){return this.attributes[F]=_,this}deleteAttribute(F){return delete this.attributes[F],this}hasAttribute(F){return this.attributes[F]!==void 0}addGroup(F,_,$=0){this.groups.push({start:F,count:_,materialIndex:$})}clearGroups(){this.groups=[]}setDrawRange(F,_){this.drawRange.start=F,this.drawRange.count=_}applyMatrix4(F){let _=this.attributes.position;if(_!==void 0)_.applyMatrix4(F),_.needsUpdate=!0;let $=this.attributes.normal;if($!==void 0){let H=new EF().getNormalMatrix(F);$.applyNormalMatrix(H),$.needsUpdate=!0}let W=this.attributes.tangent;if(W!==void 0)W.transformDirection(F),W.needsUpdate=!0;if(this.boundingBox!==null)this.computeBoundingBox();if(this.boundingSphere!==null)this.computeBoundingSphere();return this}applyQuaternion(F){return L8.makeRotationFromQuaternion(F),this.applyMatrix4(L8),this}rotateX(F){return L8.makeRotationX(F),this.applyMatrix4(L8),this}rotateY(F){return L8.makeRotationY(F),this.applyMatrix4(L8),this}rotateZ(F){return L8.makeRotationZ(F),this.applyMatrix4(L8),this}translate(F,_,$){return L8.makeTranslation(F,_,$),this.applyMatrix4(L8),this}scale(F,_,$){return L8.makeScale(F,_,$),this.applyMatrix4(L8),this}lookAt(F){return L5.lookAt(F),L5.updateMatrix(),this.applyMatrix4(L5.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(qZ).negate(),this.translate(qZ.x,qZ.y,qZ.z),this}setFromPoints(F){let _=this.getAttribute("position");if(_===void 0){let $=[];for(let W=0,H=F.length;W<H;W++){let Y=F[W];$.push(Y.x,Y.y,Y.z||0)}this.setAttribute("position",new k6($,3))}else{let $=Math.min(F.length,_.count);for(let W=0;W<$;W++){let H=F[W];_.setXYZ(W,H.x,H.y,H.z||0)}if(F.length>_.count)zF("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");_.needsUpdate=!0}return this}computeBoundingBox(){if(this.boundingBox===null)this.boundingBox=new IJ;let F=this.attributes.position,_=this.morphAttributes.position;if(F&&F.isGLBufferAttribute){hF("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new w0(-1/0,-1/0,-1/0),new w0(1/0,1/0,1/0));return}if(F!==void 0){if(this.boundingBox.setFromBufferAttribute(F),_)for(let $=0,W=_.length;$<W;$++){let H=_[$];if(H8.setFromBufferAttribute(H),this.morphTargetsRelative)e1.addVectors(this.boundingBox.min,H8.min),this.boundingBox.expandByPoint(e1),e1.addVectors(this.boundingBox.max,H8.max),this.boundingBox.expandByPoint(e1);else this.boundingBox.expandByPoint(H8.min),this.boundingBox.expandByPoint(H8.max)}}else this.boundingBox.makeEmpty();if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))hF('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){if(this.boundingSphere===null)this.boundingSphere=new hZ;let F=this.attributes.position,_=this.morphAttributes.position;if(F&&F.isGLBufferAttribute){hF("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new w0,1/0);return}if(F){let $=this.boundingSphere.center;if(H8.setFromBufferAttribute(F),_)for(let H=0,Y=_.length;H<Y;H++){let K=_[H];if(YQ.setFromBufferAttribute(K),this.morphTargetsRelative)e1.addVectors(H8.min,YQ.min),H8.expandByPoint(e1),e1.addVectors(H8.max,YQ.max),H8.expandByPoint(e1);else H8.expandByPoint(YQ.min),H8.expandByPoint(YQ.max)}H8.getCenter($);let W=0;for(let H=0,Y=F.count;H<Y;H++)e1.fromBufferAttribute(F,H),W=Math.max(W,$.distanceToSquared(e1));if(_)for(let H=0,Y=_.length;H<Y;H++){let K=_[H],G=this.morphTargetsRelative;for(let U=0,z=K.count;U<z;U++){if(e1.fromBufferAttribute(K,U),G)qZ.fromBufferAttribute(F,U),e1.add(qZ);W=Math.max(W,$.distanceToSquared(e1))}}if(this.boundingSphere.radius=Math.sqrt(W),isNaN(this.boundingSphere.radius))hF('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){let F=this.index,_=this.attributes;if(F===null||_.position===void 0||_.normal===void 0||_.uv===void 0){hF("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}let{position:$,normal:W,uv:H}=_;if(this.hasAttribute("tangent")===!1)this.setAttribute("tangent",new C8(new Float32Array(4*$.count),4));let Y=this.getAttribute("tangent"),K=[],G=[];for(let o=0;o<$.count;o++)K[o]=new w0,G[o]=new w0;let U=new w0,z=new w0,h=new w0,A=new DF,N=new DF,M=new DF,T=new w0,P=new w0;function D(o,s,j){U.fromBufferAttribute($,o),z.fromBufferAttribute($,s),h.fromBufferAttribute($,j),A.fromBufferAttribute(H,o),N.fromBufferAttribute(H,s),M.fromBufferAttribute(H,j),z.sub(U),h.sub(U),N.sub(A),M.sub(A);let V=1/(N.x*M.y-M.x*N.y);if(!isFinite(V))return;T.copy(z).multiplyScalar(M.y).addScaledVector(h,-N.y).multiplyScalar(V),P.copy(h).multiplyScalar(N.x).addScaledVector(z,-M.x).multiplyScalar(V),K[o].add(T),K[s].add(T),K[j].add(T),G[o].add(P),G[s].add(P),G[j].add(P)}let O=this.groups;if(O.length===0)O=[{start:0,count:F.count}];for(let o=0,s=O.length;o<s;++o){let j=O[o],V=j.start,d=j.count;for(let $0=V,X0=V+d;$0<X0;$0+=3)D(F.getX($0+0),F.getX($0+1),F.getX($0+2))}let b=new w0,k=new w0,y=new w0,m=new w0;function x(o){y.fromBufferAttribute(W,o),m.copy(y);let s=K[o];b.copy(s),b.sub(y.multiplyScalar(y.dot(s))).normalize(),k.crossVectors(m,s);let V=k.dot(G[o])<0?-1:1;Y.setXYZW(o,b.x,b.y,b.z,V)}for(let o=0,s=O.length;o<s;++o){let j=O[o],V=j.start,d=j.count;for(let $0=V,X0=V+d;$0<X0;$0+=3)x(F.getX($0+0)),x(F.getX($0+1)),x(F.getX($0+2))}}computeVertexNormals(){let F=this.index,_=this.getAttribute("position");if(_!==void 0){let $=this.getAttribute("normal");if($===void 0)$=new C8(new Float32Array(_.count*3),3),this.setAttribute("normal",$);else for(let A=0,N=$.count;A<N;A++)$.setXYZ(A,0,0,0);let W=new w0,H=new w0,Y=new w0,K=new w0,G=new w0,U=new w0,z=new w0,h=new w0;if(F)for(let A=0,N=F.count;A<N;A+=3){let M=F.getX(A+0),T=F.getX(A+1),P=F.getX(A+2);W.fromBufferAttribute(_,M),H.fromBufferAttribute(_,T),Y.fromBufferAttribute(_,P),z.subVectors(Y,H),h.subVectors(W,H),z.cross(h),K.fromBufferAttribute($,M),G.fromBufferAttribute($,T),U.fromBufferAttribute($,P),K.add(z),G.add(z),U.add(z),$.setXYZ(M,K.x,K.y,K.z),$.setXYZ(T,G.x,G.y,G.z),$.setXYZ(P,U.x,U.y,U.z)}else for(let A=0,N=_.count;A<N;A+=3)W.fromBufferAttribute(_,A+0),H.fromBufferAttribute(_,A+1),Y.fromBufferAttribute(_,A+2),z.subVectors(Y,H),h.subVectors(W,H),z.cross(h),$.setXYZ(A+0,z.x,z.y,z.z),$.setXYZ(A+1,z.x,z.y,z.z),$.setXYZ(A+2,z.x,z.y,z.z);this.normalizeNormals(),$.needsUpdate=!0}}normalizeNormals(){let F=this.attributes.normal;for(let _=0,$=F.count;_<$;_++)e1.fromBufferAttribute(F,_),e1.normalize(),F.setXYZ(_,e1.x,e1.y,e1.z)}toNonIndexed(){function F(K,G){let{array:U,itemSize:z,normalized:h}=K,A=new U.constructor(G.length*z),N=0,M=0;for(let T=0,P=G.length;T<P;T++){if(K.isInterleavedBufferAttribute)N=G[T]*K.data.stride+K.offset;else N=G[T]*z;for(let D=0;D<z;D++)A[M++]=U[N++]}return new C8(A,z,h)}if(this.index===null)return zF("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let _=new l6,$=this.index.array,W=this.attributes;for(let K in W){let G=W[K],U=F(G,$);_.setAttribute(K,U)}let H=this.morphAttributes;for(let K in H){let G=[],U=H[K];for(let z=0,h=U.length;z<h;z++){let A=U[z],N=F(A,$);G.push(N)}_.morphAttributes[K]=G}_.morphTargetsRelative=this.morphTargetsRelative;let Y=this.groups;for(let K=0,G=Y.length;K<G;K++){let U=Y[K];_.addGroup(U.start,U.count,U.materialIndex)}return _}toJSON(){let F={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(F.uuid=this.uuid,F.type=this.type,this.name!=="")F.name=this.name;if(Object.keys(this.userData).length>0)F.userData=this.userData;if(this.parameters!==void 0){let G=this.parameters;for(let U in G)if(G[U]!==void 0)F[U]=G[U];return F}F.data={attributes:{}};let _=this.index;if(_!==null)F.data.index={type:_.array.constructor.name,array:Array.prototype.slice.call(_.array)};let $=this.attributes;for(let G in $){let U=$[G];F.data.attributes[G]=U.toJSON(F.data)}let W={},H=!1;for(let G in this.morphAttributes){let U=this.morphAttributes[G],z=[];for(let h=0,A=U.length;h<A;h++){let N=U[h];z.push(N.toJSON(F.data))}if(z.length>0)W[G]=z,H=!0}if(H)F.data.morphAttributes=W,F.data.morphTargetsRelative=this.morphTargetsRelative;let Y=this.groups;if(Y.length>0)F.data.groups=JSON.parse(JSON.stringify(Y));let K=this.boundingSphere;if(K!==null)F.data.boundingSphere=K.toJSON();return F}clone(){return new this.constructor().copy(this)}copy(F){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;let _={};this.name=F.name;let $=F.index;if($!==null)this.setIndex($.clone());let W=F.attributes;for(let U in W){let z=W[U];this.setAttribute(U,z.clone(_))}let H=F.morphAttributes;for(let U in H){let z=[],h=H[U];for(let A=0,N=h.length;A<N;A++)z.push(h[A].clone(_));this.morphAttributes[U]=z}this.morphTargetsRelative=F.morphTargetsRelative;let Y=F.groups;for(let U=0,z=Y.length;U<z;U++){let h=Y[U];this.addGroup(h.start,h.count,h.materialIndex)}let K=F.boundingBox;if(K!==null)this.boundingBox=K.clone();let G=F.boundingSphere;if(G!==null)this.boundingSphere=G.clone();return this.drawRange.start=F.drawRange.start,this.drawRange.count=F.drawRange.count,this.userData=F.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}var wO=new N1,RJ=new TJ,Aw=new hZ,YO=new w0,hw=new w0,Rw=new w0,Nw=new w0,E5=new w0,Dw=new w0,XO=new w0,Mw=new w0;class X8 extends F6{constructor(F=new l6,_=new sw){super();this.isMesh=!0,this.type="Mesh",this.geometry=F,this.material=_,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(F,_){if(super.copy(F,_),F.morphTargetInfluences!==void 0)this.morphTargetInfluences=F.morphTargetInfluences.slice();if(F.morphTargetDictionary!==void 0)this.morphTargetDictionary=Object.assign({},F.morphTargetDictionary);return this.material=Array.isArray(F.material)?F.material.slice():F.material,this.geometry=F.geometry,this}updateMorphTargets(){let _=this.geometry.morphAttributes,$=Object.keys(_);if($.length>0){let W=_[$[0]];if(W!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let H=0,Y=W.length;H<Y;H++){let K=W[H].name||String(H);this.morphTargetInfluences.push(0),this.morphTargetDictionary[K]=H}}}}getVertexPosition(F,_){let $=this.geometry,W=$.attributes.position,H=$.morphAttributes.position,Y=$.morphTargetsRelative;_.fromBufferAttribute(W,F);let K=this.morphTargetInfluences;if(H&&K){Dw.set(0,0,0);for(let G=0,U=H.length;G<U;G++){let z=K[G],h=H[G];if(z===0)continue;if(E5.fromBufferAttribute(h,F),Y)Dw.addScaledVector(E5,z);else Dw.addScaledVector(E5.sub(_),z)}_.add(Dw)}return _}raycast(F,_){let $=this.geometry,W=this.material,H=this.matrixWorld;if(W===void 0)return;if($.boundingSphere===null)$.computeBoundingSphere();if(Aw.copy($.boundingSphere),Aw.applyMatrix4(H),RJ.copy(F.ray).recast(F.near),Aw.containsPoint(RJ.origin)===!1){if(RJ.intersectSphere(Aw,YO)===null)return;if(RJ.origin.distanceToSquared(YO)>(F.far-F.near)**2)return}if(wO.copy(H).invert(),RJ.copy(F.ray).applyMatrix4(wO),$.boundingBox!==null){if(RJ.intersectsBox($.boundingBox)===!1)return}this._computeIntersections(F,_,RJ)}_computeIntersections(F,_,$){let W,H=this.geometry,Y=this.material,K=H.index,G=H.attributes.position,U=H.attributes.uv,z=H.attributes.uv1,h=H.attributes.normal,A=H.groups,N=H.drawRange;if(K!==null)if(Array.isArray(Y))for(let M=0,T=A.length;M<T;M++){let P=A[M],D=Y[P.materialIndex],O=Math.max(P.start,N.start),b=Math.min(K.count,Math.min(P.start+P.count,N.start+N.count));for(let k=O,y=b;k<y;k+=3){let m=K.getX(k),x=K.getX(k+1),o=K.getX(k+2);if(W=Ow(this,D,F,$,U,z,h,m,x,o),W)W.faceIndex=Math.floor(k/3),W.face.materialIndex=P.materialIndex,_.push(W)}}else{let M=Math.max(0,N.start),T=Math.min(K.count,N.start+N.count);for(let P=M,D=T;P<D;P+=3){let O=K.getX(P),b=K.getX(P+1),k=K.getX(P+2);if(W=Ow(this,Y,F,$,U,z,h,O,b,k),W)W.faceIndex=Math.floor(P/3),_.push(W)}}else if(G!==void 0)if(Array.isArray(Y))for(let M=0,T=A.length;M<T;M++){let P=A[M],D=Y[P.materialIndex],O=Math.max(P.start,N.start),b=Math.min(G.count,Math.min(P.start+P.count,N.start+N.count));for(let k=O,y=b;k<y;k+=3){let m=k,x=k+1,o=k+2;if(W=Ow(this,D,F,$,U,z,h,m,x,o),W)W.faceIndex=Math.floor(k/3),W.face.materialIndex=P.materialIndex,_.push(W)}}else{let M=Math.max(0,N.start),T=Math.min(G.count,N.start+N.count);for(let P=M,D=T;P<D;P+=3){let O=P,b=P+1,k=P+2;if(W=Ow(this,Y,F,$,U,z,h,O,b,k),W)W.faceIndex=Math.floor(P/3),_.push(W)}}}}function dL(F,_,$,W,H,Y,K,G){let U;if(_.side===1)U=W.intersectTriangle(K,Y,H,!0,G);else U=W.intersectTriangle(H,Y,K,_.side===0,G);if(U===null)return null;Mw.copy(G),Mw.applyMatrix4(F.matrixWorld);let z=$.ray.origin.distanceTo(Mw);if(z<$.near||z>$.far)return null;return{distance:z,point:Mw.clone(),object:F}}function Ow(F,_,$,W,H,Y,K,G,U,z){F.getVertexPosition(G,hw),F.getVertexPosition(U,Rw),F.getVertexPosition(z,Nw);let h=dL(F,_,$,W,hw,Rw,Nw,XO);if(h){let A=new w0;if(E8.getBarycoord(XO,hw,Rw,Nw,A),H)h.uv=E8.getInterpolatedAttribute(H,G,U,z,A,new DF);if(Y)h.uv1=E8.getInterpolatedAttribute(Y,G,U,z,A,new DF);if(K){if(h.normal=E8.getInterpolatedAttribute(K,G,U,z,A,new w0),h.normal.dot(W.direction)>0)h.normal.multiplyScalar(-1)}let N={a:G,b:U,c:z,normal:new w0,materialIndex:0};E8.getNormal(hw,Rw,Nw,N.normal),h.face=N,h.barycoord=A}return h}class RZ extends l6{constructor(F=1,_=1,$=1,W=1,H=1,Y=1){super();this.type="BoxGeometry",this.parameters={width:F,height:_,depth:$,widthSegments:W,heightSegments:H,depthSegments:Y};let K=this;W=Math.floor(W),H=Math.floor(H),Y=Math.floor(Y);let G=[],U=[],z=[],h=[],A=0,N=0;M("z","y","x",-1,-1,$,_,F,Y,H,0),M("z","y","x",1,-1,$,_,-F,Y,H,1),M("x","z","y",1,1,F,$,_,W,Y,2),M("x","z","y",1,-1,F,$,-_,W,Y,3),M("x","y","z",1,-1,F,_,$,W,H,4),M("x","y","z",-1,-1,F,_,-$,W,H,5),this.setIndex(G),this.setAttribute("position",new k6(U,3)),this.setAttribute("normal",new k6(z,3)),this.setAttribute("uv",new k6(h,2));function M(T,P,D,O,b,k,y,m,x,o,s){let j=k/x,V=y/o,d=k/2,$0=y/2,X0=m/2,K0=x+1,J0=o+1,u=0,n=0,Q0=new w0;for(let O0=0;O0<J0;O0++){let t=O0*V-$0;for(let T0=0;T0<K0;T0++){let g0=T0*j-d;Q0[T]=g0*O,Q0[P]=t*b,Q0[D]=X0,U.push(Q0.x,Q0.y,Q0.z),Q0[T]=0,Q0[P]=0,Q0[D]=m>0?1:-1,z.push(Q0.x,Q0.y,Q0.z),h.push(T0/x),h.push(1-O0/o),u+=1}}for(let O0=0;O0<o;O0++)for(let t=0;t<x;t++){let T0=A+t+K0*O0,g0=A+t+K0*(O0+1),_F=A+(t+1)+K0*(O0+1),c0=A+(t+1)+K0*O0;G.push(T0,g0,c0),G.push(g0,_F,c0),n+=6}K.addGroup(N,n,s),N+=n,A+=u}}copy(F){return super.copy(F),this.parameters=Object.assign({},F.parameters),this}static fromJSON(F){return new RZ(F.width,F.height,F.depth,F.widthSegments,F.heightSegments,F.depthSegments)}}function LJ(F){let _={};for(let $ in F){_[$]={};for(let W in F[$]){let H=F[$][W];if(H&&(H.isColor||H.isMatrix3||H.isMatrix4||H.isVector2||H.isVector3||H.isVector4||H.isTexture||H.isQuaternion))if(H.isRenderTargetTexture)zF("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),_[$][W]=null;else _[$][W]=H.clone();else if(Array.isArray(H))_[$][W]=H.slice();else _[$][W]=H}}return _}function h6(F){let _={};for(let $=0;$<F.length;$++){let W=LJ(F[$]);for(let H in W)_[H]=W[H]}return _}function iL(F){let _=[];for(let $=0;$<F.length;$++)_.push(F[$].clone());return _}function xU(F){let _=F.getRenderTarget();if(_===null)return F.outputColorSpace;if(_.isXRRenderTarget===!0)return _.texture.colorSpace;return aF.workingColorSpace}var Bf={clone:LJ,merge:h6},nL=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,cL=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class V8 extends Oq{constructor(F){super();if(this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=nL,this.fragmentShader=cL,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,F!==void 0)this.setValues(F)}copy(F){return super.copy(F),this.fragmentShader=F.fragmentShader,this.vertexShader=F.vertexShader,this.uniforms=LJ(F.uniforms),this.uniformsGroups=iL(F.uniformsGroups),this.defines=Object.assign({},F.defines),this.wireframe=F.wireframe,this.wireframeLinewidth=F.wireframeLinewidth,this.fog=F.fog,this.lights=F.lights,this.clipping=F.clipping,this.extensions=Object.assign({},F.extensions),this.glslVersion=F.glslVersion,this.defaultAttributeValues=Object.assign({},F.defaultAttributeValues),this.index0AttributeName=F.index0AttributeName,this.uniformsNeedUpdate=F.uniformsNeedUpdate,this}toJSON(F){let _=super.toJSON(F);_.glslVersion=this.glslVersion,_.uniforms={};for(let W in this.uniforms){let Y=this.uniforms[W].value;if(Y&&Y.isTexture)_.uniforms[W]={type:"t",value:Y.toJSON(F).uuid};else if(Y&&Y.isColor)_.uniforms[W]={type:"c",value:Y.getHex()};else if(Y&&Y.isVector2)_.uniforms[W]={type:"v2",value:Y.toArray()};else if(Y&&Y.isVector3)_.uniforms[W]={type:"v3",value:Y.toArray()};else if(Y&&Y.isVector4)_.uniforms[W]={type:"v4",value:Y.toArray()};else if(Y&&Y.isMatrix3)_.uniforms[W]={type:"m3",value:Y.toArray()};else if(Y&&Y.isMatrix4)_.uniforms[W]={type:"m4",value:Y.toArray()};else _.uniforms[W]={value:Y}}if(Object.keys(this.defines).length>0)_.defines=this.defines;_.vertexShader=this.vertexShader,_.fragmentShader=this.fragmentShader,_.lights=this.lights,_.clipping=this.clipping;let $={};for(let W in this.extensions)if(this.extensions[W]===!0)$[W]=!0;if(Object.keys($).length>0)_.extensions=$;return _}}class rw extends F6{constructor(){super();this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new N1,this.projectionMatrix=new N1,this.projectionMatrixInverse=new N1,this.coordinateSystem=2000,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(F,_){return super.copy(F,_),this.matrixWorldInverse.copy(F.matrixWorldInverse),this.projectionMatrix.copy(F.projectionMatrix),this.projectionMatrixInverse.copy(F.projectionMatrixInverse),this.coordinateSystem=F.coordinateSystem,this}getWorldDirection(F){return super.getWorldDirection(F).negate()}updateMatrixWorld(F){super.updateMatrixWorld(F),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(F,_){super.updateWorldMatrix(F,_),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}var hq=new w0,GO=new DF,KO=new DF;class V6 extends rw{constructor(F=50,_=1,$=0.1,W=2000){super();this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=F,this.zoom=1,this.near=$,this.far=W,this.focus=10,this.aspect=_,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(F,_){return super.copy(F,_),this.fov=F.fov,this.zoom=F.zoom,this.near=F.near,this.far=F.far,this.focus=F.focus,this.aspect=F.aspect,this.view=F.view===null?null:Object.assign({},F.view),this.filmGauge=F.filmGauge,this.filmOffset=F.filmOffset,this}setFocalLength(F){let _=0.5*this.getFilmHeight()/F;this.fov=wZ*2*Math.atan(_),this.updateProjectionMatrix()}getFocalLength(){let F=Math.tan(GQ*0.5*this.fov);return 0.5*this.getFilmHeight()/F}getEffectiveFOV(){return wZ*2*Math.atan(Math.tan(GQ*0.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(F,_,$){hq.set(-1,-1,0.5).applyMatrix4(this.projectionMatrixInverse),_.set(hq.x,hq.y).multiplyScalar(-F/hq.z),hq.set(1,1,0.5).applyMatrix4(this.projectionMatrixInverse),$.set(hq.x,hq.y).multiplyScalar(-F/hq.z)}getViewSize(F,_){return this.getViewBounds(F,GO,KO),_.subVectors(KO,GO)}setViewOffset(F,_,$,W,H,Y){if(this.aspect=F/_,this.view===null)this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};this.view.enabled=!0,this.view.fullWidth=F,this.view.fullHeight=_,this.view.offsetX=$,this.view.offsetY=W,this.view.width=H,this.view.height=Y,this.updateProjectionMatrix()}clearViewOffset(){if(this.view!==null)this.view.enabled=!1;this.updateProjectionMatrix()}updateProjectionMatrix(){let F=this.near,_=F*Math.tan(GQ*0.5*this.fov)/this.zoom,$=2*_,W=this.aspect*$,H=-0.5*W,Y=this.view;if(this.view!==null&&this.view.enabled){let{fullWidth:G,fullHeight:U}=Y;H+=Y.offsetX*W/G,_-=Y.offsetY*$/U,W*=Y.width/G,$*=Y.height/U}let K=this.filmOffset;if(K!==0)H+=F*K/this.getFilmWidth();this.projectionMatrix.makePerspective(H,H+W,_,_-$,F,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(F){let _=super.toJSON(F);if(_.object.fov=this.fov,_.object.zoom=this.zoom,_.object.near=this.near,_.object.far=this.far,_.object.focus=this.focus,_.object.aspect=this.aspect,this.view!==null)_.object.view=Object.assign({},this.view);return _.object.filmGauge=this.filmGauge,_.object.filmOffset=this.filmOffset,_}}var JZ=-90,_Z=1;class gU extends F6{constructor(F,_,$){super();this.type="CubeCamera",this.renderTarget=$,this.coordinateSystem=null,this.activeMipmapLevel=0;let W=new V6(JZ,_Z,F,_);W.layers=this.layers,this.add(W);let H=new V6(JZ,_Z,F,_);H.layers=this.layers,this.add(H);let Y=new V6(JZ,_Z,F,_);Y.layers=this.layers,this.add(Y);let K=new V6(JZ,_Z,F,_);K.layers=this.layers,this.add(K);let G=new V6(JZ,_Z,F,_);G.layers=this.layers,this.add(G);let U=new V6(JZ,_Z,F,_);U.layers=this.layers,this.add(U)}updateCoordinateSystem(){let F=this.coordinateSystem,_=this.children.concat(),[$,W,H,Y,K,G]=_;for(let U of _)this.remove(U);if(F===2000)$.up.set(0,1,0),$.lookAt(1,0,0),W.up.set(0,1,0),W.lookAt(-1,0,0),H.up.set(0,0,-1),H.lookAt(0,1,0),Y.up.set(0,0,1),Y.lookAt(0,-1,0),K.up.set(0,1,0),K.lookAt(0,0,1),G.up.set(0,1,0),G.lookAt(0,0,-1);else if(F===2001)$.up.set(0,-1,0),$.lookAt(-1,0,0),W.up.set(0,-1,0),W.lookAt(1,0,0),H.up.set(0,0,1),H.lookAt(0,1,0),Y.up.set(0,0,-1),Y.lookAt(0,-1,0),K.up.set(0,-1,0),K.lookAt(0,0,1),G.up.set(0,-1,0),G.lookAt(0,0,-1);else throw Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+F);for(let U of _)this.add(U),U.updateMatrixWorld()}update(F,_){if(this.parent===null)this.updateMatrixWorld();let{renderTarget:$,activeMipmapLevel:W}=this;if(this.coordinateSystem!==F.coordinateSystem)this.coordinateSystem=F.coordinateSystem,this.updateCoordinateSystem();let[H,Y,K,G,U,z]=this.children,h=F.getRenderTarget(),A=F.getActiveCubeFace(),N=F.getActiveMipmapLevel(),M=F.xr.enabled;F.xr.enabled=!1;let T=$.texture.generateMipmaps;$.texture.generateMipmaps=!1,F.setRenderTarget($,0,W),F.render(_,H),F.setRenderTarget($,1,W),F.render(_,Y),F.setRenderTarget($,2,W),F.render(_,K),F.setRenderTarget($,3,W),F.render(_,G),F.setRenderTarget($,4,W),F.render(_,U),$.texture.generateMipmaps=T,F.setRenderTarget($,5,W),F.render(_,z),F.setRenderTarget(h,A,N),F.xr.enabled=M,$.texture.needsPMREMUpdate=!0}}class tw extends A6{constructor(F=[],_=301,$,W,H,Y,K,G,U,z){super(F,_,$,W,H,Y,K,G,U,z);this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(F){this.image=F}}class ew extends P8{constructor(F=1,_={}){super(F,F,_);this.isWebGLCubeRenderTarget=!0;let $={width:F,height:F,depth:1},W=[$,$,$,$,$,$];this.texture=new tw(W),this._setTextureOptions(_),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(F,_){this.texture.type=_.type,this.texture.colorSpace=_.colorSpace,this.texture.generateMipmaps=_.generateMipmaps,this.texture.minFilter=_.minFilter,this.texture.magFilter=_.magFilter;let $={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},W=new RZ(5,5,5),H=new V8({name:"CubemapFromEquirect",uniforms:LJ($.uniforms),vertexShader:$.vertexShader,fragmentShader:$.fragmentShader,side:1,blending:0});H.uniforms.tEquirect.value=_;let Y=new X8(W,H),K=_.minFilter;if(_.minFilter===1008)_.minFilter=1006;return new gU(1,10,this).update(F,Y),_.minFilter=K,Y.geometry.dispose(),Y.material.dispose(),this}clear(F,_=!0,$=!0,W=!0){let H=F.getRenderTarget();for(let Y=0;Y<6;Y++)F.setRenderTarget(this,Y),F.clear(_,$,W);F.setRenderTarget(H)}}class $Z extends F6{constructor(){super();this.isGroup=!0,this.type="Group"}}var sL={type:"move"};class fQ{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){if(this._hand===null)this._hand=new $Z,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1};return this._hand}getTargetRaySpace(){if(this._targetRay===null)this._targetRay=new $Z,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new w0,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new w0;return this._targetRay}getGripSpace(){if(this._grip===null)this._grip=new $Z,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new w0,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new w0;return this._grip}dispatchEvent(F){if(this._targetRay!==null)this._targetRay.dispatchEvent(F);if(this._grip!==null)this._grip.dispatchEvent(F);if(this._hand!==null)this._hand.dispatchEvent(F);return this}connect(F){if(F&&F.hand){let _=this._hand;if(_)for(let $ of F.hand.values())this._getHandJoint(_,$)}return this.dispatchEvent({type:"connected",data:F}),this}disconnect(F){if(this.dispatchEvent({type:"disconnected",data:F}),this._targetRay!==null)this._targetRay.visible=!1;if(this._grip!==null)this._grip.visible=!1;if(this._hand!==null)this._hand.visible=!1;return this}update(F,_,$){let W=null,H=null,Y=null,K=this._targetRay,G=this._grip,U=this._hand;if(F&&_.session.visibilityState!=="visible-blurred"){if(U&&F.hand){Y=!0;for(let T of F.hand.values()){let P=_.getJointPose(T,$),D=this._getHandJoint(U,T);if(P!==null)D.matrix.fromArray(P.transform.matrix),D.matrix.decompose(D.position,D.rotation,D.scale),D.matrixWorldNeedsUpdate=!0,D.jointRadius=P.radius;D.visible=P!==null}let z=U.joints["index-finger-tip"],h=U.joints["thumb-tip"],A=z.position.distanceTo(h.position),N=0.02,M=0.005;if(U.inputState.pinching&&A>N+M)U.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:F.handedness,target:this});else if(!U.inputState.pinching&&A<=N-M)U.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:F.handedness,target:this})}else if(G!==null&&F.gripSpace){if(H=_.getPose(F.gripSpace,$),H!==null){if(G.matrix.fromArray(H.transform.matrix),G.matrix.decompose(G.position,G.rotation,G.scale),G.matrixWorldNeedsUpdate=!0,H.linearVelocity)G.hasLinearVelocity=!0,G.linearVelocity.copy(H.linearVelocity);else G.hasLinearVelocity=!1;if(H.angularVelocity)G.hasAngularVelocity=!0,G.angularVelocity.copy(H.angularVelocity);else G.hasAngularVelocity=!1}}if(K!==null){if(W=_.getPose(F.targetRaySpace,$),W===null&&H!==null)W=H;if(W!==null){if(K.matrix.fromArray(W.transform.matrix),K.matrix.decompose(K.position,K.rotation,K.scale),K.matrixWorldNeedsUpdate=!0,W.linearVelocity)K.hasLinearVelocity=!0,K.linearVelocity.copy(W.linearVelocity);else K.hasLinearVelocity=!1;if(W.angularVelocity)K.hasAngularVelocity=!0,K.angularVelocity.copy(W.angularVelocity);else K.hasAngularVelocity=!1;this.dispatchEvent(sL)}}}if(K!==null)K.visible=W!==null;if(G!==null)G.visible=H!==null;if(U!==null)U.visible=Y!==null;return this}_getHandJoint(F,_){if(F.joints[_.jointName]===void 0){let $=new $Z;$.matrixAutoUpdate=!1,$.visible=!1,F.joints[_.jointName]=$,F.add($)}return F.joints[_.jointName]}}class FY extends F6{constructor(){super();if(this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new r8,this.environmentIntensity=1,this.environmentRotation=new r8,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u")__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(F,_){if(super.copy(F,_),F.background!==null)this.background=F.background.clone();if(F.environment!==null)this.environment=F.environment.clone();if(F.fog!==null)this.fog=F.fog.clone();if(this.backgroundBlurriness=F.backgroundBlurriness,this.backgroundIntensity=F.backgroundIntensity,this.backgroundRotation.copy(F.backgroundRotation),this.environmentIntensity=F.environmentIntensity,this.environmentRotation.copy(F.environmentRotation),F.overrideMaterial!==null)this.overrideMaterial=F.overrideMaterial.clone();return this.matrixAutoUpdate=F.matrixAutoUpdate,this}toJSON(F){let _=super.toJSON(F);if(this.fog!==null)_.object.fog=this.fog.toJSON();if(this.backgroundBlurriness>0)_.object.backgroundBlurriness=this.backgroundBlurriness;if(this.backgroundIntensity!==1)_.object.backgroundIntensity=this.backgroundIntensity;if(_.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1)_.object.environmentIntensity=this.environmentIntensity;return _.object.environmentRotation=this.environmentRotation.toArray(),_}}class uU extends A6{constructor(F=null,_=1,$=1,W,H,Y,K,G,U=1003,z=1003,h,A){super(null,Y,K,G,U,z,W,H,h,A);this.isDataTexture=!0,this.image={data:F,width:_,height:$},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}var C5=new w0,oL=new w0,aL=new EF;class a8{constructor(F=new w0(1,0,0),_=0){this.isPlane=!0,this.normal=F,this.constant=_}set(F,_){return this.normal.copy(F),this.constant=_,this}setComponents(F,_,$,W){return this.normal.set(F,_,$),this.constant=W,this}setFromNormalAndCoplanarPoint(F,_){return this.normal.copy(F),this.constant=-_.dot(this.normal),this}setFromCoplanarPoints(F,_,$){let W=C5.subVectors($,_).cross(oL.subVectors(F,_)).normalize();return this.setFromNormalAndCoplanarPoint(W,F),this}copy(F){return this.normal.copy(F.normal),this.constant=F.constant,this}normalize(){let F=1/this.normal.length();return this.normal.multiplyScalar(F),this.constant*=F,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(F){return this.normal.dot(F)+this.constant}distanceToSphere(F){return this.distanceToPoint(F.center)-F.radius}projectPoint(F,_){return _.copy(F).addScaledVector(this.normal,-this.distanceToPoint(F))}intersectLine(F,_){let $=F.delta(C5),W=this.normal.dot($);if(W===0){if(this.distanceToPoint(F.start)===0)return _.copy(F.start);return null}let H=-(F.start.dot(this.normal)+this.constant)/W;if(H<0||H>1)return null;return _.copy(F.start).addScaledVector($,H)}intersectsLine(F){let _=this.distanceToPoint(F.start),$=this.distanceToPoint(F.end);return _<0&&$>0||$<0&&_>0}intersectsBox(F){return F.intersectsPlane(this)}intersectsSphere(F){return F.intersectsPlane(this)}coplanarPoint(F){return F.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(F,_){let $=_||aL.getNormalMatrix(F),W=this.coplanarPoint(C5).applyMatrix4(F),H=this.normal.applyMatrix3($).normalize();return this.constant=-W.dot(H),this}translate(F){return this.constant-=F.dot(this.normal),this}equals(F){return F.normal.equals(this.normal)&&F.constant===this.constant}clone(){return new this.constructor().copy(this)}}var NJ=new hZ,rL=new DF(0.5,0.5),fw=new w0;class IQ{constructor(F=new a8,_=new a8,$=new a8,W=new a8,H=new a8,Y=new a8){this.planes=[F,_,$,W,H,Y]}set(F,_,$,W,H,Y){let K=this.planes;return K[0].copy(F),K[1].copy(_),K[2].copy($),K[3].copy(W),K[4].copy(H),K[5].copy(Y),this}copy(F){let _=this.planes;for(let $=0;$<6;$++)_[$].copy(F.planes[$]);return this}setFromProjectionMatrix(F,_=2000,$=!1){let W=this.planes,H=F.elements,Y=H[0],K=H[1],G=H[2],U=H[3],z=H[4],h=H[5],A=H[6],N=H[7],M=H[8],T=H[9],P=H[10],D=H[11],O=H[12],b=H[13],k=H[14],y=H[15];if(W[0].setComponents(U-Y,N-z,D-M,y-O).normalize(),W[1].setComponents(U+Y,N+z,D+M,y+O).normalize(),W[2].setComponents(U+K,N+h,D+T,y+b).normalize(),W[3].setComponents(U-K,N-h,D-T,y-b).normalize(),$)W[4].setComponents(G,A,P,k).normalize(),W[5].setComponents(U-G,N-A,D-P,y-k).normalize();else if(W[4].setComponents(U-G,N-A,D-P,y-k).normalize(),_===2000)W[5].setComponents(U+G,N+A,D+P,y+k).normalize();else if(_===2001)W[5].setComponents(G,A,P,k).normalize();else throw Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+_);return this}intersectsObject(F){if(F.boundingSphere!==void 0){if(F.boundingSphere===null)F.computeBoundingSphere();NJ.copy(F.boundingSphere).applyMatrix4(F.matrixWorld)}else{let _=F.geometry;if(_.boundingSphere===null)_.computeBoundingSphere();NJ.copy(_.boundingSphere).applyMatrix4(F.matrixWorld)}return this.intersectsSphere(NJ)}intersectsSprite(F){NJ.center.set(0,0,0);let _=rL.distanceTo(F.center);return NJ.radius=0.7071067811865476+_,NJ.applyMatrix4(F.matrixWorld),this.intersectsSphere(NJ)}intersectsSphere(F){let _=this.planes,$=F.center,W=-F.radius;for(let H=0;H<6;H++)if(_[H].distanceToPoint($)<W)return!1;return!0}intersectsBox(F){let _=this.planes;for(let $=0;$<6;$++){let W=_[$];if(fw.x=W.normal.x>0?F.max.x:F.min.x,fw.y=W.normal.y>0?F.max.y:F.min.y,fw.z=W.normal.z>0?F.max.z:F.min.z,W.distanceToPoint(fw)<0)return!1}return!0}containsPoint(F){let _=this.planes;for(let $=0;$<6;$++)if(_[$].distanceToPoint(F)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class TQ extends Oq{constructor(F){super();this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new lF(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(F)}copy(F){return super.copy(F),this.color.copy(F.color),this.map=F.map,this.linewidth=F.linewidth,this.linecap=F.linecap,this.linejoin=F.linejoin,this.fog=F.fog,this}}var Ew=new w0,Cw=new w0,UO=new N1,XQ=new TJ,Iw=new hZ,P5=new w0,BO=new w0;class qY extends F6{constructor(F=new l6,_=new TQ){super();this.isLine=!0,this.type="Line",this.geometry=F,this.material=_,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(F,_){return super.copy(F,_),this.material=Array.isArray(F.material)?F.material.slice():F.material,this.geometry=F.geometry,this}computeLineDistances(){let F=this.geometry;if(F.index===null){let _=F.attributes.position,$=[0];for(let W=1,H=_.count;W<H;W++)Ew.fromBufferAttribute(_,W-1),Cw.fromBufferAttribute(_,W),$[W]=$[W-1],$[W]+=Ew.distanceTo(Cw);F.setAttribute("lineDistance",new k6($,1))}else zF("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(F,_){let $=this.geometry,W=this.matrixWorld,H=F.params.Line.threshold,Y=$.drawRange;if($.boundingSphere===null)$.computeBoundingSphere();if(Iw.copy($.boundingSphere),Iw.applyMatrix4(W),Iw.radius+=H,F.ray.intersectsSphere(Iw)===!1)return;UO.copy(W).invert(),XQ.copy(F.ray).applyMatrix4(UO);let K=H/((this.scale.x+this.scale.y+this.scale.z)/3),G=K*K,U=this.isLineSegments?2:1,z=$.index,A=$.attributes.position;if(z!==null){let N=Math.max(0,Y.start),M=Math.min(z.count,Y.start+Y.count);for(let T=N,P=M-1;T<P;T+=U){let D=z.getX(T),O=z.getX(T+1),b=Tw(this,F,XQ,G,D,O,T);if(b)_.push(b)}if(this.isLineLoop){let T=z.getX(M-1),P=z.getX(N),D=Tw(this,F,XQ,G,T,P,M-1);if(D)_.push(D)}}else{let N=Math.max(0,Y.start),M=Math.min(A.count,Y.start+Y.count);for(let T=N,P=M-1;T<P;T+=U){let D=Tw(this,F,XQ,G,T,T+1,T);if(D)_.push(D)}if(this.isLineLoop){let T=Tw(this,F,XQ,G,M-1,N,M-1);if(T)_.push(T)}}}updateMorphTargets(){let _=this.geometry.morphAttributes,$=Object.keys(_);if($.length>0){let W=_[$[0]];if(W!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let H=0,Y=W.length;H<Y;H++){let K=W[H].name||String(H);this.morphTargetInfluences.push(0),this.morphTargetDictionary[K]=H}}}}}function Tw(F,_,$,W,H,Y,K){let G=F.geometry.attributes.position;if(Ew.fromBufferAttribute(G,H),Cw.fromBufferAttribute(G,Y),$.distanceSqToSegment(Ew,Cw,P5,BO)>W)return;P5.applyMatrix4(F.matrixWorld);let z=_.ray.origin.distanceTo(P5);if(z<_.near||z>_.far)return;return{distance:z,point:BO.clone().applyMatrix4(F.matrixWorld),index:K,face:null,faceIndex:null,barycoord:null,object:F}}class EJ extends A6{constructor(F,_,$=1014,W,H,Y,K=1003,G=1003,U,z=1026,h=1){if(z!==1026&&z!==1027)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");let A={width:F,height:_,depth:h};super(A,W,H,Y,K,G,z,$,U);this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(F){return super.copy(F),this.source=new MQ(Object.assign({},F.image)),this.compareFunction=F.compareFunction,this}toJSON(F){let _=super.toJSON(F);if(this.compareFunction!==null)_.compareFunction=this.compareFunction;return _}}class pU extends EJ{constructor(F,_=1014,$=301,W,H,Y=1003,K=1003,G,U=1026){let z={width:F,height:F,depth:1},h=[z,z,z,z,z,z];super(F,F,_,$,W,H,Y,K,G,U);this.image=h,this.isCubeDepthTexture=!0,this.isCubeTexture=!0}get images(){return this.image}set images(F){this.image=F}}class JY extends A6{constructor(F=null){super();this.sourceTexture=F,this.isExternalTexture=!0}copy(F){return super.copy(F),this.sourceTexture=F.sourceTexture,this}}class LQ extends l6{constructor(F=1,_=1,$=1,W=1){super();this.type="PlaneGeometry",this.parameters={width:F,height:_,widthSegments:$,heightSegments:W};let H=F/2,Y=_/2,K=Math.floor($),G=Math.floor(W),U=K+1,z=G+1,h=F/K,A=_/G,N=[],M=[],T=[],P=[];for(let D=0;D<z;D++){let O=D*A-Y;for(let b=0;b<U;b++){let k=b*h-H;M.push(k,-O,0),T.push(0,0,1),P.push(b/K),P.push(1-D/G)}}for(let D=0;D<G;D++)for(let O=0;O<K;O++){let b=O+U*D,k=O+U*(D+1),y=O+1+U*(D+1),m=O+1+U*D;N.push(b,k,m),N.push(k,y,m)}this.setIndex(N),this.setAttribute("position",new k6(M,3)),this.setAttribute("normal",new k6(T,3)),this.setAttribute("uv",new k6(P,2))}copy(F){return super.copy(F),this.parameters=Object.assign({},F.parameters),this}static fromJSON(F){return new LQ(F.width,F.height,F.widthSegments,F.heightSegments)}}class EQ extends l6{constructor(F=1,_=32,$=16,W=0,H=Math.PI*2,Y=0,K=Math.PI){super();this.type="SphereGeometry",this.parameters={radius:F,widthSegments:_,heightSegments:$,phiStart:W,phiLength:H,thetaStart:Y,thetaLength:K},_=Math.max(3,Math.floor(_)),$=Math.max(2,Math.floor($));let G=Math.min(Y+K,Math.PI),U=0,z=[],h=new w0,A=new w0,N=[],M=[],T=[],P=[];for(let D=0;D<=$;D++){let O=[],b=D/$,k=0;if(D===0&&Y===0)k=0.5/_;else if(D===$&&G===Math.PI)k=-0.5/_;for(let y=0;y<=_;y++){let m=y/_;h.x=-F*Math.cos(W+m*H)*Math.sin(Y+b*K),h.y=F*Math.cos(Y+b*K),h.z=F*Math.sin(W+m*H)*Math.sin(Y+b*K),M.push(h.x,h.y,h.z),A.copy(h).normalize(),T.push(A.x,A.y,A.z),P.push(m+k,1-b),O.push(U++)}z.push(O)}for(let D=0;D<$;D++)for(let O=0;O<_;O++){let b=z[D][O+1],k=z[D][O],y=z[D+1][O],m=z[D+1][O+1];if(D!==0||Y>0)N.push(b,k,m);if(D!==$-1||G<Math.PI)N.push(k,y,m)}this.setIndex(N),this.setAttribute("position",new k6(M,3)),this.setAttribute("normal",new k6(T,3)),this.setAttribute("uv",new k6(P,2))}copy(F){return super.copy(F),this.parameters=Object.assign({},F.parameters),this}static fromJSON(F){return new EQ(F.radius,F.widthSegments,F.heightSegments,F.phiStart,F.phiLength,F.thetaStart,F.thetaLength)}}class mU extends V8{constructor(F){super(F);this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class _Y extends Oq{constructor(F){super();this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new lF(16777215),this.specular=new lF(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lF(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new DF(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new r8,this.combine=0,this.reflectivity=1,this.refractionRatio=0.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(F)}copy(F){return super.copy(F),this.color.copy(F.color),this.specular.copy(F.specular),this.shininess=F.shininess,this.map=F.map,this.lightMap=F.lightMap,this.lightMapIntensity=F.lightMapIntensity,this.aoMap=F.aoMap,this.aoMapIntensity=F.aoMapIntensity,this.emissive.copy(F.emissive),this.emissiveMap=F.emissiveMap,this.emissiveIntensity=F.emissiveIntensity,this.bumpMap=F.bumpMap,this.bumpScale=F.bumpScale,this.normalMap=F.normalMap,this.normalMapType=F.normalMapType,this.normalScale.copy(F.normalScale),this.displacementMap=F.displacementMap,this.displacementScale=F.displacementScale,this.displacementBias=F.displacementBias,this.specularMap=F.specularMap,this.alphaMap=F.alphaMap,this.envMap=F.envMap,this.envMapRotation.copy(F.envMapRotation),this.combine=F.combine,this.reflectivity=F.reflectivity,this.refractionRatio=F.refractionRatio,this.wireframe=F.wireframe,this.wireframeLinewidth=F.wireframeLinewidth,this.wireframeLinecap=F.wireframeLinecap,this.wireframeLinejoin=F.wireframeLinejoin,this.flatShading=F.flatShading,this.fog=F.fog,this}}class lU extends Oq{constructor(F){super();this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(F)}copy(F){return super.copy(F),this.depthPacking=F.depthPacking,this.map=F.map,this.alphaMap=F.alphaMap,this.displacementMap=F.displacementMap,this.displacementScale=F.displacementScale,this.displacementBias=F.displacementBias,this.wireframe=F.wireframe,this.wireframeLinewidth=F.wireframeLinewidth,this}}class dU extends Oq{constructor(F){super();this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(F)}copy(F){return super.copy(F),this.map=F.map,this.alphaMap=F.alphaMap,this.displacementMap=F.displacementMap,this.displacementScale=F.displacementScale,this.displacementBias=F.displacementBias,this}}function Lw(F,_){if(!F||F.constructor===_)return F;if(typeof _.BYTES_PER_ELEMENT==="number")return new _(F);return Array.prototype.slice.call(F)}class NZ{constructor(F,_,$,W){this.parameterPositions=F,this._cachedIndex=0,this.resultBuffer=W!==void 0?W:new _.constructor($),this.sampleValues=_,this.valueSize=$,this.settings=null,this.DefaultSettings_={}}evaluate(F){let _=this.parameterPositions,$=this._cachedIndex,W=_[$],H=_[$-1];F:{q:{let Y;J:{_:if(!(F<W)){for(let K=$+2;;){if(W===void 0){if(F<H)break _;return $=_.length,this._cachedIndex=$,this.copySampleValue_($-1)}if($===K)break;if(H=W,W=_[++$],F<W)break q}Y=_.length;break J}if(!(F>=H)){let K=_[1];if(F<K)$=2,H=K;for(let G=$-2;;){if(H===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if($===G)break;if(W=H,H=_[--$-1],F>=H)break q}Y=$,$=0;break J}break F}while($<Y){let K=$+Y>>>1;if(F<_[K])Y=K;else $=K+1}if(W=_[$],H=_[$-1],H===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(W===void 0)return $=_.length,this._cachedIndex=$,this.copySampleValue_($-1)}this._cachedIndex=$,this.intervalChanged_($,H,W)}return this.interpolate_($,H,F,W)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(F){let _=this.resultBuffer,$=this.sampleValues,W=this.valueSize,H=F*W;for(let Y=0;Y!==W;++Y)_[Y]=$[H+Y];return _}interpolate_(){throw Error("call to abstract method")}intervalChanged_(){}}class iU extends NZ{constructor(F,_,$,W){super(F,_,$,W);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(F,_,$){let W=this.parameterPositions,H=F-2,Y=F+1,K=W[H],G=W[Y];if(K===void 0)switch(this.getSettings_().endingStart){case 2401:H=F,K=2*_-$;break;case 2402:H=W.length-2,K=_+W[H]-W[H+1];break;default:H=F,K=$}if(G===void 0)switch(this.getSettings_().endingEnd){case 2401:Y=F,G=2*$-_;break;case 2402:Y=1,G=$+W[1]-W[0];break;default:Y=F-1,G=_}let U=($-_)*0.5,z=this.valueSize;this._weightPrev=U/(_-K),this._weightNext=U/(G-$),this._offsetPrev=H*z,this._offsetNext=Y*z}interpolate_(F,_,$,W){let H=this.resultBuffer,Y=this.sampleValues,K=this.valueSize,G=F*K,U=G-K,z=this._offsetPrev,h=this._offsetNext,A=this._weightPrev,N=this._weightNext,M=($-_)/(W-_),T=M*M,P=T*M,D=-A*P+2*A*T-A*M,O=(1+A)*P+(-1.5-2*A)*T+(-0.5+A)*M+1,b=(-1-N)*P+(1.5+N)*T+0.5*M,k=N*P-N*T;for(let y=0;y!==K;++y)H[y]=D*Y[z+y]+O*Y[U+y]+b*Y[G+y]+k*Y[h+y];return H}}class nU extends NZ{constructor(F,_,$,W){super(F,_,$,W)}interpolate_(F,_,$,W){let H=this.resultBuffer,Y=this.sampleValues,K=this.valueSize,G=F*K,U=G-K,z=($-_)/(W-_),h=1-z;for(let A=0;A!==K;++A)H[A]=Y[U+A]*h+Y[G+A]*z;return H}}class cU extends NZ{constructor(F,_,$,W){super(F,_,$,W)}interpolate_(F){return this.copySampleValue_(F-1)}}class k8{constructor(F,_,$,W){if(F===void 0)throw Error("THREE.KeyframeTrack: track name is undefined");if(_===void 0||_.length===0)throw Error("THREE.KeyframeTrack: no keyframes in track named "+F);this.name=F,this.times=Lw(_,this.TimeBufferType),this.values=Lw($,this.ValueBufferType),this.setInterpolation(W||this.DefaultInterpolation)}static toJSON(F){let _=F.constructor,$;if(_.toJSON!==this.toJSON)$=_.toJSON(F);else{$={name:F.name,times:Lw(F.times,Array),values:Lw(F.values,Array)};let W=F.getInterpolation();if(W!==F.DefaultInterpolation)$.interpolation=W}return $.type=F.ValueTypeName,$}InterpolantFactoryMethodDiscrete(F){return new cU(this.times,this.values,this.getValueSize(),F)}InterpolantFactoryMethodLinear(F){return new nU(this.times,this.values,this.getValueSize(),F)}InterpolantFactoryMethodSmooth(F){return new iU(this.times,this.values,this.getValueSize(),F)}setInterpolation(F){let _;switch(F){case 2300:_=this.InterpolantFactoryMethodDiscrete;break;case 2301:_=this.InterpolantFactoryMethodLinear;break;case 2302:_=this.InterpolantFactoryMethodSmooth;break}if(_===void 0){let $="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(F!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error($);return zF("KeyframeTrack:",$),this}return this.createInterpolant=_,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(F){if(F!==0){let _=this.times;for(let $=0,W=_.length;$!==W;++$)_[$]+=F}return this}scale(F){if(F!==1){let _=this.times;for(let $=0,W=_.length;$!==W;++$)_[$]*=F}return this}trim(F,_){let $=this.times,W=$.length,H=0,Y=W-1;while(H!==W&&$[H]<F)++H;while(Y!==-1&&$[Y]>_)--Y;if(++Y,H!==0||Y!==W){if(H>=Y)Y=Math.max(Y,1),H=Y-1;let K=this.getValueSize();this.times=$.slice(H,Y),this.values=this.values.slice(H*K,Y*K)}return this}validate(){let F=!0,_=this.getValueSize();if(_-Math.floor(_)!==0)hF("KeyframeTrack: Invalid value size in track.",this),F=!1;let $=this.times,W=this.values,H=$.length;if(H===0)hF("KeyframeTrack: Track is empty.",this),F=!1;let Y=null;for(let K=0;K!==H;K++){let G=$[K];if(typeof G==="number"&&isNaN(G)){hF("KeyframeTrack: Time is not a valid number.",this,K,G),F=!1;break}if(Y!==null&&Y>G){hF("KeyframeTrack: Out of order keys.",this,K,G,Y),F=!1;break}Y=G}if(W!==void 0){if(UL(W))for(let K=0,G=W.length;K!==G;++K){let U=W[K];if(isNaN(U)){hF("KeyframeTrack: Value is not a valid number.",this,K,U),F=!1;break}}}return F}optimize(){let F=this.times.slice(),_=this.values.slice(),$=this.getValueSize(),W=this.getInterpolation()===2302,H=F.length-1,Y=1;for(let K=1;K<H;++K){let G=!1,U=F[K],z=F[K+1];if(U!==z&&(K!==1||U!==F[0]))if(!W){let h=K*$,A=h-$,N=h+$;for(let M=0;M!==$;++M){let T=_[h+M];if(T!==_[A+M]||T!==_[N+M]){G=!0;break}}}else G=!0;if(G){if(K!==Y){F[Y]=F[K];let h=K*$,A=Y*$;for(let N=0;N!==$;++N)_[A+N]=_[h+N]}++Y}}if(H>0){F[Y]=F[H];for(let K=H*$,G=Y*$,U=0;U!==$;++U)_[G+U]=_[K+U];++Y}if(Y!==F.length)this.times=F.slice(0,Y),this.values=_.slice(0,Y*$);else this.times=F,this.values=_;return this}clone(){let F=this.times.slice(),_=this.values.slice(),W=new this.constructor(this.name,F,_);return W.createInterpolant=this.createInterpolant,W}}k8.prototype.ValueTypeName="";k8.prototype.TimeBufferType=Float32Array;k8.prototype.ValueBufferType=Float32Array;k8.prototype.DefaultInterpolation=2301;class CJ extends k8{constructor(F,_,$){super(F,_,$)}}CJ.prototype.ValueTypeName="bool";CJ.prototype.ValueBufferType=Array;CJ.prototype.DefaultInterpolation=2300;CJ.prototype.InterpolantFactoryMethodLinear=void 0;CJ.prototype.InterpolantFactoryMethodSmooth=void 0;class sU extends k8{constructor(F,_,$,W){super(F,_,$,W)}}sU.prototype.ValueTypeName="color";class oU extends k8{constructor(F,_,$,W){super(F,_,$,W)}}oU.prototype.ValueTypeName="number";class aU extends NZ{constructor(F,_,$,W){super(F,_,$,W)}interpolate_(F,_,$,W){let H=this.resultBuffer,Y=this.sampleValues,K=this.valueSize,G=($-_)/(W-_),U=F*K;for(let z=U+K;U!==z;U+=4)F7.slerpFlat(H,0,Y,U-K,Y,U,G);return H}}class ZY extends k8{constructor(F,_,$,W){super(F,_,$,W)}InterpolantFactoryMethodLinear(F){return new aU(this.times,this.values,this.getValueSize(),F)}}ZY.prototype.ValueTypeName="quaternion";ZY.prototype.InterpolantFactoryMethodSmooth=void 0;class PJ extends k8{constructor(F,_,$){super(F,_,$)}}PJ.prototype.ValueTypeName="string";PJ.prototype.ValueBufferType=Array;PJ.prototype.DefaultInterpolation=2300;PJ.prototype.InterpolantFactoryMethodLinear=void 0;PJ.prototype.InterpolantFactoryMethodSmooth=void 0;class rU extends k8{constructor(F,_,$,W){super(F,_,$,W)}}rU.prototype.ValueTypeName="vector";class tU{constructor(F,_,$){let W=this,H=!1,Y=0,K=0,G=void 0,U=[];this.onStart=void 0,this.onLoad=F,this.onProgress=_,this.onError=$,this._abortController=null,this.itemStart=function(z){if(K++,H===!1){if(W.onStart!==void 0)W.onStart(z,Y,K)}H=!0},this.itemEnd=function(z){if(Y++,W.onProgress!==void 0)W.onProgress(z,Y,K);if(Y===K){if(H=!1,W.onLoad!==void 0)W.onLoad()}},this.itemError=function(z){if(W.onError!==void 0)W.onError(z)},this.resolveURL=function(z){if(G)return G(z);return z},this.setURLModifier=function(z){return G=z,this},this.addHandler=function(z,h){return U.push(z,h),this},this.removeHandler=function(z){let h=U.indexOf(z);if(h!==-1)U.splice(h,2);return this},this.getHandler=function(z){for(let h=0,A=U.length;h<A;h+=2){let N=U[h],M=U[h+1];if(N.global)N.lastIndex=0;if(N.test(z))return M}return null},this.abort=function(){return this.abortController.abort(),this._abortController=null,this}}get abortController(){if(!this._abortController)this._abortController=new AbortController;return this._abortController}}var zf=new tU;class eU{constructor(F){this.manager=F!==void 0?F:zf,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(F,_){let $=this;return new Promise(function(W,H){$.load(F,W,_,H)})}parse(){}setCrossOrigin(F){return this.crossOrigin=F,this}setWithCredentials(F){return this.withCredentials=F,this}setPath(F){return this.path=F,this}setResourcePath(F){return this.resourcePath=F,this}setRequestHeader(F){return this.requestHeader=F,this}abort(){return this}}eU.DEFAULT_MATERIAL_NAME="__DEFAULT";class $Y extends F6{constructor(F,_=1){super();this.isLight=!0,this.type="Light",this.color=new lF(F),this.intensity=_}dispose(){this.dispatchEvent({type:"dispose"})}copy(F,_){return super.copy(F,_),this.color.copy(F.color),this.intensity=F.intensity,this}toJSON(F){let _=super.toJSON(F);return _.object.color=this.color.getHex(),_.object.intensity=this.intensity,_}}var V5=new N1,zO=new w0,AO=new w0;class Af{constructor(F){this.camera=F,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new DF(512,512),this.mapType=1009,this.map=null,this.mapPass=null,this.matrix=new N1,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new IQ,this._frameExtents=new DF(1,1),this._viewportCount=1,this._viewports=[new T1(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(F){let _=this.camera,$=this.matrix;if(zO.setFromMatrixPosition(F.matrixWorld),_.position.copy(zO),AO.setFromMatrixPosition(F.target.matrixWorld),_.lookAt(AO),_.updateMatrixWorld(),V5.multiplyMatrices(_.projectionMatrix,_.matrixWorldInverse),this._frustum.setFromProjectionMatrix(V5,_.coordinateSystem,_.reversedDepth),_.reversedDepth)$.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,1,0,0,0,0,1);else $.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1);$.multiply(V5)}getViewport(F){return this._viewports[F]}getFrameExtents(){return this._frameExtents}dispose(){if(this.map)this.map.dispose();if(this.mapPass)this.mapPass.dispose()}copy(F){return this.camera=F.camera.clone(),this.intensity=F.intensity,this.bias=F.bias,this.radius=F.radius,this.autoUpdate=F.autoUpdate,this.needsUpdate=F.needsUpdate,this.normalBias=F.normalBias,this.blurSamples=F.blurSamples,this.mapSize.copy(F.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){let F={};if(this.intensity!==1)F.intensity=this.intensity;if(this.bias!==0)F.bias=this.bias;if(this.normalBias!==0)F.normalBias=this.normalBias;if(this.radius!==1)F.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)F.mapSize=this.mapSize.toArray();return F.camera=this.camera.toJSON(!1).object,delete F.camera.matrix,F}}class CQ extends rw{constructor(F=-1,_=1,$=1,W=-1,H=0.1,Y=2000){super();this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=F,this.right=_,this.top=$,this.bottom=W,this.near=H,this.far=Y,this.updateProjectionMatrix()}copy(F,_){return super.copy(F,_),this.left=F.left,this.right=F.right,this.top=F.top,this.bottom=F.bottom,this.near=F.near,this.far=F.far,this.zoom=F.zoom,this.view=F.view===null?null:Object.assign({},F.view),this}setViewOffset(F,_,$,W,H,Y){if(this.view===null)this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};this.view.enabled=!0,this.view.fullWidth=F,this.view.fullHeight=_,this.view.offsetX=$,this.view.offsetY=W,this.view.width=H,this.view.height=Y,this.updateProjectionMatrix()}clearViewOffset(){if(this.view!==null)this.view.enabled=!1;this.updateProjectionMatrix()}updateProjectionMatrix(){let F=(this.right-this.left)/(2*this.zoom),_=(this.top-this.bottom)/(2*this.zoom),$=(this.right+this.left)/2,W=(this.top+this.bottom)/2,H=$-F,Y=$+F,K=W+_,G=W-_;if(this.view!==null&&this.view.enabled){let U=(this.right-this.left)/this.view.fullWidth/this.zoom,z=(this.top-this.bottom)/this.view.fullHeight/this.zoom;H+=U*this.view.offsetX,Y=H+U*this.view.width,K-=z*this.view.offsetY,G=K-z*this.view.height}this.projectionMatrix.makeOrthographic(H,Y,K,G,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(F){let _=super.toJSON(F);if(_.object.zoom=this.zoom,_.object.left=this.left,_.object.right=this.right,_.object.top=this.top,_.object.bottom=this.bottom,_.object.near=this.near,_.object.far=this.far,this.view!==null)_.object.view=Object.assign({},this.view);return _}}class hf extends Af{constructor(){super(new CQ(-5,5,5,-5,0.5,500));this.isDirectionalLightShadow=!0}}class QY extends $Y{constructor(F,_){super(F,_);this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(F6.DEFAULT_UP),this.updateMatrix(),this.target=new F6,this.shadow=new hf}dispose(){super.dispose(),this.shadow.dispose()}copy(F){return super.copy(F),this.target=F.target.clone(),this.shadow=F.shadow.clone(),this}toJSON(F){let _=super.toJSON(F);return _.object.shadow=this.shadow.toJSON(),_.object.target=this.target.uuid,_}}class WY extends $Y{constructor(F,_){super(F,_);this.isAmbientLight=!0,this.type="AmbientLight"}}class FB extends V6{constructor(F=[]){super();this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=F}}var qB="\\[\\]\\.:\\/",tL=new RegExp("["+qB+"]","g"),JB="[^"+qB+"]",eL="[^"+qB.replace("\\.","")+"]",FE=/((?:WC+[\/:])*)/.source.replace("WC",JB),qE=/(WCOD+)?/.source.replace("WCOD",eL),JE=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",JB),_E=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",JB),ZE=new RegExp("^"+FE+qE+JE+_E+"$"),$E=["material","materials","bones","map"];class Rf{constructor(F,_,$){let W=$||Z1.parseTrackName(_);this._targetGroup=F,this._bindings=F.subscribe_(_,W)}getValue(F,_){this.bind();let $=this._targetGroup.nCachedObjects_,W=this._bindings[$];if(W!==void 0)W.getValue(F,_)}setValue(F,_){let $=this._bindings;for(let W=this._targetGroup.nCachedObjects_,H=$.length;W!==H;++W)$[W].setValue(F,_)}bind(){let F=this._bindings;for(let _=this._targetGroup.nCachedObjects_,$=F.length;_!==$;++_)F[_].bind()}unbind(){let F=this._bindings;for(let _=this._targetGroup.nCachedObjects_,$=F.length;_!==$;++_)F[_].unbind()}}class Z1{constructor(F,_,$){this.path=_,this.parsedPath=$||Z1.parseTrackName(_),this.node=Z1.findNode(F,this.parsedPath.nodeName),this.rootNode=F,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(F,_,$){if(!(F&&F.isAnimationObjectGroup))return new Z1(F,_,$);else return new Z1.Composite(F,_,$)}static sanitizeNodeName(F){return F.replace(/\s/g,"_").replace(tL,"")}static parseTrackName(F){let _=ZE.exec(F);if(_===null)throw Error("PropertyBinding: Cannot parse trackName: "+F);let $={nodeName:_[2],objectName:_[3],objectIndex:_[4],propertyName:_[5],propertyIndex:_[6]},W=$.nodeName&&$.nodeName.lastIndexOf(".");if(W!==void 0&&W!==-1){let H=$.nodeName.substring(W+1);if($E.indexOf(H)!==-1)$.nodeName=$.nodeName.substring(0,W),$.objectName=H}if($.propertyName===null||$.propertyName.length===0)throw Error("PropertyBinding: can not parse propertyName from trackName: "+F);return $}static findNode(F,_){if(_===void 0||_===""||_==="."||_===-1||_===F.name||_===F.uuid)return F;if(F.skeleton){let $=F.skeleton.getBoneByName(_);if($!==void 0)return $}if(F.children){let $=function(H){for(let Y=0;Y<H.length;Y++){let K=H[Y];if(K.name===_||K.uuid===_)return K;let G=$(K.children);if(G)return G}return null},W=$(F.children);if(W)return W}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(F,_){F[_]=this.targetObject[this.propertyName]}_getValue_array(F,_){let $=this.resolvedProperty;for(let W=0,H=$.length;W!==H;++W)F[_++]=$[W]}_getValue_arrayElement(F,_){F[_]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(F,_){this.resolvedProperty.toArray(F,_)}_setValue_direct(F,_){this.targetObject[this.propertyName]=F[_]}_setValue_direct_setNeedsUpdate(F,_){this.targetObject[this.propertyName]=F[_],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(F,_){this.targetObject[this.propertyName]=F[_],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(F,_){let $=this.resolvedProperty;for(let W=0,H=$.length;W!==H;++W)$[W]=F[_++]}_setValue_array_setNeedsUpdate(F,_){let $=this.resolvedProperty;for(let W=0,H=$.length;W!==H;++W)$[W]=F[_++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(F,_){let $=this.resolvedProperty;for(let W=0,H=$.length;W!==H;++W)$[W]=F[_++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(F,_){this.resolvedProperty[this.propertyIndex]=F[_]}_setValue_arrayElement_setNeedsUpdate(F,_){this.resolvedProperty[this.propertyIndex]=F[_],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(F,_){this.resolvedProperty[this.propertyIndex]=F[_],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(F,_){this.resolvedProperty.fromArray(F,_)}_setValue_fromArray_setNeedsUpdate(F,_){this.resolvedProperty.fromArray(F,_),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(F,_){this.resolvedProperty.fromArray(F,_),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(F,_){this.bind(),this.getValue(F,_)}_setValue_unbound(F,_){this.bind(),this.setValue(F,_)}bind(){let F=this.node,_=this.parsedPath,$=_.objectName,W=_.propertyName,H=_.propertyIndex;if(!F)F=Z1.findNode(this.rootNode,_.nodeName),this.node=F;if(this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!F){zF("PropertyBinding: No target node found for track: "+this.path+".");return}if($){let U=_.objectIndex;switch($){case"materials":if(!F.material){hF("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!F.material.materials){hF("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}F=F.material.materials;break;case"bones":if(!F.skeleton){hF("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}F=F.skeleton.bones;for(let z=0;z<F.length;z++)if(F[z].name===U){U=z;break}break;case"map":if("map"in F){F=F.map;break}if(!F.material){hF("PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!F.material.map){hF("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}F=F.material.map;break;default:if(F[$]===void 0){hF("PropertyBinding: Can not bind to objectName of node undefined.",this);return}F=F[$]}if(U!==void 0){if(F[U]===void 0){hF("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,F);return}F=F[U]}}let Y=F[W];if(Y===void 0){let U=_.nodeName;hF("PropertyBinding: Trying to update property for track: "+U+"."+W+" but it wasn't found.",F);return}let K=this.Versioning.None;if(this.targetObject=F,F.isMaterial===!0)K=this.Versioning.NeedsUpdate;else if(F.isObject3D===!0)K=this.Versioning.MatrixWorldNeedsUpdate;let G=this.BindingType.Direct;if(H!==void 0){if(W==="morphTargetInfluences"){if(!F.geometry){hF("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!F.geometry.morphAttributes){hF("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}if(F.morphTargetDictionary[H]!==void 0)H=F.morphTargetDictionary[H]}G=this.BindingType.ArrayElement,this.resolvedProperty=Y,this.propertyIndex=H}else if(Y.fromArray!==void 0&&Y.toArray!==void 0)G=this.BindingType.HasFromToArray,this.resolvedProperty=Y;else if(Array.isArray(Y))G=this.BindingType.EntireArray,this.resolvedProperty=Y;else this.propertyName=W;this.getValue=this.GetterByBindingType[G],this.setValue=this.SetterByBindingTypeAndVersioning[G][K]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Z1.Composite=Rf;Z1.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Z1.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Z1.prototype.GetterByBindingType=[Z1.prototype._getValue_direct,Z1.prototype._getValue_array,Z1.prototype._getValue_arrayElement,Z1.prototype._getValue_toArray];Z1.prototype.SetterByBindingTypeAndVersioning=[[Z1.prototype._setValue_direct,Z1.prototype._setValue_direct_setNeedsUpdate,Z1.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Z1.prototype._setValue_array,Z1.prototype._setValue_array_setNeedsUpdate,Z1.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Z1.prototype._setValue_arrayElement,Z1.prototype._setValue_arrayElement_setNeedsUpdate,Z1.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Z1.prototype._setValue_fromArray,Z1.prototype._setValue_fromArray_setNeedsUpdate,Z1.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];var bj=new Float32Array(1);var hO=new N1;class HY{constructor(F,_,$=0,W=1/0){this.ray=new TJ(F,_),this.near=$,this.far=W,this.camera=null,this.layers=new OQ,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(F,_){this.ray.set(F,_)}setFromCamera(F,_){if(_.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(_.matrixWorld),this.ray.direction.set(F.x,F.y,0.5).unproject(_).sub(this.ray.origin).normalize(),this.camera=_;else if(_.isOrthographicCamera)this.ray.origin.set(F.x,F.y,(_.near+_.far)/(_.near-_.far)).unproject(_),this.ray.direction.set(0,0,-1).transformDirection(_.matrixWorld),this.camera=_;else hF("Raycaster: Unsupported camera type: "+_.type)}setFromXRController(F){return hO.identity().extractRotation(F.matrixWorld),this.ray.origin.setFromMatrixPosition(F.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(hO),this}intersectObject(F,_=!0,$=[]){return k5(F,this,$,_),$.sort(RO),$}intersectObjects(F,_=!0,$=[]){for(let W=0,H=F.length;W<H;W++)k5(F[W],this,$,_);return $.sort(RO),$}}function RO(F,_){return F.distance-_.distance}function k5(F,_,$,W){let H=!0;if(F.layers.test(_.layers)){if(F.raycast(_,$)===!1)H=!1}if(H===!0&&W===!0){let Y=F.children;for(let K=0,G=Y.length;K<G;K++)k5(Y[K],_,$,!0)}}class PQ{constructor(F=1,_=0,$=0){this.radius=F,this.phi=_,this.theta=$}set(F,_,$){return this.radius=F,this.phi=_,this.theta=$,this}copy(F){return this.radius=F.radius,this.phi=F.phi,this.theta=F.theta,this}makeSafe(){return this.phi=uF(this.phi,0.000001,Math.PI-0.000001),this}setFromVector3(F){return this.setFromCartesianCoords(F.x,F.y,F.z)}setFromCartesianCoords(F,_,$){if(this.radius=Math.sqrt(F*F+_*_+$*$),this.radius===0)this.theta=0,this.phi=0;else this.theta=Math.atan2(F,$),this.phi=Math.acos(uF(_/this.radius,-1,1));return this}clone(){return new this.constructor().copy(this)}}class wY extends N9{constructor(F,_=null){super();this.object=F,this.domElement=_,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(F){if(F===void 0){zF("Controls: connect() now requires an element.");return}if(this.domElement!==null)this.disconnect();this.domElement=F}disconnect(){}dispose(){}update(){}}function _B(F,_,$,W){let H=QE(W);switch($){case 1021:return F*_;case 1028:return F*_/H.components*H.byteLength;case 1029:return F*_/H.components*H.byteLength;case 1030:return F*_*2/H.components*H.byteLength;case 1031:return F*_*2/H.components*H.byteLength;case 1022:return F*_*3/H.components*H.byteLength;case 1023:return F*_*4/H.components*H.byteLength;case 1033:return F*_*4/H.components*H.byteLength;case 33776:case 33777:return Math.floor((F+3)/4)*Math.floor((_+3)/4)*8;case 33778:case 33779:return Math.floor((F+3)/4)*Math.floor((_+3)/4)*16;case 35841:case 35843:return Math.max(F,16)*Math.max(_,8)/4;case 35840:case 35842:return Math.max(F,8)*Math.max(_,8)/2;case 36196:case 37492:case 37488:case 37489:return Math.floor((F+3)/4)*Math.floor((_+3)/4)*8;case 37496:case 37490:case 37491:return Math.floor((F+3)/4)*Math.floor((_+3)/4)*16;case 37808:return Math.floor((F+3)/4)*Math.floor((_+3)/4)*16;case 37809:return Math.floor((F+4)/5)*Math.floor((_+3)/4)*16;case 37810:return Math.floor((F+4)/5)*Math.floor((_+4)/5)*16;case 37811:return Math.floor((F+5)/6)*Math.floor((_+4)/5)*16;case 37812:return Math.floor((F+5)/6)*Math.floor((_+5)/6)*16;case 37813:return Math.floor((F+7)/8)*Math.floor((_+4)/5)*16;case 37814:return Math.floor((F+7)/8)*Math.floor((_+5)/6)*16;case 37815:return Math.floor((F+7)/8)*Math.floor((_+7)/8)*16;case 37816:return Math.floor((F+9)/10)*Math.floor((_+4)/5)*16;case 37817:return Math.floor((F+9)/10)*Math.floor((_+5)/6)*16;case 37818:return Math.floor((F+9)/10)*Math.floor((_+7)/8)*16;case 37819:return Math.floor((F+9)/10)*Math.floor((_+9)/10)*16;case 37820:return Math.floor((F+11)/12)*Math.floor((_+9)/10)*16;case 37821:return Math.floor((F+11)/12)*Math.floor((_+11)/12)*16;case 36492:case 36494:case 36495:return Math.ceil(F/4)*Math.ceil(_/4)*16;case 36283:case 36284:return Math.ceil(F/4)*Math.ceil(_/4)*8;case 36285:case 36286:return Math.ceil(F/4)*Math.ceil(_/4)*16}throw Error(`Unable to determine texture byte length for ${$} format.`)}function QE(F){switch(F){case 1009:case 1010:return{byteLength:1,components:1};case 1012:case 1011:case 1016:return{byteLength:2,components:1};case 1017:case 1018:return{byteLength:2,components:4};case 1014:case 1013:case 1015:return{byteLength:4,components:1};case 35902:case 35899:return{byteLength:4,components:3}}throw Error(`Unknown texture type ${F}.`)}if(typeof __THREE_DEVTOOLS__<"u")__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"182"}}));if(typeof window<"u")if(window.__THREE__)zF("WARNING: Multiple instances of Three.js being imported.");else window.__THREE__="182";function mf(){let F=null,_=!1,$=null,W=null;function H(Y,K){$(Y,K),W=F.requestAnimationFrame(H)}return{start:function(){if(_===!0)return;if($===null)return;W=F.requestAnimationFrame(H),_=!0},stop:function(){F.cancelAnimationFrame(W),_=!1},setAnimationLoop:function(Y){$=Y},setContext:function(Y){F=Y}}}function WE(F){let _=new WeakMap;function $(G,U){let{array:z,usage:h}=G,A=z.byteLength,N=F.createBuffer();F.bindBuffer(U,N),F.bufferData(U,z,h),G.onUploadCallback();let M;if(z instanceof Float32Array)M=F.FLOAT;else if(typeof Float16Array<"u"&&z instanceof Float16Array)M=F.HALF_FLOAT;else if(z instanceof Uint16Array)if(G.isFloat16BufferAttribute)M=F.HALF_FLOAT;else M=F.UNSIGNED_SHORT;else if(z instanceof Int16Array)M=F.SHORT;else if(z instanceof Uint32Array)M=F.UNSIGNED_INT;else if(z instanceof Int32Array)M=F.INT;else if(z instanceof Int8Array)M=F.BYTE;else if(z instanceof Uint8Array)M=F.UNSIGNED_BYTE;else if(z instanceof Uint8ClampedArray)M=F.UNSIGNED_BYTE;else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: "+z);return{buffer:N,type:M,bytesPerElement:z.BYTES_PER_ELEMENT,version:G.version,size:A}}function W(G,U,z){let{array:h,updateRanges:A}=U;if(F.bindBuffer(z,G),A.length===0)F.bufferSubData(z,0,h);else{A.sort((M,T)=>M.start-T.start);let N=0;for(let M=1;M<A.length;M++){let T=A[N],P=A[M];if(P.start<=T.start+T.count+1)T.count=Math.max(T.count,P.start+P.count-T.start);else++N,A[N]=P}A.length=N+1;for(let M=0,T=A.length;M<T;M++){let P=A[M];F.bufferSubData(z,P.start*h.BYTES_PER_ELEMENT,h,P.start,P.count)}U.clearUpdateRanges()}U.onUploadCallback()}function H(G){if(G.isInterleavedBufferAttribute)G=G.data;return _.get(G)}function Y(G){if(G.isInterleavedBufferAttribute)G=G.data;let U=_.get(G);if(U)F.deleteBuffer(U.buffer),_.delete(G)}function K(G,U){if(G.isInterleavedBufferAttribute)G=G.data;if(G.isGLBufferAttribute){let h=_.get(G);if(!h||h.version<G.version)_.set(G,{buffer:G.buffer,type:G.type,bytesPerElement:G.elementSize,version:G.version});return}let z=_.get(G);if(z===void 0)_.set(G,$(G,U));else if(z.version<G.version){if(z.size!==G.array.byteLength)throw Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");W(z.buffer,G,U),z.version=G.version}}return{get:H,remove:Y,update:K}}var HE=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,wE=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,YE=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,XE=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,GE=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,KE=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,UE=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,BE=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,zE=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,AE=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,hE=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,RE=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,NE=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,DE=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,ME=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,OE=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,fE=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,IE=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,TE=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,LE=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,EE=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,CE=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,PE=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,VE=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,kE=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,SE=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,yE=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,vE=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,bE=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,jE=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,xE="gl_FragColor = linearToOutputTexel( gl_FragColor );",gE=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,uE=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,pE=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,mE=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,lE=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,dE=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,iE=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,nE=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,cE=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,sE=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,oE=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,aE=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,rE=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,tE=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,eE=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,FC=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,qC=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,JC=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,_C=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,ZC=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,$C=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.metalness = metalnessFactor;
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = vec3( 0.04 );
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,QC=`uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	vec3 diffuseContribution;
	vec3 specularColor;
	vec3 specularColorBlended;
	float roughness;
	float metalness;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
		vec3 iridescenceFresnelDielectric;
		vec3 iridescenceFresnelMetallic;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return v;
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColorBlended;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float rInv = 1.0 / ( roughness + 0.1 );
	float a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;
	float b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;
	float DG = exp( a * dotNV + b );
	return saturate( DG );
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;
	vec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;
	vec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColorBlended * t2.x + ( vec3( 1.0 ) - material.specularColorBlended ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
 
 		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
 
 		float sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
 		float sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );
 
 		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );
 
 		irradiance *= sheenEnergyComp;
 
 	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		diffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectDiffuse += diffuse;
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;
 	#endif
	vec3 singleScatteringDielectric = vec3( 0.0 );
	vec3 multiScatteringDielectric = vec3( 0.0 );
	vec3 singleScatteringMetallic = vec3( 0.0 );
	vec3 multiScatteringMetallic = vec3( 0.0 );
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#endif
	vec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );
	vec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );
	vec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;
	vec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	vec3 indirectSpecular = radiance * singleScattering;
	indirectSpecular += multiScattering * cosineWeightedIrradiance;
	vec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		indirectSpecular *= sheenEnergyComp;
		indirectDiffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectSpecular += indirectSpecular;
	reflectedLight.indirectDiffuse += indirectDiffuse;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,WC=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );
		material.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,HC=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,wC=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,YC=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,XC=`#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,GC=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,KC=`#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,UC=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,BC=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,zC=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,AC=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,hC=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,RC=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,NC=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,DC=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,MC=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,OC=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,fC=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,IC=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,TC=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,LC=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,EC=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,CC=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,PC=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,VC=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,kC=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,SC=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,yC=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,vC=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,bC=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,jC=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,xC=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,gC=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,uC=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,pC=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,mC=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,lC=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#else
			uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#endif
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#else
			uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#endif
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#elif defined( SHADOWMAP_TYPE_BASIC )
			uniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#endif
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float interleavedGradientNoise( vec2 position ) {
			return fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );
		}
		vec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {
			const float goldenAngle = 2.399963229728653;
			float r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );
			float theta = float( sampleIndex ) * goldenAngle + phi;
			return vec2( cos( theta ), sin( theta ) ) * r;
		}
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
				float radius = shadowRadius * texelSize.x;
				float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
				shadow = (
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )
				) * 0.2;
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#elif defined( SHADOWMAP_TYPE_VSM )
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;
				float mean = distribution.x;
				float variance = distribution.y * distribution.y;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					float hard_shadow = step( mean, shadowCoord.z );
				#else
					float hard_shadow = step( shadowCoord.z, mean );
				#endif
				if ( hard_shadow == 1.0 ) {
					shadow = 1.0;
				} else {
					variance = max( variance, 0.0000001 );
					float d = shadowCoord.z - mean;
					float p_max = variance / ( variance + d * d );
					p_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );
					shadow = max( hard_shadow, p_max );
				}
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#else
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				float depth = texture2D( shadowMap, shadowCoord.xy ).r;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					shadow = step( depth, shadowCoord.z );
				#else
					shadow = step( shadowCoord.z, depth );
				#endif
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#if defined( SHADOWMAP_TYPE_PCF )
	float getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float texelSize = shadowRadius / shadowMapSize.x;
			vec3 absDir = abs( bd3D );
			vec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );
			tangent = normalize( cross( bd3D, tangent ) );
			vec3 bitangent = cross( bd3D, tangent );
			float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
			shadow = (
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 0, 5, phi ).x + bitangent * vogelDiskSample( 0, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 1, 5, phi ).x + bitangent * vogelDiskSample( 1, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 2, 5, phi ).x + bitangent * vogelDiskSample( 2, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 3, 5, phi ).x + bitangent * vogelDiskSample( 3, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 4, 5, phi ).x + bitangent * vogelDiskSample( 4, 5, phi ).y ) * texelSize, dp ) )
			) * 0.2;
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#elif defined( SHADOWMAP_TYPE_BASIC )
	float getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float depth = textureCube( shadowMap, bd3D ).r;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				shadow = step( depth, dp );
			#else
				shadow = step( dp, depth );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#endif
	#endif
#endif`,dC=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,iC=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,nC=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,cC=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,sC=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,oC=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,aC=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,rC=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,tC=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,eC=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,FP=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,qP=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,JP=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,_P=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,ZP=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,$P=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,QP=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,WP=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,HP=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,wP=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,YP=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,XP=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,GP=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,KP=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,UP=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,BP=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,zP=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );
}`,AP=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,hP=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,RP=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,NP=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,DP=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,MP=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,OP=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fP=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,IP=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,TP=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,LP=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,EP=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,CP=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,PP=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,VP=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,kP=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
 
		outgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;
 
 	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,SP=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,yP=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vP=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,bP=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,jP=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,xP=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,gP=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,uP=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,bF={alphahash_fragment:HE,alphahash_pars_fragment:wE,alphamap_fragment:YE,alphamap_pars_fragment:XE,alphatest_fragment:GE,alphatest_pars_fragment:KE,aomap_fragment:UE,aomap_pars_fragment:BE,batching_pars_vertex:zE,batching_vertex:AE,begin_vertex:hE,beginnormal_vertex:RE,bsdfs:NE,iridescence_fragment:DE,bumpmap_pars_fragment:ME,clipping_planes_fragment:OE,clipping_planes_pars_fragment:fE,clipping_planes_pars_vertex:IE,clipping_planes_vertex:TE,color_fragment:LE,color_pars_fragment:EE,color_pars_vertex:CE,color_vertex:PE,common:VE,cube_uv_reflection_fragment:kE,defaultnormal_vertex:SE,displacementmap_pars_vertex:yE,displacementmap_vertex:vE,emissivemap_fragment:bE,emissivemap_pars_fragment:jE,colorspace_fragment:xE,colorspace_pars_fragment:gE,envmap_fragment:uE,envmap_common_pars_fragment:pE,envmap_pars_fragment:mE,envmap_pars_vertex:lE,envmap_physical_pars_fragment:FC,envmap_vertex:dE,fog_vertex:iE,fog_pars_vertex:nE,fog_fragment:cE,fog_pars_fragment:sE,gradientmap_pars_fragment:oE,lightmap_pars_fragment:aE,lights_lambert_fragment:rE,lights_lambert_pars_fragment:tE,lights_pars_begin:eE,lights_toon_fragment:qC,lights_toon_pars_fragment:JC,lights_phong_fragment:_C,lights_phong_pars_fragment:ZC,lights_physical_fragment:$C,lights_physical_pars_fragment:QC,lights_fragment_begin:WC,lights_fragment_maps:HC,lights_fragment_end:wC,logdepthbuf_fragment:YC,logdepthbuf_pars_fragment:XC,logdepthbuf_pars_vertex:GC,logdepthbuf_vertex:KC,map_fragment:UC,map_pars_fragment:BC,map_particle_fragment:zC,map_particle_pars_fragment:AC,metalnessmap_fragment:hC,metalnessmap_pars_fragment:RC,morphinstance_vertex:NC,morphcolor_vertex:DC,morphnormal_vertex:MC,morphtarget_pars_vertex:OC,morphtarget_vertex:fC,normal_fragment_begin:IC,normal_fragment_maps:TC,normal_pars_fragment:LC,normal_pars_vertex:EC,normal_vertex:CC,normalmap_pars_fragment:PC,clearcoat_normal_fragment_begin:VC,clearcoat_normal_fragment_maps:kC,clearcoat_pars_fragment:SC,iridescence_pars_fragment:yC,opaque_fragment:vC,packing:bC,premultiplied_alpha_fragment:jC,project_vertex:xC,dithering_fragment:gC,dithering_pars_fragment:uC,roughnessmap_fragment:pC,roughnessmap_pars_fragment:mC,shadowmap_pars_fragment:lC,shadowmap_pars_vertex:dC,shadowmap_vertex:iC,shadowmask_pars_fragment:nC,skinbase_vertex:cC,skinning_pars_vertex:sC,skinning_vertex:oC,skinnormal_vertex:aC,specularmap_fragment:rC,specularmap_pars_fragment:tC,tonemapping_fragment:eC,tonemapping_pars_fragment:FP,transmission_fragment:qP,transmission_pars_fragment:JP,uv_pars_fragment:_P,uv_pars_vertex:ZP,uv_vertex:$P,worldpos_vertex:QP,background_vert:WP,background_frag:HP,backgroundCube_vert:wP,backgroundCube_frag:YP,cube_vert:XP,cube_frag:GP,depth_vert:KP,depth_frag:UP,distance_vert:BP,distance_frag:zP,equirect_vert:AP,equirect_frag:hP,linedashed_vert:RP,linedashed_frag:NP,meshbasic_vert:DP,meshbasic_frag:MP,meshlambert_vert:OP,meshlambert_frag:fP,meshmatcap_vert:IP,meshmatcap_frag:TP,meshnormal_vert:LP,meshnormal_frag:EP,meshphong_vert:CP,meshphong_frag:PP,meshphysical_vert:VP,meshphysical_frag:kP,meshtoon_vert:SP,meshtoon_frag:yP,points_vert:vP,points_frag:bP,shadow_vert:jP,shadow_frag:xP,sprite_vert:gP,sprite_frag:uP},d0={common:{diffuse:{value:new lF(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new EF},alphaMap:{value:null},alphaMapTransform:{value:new EF},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new EF}},envmap:{envMap:{value:null},envMapRotation:{value:new EF},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:0.98},dfgLUT:{value:null}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new EF}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new EF}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new EF},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new EF},normalScale:{value:new DF(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new EF},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new EF}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new EF}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new EF}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new lF(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new lF(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new EF},alphaTest:{value:0},uvTransform:{value:new EF}},sprite:{diffuse:{value:new lF(16777215)},opacity:{value:1},center:{value:new DF(0.5,0.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new EF},alphaMap:{value:null},alphaMapTransform:{value:new EF},alphaTest:{value:0}}},y7={basic:{uniforms:h6([d0.common,d0.specularmap,d0.envmap,d0.aomap,d0.lightmap,d0.fog]),vertexShader:bF.meshbasic_vert,fragmentShader:bF.meshbasic_frag},lambert:{uniforms:h6([d0.common,d0.specularmap,d0.envmap,d0.aomap,d0.lightmap,d0.emissivemap,d0.bumpmap,d0.normalmap,d0.displacementmap,d0.fog,d0.lights,{emissive:{value:new lF(0)}}]),vertexShader:bF.meshlambert_vert,fragmentShader:bF.meshlambert_frag},phong:{uniforms:h6([d0.common,d0.specularmap,d0.envmap,d0.aomap,d0.lightmap,d0.emissivemap,d0.bumpmap,d0.normalmap,d0.displacementmap,d0.fog,d0.lights,{emissive:{value:new lF(0)},specular:{value:new lF(1118481)},shininess:{value:30}}]),vertexShader:bF.meshphong_vert,fragmentShader:bF.meshphong_frag},standard:{uniforms:h6([d0.common,d0.envmap,d0.aomap,d0.lightmap,d0.emissivemap,d0.bumpmap,d0.normalmap,d0.displacementmap,d0.roughnessmap,d0.metalnessmap,d0.fog,d0.lights,{emissive:{value:new lF(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:bF.meshphysical_vert,fragmentShader:bF.meshphysical_frag},toon:{uniforms:h6([d0.common,d0.aomap,d0.lightmap,d0.emissivemap,d0.bumpmap,d0.normalmap,d0.displacementmap,d0.gradientmap,d0.fog,d0.lights,{emissive:{value:new lF(0)}}]),vertexShader:bF.meshtoon_vert,fragmentShader:bF.meshtoon_frag},matcap:{uniforms:h6([d0.common,d0.bumpmap,d0.normalmap,d0.displacementmap,d0.fog,{matcap:{value:null}}]),vertexShader:bF.meshmatcap_vert,fragmentShader:bF.meshmatcap_frag},points:{uniforms:h6([d0.points,d0.fog]),vertexShader:bF.points_vert,fragmentShader:bF.points_frag},dashed:{uniforms:h6([d0.common,d0.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:bF.linedashed_vert,fragmentShader:bF.linedashed_frag},depth:{uniforms:h6([d0.common,d0.displacementmap]),vertexShader:bF.depth_vert,fragmentShader:bF.depth_frag},normal:{uniforms:h6([d0.common,d0.bumpmap,d0.normalmap,d0.displacementmap,{opacity:{value:1}}]),vertexShader:bF.meshnormal_vert,fragmentShader:bF.meshnormal_frag},sprite:{uniforms:h6([d0.sprite,d0.fog]),vertexShader:bF.sprite_vert,fragmentShader:bF.sprite_frag},background:{uniforms:{uvTransform:{value:new EF},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:bF.background_vert,fragmentShader:bF.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new EF}},vertexShader:bF.backgroundCube_vert,fragmentShader:bF.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:bF.cube_vert,fragmentShader:bF.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:bF.equirect_vert,fragmentShader:bF.equirect_frag},distance:{uniforms:h6([d0.common,d0.displacementmap,{referencePosition:{value:new w0},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:bF.distance_vert,fragmentShader:bF.distance_frag},shadow:{uniforms:h6([d0.lights,d0.fog,{color:{value:new lF(0)},opacity:{value:1}}]),vertexShader:bF.shadow_vert,fragmentShader:bF.shadow_frag}};y7.physical={uniforms:h6([y7.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new EF},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new EF},clearcoatNormalScale:{value:new DF(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new EF},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new EF},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new EF},sheen:{value:0},sheenColor:{value:new lF(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new EF},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new EF},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new EF},transmissionSamplerSize:{value:new DF},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new EF},attenuationDistance:{value:0},attenuationColor:{value:new lF(0)},specularColor:{value:new lF(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new EF},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new EF},anisotropyVector:{value:new DF},anisotropyMap:{value:null},anisotropyMapTransform:{value:new EF}}]),vertexShader:bF.meshphysical_vert,fragmentShader:bF.meshphysical_frag};var YY={r:0,b:0,g:0},VJ=new r8,pP=new N1;function mP(F,_,$,W,H,Y,K){let G=new lF(0),U=Y===!0?0:1,z,h,A=null,N=0,M=null;function T(k){let y=k.isScene===!0?k.background:null;if(y&&y.isTexture)y=(k.backgroundBlurriness>0?$:_).get(y);return y}function P(k){let y=!1,m=T(k);if(m===null)O(G,U);else if(m&&m.isColor)O(m,1),y=!0;let x=F.xr.getEnvironmentBlendMode();if(x==="additive")W.buffers.color.setClear(0,0,0,1,K);else if(x==="alpha-blend")W.buffers.color.setClear(0,0,0,0,K);if(F.autoClear||y)W.buffers.depth.setTest(!0),W.buffers.depth.setMask(!0),W.buffers.color.setMask(!0),F.clear(F.autoClearColor,F.autoClearDepth,F.autoClearStencil)}function D(k,y){let m=T(y);if(m&&(m.isCubeTexture||m.mapping===hQ)){if(h===void 0)h=new X8(new RZ(1,1,1),new V8({name:"BackgroundCubeMaterial",uniforms:LJ(y7.backgroundCube.uniforms),vertexShader:y7.backgroundCube.vertexShader,fragmentShader:y7.backgroundCube.fragmentShader,side:w8,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(x,o,s){this.matrixWorld.copyPosition(s.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),H.update(h);if(VJ.copy(y.backgroundRotation),VJ.x*=-1,VJ.y*=-1,VJ.z*=-1,m.isCubeTexture&&m.isRenderTargetTexture===!1)VJ.y*=-1,VJ.z*=-1;if(h.material.uniforms.envMap.value=m,h.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=y.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(pP.makeRotationFromEuler(VJ)),h.material.toneMapped=aF.getTransfer(m.colorSpace)!==G1,A!==m||N!==m.version||M!==F.toneMapping)h.material.needsUpdate=!0,A=m,N=m.version,M=F.toneMapping;h.layers.enableAll(),k.unshift(h,h.geometry,h.material,0,0,null)}else if(m&&m.isTexture){if(z===void 0)z=new X8(new LQ(2,2),new V8({name:"BackgroundMaterial",uniforms:LJ(y7.background.uniforms),vertexShader:y7.background.vertexShader,fragmentShader:y7.background.fragmentShader,side:XZ,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),z.geometry.deleteAttribute("normal"),Object.defineProperty(z.material,"map",{get:function(){return this.uniforms.t2D.value}}),H.update(z);if(z.material.uniforms.t2D.value=m,z.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,z.material.toneMapped=aF.getTransfer(m.colorSpace)!==G1,m.matrixAutoUpdate===!0)m.updateMatrix();if(z.material.uniforms.uvTransform.value.copy(m.matrix),A!==m||N!==m.version||M!==F.toneMapping)z.material.needsUpdate=!0,A=m,N=m.version,M=F.toneMapping;z.layers.enableAll(),k.unshift(z,z.geometry,z.material,0,0,null)}}function O(k,y){k.getRGB(YY,xU(F)),W.buffers.color.setClear(YY.r,YY.g,YY.b,y,K)}function b(){if(h!==void 0)h.geometry.dispose(),h.material.dispose(),h=void 0;if(z!==void 0)z.geometry.dispose(),z.material.dispose(),z=void 0}return{getClearColor:function(){return G},setClearColor:function(k,y=1){G.set(k),U=y,O(G,U)},getClearAlpha:function(){return U},setClearAlpha:function(k){U=k,O(G,U)},render:P,addToRenderList:D,dispose:b}}function lP(F,_){let $=F.getParameter(F.MAX_VERTEX_ATTRIBS),W={},H=N(null),Y=H,K=!1;function G(V,d,$0,X0,K0){let J0=!1,u=A(X0,$0,d);if(Y!==u)Y=u,z(Y.object);if(J0=M(V,X0,$0,K0),J0)T(V,X0,$0,K0);if(K0!==null)_.update(K0,F.ELEMENT_ARRAY_BUFFER);if(J0||K){if(K=!1,y(V,d,$0,X0),K0!==null)F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,_.get(K0).buffer)}}function U(){return F.createVertexArray()}function z(V){return F.bindVertexArray(V)}function h(V){return F.deleteVertexArray(V)}function A(V,d,$0){let X0=$0.wireframe===!0,K0=W[V.id];if(K0===void 0)K0={},W[V.id]=K0;let J0=K0[d.id];if(J0===void 0)J0={},K0[d.id]=J0;let u=J0[X0];if(u===void 0)u=N(U()),J0[X0]=u;return u}function N(V){let d=[],$0=[],X0=[];for(let K0=0;K0<$;K0++)d[K0]=0,$0[K0]=0,X0[K0]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:d,enabledAttributes:$0,attributeDivisors:X0,object:V,attributes:{},index:null}}function M(V,d,$0,X0){let K0=Y.attributes,J0=d.attributes,u=0,n=$0.getAttributes();for(let Q0 in n)if(n[Q0].location>=0){let t=K0[Q0],T0=J0[Q0];if(T0===void 0){if(Q0==="instanceMatrix"&&V.instanceMatrix)T0=V.instanceMatrix;if(Q0==="instanceColor"&&V.instanceColor)T0=V.instanceColor}if(t===void 0)return!0;if(t.attribute!==T0)return!0;if(T0&&t.data!==T0.data)return!0;u++}if(Y.attributesNum!==u)return!0;if(Y.index!==X0)return!0;return!1}function T(V,d,$0,X0){let K0={},J0=d.attributes,u=0,n=$0.getAttributes();for(let Q0 in n)if(n[Q0].location>=0){let t=J0[Q0];if(t===void 0){if(Q0==="instanceMatrix"&&V.instanceMatrix)t=V.instanceMatrix;if(Q0==="instanceColor"&&V.instanceColor)t=V.instanceColor}let T0={};if(T0.attribute=t,t&&t.data)T0.data=t.data;K0[Q0]=T0,u++}Y.attributes=K0,Y.attributesNum=u,Y.index=X0}function P(){let V=Y.newAttributes;for(let d=0,$0=V.length;d<$0;d++)V[d]=0}function D(V){O(V,0)}function O(V,d){let{newAttributes:$0,enabledAttributes:X0,attributeDivisors:K0}=Y;if($0[V]=1,X0[V]===0)F.enableVertexAttribArray(V),X0[V]=1;if(K0[V]!==d)F.vertexAttribDivisor(V,d),K0[V]=d}function b(){let{newAttributes:V,enabledAttributes:d}=Y;for(let $0=0,X0=d.length;$0<X0;$0++)if(d[$0]!==V[$0])F.disableVertexAttribArray($0),d[$0]=0}function k(V,d,$0,X0,K0,J0,u){if(u===!0)F.vertexAttribIPointer(V,d,$0,K0,J0);else F.vertexAttribPointer(V,d,$0,X0,K0,J0)}function y(V,d,$0,X0){P();let K0=X0.attributes,J0=$0.getAttributes(),u=d.defaultAttributeValues;for(let n in J0){let Q0=J0[n];if(Q0.location>=0){let O0=K0[n];if(O0===void 0){if(n==="instanceMatrix"&&V.instanceMatrix)O0=V.instanceMatrix;if(n==="instanceColor"&&V.instanceColor)O0=V.instanceColor}if(O0!==void 0){let{normalized:t,itemSize:T0}=O0,g0=_.get(O0);if(g0===void 0)continue;let{buffer:_F,type:c0,bytesPerElement:D0}=g0,P0=c0===F.INT||c0===F.UNSIGNED_INT||O0.gpuType===d5;if(O0.isInterleavedBufferAttribute){let S0=O0.data,e0=S0.stride,JF=O0.offset;if(S0.isInstancedInterleavedBuffer){for(let UF=0;UF<Q0.locationSize;UF++)O(Q0.location+UF,S0.meshPerAttribute);if(V.isInstancedMesh!==!0&&X0._maxInstanceCount===void 0)X0._maxInstanceCount=S0.meshPerAttribute*S0.count}else for(let UF=0;UF<Q0.locationSize;UF++)D(Q0.location+UF);F.bindBuffer(F.ARRAY_BUFFER,_F);for(let UF=0;UF<Q0.locationSize;UF++)k(Q0.location+UF,T0/Q0.locationSize,c0,t,e0*D0,(JF+T0/Q0.locationSize*UF)*D0,P0)}else{if(O0.isInstancedBufferAttribute){for(let S0=0;S0<Q0.locationSize;S0++)O(Q0.location+S0,O0.meshPerAttribute);if(V.isInstancedMesh!==!0&&X0._maxInstanceCount===void 0)X0._maxInstanceCount=O0.meshPerAttribute*O0.count}else for(let S0=0;S0<Q0.locationSize;S0++)D(Q0.location+S0);F.bindBuffer(F.ARRAY_BUFFER,_F);for(let S0=0;S0<Q0.locationSize;S0++)k(Q0.location+S0,T0/Q0.locationSize,c0,t,T0*D0,T0/Q0.locationSize*S0*D0,P0)}}else if(u!==void 0){let t=u[n];if(t!==void 0)switch(t.length){case 2:F.vertexAttrib2fv(Q0.location,t);break;case 3:F.vertexAttrib3fv(Q0.location,t);break;case 4:F.vertexAttrib4fv(Q0.location,t);break;default:F.vertexAttrib1fv(Q0.location,t)}}}}b()}function m(){s();for(let V in W){let d=W[V];for(let $0 in d){let X0=d[$0];for(let K0 in X0)h(X0[K0].object),delete X0[K0];delete d[$0]}delete W[V]}}function x(V){if(W[V.id]===void 0)return;let d=W[V.id];for(let $0 in d){let X0=d[$0];for(let K0 in X0)h(X0[K0].object),delete X0[K0];delete d[$0]}delete W[V.id]}function o(V){for(let d in W){let $0=W[d];if($0[V.id]===void 0)continue;let X0=$0[V.id];for(let K0 in X0)h(X0[K0].object),delete X0[K0];delete $0[V.id]}}function s(){if(j(),K=!0,Y===H)return;Y=H,z(Y.object)}function j(){H.geometry=null,H.program=null,H.wireframe=!1}return{setup:G,reset:s,resetDefaultState:j,dispose:m,releaseStatesOfGeometry:x,releaseStatesOfProgram:o,initAttributes:P,enableAttribute:D,disableUnusedAttributes:b}}function dP(F,_,$){let W;function H(z){W=z}function Y(z,h){F.drawArrays(W,z,h),$.update(h,W,1)}function K(z,h,A){if(A===0)return;F.drawArraysInstanced(W,z,h,A),$.update(h,W,A)}function G(z,h,A){if(A===0)return;_.get("WEBGL_multi_draw").multiDrawArraysWEBGL(W,z,0,h,0,A);let M=0;for(let T=0;T<A;T++)M+=h[T];$.update(M,W,1)}function U(z,h,A,N){if(A===0)return;let M=_.get("WEBGL_multi_draw");if(M===null)for(let T=0;T<z.length;T++)K(z[T],h[T],N[T]);else{M.multiDrawArraysInstancedWEBGL(W,z,0,h,0,N,0,A);let T=0;for(let P=0;P<A;P++)T+=h[P]*N[P];$.update(T,W,1)}}this.setMode=H,this.render=Y,this.renderInstances=K,this.renderMultiDraw=G,this.renderMultiDrawInstances=U}function iP(F,_,$,W){let H;function Y(){if(H!==void 0)return H;if(_.has("EXT_texture_filter_anisotropic")===!0){let o=_.get("EXT_texture_filter_anisotropic");H=F.getParameter(o.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else H=0;return H}function K(o){if(o!==k7&&W.convert(o)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT))return!1;return!0}function G(o){let s=o===R9&&(_.has("EXT_color_buffer_half_float")||_.has("EXT_color_buffer_float"));if(o!==e8&&W.convert(o)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE)&&o!==h9&&!s)return!1;return!0}function U(o){if(o==="highp"){if(F.getShaderPrecisionFormat(F.VERTEX_SHADER,F.HIGH_FLOAT).precision>0&&F.getShaderPrecisionFormat(F.FRAGMENT_SHADER,F.HIGH_FLOAT).precision>0)return"highp";o="mediump"}if(o==="mediump"){if(F.getShaderPrecisionFormat(F.VERTEX_SHADER,F.MEDIUM_FLOAT).precision>0&&F.getShaderPrecisionFormat(F.FRAGMENT_SHADER,F.MEDIUM_FLOAT).precision>0)return"mediump"}return"lowp"}let z=$.precision!==void 0?$.precision:"highp",h=U(z);if(h!==z)zF("WebGLRenderer:",z,"not supported, using",h,"instead."),z=h;let A=$.logarithmicDepthBuffer===!0,N=$.reversedDepthBuffer===!0&&_.has("EXT_clip_control"),M=F.getParameter(F.MAX_TEXTURE_IMAGE_UNITS),T=F.getParameter(F.MAX_VERTEX_TEXTURE_IMAGE_UNITS),P=F.getParameter(F.MAX_TEXTURE_SIZE),D=F.getParameter(F.MAX_CUBE_MAP_TEXTURE_SIZE),O=F.getParameter(F.MAX_VERTEX_ATTRIBS),b=F.getParameter(F.MAX_VERTEX_UNIFORM_VECTORS),k=F.getParameter(F.MAX_VARYING_VECTORS),y=F.getParameter(F.MAX_FRAGMENT_UNIFORM_VECTORS),m=F.getParameter(F.MAX_SAMPLES),x=F.getParameter(F.SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:Y,getMaxPrecision:U,textureFormatReadable:K,textureTypeReadable:G,precision:z,logarithmicDepthBuffer:A,reversedDepthBuffer:N,maxTextures:M,maxVertexTextures:T,maxTextureSize:P,maxCubemapSize:D,maxAttributes:O,maxVertexUniforms:b,maxVaryings:k,maxFragmentUniforms:y,maxSamples:m,samples:x}}function nP(F){let _=this,$=null,W=0,H=!1,Y=!1,K=new a8,G=new EF,U={value:null,needsUpdate:!1};this.uniform=U,this.numPlanes=0,this.numIntersection=0,this.init=function(A,N){let M=A.length!==0||N||W!==0||H;return H=N,W=A.length,M},this.beginShadows=function(){Y=!0,h(null)},this.endShadows=function(){Y=!1},this.setGlobalState=function(A,N){$=h(A,N,0)},this.setState=function(A,N,M){let{clippingPlanes:T,clipIntersection:P,clipShadows:D}=A,O=F.get(A);if(!H||T===null||T.length===0||Y&&!D)if(Y)h(null);else z();else{let b=Y?0:W,k=b*4,y=O.clippingState||null;U.value=y,y=h(T,N,k,M);for(let m=0;m!==k;++m)y[m]=$[m];O.clippingState=y,this.numIntersection=P?this.numPlanes:0,this.numPlanes+=b}};function z(){if(U.value!==$)U.value=$,U.needsUpdate=W>0;_.numPlanes=W,_.numIntersection=0}function h(A,N,M,T){let P=A!==null?A.length:0,D=null;if(P!==0){if(D=U.value,T!==!0||D===null){let O=M+P*4,b=N.matrixWorldInverse;if(G.getNormalMatrix(b),D===null||D.length<O)D=new Float32Array(O);for(let k=0,y=M;k!==P;++k,y+=4)K.copy(A[k]).applyMatrix4(b,G),K.normal.toArray(D,y),D[y+3]=K.constant}U.value=D,U.needsUpdate=!0}return _.numPlanes=P,_.numIntersection=0,D}}function cP(F){let _=new WeakMap;function $(K,G){if(G===jw)K.mapping=KZ;else if(G===xw)K.mapping=DJ;return K}function W(K){if(K&&K.isTexture){let G=K.mapping;if(G===jw||G===xw)if(_.has(K)){let U=_.get(K).texture;return $(U,K.mapping)}else{let U=K.image;if(U&&U.height>0){let z=new ew(U.height);return z.fromEquirectangularTexture(F,K),_.set(K,z),K.addEventListener("dispose",H),$(z.texture,K.mapping)}else return null}}return K}function H(K){let G=K.target;G.removeEventListener("dispose",H);let U=_.get(G);if(U!==void 0)_.delete(G),U.dispose()}function Y(){_=new WeakMap}return{get:W,dispose:Y}}var fq=4,Nf=[0.125,0.215,0.35,0.446,0.526,0.582],SJ=20,sP=256,VQ=new CQ,Df=new lF,ZB=null,$B=0,QB=0,WB=!1,oP=new w0;class YB{constructor(F){this._renderer=F,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._backgroundBox=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._blurMaterial=null,this._ggxMaterial=null}fromScene(F,_=0,$=0.1,W=100,H={}){let{size:Y=256,position:K=oP}=H;ZB=this._renderer.getRenderTarget(),$B=this._renderer.getActiveCubeFace(),QB=this._renderer.getActiveMipmapLevel(),WB=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(Y);let G=this._allocateTargets();if(G.depthBuffer=!0,this._sceneToCubeUV(F,$,W,G,K),_>0)this._blur(G,0,0,_);return this._applyPMREM(G),this._cleanup(G),G}fromEquirectangular(F,_=null){return this._fromTexture(F,_)}fromCubemap(F,_=null){return this._fromTexture(F,_)}compileCubemapShader(){if(this._cubemapMaterial===null)this._cubemapMaterial=ff(),this._compileMaterial(this._cubemapMaterial)}compileEquirectangularShader(){if(this._equirectMaterial===null)this._equirectMaterial=Of(),this._compileMaterial(this._equirectMaterial)}dispose(){if(this._dispose(),this._cubemapMaterial!==null)this._cubemapMaterial.dispose();if(this._equirectMaterial!==null)this._equirectMaterial.dispose();if(this._backgroundBox!==null)this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose()}_setSize(F){this._lodMax=Math.floor(Math.log2(F)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){if(this._blurMaterial!==null)this._blurMaterial.dispose();if(this._ggxMaterial!==null)this._ggxMaterial.dispose();if(this._pingPongRenderTarget!==null)this._pingPongRenderTarget.dispose();for(let F=0;F<this._lodMeshes.length;F++)this._lodMeshes[F].geometry.dispose()}_cleanup(F){this._renderer.setRenderTarget(ZB,$B,QB),this._renderer.xr.enabled=WB,F.scissorTest=!1,DZ(F,0,0,F.width,F.height)}_fromTexture(F,_){if(F.mapping===KZ||F.mapping===DJ)this._setSize(F.image.length===0?16:F.image[0].width||F.image[0].image.width);else this._setSize(F.image.width/4);ZB=this._renderer.getRenderTarget(),$B=this._renderer.getActiveCubeFace(),QB=this._renderer.getActiveMipmapLevel(),WB=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;let $=_||this._allocateTargets();return this._textureToCubeUV(F,$),this._applyPMREM($),this._cleanup($),$}_allocateTargets(){let F=3*Math.max(this._cubeSize,112),_=4*this._cubeSize,$={magFilter:Y8,minFilter:Y8,generateMipmaps:!1,type:R9,format:k7,colorSpace:DQ,depthBuffer:!1},W=Mf(F,_,$);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==F||this._pingPongRenderTarget.height!==_){if(this._pingPongRenderTarget!==null)this._dispose();this._pingPongRenderTarget=Mf(F,_,$);let{_lodMax:H}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=aP(H)),this._blurMaterial=tP(H,F,_),this._ggxMaterial=rP(H,F,_)}return W}_compileMaterial(F){let _=new X8(new l6,F);this._renderer.compile(_,VQ)}_sceneToCubeUV(F,_,$,W,H){let G=new V6(90,1,_,$),U=[1,-1,1,1,1,1],z=[1,1,1,-1,-1,-1],h=this._renderer,A=h.autoClear,N=h.toneMapping;if(h.getClearColor(Df),h.toneMapping=t8,h.autoClear=!1,h.state.buffers.depth.getReversed())h.setRenderTarget(W),h.clearDepth(),h.setRenderTarget(null);if(this._backgroundBox===null)this._backgroundBox=new X8(new RZ,new sw({name:"PMREM.Background",side:w8,depthWrite:!1,depthTest:!1}));let T=this._backgroundBox,P=T.material,D=!1,O=F.background;if(O){if(O.isColor)P.color.copy(O),F.background=null,D=!0}else P.color.copy(Df),D=!0;for(let b=0;b<6;b++){let k=b%3;if(k===0)G.up.set(0,U[b],0),G.position.set(H.x,H.y,H.z),G.lookAt(H.x+z[b],H.y,H.z);else if(k===1)G.up.set(0,0,U[b]),G.position.set(H.x,H.y,H.z),G.lookAt(H.x,H.y+z[b],H.z);else G.up.set(0,U[b],0),G.position.set(H.x,H.y,H.z),G.lookAt(H.x,H.y,H.z+z[b]);let y=this._cubeSize;if(DZ(W,k*y,b>2?y:0,y,y),h.setRenderTarget(W),D)h.render(T,G);h.render(F,G)}h.toneMapping=N,h.autoClear=A,F.background=O}_textureToCubeUV(F,_){let $=this._renderer,W=F.mapping===KZ||F.mapping===DJ;if(W){if(this._cubemapMaterial===null)this._cubemapMaterial=ff();this._cubemapMaterial.uniforms.flipEnvMap.value=F.isRenderTargetTexture===!1?-1:1}else if(this._equirectMaterial===null)this._equirectMaterial=Of();let H=W?this._cubemapMaterial:this._equirectMaterial,Y=this._lodMeshes[0];Y.material=H;let K=H.uniforms;K.envMap.value=F;let G=this._cubeSize;DZ(_,0,0,3*G,2*G),$.setRenderTarget(_),$.render(Y,VQ)}_applyPMREM(F){let _=this._renderer,$=_.autoClear;_.autoClear=!1;let W=this._lodMeshes.length;for(let H=1;H<W;H++)this._applyGGXFilter(F,H-1,H);_.autoClear=$}_applyGGXFilter(F,_,$){let W=this._renderer,H=this._pingPongRenderTarget,Y=this._ggxMaterial,K=this._lodMeshes[$];K.material=Y;let G=Y.uniforms,U=$/(this._lodMeshes.length-1),z=_/(this._lodMeshes.length-1),h=Math.sqrt(U*U-z*z),A=0+U*1.25,N=h*A,{_lodMax:M}=this,T=this._sizeLods[$],P=3*T*($>M-fq?$-M+fq:0),D=4*(this._cubeSize-T);G.envMap.value=F.texture,G.roughness.value=N,G.mipInt.value=M-_,DZ(H,P,D,3*T,2*T),W.setRenderTarget(H),W.render(K,VQ),G.envMap.value=H.texture,G.roughness.value=0,G.mipInt.value=M-$,DZ(F,P,D,3*T,2*T),W.setRenderTarget(F),W.render(K,VQ)}_blur(F,_,$,W,H){let Y=this._pingPongRenderTarget;this._halfBlur(F,Y,_,$,W,"latitudinal",H),this._halfBlur(Y,F,$,$,W,"longitudinal",H)}_halfBlur(F,_,$,W,H,Y,K){let G=this._renderer,U=this._blurMaterial;if(Y!=="latitudinal"&&Y!=="longitudinal")hF("blur direction must be either latitudinal or longitudinal!");let z=3,h=this._lodMeshes[W];h.material=U;let A=U.uniforms,N=this._sizeLods[$]-1,M=isFinite(H)?Math.PI/(2*N):2*Math.PI/(2*SJ-1),T=H/M,P=isFinite(H)?1+Math.floor(z*T):SJ;if(P>SJ)zF(`sigmaRadians, ${H}, is too large and will clip, as it requested ${P} samples when the maximum is set to ${SJ}`);let D=[],O=0;for(let x=0;x<SJ;++x){let o=x/T,s=Math.exp(-o*o/2);if(D.push(s),x===0)O+=s;else if(x<P)O+=2*s}for(let x=0;x<D.length;x++)D[x]=D[x]/O;if(A.envMap.value=F.texture,A.samples.value=P,A.weights.value=D,A.latitudinal.value=Y==="latitudinal",K)A.poleAxis.value=K;let{_lodMax:b}=this;A.dTheta.value=M,A.mipInt.value=b-$;let k=this._sizeLods[W],y=3*k*(W>b-fq?W-b+fq:0),m=4*(this._cubeSize-k);DZ(_,y,m,3*k,2*k),G.setRenderTarget(_),G.render(h,VQ)}}function aP(F){let _=[],$=[],W=[],H=F,Y=F-fq+1+Nf.length;for(let K=0;K<Y;K++){let G=Math.pow(2,H);_.push(G);let U=1/G;if(K>F-fq)U=Nf[K-F+fq-1];else if(K===0)U=0;$.push(U);let z=1/(G-2),h=-z,A=1+z,N=[h,h,A,h,A,A,h,h,A,A,h,A],M=6,T=6,P=3,D=2,O=1,b=new Float32Array(P*T*M),k=new Float32Array(D*T*M),y=new Float32Array(O*T*M);for(let x=0;x<M;x++){let o=x%3*2/3-1,s=x>2?0:-1,j=[o,s,0,o+0.6666666666666666,s,0,o+0.6666666666666666,s+1,0,o,s,0,o+0.6666666666666666,s+1,0,o,s+1,0];b.set(j,P*T*x),k.set(N,D*T*x);let V=[x,x,x,x,x,x];y.set(V,O*T*x)}let m=new l6;if(m.setAttribute("position",new C8(b,P)),m.setAttribute("uv",new C8(k,D)),m.setAttribute("faceIndex",new C8(y,O)),W.push(new X8(m,null)),H>fq)H--}return{lodMeshes:W,sizeLods:_,sigmas:$}}function Mf(F,_,$){let W=new P8(F,_,$);return W.texture.mapping=hQ,W.texture.name="PMREM.cubeUv",W.scissorTest=!0,W}function DZ(F,_,$,W,H){F.viewport.set(_,$,W,H),F.scissor.set(_,$,W,H)}function rP(F,_,$){return new V8({name:"PMREMGGXConvolution",defines:{GGX_SAMPLES:sP,CUBEUV_TEXEL_WIDTH:1/_,CUBEUV_TEXEL_HEIGHT:1/$,CUBEUV_MAX_MIP:`${F}.0`},uniforms:{envMap:{value:null},roughness:{value:0},mipInt:{value:0}},vertexShader:GY(),fragmentShader:`

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`,blending:A9,depthTest:!1,depthWrite:!1})}function tP(F,_,$){let W=new Float32Array(SJ),H=new w0(0,1,0);return new V8({name:"SphericalGaussianBlur",defines:{n:SJ,CUBEUV_TEXEL_WIDTH:1/_,CUBEUV_TEXEL_HEIGHT:1/$,CUBEUV_MAX_MIP:`${F}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:W},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:H}},vertexShader:GY(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:A9,depthTest:!1,depthWrite:!1})}function Of(){return new V8({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:GY(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:A9,depthTest:!1,depthWrite:!1})}function ff(){return new V8({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:GY(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:A9,depthTest:!1,depthWrite:!1})}function GY(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function eP(F){let _=new WeakMap,$=null;function W(G){if(G&&G.isTexture){let U=G.mapping,z=U===jw||U===xw,h=U===KZ||U===DJ;if(z||h){let A=_.get(G),N=A!==void 0?A.texture.pmremVersion:0;if(G.isRenderTargetTexture&&G.pmremVersion!==N){if($===null)$=new YB(F);return A=z?$.fromEquirectangular(G,A):$.fromCubemap(G,A),A.texture.pmremVersion=G.pmremVersion,_.set(G,A),A.texture}else if(A!==void 0)return A.texture;else{let M=G.image;if(z&&M&&M.height>0||h&&M&&H(M)){if($===null)$=new YB(F);return A=z?$.fromEquirectangular(G):$.fromCubemap(G),A.texture.pmremVersion=G.pmremVersion,_.set(G,A),G.addEventListener("dispose",Y),A.texture}else return null}}}return G}function H(G){let U=0,z=6;for(let h=0;h<z;h++)if(G[h]!==void 0)U++;return U===z}function Y(G){let U=G.target;U.removeEventListener("dispose",Y);let z=_.get(U);if(z!==void 0)_.delete(U),z.dispose()}function K(){if(_=new WeakMap,$!==null)$.dispose(),$=null}return{get:W,dispose:K}}function FV(F){let _={};function $(W){if(_[W]!==void 0)return _[W];let H=F.getExtension(W);return _[W]=H,H}return{has:function(W){return $(W)!==null},init:function(){$("EXT_color_buffer_float"),$("WEBGL_clip_cull_distance"),$("OES_texture_float_linear"),$("EXT_color_buffer_half_float"),$("WEBGL_multisampled_render_to_texture"),$("WEBGL_render_shared_exponent")},get:function(W){let H=$(W);if(H===null)HZ("WebGLRenderer: "+W+" extension not supported.");return H}}}function qV(F,_,$,W){let H={},Y=new WeakMap;function K(A){let N=A.target;if(N.index!==null)_.remove(N.index);for(let T in N.attributes)_.remove(N.attributes[T]);N.removeEventListener("dispose",K),delete H[N.id];let M=Y.get(N);if(M)_.remove(M),Y.delete(N);if(W.releaseStatesOfGeometry(N),N.isInstancedBufferGeometry===!0)delete N._maxInstanceCount;$.memory.geometries--}function G(A,N){if(H[N.id]===!0)return N;return N.addEventListener("dispose",K),H[N.id]=!0,$.memory.geometries++,N}function U(A){let N=A.attributes;for(let M in N)_.update(N[M],F.ARRAY_BUFFER)}function z(A){let N=[],M=A.index,T=A.attributes.position,P=0;if(M!==null){let b=M.array;P=M.version;for(let k=0,y=b.length;k<y;k+=3){let m=b[k+0],x=b[k+1],o=b[k+2];N.push(m,x,x,o,o,m)}}else if(T!==void 0){let b=T.array;P=T.version;for(let k=0,y=b.length/3-1;k<y;k+=3){let m=k+0,x=k+1,o=k+2;N.push(m,x,x,o,o,m)}}else return;let D=new((VU(N))?aw:ow)(N,1);D.version=P;let O=Y.get(A);if(O)_.remove(O);Y.set(A,D)}function h(A){let N=Y.get(A);if(N){let M=A.index;if(M!==null){if(N.version<M.version)z(A)}}else z(A);return Y.get(A)}return{get:G,update:U,getWireframeAttribute:h}}function JV(F,_,$){let W;function H(N){W=N}let Y,K;function G(N){Y=N.type,K=N.bytesPerElement}function U(N,M){F.drawElements(W,M,Y,N*K),$.update(M,W,1)}function z(N,M,T){if(T===0)return;F.drawElementsInstanced(W,M,Y,N*K,T),$.update(M,W,T)}function h(N,M,T){if(T===0)return;_.get("WEBGL_multi_draw").multiDrawElementsWEBGL(W,M,0,Y,N,0,T);let D=0;for(let O=0;O<T;O++)D+=M[O];$.update(D,W,1)}function A(N,M,T,P){if(T===0)return;let D=_.get("WEBGL_multi_draw");if(D===null)for(let O=0;O<N.length;O++)z(N[O]/K,M[O],P[O]);else{D.multiDrawElementsInstancedWEBGL(W,M,0,Y,N,0,P,0,T);let O=0;for(let b=0;b<T;b++)O+=M[b]*P[b];$.update(O,W,1)}}this.setMode=H,this.setIndex=G,this.render=U,this.renderInstances=z,this.renderMultiDraw=h,this.renderMultiDrawInstances=A}function _V(F){let _={geometries:0,textures:0},$={frame:0,calls:0,triangles:0,points:0,lines:0};function W(Y,K,G){switch($.calls++,K){case F.TRIANGLES:$.triangles+=G*(Y/3);break;case F.LINES:$.lines+=G*(Y/2);break;case F.LINE_STRIP:$.lines+=G*(Y-1);break;case F.LINE_LOOP:$.lines+=G*Y;break;case F.POINTS:$.points+=G*Y;break;default:hF("WebGLInfo: Unknown draw mode:",K);break}}function H(){$.calls=0,$.triangles=0,$.points=0,$.lines=0}return{memory:_,render:$,programs:null,autoReset:!0,reset:H,update:W}}function ZV(F,_,$){let W=new WeakMap,H=new T1;function Y(K,G,U){let z=K.morphTargetInfluences,h=G.morphAttributes.position||G.morphAttributes.normal||G.morphAttributes.color,A=h!==void 0?h.length:0,N=W.get(G);if(N===void 0||N.count!==A){let j=function(){o.dispose(),W.delete(G),G.removeEventListener("dispose",j)};if(N!==void 0)N.texture.dispose();let M=G.morphAttributes.position!==void 0,T=G.morphAttributes.normal!==void 0,P=G.morphAttributes.color!==void 0,D=G.morphAttributes.position||[],O=G.morphAttributes.normal||[],b=G.morphAttributes.color||[],k=0;if(M===!0)k=1;if(T===!0)k=2;if(P===!0)k=3;let y=G.attributes.position.count*k,m=1;if(y>_.maxTextureSize)m=Math.ceil(y/_.maxTextureSize),y=_.maxTextureSize;let x=new Float32Array(y*m*4*A),o=new cw(x,y,m,A);o.type=h9,o.needsUpdate=!0;let s=k*4;for(let V=0;V<A;V++){let d=D[V],$0=O[V],X0=b[V],K0=y*m*4*V;for(let J0=0;J0<d.count;J0++){let u=J0*s;if(M===!0)H.fromBufferAttribute(d,J0),x[K0+u+0]=H.x,x[K0+u+1]=H.y,x[K0+u+2]=H.z,x[K0+u+3]=0;if(T===!0)H.fromBufferAttribute($0,J0),x[K0+u+4]=H.x,x[K0+u+5]=H.y,x[K0+u+6]=H.z,x[K0+u+7]=0;if(P===!0)H.fromBufferAttribute(X0,J0),x[K0+u+8]=H.x,x[K0+u+9]=H.y,x[K0+u+10]=H.z,x[K0+u+11]=X0.itemSize===4?H.w:1}}N={count:A,texture:o,size:new DF(y,m)},W.set(G,N),G.addEventListener("dispose",j)}if(K.isInstancedMesh===!0&&K.morphTexture!==null)U.getUniforms().setValue(F,"morphTexture",K.morphTexture,$);else{let M=0;for(let P=0;P<z.length;P++)M+=z[P];let T=G.morphTargetsRelative?1:1-M;U.getUniforms().setValue(F,"morphTargetBaseInfluence",T),U.getUniforms().setValue(F,"morphTargetInfluences",z)}U.getUniforms().setValue(F,"morphTargetsTexture",N.texture,$),U.getUniforms().setValue(F,"morphTargetsTextureSize",N.size)}return{update:Y}}function $V(F,_,$,W){let H=new WeakMap;function Y(U){let z=W.render.frame,h=U.geometry,A=_.get(U,h);if(H.get(A)!==z)_.update(A),H.set(A,z);if(U.isInstancedMesh){if(U.hasEventListener("dispose",G)===!1)U.addEventListener("dispose",G);if(H.get(U)!==z){if($.update(U.instanceMatrix,F.ARRAY_BUFFER),U.instanceColor!==null)$.update(U.instanceColor,F.ARRAY_BUFFER);H.set(U,z)}}if(U.isSkinnedMesh){let N=U.skeleton;if(H.get(N)!==z)N.update(),H.set(N,z)}return A}function K(){H=new WeakMap}function G(U){let z=U.target;if(z.removeEventListener("dispose",G),$.remove(z.instanceMatrix),z.instanceColor!==null)$.remove(z.instanceColor)}return{update:Y,dispose:K}}var QV={[j5]:"LINEAR_TONE_MAPPING",[x5]:"REINHARD_TONE_MAPPING",[g5]:"CINEON_TONE_MAPPING",[u5]:"ACES_FILMIC_TONE_MAPPING",[m5]:"AGX_TONE_MAPPING",[l5]:"NEUTRAL_TONE_MAPPING",[p5]:"CUSTOM_TONE_MAPPING"};function WV(F,_,$,W,H){let Y=new P8(_,$,{type:F,depthBuffer:W,stencilBuffer:H}),K=new P8(_,$,{type:R9,depthBuffer:!1,stencilBuffer:!1}),G=new l6;G.setAttribute("position",new k6([-1,3,0,-1,-1,0,3,-1,0],3)),G.setAttribute("uv",new k6([0,2,0,0,2,0],2));let U=new mU({uniforms:{tDiffuse:{value:null}},vertexShader:`
			precision highp float;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}`,fragmentShader:`
			precision highp float;

			uniform sampler2D tDiffuse;

			varying vec2 vUv;

			#include <tonemapping_pars_fragment>
			#include <colorspace_pars_fragment>

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );

				#ifdef LINEAR_TONE_MAPPING
					gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
				#elif defined( REINHARD_TONE_MAPPING )
					gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
				#elif defined( CINEON_TONE_MAPPING )
					gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );
				#elif defined( ACES_FILMIC_TONE_MAPPING )
					gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
				#elif defined( AGX_TONE_MAPPING )
					gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );
				#elif defined( NEUTRAL_TONE_MAPPING )
					gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );
				#elif defined( CUSTOM_TONE_MAPPING )
					gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );
				#endif

				#ifdef SRGB_TRANSFER
					gl_FragColor = sRGBTransferOETF( gl_FragColor );
				#endif
			}`,depthTest:!1,depthWrite:!1}),z=new X8(G,U),h=new CQ(-1,1,1,-1,0,1),A=null,N=null,M=!1,T,P=null,D=[],O=!1;this.setSize=function(b,k){Y.setSize(b,k),K.setSize(b,k);for(let y=0;y<D.length;y++){let m=D[y];if(m.setSize)m.setSize(b,k)}},this.setEffects=function(b){D=b,O=D.length>0&&D[0].isRenderPass===!0;let{width:k,height:y}=Y;for(let m=0;m<D.length;m++){let x=D[m];if(x.setSize)x.setSize(k,y)}},this.begin=function(b,k){if(M)return!1;if(b.toneMapping===t8&&D.length===0)return!1;if(P=k,k!==null){let{width:y,height:m}=k;if(Y.width!==y||Y.height!==m)this.setSize(y,m)}if(O===!1)b.setRenderTarget(Y);return T=b.toneMapping,b.toneMapping=t8,!0},this.hasRenderPass=function(){return O},this.end=function(b,k){b.toneMapping=T,M=!0;let y=Y,m=K;for(let x=0;x<D.length;x++){let o=D[x];if(o.enabled===!1)continue;if(o.render(b,m,y,k),o.needsSwap!==!1){let s=y;y=m,m=s}}if(A!==b.outputColorSpace||N!==b.toneMapping){if(A=b.outputColorSpace,N=b.toneMapping,U.defines={},aF.getTransfer(A)===G1)U.defines.SRGB_TRANSFER="";let x=QV[N];if(x)U.defines[x]="";U.needsUpdate=!0}U.uniforms.tDiffuse.value=y.texture,b.setRenderTarget(P),b.render(z,h),P=null,M=!1},this.isCompositing=function(){return M},this.dispose=function(){Y.dispose(),K.dispose(),G.dispose(),U.dispose()}}var lf=new A6,XB=new EJ(1,1),df=new cw,nf=new jU,cf=new tw,If=[],Tf=[],Lf=new Float32Array(16),Ef=new Float32Array(9),Cf=new Float32Array(4);function MZ(F,_,$){let W=F[0];if(W<=0||W>0)return F;let H=_*$,Y=If[H];if(Y===void 0)Y=new Float32Array(H),If[H]=Y;if(_!==0){W.toArray(Y,0);for(let K=1,G=0;K!==_;++K)G+=$,F[K].toArray(Y,G)}return Y}function d1(F,_){if(F.length!==_.length)return!1;for(let $=0,W=F.length;$<W;$++)if(F[$]!==_[$])return!1;return!0}function i1(F,_){for(let $=0,W=_.length;$<W;$++)F[$]=_[$]}function KY(F,_){let $=Tf[_];if($===void 0)$=new Int32Array(_),Tf[_]=$;for(let W=0;W!==_;++W)$[W]=F.allocateTextureUnit();return $}function HV(F,_){let $=this.cache;if($[0]===_)return;F.uniform1f(this.addr,_),$[0]=_}function wV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y)F.uniform2f(this.addr,_.x,_.y),$[0]=_.x,$[1]=_.y}else{if(d1($,_))return;F.uniform2fv(this.addr,_),i1($,_)}}function YV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y||$[2]!==_.z)F.uniform3f(this.addr,_.x,_.y,_.z),$[0]=_.x,$[1]=_.y,$[2]=_.z}else if(_.r!==void 0){if($[0]!==_.r||$[1]!==_.g||$[2]!==_.b)F.uniform3f(this.addr,_.r,_.g,_.b),$[0]=_.r,$[1]=_.g,$[2]=_.b}else{if(d1($,_))return;F.uniform3fv(this.addr,_),i1($,_)}}function XV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y||$[2]!==_.z||$[3]!==_.w)F.uniform4f(this.addr,_.x,_.y,_.z,_.w),$[0]=_.x,$[1]=_.y,$[2]=_.z,$[3]=_.w}else{if(d1($,_))return;F.uniform4fv(this.addr,_),i1($,_)}}function GV(F,_){let $=this.cache,W=_.elements;if(W===void 0){if(d1($,_))return;F.uniformMatrix2fv(this.addr,!1,_),i1($,_)}else{if(d1($,W))return;Cf.set(W),F.uniformMatrix2fv(this.addr,!1,Cf),i1($,W)}}function KV(F,_){let $=this.cache,W=_.elements;if(W===void 0){if(d1($,_))return;F.uniformMatrix3fv(this.addr,!1,_),i1($,_)}else{if(d1($,W))return;Ef.set(W),F.uniformMatrix3fv(this.addr,!1,Ef),i1($,W)}}function UV(F,_){let $=this.cache,W=_.elements;if(W===void 0){if(d1($,_))return;F.uniformMatrix4fv(this.addr,!1,_),i1($,_)}else{if(d1($,W))return;Lf.set(W),F.uniformMatrix4fv(this.addr,!1,Lf),i1($,W)}}function BV(F,_){let $=this.cache;if($[0]===_)return;F.uniform1i(this.addr,_),$[0]=_}function zV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y)F.uniform2i(this.addr,_.x,_.y),$[0]=_.x,$[1]=_.y}else{if(d1($,_))return;F.uniform2iv(this.addr,_),i1($,_)}}function AV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y||$[2]!==_.z)F.uniform3i(this.addr,_.x,_.y,_.z),$[0]=_.x,$[1]=_.y,$[2]=_.z}else{if(d1($,_))return;F.uniform3iv(this.addr,_),i1($,_)}}function hV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y||$[2]!==_.z||$[3]!==_.w)F.uniform4i(this.addr,_.x,_.y,_.z,_.w),$[0]=_.x,$[1]=_.y,$[2]=_.z,$[3]=_.w}else{if(d1($,_))return;F.uniform4iv(this.addr,_),i1($,_)}}function RV(F,_){let $=this.cache;if($[0]===_)return;F.uniform1ui(this.addr,_),$[0]=_}function NV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y)F.uniform2ui(this.addr,_.x,_.y),$[0]=_.x,$[1]=_.y}else{if(d1($,_))return;F.uniform2uiv(this.addr,_),i1($,_)}}function DV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y||$[2]!==_.z)F.uniform3ui(this.addr,_.x,_.y,_.z),$[0]=_.x,$[1]=_.y,$[2]=_.z}else{if(d1($,_))return;F.uniform3uiv(this.addr,_),i1($,_)}}function MV(F,_){let $=this.cache;if(_.x!==void 0){if($[0]!==_.x||$[1]!==_.y||$[2]!==_.z||$[3]!==_.w)F.uniform4ui(this.addr,_.x,_.y,_.z,_.w),$[0]=_.x,$[1]=_.y,$[2]=_.z,$[3]=_.w}else{if(d1($,_))return;F.uniform4uiv(this.addr,_),i1($,_)}}function OV(F,_,$){let W=this.cache,H=$.allocateTextureUnit();if(W[0]!==H)F.uniform1i(this.addr,H),W[0]=H;let Y;if(this.type===F.SAMPLER_2D_SHADOW)XB.compareFunction=$.isReversedDepthBuffer()?nw:iw,Y=XB;else Y=lf;$.setTexture2D(_||Y,H)}function fV(F,_,$){let W=this.cache,H=$.allocateTextureUnit();if(W[0]!==H)F.uniform1i(this.addr,H),W[0]=H;$.setTexture3D(_||nf,H)}function IV(F,_,$){let W=this.cache,H=$.allocateTextureUnit();if(W[0]!==H)F.uniform1i(this.addr,H),W[0]=H;$.setTextureCube(_||cf,H)}function TV(F,_,$){let W=this.cache,H=$.allocateTextureUnit();if(W[0]!==H)F.uniform1i(this.addr,H),W[0]=H;$.setTexture2DArray(_||df,H)}function LV(F){switch(F){case 5126:return HV;case 35664:return wV;case 35665:return YV;case 35666:return XV;case 35674:return GV;case 35675:return KV;case 35676:return UV;case 5124:case 35670:return BV;case 35667:case 35671:return zV;case 35668:case 35672:return AV;case 35669:case 35673:return hV;case 5125:return RV;case 36294:return NV;case 36295:return DV;case 36296:return MV;case 35678:case 36198:case 36298:case 36306:case 35682:return OV;case 35679:case 36299:case 36307:return fV;case 35680:case 36300:case 36308:case 36293:return IV;case 36289:case 36303:case 36311:case 36292:return TV}}function EV(F,_){F.uniform1fv(this.addr,_)}function CV(F,_){let $=MZ(_,this.size,2);F.uniform2fv(this.addr,$)}function PV(F,_){let $=MZ(_,this.size,3);F.uniform3fv(this.addr,$)}function VV(F,_){let $=MZ(_,this.size,4);F.uniform4fv(this.addr,$)}function kV(F,_){let $=MZ(_,this.size,4);F.uniformMatrix2fv(this.addr,!1,$)}function SV(F,_){let $=MZ(_,this.size,9);F.uniformMatrix3fv(this.addr,!1,$)}function yV(F,_){let $=MZ(_,this.size,16);F.uniformMatrix4fv(this.addr,!1,$)}function vV(F,_){F.uniform1iv(this.addr,_)}function bV(F,_){F.uniform2iv(this.addr,_)}function jV(F,_){F.uniform3iv(this.addr,_)}function xV(F,_){F.uniform4iv(this.addr,_)}function gV(F,_){F.uniform1uiv(this.addr,_)}function uV(F,_){F.uniform2uiv(this.addr,_)}function pV(F,_){F.uniform3uiv(this.addr,_)}function mV(F,_){F.uniform4uiv(this.addr,_)}function lV(F,_,$){let W=this.cache,H=_.length,Y=KY($,H);if(!d1(W,Y))F.uniform1iv(this.addr,Y),i1(W,Y);let K;if(this.type===F.SAMPLER_2D_SHADOW)K=XB;else K=lf;for(let G=0;G!==H;++G)$.setTexture2D(_[G]||K,Y[G])}function dV(F,_,$){let W=this.cache,H=_.length,Y=KY($,H);if(!d1(W,Y))F.uniform1iv(this.addr,Y),i1(W,Y);for(let K=0;K!==H;++K)$.setTexture3D(_[K]||nf,Y[K])}function iV(F,_,$){let W=this.cache,H=_.length,Y=KY($,H);if(!d1(W,Y))F.uniform1iv(this.addr,Y),i1(W,Y);for(let K=0;K!==H;++K)$.setTextureCube(_[K]||cf,Y[K])}function nV(F,_,$){let W=this.cache,H=_.length,Y=KY($,H);if(!d1(W,Y))F.uniform1iv(this.addr,Y),i1(W,Y);for(let K=0;K!==H;++K)$.setTexture2DArray(_[K]||df,Y[K])}function cV(F){switch(F){case 5126:return EV;case 35664:return CV;case 35665:return PV;case 35666:return VV;case 35674:return kV;case 35675:return SV;case 35676:return yV;case 5124:case 35670:return vV;case 35667:case 35671:return bV;case 35668:case 35672:return jV;case 35669:case 35673:return xV;case 5125:return gV;case 36294:return uV;case 36295:return pV;case 36296:return mV;case 35678:case 36198:case 36298:case 36306:case 35682:return lV;case 35679:case 36299:case 36307:return dV;case 35680:case 36300:case 36308:case 36293:return iV;case 36289:case 36303:case 36311:case 36292:return nV}}class sf{constructor(F,_,$){this.id=F,this.addr=$,this.cache=[],this.type=_.type,this.setValue=LV(_.type)}}class of{constructor(F,_,$){this.id=F,this.addr=$,this.cache=[],this.type=_.type,this.size=_.size,this.setValue=cV(_.type)}}class af{constructor(F){this.id=F,this.seq=[],this.map={}}setValue(F,_,$){let W=this.seq;for(let H=0,Y=W.length;H!==Y;++H){let K=W[H];K.setValue(F,_[K.id],$)}}}var HB=/(\w+)(\])?(\[|\.)?/g;function Pf(F,_){F.seq.push(_),F.map[_.id]=_}function sV(F,_,$){let W=F.name,H=W.length;HB.lastIndex=0;while(!0){let Y=HB.exec(W),K=HB.lastIndex,G=Y[1],U=Y[2]==="]",z=Y[3];if(U)G=G|0;if(z===void 0||z==="["&&K+2===H){Pf($,z===void 0?new sf(G,F,_):new of(G,F,_));break}else{let A=$.map[G];if(A===void 0)A=new af(G),Pf($,A);$=A}}}class yQ{constructor(F,_){this.seq=[],this.map={};let $=F.getProgramParameter(_,F.ACTIVE_UNIFORMS);for(let Y=0;Y<$;++Y){let K=F.getActiveUniform(_,Y),G=F.getUniformLocation(_,K.name);sV(K,G,this)}let W=[],H=[];for(let Y of this.seq)if(Y.type===F.SAMPLER_2D_SHADOW||Y.type===F.SAMPLER_CUBE_SHADOW||Y.type===F.SAMPLER_2D_ARRAY_SHADOW)W.push(Y);else H.push(Y);if(W.length>0)this.seq=W.concat(H)}setValue(F,_,$,W){let H=this.map[_];if(H!==void 0)H.setValue(F,$,W)}setOptional(F,_,$){let W=_[$];if(W!==void 0)this.setValue(F,$,W)}static upload(F,_,$,W){for(let H=0,Y=_.length;H!==Y;++H){let K=_[H],G=$[K.id];if(G.needsUpdate!==!1)K.setValue(F,G.value,W)}}static seqWithValue(F,_){let $=[];for(let W=0,H=F.length;W!==H;++W){let Y=F[W];if(Y.id in _)$.push(Y)}return $}}function Vf(F,_,$){let W=F.createShader(_);return F.shaderSource(W,$),F.compileShader(W),W}var oV=37297,aV=0;function rV(F,_){let $=F.split(`
`),W=[],H=Math.max(_-6,0),Y=Math.min(_+6,$.length);for(let K=H;K<Y;K++){let G=K+1;W.push(`${G===_?">":" "} ${G}: ${$[K]}`)}return W.join(`
`)}var kf=new EF;function tV(F){aF._getMatrix(kf,aF.workingColorSpace,F);let _=`mat3( ${kf.elements.map(($)=>$.toFixed(4))} )`;switch(aF.getTransfer(F)){case EU:return[_,"LinearTransferOETF"];case G1:return[_,"sRGBTransferOETF"];default:return zF("WebGLProgram: Unsupported color space: ",F),[_,"LinearTransferOETF"]}}function Sf(F,_,$){let W=F.getShaderParameter(_,F.COMPILE_STATUS),Y=(F.getShaderInfoLog(_)||"").trim();if(W&&Y==="")return"";let K=/ERROR: 0:(\d+)/.exec(Y);if(K){let G=parseInt(K[1]);return $.toUpperCase()+`

`+Y+`

`+rV(F.getShaderSource(_),G)}else return Y}function eV(F,_){let $=tV(_);return[`vec4 ${F}( vec4 value ) {`,`	return ${$[1]}( vec4( value.rgb * ${$[0]}, value.a ) );`,"}"].join(`
`)}var Fk={[j5]:"Linear",[x5]:"Reinhard",[g5]:"Cineon",[u5]:"ACESFilmic",[m5]:"AgX",[l5]:"Neutral",[p5]:"Custom"};function qk(F,_){let $=Fk[_];if($===void 0)return zF("WebGLProgram: Unsupported toneMapping:",_),"vec3 "+F+"( vec3 color ) { return LinearToneMapping( color ); }";return"vec3 "+F+"( vec3 color ) { return "+$+"ToneMapping( color ); }"}var XY=new w0;function Jk(){aF.getLuminanceCoefficients(XY);let F=XY.x.toFixed(4),_=XY.y.toFixed(4),$=XY.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${F}, ${_}, ${$} );`,"\treturn dot( weights, rgb );","}"].join(`
`)}function _k(F){return[F.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",F.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(SQ).join(`
`)}function Zk(F){let _=[];for(let $ in F){let W=F[$];if(W===!1)continue;_.push("#define "+$+" "+W)}return _.join(`
`)}function $k(F,_){let $={},W=F.getProgramParameter(_,F.ACTIVE_ATTRIBUTES);for(let H=0;H<W;H++){let Y=F.getActiveAttrib(_,H),K=Y.name,G=1;if(Y.type===F.FLOAT_MAT2)G=2;if(Y.type===F.FLOAT_MAT3)G=3;if(Y.type===F.FLOAT_MAT4)G=4;$[K]={type:Y.type,location:F.getAttribLocation(_,K),locationSize:G}}return $}function SQ(F){return F!==""}function yf(F,_){let $=_.numSpotLightShadows+_.numSpotLightMaps-_.numSpotLightShadowsWithMaps;return F.replace(/NUM_DIR_LIGHTS/g,_.numDirLights).replace(/NUM_SPOT_LIGHTS/g,_.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,_.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,$).replace(/NUM_RECT_AREA_LIGHTS/g,_.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,_.numPointLights).replace(/NUM_HEMI_LIGHTS/g,_.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,_.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,_.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,_.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,_.numPointLightShadows)}function vf(F,_){return F.replace(/NUM_CLIPPING_PLANES/g,_.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,_.numClippingPlanes-_.numClipIntersection)}var Qk=/^[ \t]*#include +<([\w\d./]+)>/gm;function GB(F){return F.replace(Qk,Hk)}var Wk=new Map;function Hk(F,_){let $=bF[_];if($===void 0){let W=Wk.get(_);if(W!==void 0)$=bF[W],zF('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',_,W);else throw Error("Can not resolve #include <"+_+">")}return GB($)}var wk=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function bf(F){return F.replace(wk,Yk)}function Yk(F,_,$,W){let H="";for(let Y=parseInt(_);Y<parseInt($);Y++)H+=W.replace(/\[\s*i\s*\]/g,"[ "+Y+" ]").replace(/UNROLLED_LOOP_INDEX/g,Y);return H}function jf(F){let _=`precision ${F.precision} float;
	precision ${F.precision} int;
	precision ${F.precision} sampler2D;
	precision ${F.precision} samplerCube;
	precision ${F.precision} sampler3D;
	precision ${F.precision} sampler2DArray;
	precision ${F.precision} sampler2DShadow;
	precision ${F.precision} samplerCubeShadow;
	precision ${F.precision} sampler2DArrayShadow;
	precision ${F.precision} isampler2D;
	precision ${F.precision} isampler3D;
	precision ${F.precision} isamplerCube;
	precision ${F.precision} isampler2DArray;
	precision ${F.precision} usampler2D;
	precision ${F.precision} usampler3D;
	precision ${F.precision} usamplerCube;
	precision ${F.precision} usampler2DArray;
	`;if(F.precision==="highp")_+=`
#define HIGH_PRECISION`;else if(F.precision==="mediump")_+=`
#define MEDIUM_PRECISION`;else if(F.precision==="lowp")_+=`
#define LOW_PRECISION`;return _}var Xk={[BQ]:"SHADOWMAP_TYPE_PCF",[YZ]:"SHADOWMAP_TYPE_VSM"};function Gk(F){return Xk[F.shadowMapType]||"SHADOWMAP_TYPE_BASIC"}var Kk={[KZ]:"ENVMAP_TYPE_CUBE",[DJ]:"ENVMAP_TYPE_CUBE",[hQ]:"ENVMAP_TYPE_CUBE_UV"};function Uk(F){if(F.envMap===!1)return"ENVMAP_TYPE_CUBE";return Kk[F.envMapMode]||"ENVMAP_TYPE_CUBE"}var Bk={[DJ]:"ENVMAP_MODE_REFRACTION"};function zk(F){if(F.envMap===!1)return"ENVMAP_MODE_REFLECTION";return Bk[F.envMapMode]||"ENVMAP_MODE_REFLECTION"}var Ak={[dO]:"ENVMAP_BLENDING_MULTIPLY",[iO]:"ENVMAP_BLENDING_MIX",[nO]:"ENVMAP_BLENDING_ADD"};function hk(F){if(F.envMap===!1)return"ENVMAP_BLENDING_NONE";return Ak[F.combine]||"ENVMAP_BLENDING_NONE"}function Rk(F){let _=F.envMapCubeUVHeight;if(_===null)return null;let $=Math.log2(_)-2,W=1/_;return{texelWidth:1/(3*Math.max(Math.pow(2,$),112)),texelHeight:W,maxMip:$}}function Nk(F,_,$,W){let H=F.getContext(),Y=$.defines,K=$.vertexShader,G=$.fragmentShader,U=Gk($),z=Uk($),h=zk($),A=hk($),N=Rk($),M=_k($),T=Zk(Y),P=H.createProgram(),D,O,b=$.glslVersion?"#version "+$.glslVersion+`
`:"";if($.isRawShaderMaterial){if(D=["#define SHADER_TYPE "+$.shaderType,"#define SHADER_NAME "+$.shaderName,T].filter(SQ).join(`
`),D.length>0)D+=`
`;if(O=["#define SHADER_TYPE "+$.shaderType,"#define SHADER_NAME "+$.shaderName,T].filter(SQ).join(`
`),O.length>0)O+=`
`}else D=[jf($),"#define SHADER_TYPE "+$.shaderType,"#define SHADER_NAME "+$.shaderName,T,$.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",$.batching?"#define USE_BATCHING":"",$.batchingColor?"#define USE_BATCHING_COLOR":"",$.instancing?"#define USE_INSTANCING":"",$.instancingColor?"#define USE_INSTANCING_COLOR":"",$.instancingMorph?"#define USE_INSTANCING_MORPH":"",$.useFog&&$.fog?"#define USE_FOG":"",$.useFog&&$.fogExp2?"#define FOG_EXP2":"",$.map?"#define USE_MAP":"",$.envMap?"#define USE_ENVMAP":"",$.envMap?"#define "+h:"",$.lightMap?"#define USE_LIGHTMAP":"",$.aoMap?"#define USE_AOMAP":"",$.bumpMap?"#define USE_BUMPMAP":"",$.normalMap?"#define USE_NORMALMAP":"",$.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",$.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",$.displacementMap?"#define USE_DISPLACEMENTMAP":"",$.emissiveMap?"#define USE_EMISSIVEMAP":"",$.anisotropy?"#define USE_ANISOTROPY":"",$.anisotropyMap?"#define USE_ANISOTROPYMAP":"",$.clearcoatMap?"#define USE_CLEARCOATMAP":"",$.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",$.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",$.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",$.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",$.specularMap?"#define USE_SPECULARMAP":"",$.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",$.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",$.roughnessMap?"#define USE_ROUGHNESSMAP":"",$.metalnessMap?"#define USE_METALNESSMAP":"",$.alphaMap?"#define USE_ALPHAMAP":"",$.alphaHash?"#define USE_ALPHAHASH":"",$.transmission?"#define USE_TRANSMISSION":"",$.transmissionMap?"#define USE_TRANSMISSIONMAP":"",$.thicknessMap?"#define USE_THICKNESSMAP":"",$.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",$.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",$.mapUv?"#define MAP_UV "+$.mapUv:"",$.alphaMapUv?"#define ALPHAMAP_UV "+$.alphaMapUv:"",$.lightMapUv?"#define LIGHTMAP_UV "+$.lightMapUv:"",$.aoMapUv?"#define AOMAP_UV "+$.aoMapUv:"",$.emissiveMapUv?"#define EMISSIVEMAP_UV "+$.emissiveMapUv:"",$.bumpMapUv?"#define BUMPMAP_UV "+$.bumpMapUv:"",$.normalMapUv?"#define NORMALMAP_UV "+$.normalMapUv:"",$.displacementMapUv?"#define DISPLACEMENTMAP_UV "+$.displacementMapUv:"",$.metalnessMapUv?"#define METALNESSMAP_UV "+$.metalnessMapUv:"",$.roughnessMapUv?"#define ROUGHNESSMAP_UV "+$.roughnessMapUv:"",$.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+$.anisotropyMapUv:"",$.clearcoatMapUv?"#define CLEARCOATMAP_UV "+$.clearcoatMapUv:"",$.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+$.clearcoatNormalMapUv:"",$.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+$.clearcoatRoughnessMapUv:"",$.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+$.iridescenceMapUv:"",$.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+$.iridescenceThicknessMapUv:"",$.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+$.sheenColorMapUv:"",$.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+$.sheenRoughnessMapUv:"",$.specularMapUv?"#define SPECULARMAP_UV "+$.specularMapUv:"",$.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+$.specularColorMapUv:"",$.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+$.specularIntensityMapUv:"",$.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+$.transmissionMapUv:"",$.thicknessMapUv?"#define THICKNESSMAP_UV "+$.thicknessMapUv:"",$.vertexTangents&&$.flatShading===!1?"#define USE_TANGENT":"",$.vertexColors?"#define USE_COLOR":"",$.vertexAlphas?"#define USE_COLOR_ALPHA":"",$.vertexUv1s?"#define USE_UV1":"",$.vertexUv2s?"#define USE_UV2":"",$.vertexUv3s?"#define USE_UV3":"",$.pointsUvs?"#define USE_POINTS_UV":"",$.flatShading?"#define FLAT_SHADED":"",$.skinning?"#define USE_SKINNING":"",$.morphTargets?"#define USE_MORPHTARGETS":"",$.morphNormals&&$.flatShading===!1?"#define USE_MORPHNORMALS":"",$.morphColors?"#define USE_MORPHCOLORS":"",$.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+$.morphTextureStride:"",$.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+$.morphTargetsCount:"",$.doubleSided?"#define DOUBLE_SIDED":"",$.flipSided?"#define FLIP_SIDED":"",$.shadowMapEnabled?"#define USE_SHADOWMAP":"",$.shadowMapEnabled?"#define "+U:"",$.sizeAttenuation?"#define USE_SIZEATTENUATION":"",$.numLightProbes>0?"#define USE_LIGHT_PROBES":"",$.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",$.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif",`
`].filter(SQ).join(`
`),O=[jf($),"#define SHADER_TYPE "+$.shaderType,"#define SHADER_NAME "+$.shaderName,T,$.useFog&&$.fog?"#define USE_FOG":"",$.useFog&&$.fogExp2?"#define FOG_EXP2":"",$.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",$.map?"#define USE_MAP":"",$.matcap?"#define USE_MATCAP":"",$.envMap?"#define USE_ENVMAP":"",$.envMap?"#define "+z:"",$.envMap?"#define "+h:"",$.envMap?"#define "+A:"",N?"#define CUBEUV_TEXEL_WIDTH "+N.texelWidth:"",N?"#define CUBEUV_TEXEL_HEIGHT "+N.texelHeight:"",N?"#define CUBEUV_MAX_MIP "+N.maxMip+".0":"",$.lightMap?"#define USE_LIGHTMAP":"",$.aoMap?"#define USE_AOMAP":"",$.bumpMap?"#define USE_BUMPMAP":"",$.normalMap?"#define USE_NORMALMAP":"",$.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",$.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",$.emissiveMap?"#define USE_EMISSIVEMAP":"",$.anisotropy?"#define USE_ANISOTROPY":"",$.anisotropyMap?"#define USE_ANISOTROPYMAP":"",$.clearcoat?"#define USE_CLEARCOAT":"",$.clearcoatMap?"#define USE_CLEARCOATMAP":"",$.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",$.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",$.dispersion?"#define USE_DISPERSION":"",$.iridescence?"#define USE_IRIDESCENCE":"",$.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",$.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",$.specularMap?"#define USE_SPECULARMAP":"",$.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",$.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",$.roughnessMap?"#define USE_ROUGHNESSMAP":"",$.metalnessMap?"#define USE_METALNESSMAP":"",$.alphaMap?"#define USE_ALPHAMAP":"",$.alphaTest?"#define USE_ALPHATEST":"",$.alphaHash?"#define USE_ALPHAHASH":"",$.sheen?"#define USE_SHEEN":"",$.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",$.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",$.transmission?"#define USE_TRANSMISSION":"",$.transmissionMap?"#define USE_TRANSMISSIONMAP":"",$.thicknessMap?"#define USE_THICKNESSMAP":"",$.vertexTangents&&$.flatShading===!1?"#define USE_TANGENT":"",$.vertexColors||$.instancingColor||$.batchingColor?"#define USE_COLOR":"",$.vertexAlphas?"#define USE_COLOR_ALPHA":"",$.vertexUv1s?"#define USE_UV1":"",$.vertexUv2s?"#define USE_UV2":"",$.vertexUv3s?"#define USE_UV3":"",$.pointsUvs?"#define USE_POINTS_UV":"",$.gradientMap?"#define USE_GRADIENTMAP":"",$.flatShading?"#define FLAT_SHADED":"",$.doubleSided?"#define DOUBLE_SIDED":"",$.flipSided?"#define FLIP_SIDED":"",$.shadowMapEnabled?"#define USE_SHADOWMAP":"",$.shadowMapEnabled?"#define "+U:"",$.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",$.numLightProbes>0?"#define USE_LIGHT_PROBES":"",$.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",$.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",$.logarithmicDepthBuffer?"#define USE_LOGARITHMIC_DEPTH_BUFFER":"",$.reversedDepthBuffer?"#define USE_REVERSED_DEPTH_BUFFER":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",$.toneMapping!==t8?"#define TONE_MAPPING":"",$.toneMapping!==t8?bF.tonemapping_pars_fragment:"",$.toneMapping!==t8?qk("toneMapping",$.toneMapping):"",$.dithering?"#define DITHERING":"",$.opaque?"#define OPAQUE":"",bF.colorspace_pars_fragment,eV("linearToOutputTexel",$.outputColorSpace),Jk(),$.useDepthPacking?"#define DEPTH_PACKING "+$.depthPacking:"",`
`].filter(SQ).join(`
`);if(K=GB(K),K=yf(K,$),K=vf(K,$),G=GB(G),G=yf(G,$),G=vf(G,$),K=bf(K),G=bf(G),$.isRawShaderMaterial!==!0)b=`#version 300 es
`,D=[M,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+D,O=["#define varying in",$.glslVersion===CU?"":"layout(location = 0) out highp vec4 pc_fragColor;",$.glslVersion===CU?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+O;let k=b+D+K,y=b+O+G,m=Vf(H,H.VERTEX_SHADER,k),x=Vf(H,H.FRAGMENT_SHADER,y);if(H.attachShader(P,m),H.attachShader(P,x),$.index0AttributeName!==void 0)H.bindAttribLocation(P,0,$.index0AttributeName);else if($.morphTargets===!0)H.bindAttribLocation(P,0,"position");H.linkProgram(P);function o(d){if(F.debug.checkShaderErrors){let $0=H.getProgramInfoLog(P)||"",X0=H.getShaderInfoLog(m)||"",K0=H.getShaderInfoLog(x)||"",J0=$0.trim(),u=X0.trim(),n=K0.trim(),Q0=!0,O0=!0;if(H.getProgramParameter(P,H.LINK_STATUS)===!1)if(Q0=!1,typeof F.debug.onShaderError==="function")F.debug.onShaderError(H,P,m,x);else{let t=Sf(H,m,"vertex"),T0=Sf(H,x,"fragment");hF("THREE.WebGLProgram: Shader Error "+H.getError()+" - VALIDATE_STATUS "+H.getProgramParameter(P,H.VALIDATE_STATUS)+`

Material Name: `+d.name+`
Material Type: `+d.type+`

Program Info Log: `+J0+`
`+t+`
`+T0)}else if(J0!=="")zF("WebGLProgram: Program Info Log:",J0);else if(u===""||n==="")O0=!1;if(O0)d.diagnostics={runnable:Q0,programLog:J0,vertexShader:{log:u,prefix:D},fragmentShader:{log:n,prefix:O}}}H.deleteShader(m),H.deleteShader(x),s=new yQ(H,P),j=$k(H,P)}let s;this.getUniforms=function(){if(s===void 0)o(this);return s};let j;this.getAttributes=function(){if(j===void 0)o(this);return j};let V=$.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){if(V===!1)V=H.getProgramParameter(P,oV);return V},this.destroy=function(){W.releaseStatesOfProgram(this),H.deleteProgram(P),this.program=void 0},this.type=$.shaderType,this.name=$.shaderName,this.id=aV++,this.cacheKey=_,this.usedTimes=1,this.program=P,this.vertexShader=m,this.fragmentShader=x,this}var Dk=0;class rf{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(F){let{vertexShader:_,fragmentShader:$}=F,W=this._getShaderStage(_),H=this._getShaderStage($),Y=this._getShaderCacheForMaterial(F);if(Y.has(W)===!1)Y.add(W),W.usedTimes++;if(Y.has(H)===!1)Y.add(H),H.usedTimes++;return this}remove(F){let _=this.materialCache.get(F);for(let $ of _)if($.usedTimes--,$.usedTimes===0)this.shaderCache.delete($.code);return this.materialCache.delete(F),this}getVertexShaderID(F){return this._getShaderStage(F.vertexShader).id}getFragmentShaderID(F){return this._getShaderStage(F.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(F){let _=this.materialCache,$=_.get(F);if($===void 0)$=new Set,_.set(F,$);return $}_getShaderStage(F){let _=this.shaderCache,$=_.get(F);if($===void 0)$=new tf(F),_.set(F,$);return $}}class tf{constructor(F){this.id=Dk++,this.code=F,this.usedTimes=0}}function Mk(F,_,$,W,H,Y,K){let G=new OQ,U=new rf,z=new Set,h=[],A=new Map,N=H.logarithmicDepthBuffer,M=H.precision,T={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distance",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function P(j){if(z.add(j),j===0)return"uv";return`uv${j}`}function D(j,V,d,$0,X0){let K0=$0.fog,J0=X0.geometry,u=j.isMeshStandardMaterial?$0.environment:null,n=(j.isMeshStandardMaterial?$:_).get(j.envMap||u),Q0=!!n&&n.mapping===hQ?n.image.height:null,O0=T[j.type];if(j.precision!==null){if(M=H.getMaxPrecision(j.precision),M!==j.precision)zF("WebGLProgram.getParameters:",j.precision,"not supported, using",M,"instead.")}let t=J0.morphAttributes.position||J0.morphAttributes.normal||J0.morphAttributes.color,T0=t!==void 0?t.length:0,g0=0;if(J0.morphAttributes.position!==void 0)g0=1;if(J0.morphAttributes.normal!==void 0)g0=2;if(J0.morphAttributes.color!==void 0)g0=3;let _F,c0,D0,P0;if(O0){let nF=y7[O0];_F=nF.vertexShader,c0=nF.fragmentShader}else _F=j.vertexShader,c0=j.fragmentShader,U.update(j),D0=U.getVertexShaderID(j),P0=U.getFragmentShaderID(j);let S0=F.getRenderTarget(),e0=F.state.buffers.depth.getReversed(),JF=X0.isInstancedMesh===!0,UF=X0.isBatchedMesh===!0,v0=!!j.map,PF=!!j.matcap,OF=!!n,jF=!!j.aoMap,t0=!!j.lightMap,XF=!!j.bumpMap,a=!!j.normalMap,C0=!!j.displacementMap,AF=!!j.emissiveMap,s0=!!j.metalnessMap,j0=!!j.roughnessMap,fF=j.anisotropy>0,v=j.clearcoat>0,E=j.dispersion>0,Y0=j.iridescence>0,q0=j.sheen>0,H0=j.transmission>0,W0=fF&&!!j.anisotropyMap,y0=v&&!!j.clearcoatMap,E0=v&&!!j.clearcoatNormalMap,n0=v&&!!j.clearcoatRoughnessMap,ZF=Y0&&!!j.iridescenceMap,V0=Y0&&!!j.iridescenceThicknessMap,b0=q0&&!!j.sheenColorMap,a0=q0&&!!j.sheenRoughnessMap,L=!!j.specularMap,p=!!j.specularColorMap,N0=!!j.specularIntensityMap,g=H0&&!!j.transmissionMap,h0=H0&&!!j.thicknessMap,M0=!!j.gradientMap,L0=!!j.alphaMap,I0=j.alphaTest>0,Z0=!!j.alphaHash,m0=!!j.extensions,$F=t8;if(j.toneMapped){if(S0===null||S0.isXRRenderTarget===!0)$F=F.toneMapping}let iF={shaderID:O0,shaderType:j.type,shaderName:j.name,vertexShader:_F,fragmentShader:c0,defines:j.defines,customVertexShaderID:D0,customFragmentShaderID:P0,isRawShaderMaterial:j.isRawShaderMaterial===!0,glslVersion:j.glslVersion,precision:M,batching:UF,batchingColor:UF&&X0._colorsTexture!==null,instancing:JF,instancingColor:JF&&X0.instanceColor!==null,instancingMorph:JF&&X0.morphTexture!==null,outputColorSpace:S0===null?F.outputColorSpace:S0.isXRRenderTarget===!0?S0.texture.colorSpace:DQ,alphaToCoverage:!!j.alphaToCoverage,map:v0,matcap:PF,envMap:OF,envMapMode:OF&&n.mapping,envMapCubeUVHeight:Q0,aoMap:jF,lightMap:t0,bumpMap:XF,normalMap:a,displacementMap:C0,emissiveMap:AF,normalMapObjectSpace:a&&j.normalMapType===Zf,normalMapTangentSpace:a&&j.normalMapType===_f,metalnessMap:s0,roughnessMap:j0,anisotropy:fF,anisotropyMap:W0,clearcoat:v,clearcoatMap:y0,clearcoatNormalMap:E0,clearcoatRoughnessMap:n0,dispersion:E,iridescence:Y0,iridescenceMap:ZF,iridescenceThicknessMap:V0,sheen:q0,sheenColorMap:b0,sheenRoughnessMap:a0,specularMap:L,specularColorMap:p,specularIntensityMap:N0,transmission:H0,transmissionMap:g,thicknessMap:h0,gradientMap:M0,opaque:j.transparent===!1&&j.blending===zQ&&j.alphaToCoverage===!1,alphaMap:L0,alphaTest:I0,alphaHash:Z0,combine:j.combine,mapUv:v0&&P(j.map.channel),aoMapUv:jF&&P(j.aoMap.channel),lightMapUv:t0&&P(j.lightMap.channel),bumpMapUv:XF&&P(j.bumpMap.channel),normalMapUv:a&&P(j.normalMap.channel),displacementMapUv:C0&&P(j.displacementMap.channel),emissiveMapUv:AF&&P(j.emissiveMap.channel),metalnessMapUv:s0&&P(j.metalnessMap.channel),roughnessMapUv:j0&&P(j.roughnessMap.channel),anisotropyMapUv:W0&&P(j.anisotropyMap.channel),clearcoatMapUv:y0&&P(j.clearcoatMap.channel),clearcoatNormalMapUv:E0&&P(j.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:n0&&P(j.clearcoatRoughnessMap.channel),iridescenceMapUv:ZF&&P(j.iridescenceMap.channel),iridescenceThicknessMapUv:V0&&P(j.iridescenceThicknessMap.channel),sheenColorMapUv:b0&&P(j.sheenColorMap.channel),sheenRoughnessMapUv:a0&&P(j.sheenRoughnessMap.channel),specularMapUv:L&&P(j.specularMap.channel),specularColorMapUv:p&&P(j.specularColorMap.channel),specularIntensityMapUv:N0&&P(j.specularIntensityMap.channel),transmissionMapUv:g&&P(j.transmissionMap.channel),thicknessMapUv:h0&&P(j.thicknessMap.channel),alphaMapUv:L0&&P(j.alphaMap.channel),vertexTangents:!!J0.attributes.tangent&&(a||fF),vertexColors:j.vertexColors,vertexAlphas:j.vertexColors===!0&&!!J0.attributes.color&&J0.attributes.color.itemSize===4,pointsUvs:X0.isPoints===!0&&!!J0.attributes.uv&&(v0||L0),fog:!!K0,useFog:j.fog===!0,fogExp2:!!K0&&K0.isFogExp2,flatShading:j.flatShading===!0&&j.wireframe===!1,sizeAttenuation:j.sizeAttenuation===!0,logarithmicDepthBuffer:N,reversedDepthBuffer:e0,skinning:X0.isSkinnedMesh===!0,morphTargets:J0.morphAttributes.position!==void 0,morphNormals:J0.morphAttributes.normal!==void 0,morphColors:J0.morphAttributes.color!==void 0,morphTargetsCount:T0,morphTextureStride:g0,numDirLights:V.directional.length,numPointLights:V.point.length,numSpotLights:V.spot.length,numSpotLightMaps:V.spotLightMap.length,numRectAreaLights:V.rectArea.length,numHemiLights:V.hemi.length,numDirLightShadows:V.directionalShadowMap.length,numPointLightShadows:V.pointShadowMap.length,numSpotLightShadows:V.spotShadowMap.length,numSpotLightShadowsWithMaps:V.numSpotLightShadowsWithMaps,numLightProbes:V.numLightProbes,numClippingPlanes:K.numPlanes,numClipIntersection:K.numIntersection,dithering:j.dithering,shadowMapEnabled:F.shadowMap.enabled&&d.length>0,shadowMapType:F.shadowMap.type,toneMapping:$F,decodeVideoTexture:v0&&j.map.isVideoTexture===!0&&aF.getTransfer(j.map.colorSpace)===G1,decodeVideoTextureEmissive:AF&&j.emissiveMap.isVideoTexture===!0&&aF.getTransfer(j.emissiveMap.colorSpace)===G1,premultipliedAlpha:j.premultipliedAlpha,doubleSided:j.side===V7,flipSided:j.side===w8,useDepthPacking:j.depthPacking>=0,depthPacking:j.depthPacking||0,index0AttributeName:j.index0AttributeName,extensionClipCullDistance:m0&&j.extensions.clipCullDistance===!0&&W.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(m0&&j.extensions.multiDraw===!0||UF)&&W.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:W.has("KHR_parallel_shader_compile"),customProgramCacheKey:j.customProgramCacheKey()};return iF.vertexUv1s=z.has(1),iF.vertexUv2s=z.has(2),iF.vertexUv3s=z.has(3),z.clear(),iF}function O(j){let V=[];if(j.shaderID)V.push(j.shaderID);else V.push(j.customVertexShaderID),V.push(j.customFragmentShaderID);if(j.defines!==void 0)for(let d in j.defines)V.push(d),V.push(j.defines[d]);if(j.isRawShaderMaterial===!1)b(V,j),k(V,j),V.push(F.outputColorSpace);return V.push(j.customProgramCacheKey),V.join()}function b(j,V){j.push(V.precision),j.push(V.outputColorSpace),j.push(V.envMapMode),j.push(V.envMapCubeUVHeight),j.push(V.mapUv),j.push(V.alphaMapUv),j.push(V.lightMapUv),j.push(V.aoMapUv),j.push(V.bumpMapUv),j.push(V.normalMapUv),j.push(V.displacementMapUv),j.push(V.emissiveMapUv),j.push(V.metalnessMapUv),j.push(V.roughnessMapUv),j.push(V.anisotropyMapUv),j.push(V.clearcoatMapUv),j.push(V.clearcoatNormalMapUv),j.push(V.clearcoatRoughnessMapUv),j.push(V.iridescenceMapUv),j.push(V.iridescenceThicknessMapUv),j.push(V.sheenColorMapUv),j.push(V.sheenRoughnessMapUv),j.push(V.specularMapUv),j.push(V.specularColorMapUv),j.push(V.specularIntensityMapUv),j.push(V.transmissionMapUv),j.push(V.thicknessMapUv),j.push(V.combine),j.push(V.fogExp2),j.push(V.sizeAttenuation),j.push(V.morphTargetsCount),j.push(V.morphAttributeCount),j.push(V.numDirLights),j.push(V.numPointLights),j.push(V.numSpotLights),j.push(V.numSpotLightMaps),j.push(V.numHemiLights),j.push(V.numRectAreaLights),j.push(V.numDirLightShadows),j.push(V.numPointLightShadows),j.push(V.numSpotLightShadows),j.push(V.numSpotLightShadowsWithMaps),j.push(V.numLightProbes),j.push(V.shadowMapType),j.push(V.toneMapping),j.push(V.numClippingPlanes),j.push(V.numClipIntersection),j.push(V.depthPacking)}function k(j,V){if(G.disableAll(),V.instancing)G.enable(0);if(V.instancingColor)G.enable(1);if(V.instancingMorph)G.enable(2);if(V.matcap)G.enable(3);if(V.envMap)G.enable(4);if(V.normalMapObjectSpace)G.enable(5);if(V.normalMapTangentSpace)G.enable(6);if(V.clearcoat)G.enable(7);if(V.iridescence)G.enable(8);if(V.alphaTest)G.enable(9);if(V.vertexColors)G.enable(10);if(V.vertexAlphas)G.enable(11);if(V.vertexUv1s)G.enable(12);if(V.vertexUv2s)G.enable(13);if(V.vertexUv3s)G.enable(14);if(V.vertexTangents)G.enable(15);if(V.anisotropy)G.enable(16);if(V.alphaHash)G.enable(17);if(V.batching)G.enable(18);if(V.dispersion)G.enable(19);if(V.batchingColor)G.enable(20);if(V.gradientMap)G.enable(21);if(j.push(G.mask),G.disableAll(),V.fog)G.enable(0);if(V.useFog)G.enable(1);if(V.flatShading)G.enable(2);if(V.logarithmicDepthBuffer)G.enable(3);if(V.reversedDepthBuffer)G.enable(4);if(V.skinning)G.enable(5);if(V.morphTargets)G.enable(6);if(V.morphNormals)G.enable(7);if(V.morphColors)G.enable(8);if(V.premultipliedAlpha)G.enable(9);if(V.shadowMapEnabled)G.enable(10);if(V.doubleSided)G.enable(11);if(V.flipSided)G.enable(12);if(V.useDepthPacking)G.enable(13);if(V.dithering)G.enable(14);if(V.transmission)G.enable(15);if(V.sheen)G.enable(16);if(V.opaque)G.enable(17);if(V.pointsUvs)G.enable(18);if(V.decodeVideoTexture)G.enable(19);if(V.decodeVideoTextureEmissive)G.enable(20);if(V.alphaToCoverage)G.enable(21);j.push(G.mask)}function y(j){let V=T[j.type],d;if(V){let $0=y7[V];d=Bf.clone($0.uniforms)}else d=j.uniforms;return d}function m(j,V){let d=A.get(V);if(d!==void 0)++d.usedTimes;else d=new Nk(F,V,j,Y),h.push(d),A.set(V,d);return d}function x(j){if(--j.usedTimes===0){let V=h.indexOf(j);h[V]=h[h.length-1],h.pop(),A.delete(j.cacheKey),j.destroy()}}function o(j){U.remove(j)}function s(){U.dispose()}return{getParameters:D,getProgramCacheKey:O,getUniforms:y,acquireProgram:m,releaseProgram:x,releaseShaderCache:o,programs:h,dispose:s}}function Ok(){let F=new WeakMap;function _(K){return F.has(K)}function $(K){let G=F.get(K);if(G===void 0)G={},F.set(K,G);return G}function W(K){F.delete(K)}function H(K,G,U){F.get(K)[G]=U}function Y(){F=new WeakMap}return{has:_,get:$,remove:W,update:H,dispose:Y}}function fk(F,_){if(F.groupOrder!==_.groupOrder)return F.groupOrder-_.groupOrder;else if(F.renderOrder!==_.renderOrder)return F.renderOrder-_.renderOrder;else if(F.material.id!==_.material.id)return F.material.id-_.material.id;else if(F.z!==_.z)return F.z-_.z;else return F.id-_.id}function xf(F,_){if(F.groupOrder!==_.groupOrder)return F.groupOrder-_.groupOrder;else if(F.renderOrder!==_.renderOrder)return F.renderOrder-_.renderOrder;else if(F.z!==_.z)return _.z-F.z;else return F.id-_.id}function gf(){let F=[],_=0,$=[],W=[],H=[];function Y(){_=0,$.length=0,W.length=0,H.length=0}function K(A,N,M,T,P,D){let O=F[_];if(O===void 0)O={id:A.id,object:A,geometry:N,material:M,groupOrder:T,renderOrder:A.renderOrder,z:P,group:D},F[_]=O;else O.id=A.id,O.object=A,O.geometry=N,O.material=M,O.groupOrder=T,O.renderOrder=A.renderOrder,O.z=P,O.group=D;return _++,O}function G(A,N,M,T,P,D){let O=K(A,N,M,T,P,D);if(M.transmission>0)W.push(O);else if(M.transparent===!0)H.push(O);else $.push(O)}function U(A,N,M,T,P,D){let O=K(A,N,M,T,P,D);if(M.transmission>0)W.unshift(O);else if(M.transparent===!0)H.unshift(O);else $.unshift(O)}function z(A,N){if($.length>1)$.sort(A||fk);if(W.length>1)W.sort(N||xf);if(H.length>1)H.sort(N||xf)}function h(){for(let A=_,N=F.length;A<N;A++){let M=F[A];if(M.id===null)break;M.id=null,M.object=null,M.geometry=null,M.material=null,M.group=null}}return{opaque:$,transmissive:W,transparent:H,init:Y,push:G,unshift:U,finish:h,sort:z}}function Ik(){let F=new WeakMap;function _(W,H){let Y=F.get(W),K;if(Y===void 0)K=new gf,F.set(W,[K]);else if(H>=Y.length)K=new gf,Y.push(K);else K=Y[H];return K}function $(){F=new WeakMap}return{get:_,dispose:$}}function Tk(){let F={};return{get:function(_){if(F[_.id]!==void 0)return F[_.id];let $;switch(_.type){case"DirectionalLight":$={direction:new w0,color:new lF};break;case"SpotLight":$={position:new w0,direction:new w0,color:new lF,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":$={position:new w0,color:new lF,distance:0,decay:0};break;case"HemisphereLight":$={direction:new w0,skyColor:new lF,groundColor:new lF};break;case"RectAreaLight":$={color:new lF,position:new w0,halfWidth:new w0,halfHeight:new w0};break}return F[_.id]=$,$}}}function Lk(){let F={};return{get:function(_){if(F[_.id]!==void 0)return F[_.id];let $;switch(_.type){case"DirectionalLight":$={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new DF};break;case"SpotLight":$={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new DF};break;case"PointLight":$={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new DF,shadowCameraNear:1,shadowCameraFar:1000};break}return F[_.id]=$,$}}}var Ek=0;function Ck(F,_){return(_.castShadow?2:0)-(F.castShadow?2:0)+(_.map?1:0)-(F.map?1:0)}function Pk(F){let _=new Tk,$=Lk(),W={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let z=0;z<9;z++)W.probe.push(new w0);let H=new w0,Y=new N1,K=new N1;function G(z){let h=0,A=0,N=0;for(let j=0;j<9;j++)W.probe[j].set(0,0,0);let M=0,T=0,P=0,D=0,O=0,b=0,k=0,y=0,m=0,x=0,o=0;z.sort(Ck);for(let j=0,V=z.length;j<V;j++){let d=z[j],$0=d.color,X0=d.intensity,K0=d.distance,J0=null;if(d.shadow&&d.shadow.map)if(d.shadow.map.texture.format===zZ)J0=d.shadow.map.texture;else J0=d.shadow.map.depthTexture||d.shadow.map.texture;if(d.isAmbientLight)h+=$0.r*X0,A+=$0.g*X0,N+=$0.b*X0;else if(d.isLightProbe){for(let u=0;u<9;u++)W.probe[u].addScaledVector(d.sh.coefficients[u],X0);o++}else if(d.isDirectionalLight){let u=_.get(d);if(u.color.copy(d.color).multiplyScalar(d.intensity),d.castShadow){let n=d.shadow,Q0=$.get(d);Q0.shadowIntensity=n.intensity,Q0.shadowBias=n.bias,Q0.shadowNormalBias=n.normalBias,Q0.shadowRadius=n.radius,Q0.shadowMapSize=n.mapSize,W.directionalShadow[M]=Q0,W.directionalShadowMap[M]=J0,W.directionalShadowMatrix[M]=d.shadow.matrix,b++}W.directional[M]=u,M++}else if(d.isSpotLight){let u=_.get(d);u.position.setFromMatrixPosition(d.matrixWorld),u.color.copy($0).multiplyScalar(X0),u.distance=K0,u.coneCos=Math.cos(d.angle),u.penumbraCos=Math.cos(d.angle*(1-d.penumbra)),u.decay=d.decay,W.spot[P]=u;let n=d.shadow;if(d.map){if(W.spotLightMap[m]=d.map,m++,n.updateMatrices(d),d.castShadow)x++}if(W.spotLightMatrix[P]=n.matrix,d.castShadow){let Q0=$.get(d);Q0.shadowIntensity=n.intensity,Q0.shadowBias=n.bias,Q0.shadowNormalBias=n.normalBias,Q0.shadowRadius=n.radius,Q0.shadowMapSize=n.mapSize,W.spotShadow[P]=Q0,W.spotShadowMap[P]=J0,y++}P++}else if(d.isRectAreaLight){let u=_.get(d);u.color.copy($0).multiplyScalar(X0),u.halfWidth.set(d.width*0.5,0,0),u.halfHeight.set(0,d.height*0.5,0),W.rectArea[D]=u,D++}else if(d.isPointLight){let u=_.get(d);if(u.color.copy(d.color).multiplyScalar(d.intensity),u.distance=d.distance,u.decay=d.decay,d.castShadow){let n=d.shadow,Q0=$.get(d);Q0.shadowIntensity=n.intensity,Q0.shadowBias=n.bias,Q0.shadowNormalBias=n.normalBias,Q0.shadowRadius=n.radius,Q0.shadowMapSize=n.mapSize,Q0.shadowCameraNear=n.camera.near,Q0.shadowCameraFar=n.camera.far,W.pointShadow[T]=Q0,W.pointShadowMap[T]=J0,W.pointShadowMatrix[T]=d.shadow.matrix,k++}W.point[T]=u,T++}else if(d.isHemisphereLight){let u=_.get(d);u.skyColor.copy(d.color).multiplyScalar(X0),u.groundColor.copy(d.groundColor).multiplyScalar(X0),W.hemi[O]=u,O++}}if(D>0)if(F.has("OES_texture_float_linear")===!0)W.rectAreaLTC1=d0.LTC_FLOAT_1,W.rectAreaLTC2=d0.LTC_FLOAT_2;else W.rectAreaLTC1=d0.LTC_HALF_1,W.rectAreaLTC2=d0.LTC_HALF_2;W.ambient[0]=h,W.ambient[1]=A,W.ambient[2]=N;let s=W.hash;if(s.directionalLength!==M||s.pointLength!==T||s.spotLength!==P||s.rectAreaLength!==D||s.hemiLength!==O||s.numDirectionalShadows!==b||s.numPointShadows!==k||s.numSpotShadows!==y||s.numSpotMaps!==m||s.numLightProbes!==o)W.directional.length=M,W.spot.length=P,W.rectArea.length=D,W.point.length=T,W.hemi.length=O,W.directionalShadow.length=b,W.directionalShadowMap.length=b,W.pointShadow.length=k,W.pointShadowMap.length=k,W.spotShadow.length=y,W.spotShadowMap.length=y,W.directionalShadowMatrix.length=b,W.pointShadowMatrix.length=k,W.spotLightMatrix.length=y+m-x,W.spotLightMap.length=m,W.numSpotLightShadowsWithMaps=x,W.numLightProbes=o,s.directionalLength=M,s.pointLength=T,s.spotLength=P,s.rectAreaLength=D,s.hemiLength=O,s.numDirectionalShadows=b,s.numPointShadows=k,s.numSpotShadows=y,s.numSpotMaps=m,s.numLightProbes=o,W.version=Ek++}function U(z,h){let A=0,N=0,M=0,T=0,P=0,D=h.matrixWorldInverse;for(let O=0,b=z.length;O<b;O++){let k=z[O];if(k.isDirectionalLight){let y=W.directional[A];y.direction.setFromMatrixPosition(k.matrixWorld),H.setFromMatrixPosition(k.target.matrixWorld),y.direction.sub(H),y.direction.transformDirection(D),A++}else if(k.isSpotLight){let y=W.spot[M];y.position.setFromMatrixPosition(k.matrixWorld),y.position.applyMatrix4(D),y.direction.setFromMatrixPosition(k.matrixWorld),H.setFromMatrixPosition(k.target.matrixWorld),y.direction.sub(H),y.direction.transformDirection(D),M++}else if(k.isRectAreaLight){let y=W.rectArea[T];y.position.setFromMatrixPosition(k.matrixWorld),y.position.applyMatrix4(D),K.identity(),Y.copy(k.matrixWorld),Y.premultiply(D),K.extractRotation(Y),y.halfWidth.set(k.width*0.5,0,0),y.halfHeight.set(0,k.height*0.5,0),y.halfWidth.applyMatrix4(K),y.halfHeight.applyMatrix4(K),T++}else if(k.isPointLight){let y=W.point[N];y.position.setFromMatrixPosition(k.matrixWorld),y.position.applyMatrix4(D),N++}else if(k.isHemisphereLight){let y=W.hemi[P];y.direction.setFromMatrixPosition(k.matrixWorld),y.direction.transformDirection(D),P++}}}return{setup:G,setupView:U,state:W}}function uf(F){let _=new Pk(F),$=[],W=[];function H(h){z.camera=h,$.length=0,W.length=0}function Y(h){$.push(h)}function K(h){W.push(h)}function G(){_.setup($)}function U(h){_.setupView($,h)}let z={lightsArray:$,shadowsArray:W,camera:null,lights:_,transmissionRenderTarget:{}};return{init:H,state:z,setupLights:G,setupLightsView:U,pushLight:Y,pushShadow:K}}function Vk(F){let _=new WeakMap;function $(H,Y=0){let K=_.get(H),G;if(K===void 0)G=new uf(F),_.set(H,[G]);else if(Y>=K.length)G=new uf(F),K.push(G);else G=K[Y];return G}function W(){_=new WeakMap}return{get:$,dispose:W}}var kk=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Sk=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );
	gl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );
}`,yk=[new w0(1,0,0),new w0(-1,0,0),new w0(0,1,0),new w0(0,-1,0),new w0(0,0,1),new w0(0,0,-1)],vk=[new w0(0,-1,0),new w0(0,-1,0),new w0(0,0,1),new w0(0,0,-1),new w0(0,-1,0),new w0(0,-1,0)],pf=new N1,kQ=new w0,wB=new w0;function bk(F,_,$){let W=new IQ,H=new DF,Y=new DF,K=new T1,G=new lU,U=new dU,z={},h=$.maxTextureSize,A={[XZ]:w8,[w8]:XZ,[V7]:V7},N=new V8({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new DF},radius:{value:4}},vertexShader:kk,fragmentShader:Sk}),M=N.clone();M.defines.HORIZONTAL_PASS=1;let T=new l6;T.setAttribute("position",new C8(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));let P=new X8(T,N),D=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=BQ;let O=this.type;this.render=function(x,o,s){if(D.enabled===!1)return;if(D.autoUpdate===!1&&D.needsUpdate===!1)return;if(x.length===0)return;if(x.type===OO)zF("WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead."),x.type=BQ;let j=F.getRenderTarget(),V=F.getActiveCubeFace(),d=F.getActiveMipmapLevel(),$0=F.state;if($0.setBlending(A9),$0.buffers.depth.getReversed()===!0)$0.buffers.color.setClear(0,0,0,0);else $0.buffers.color.setClear(1,1,1,1);$0.buffers.depth.setTest(!0),$0.setScissorTest(!1);let X0=O!==this.type;if(X0)o.traverse(function(K0){if(K0.material)if(Array.isArray(K0.material))K0.material.forEach((J0)=>J0.needsUpdate=!0);else K0.material.needsUpdate=!0});for(let K0=0,J0=x.length;K0<J0;K0++){let u=x[K0],n=u.shadow;if(n===void 0){zF("WebGLShadowMap:",u,"has no shadow.");continue}if(n.autoUpdate===!1&&n.needsUpdate===!1)continue;H.copy(n.mapSize);let Q0=n.getFrameExtents();if(H.multiply(Q0),Y.copy(n.mapSize),H.x>h||H.y>h){if(H.x>h)Y.x=Math.floor(h/Q0.x),H.x=Y.x*Q0.x,n.mapSize.x=Y.x;if(H.y>h)Y.y=Math.floor(h/Q0.y),H.y=Y.y*Q0.y,n.mapSize.y=Y.y}if(n.map===null||X0===!0){if(n.map!==null){if(n.map.depthTexture!==null)n.map.depthTexture.dispose(),n.map.depthTexture=null;n.map.dispose()}if(this.type===YZ){if(u.isPointLight){zF("WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.");continue}n.map=new P8(H.x,H.y,{format:zZ,type:R9,minFilter:Y8,magFilter:Y8,generateMipmaps:!1}),n.map.texture.name=u.name+".shadowMap",n.map.depthTexture=new EJ(H.x,H.y,h9),n.map.depthTexture.name=u.name+".shadowMapDepth",n.map.depthTexture.format=MJ,n.map.depthTexture.compareFunction=null,n.map.depthTexture.minFilter=Dq,n.map.depthTexture.magFilter=Dq}else{if(u.isPointLight)n.map=new ew(H.x),n.map.depthTexture=new pU(H.x,Mq);else n.map=new P8(H.x,H.y),n.map.depthTexture=new EJ(H.x,H.y,Mq);n.map.depthTexture.name=u.name+".shadowMap",n.map.depthTexture.format=MJ;let t=F.state.buffers.depth.getReversed();if(this.type===BQ)n.map.depthTexture.compareFunction=t?nw:iw,n.map.depthTexture.minFilter=Y8,n.map.depthTexture.magFilter=Y8;else n.map.depthTexture.compareFunction=null,n.map.depthTexture.minFilter=Dq,n.map.depthTexture.magFilter=Dq}n.camera.updateProjectionMatrix()}let O0=n.map.isWebGLCubeRenderTarget?6:1;for(let t=0;t<O0;t++){if(n.map.isWebGLCubeRenderTarget)F.setRenderTarget(n.map,t),F.clear();else{if(t===0)F.setRenderTarget(n.map),F.clear();let T0=n.getViewport(t);K.set(Y.x*T0.x,Y.y*T0.y,Y.x*T0.z,Y.y*T0.w),$0.viewport(K)}if(u.isPointLight){let{camera:T0,matrix:g0}=n,_F=u.distance||T0.far;if(_F!==T0.far)T0.far=_F,T0.updateProjectionMatrix();kQ.setFromMatrixPosition(u.matrixWorld),T0.position.copy(kQ),wB.copy(T0.position),wB.add(yk[t]),T0.up.copy(vk[t]),T0.lookAt(wB),T0.updateMatrixWorld(),g0.makeTranslation(-kQ.x,-kQ.y,-kQ.z),pf.multiplyMatrices(T0.projectionMatrix,T0.matrixWorldInverse),n._frustum.setFromProjectionMatrix(pf,T0.coordinateSystem,T0.reversedDepth)}else n.updateMatrices(u);W=n.getFrustum(),y(o,s,n.camera,u,this.type)}if(n.isPointLightShadow!==!0&&this.type===YZ)b(n,s);n.needsUpdate=!1}O=this.type,D.needsUpdate=!1,F.setRenderTarget(j,V,d)};function b(x,o){let s=_.update(P);if(N.defines.VSM_SAMPLES!==x.blurSamples)N.defines.VSM_SAMPLES=x.blurSamples,M.defines.VSM_SAMPLES=x.blurSamples,N.needsUpdate=!0,M.needsUpdate=!0;if(x.mapPass===null)x.mapPass=new P8(H.x,H.y,{format:zZ,type:R9});N.uniforms.shadow_pass.value=x.map.depthTexture,N.uniforms.resolution.value=x.mapSize,N.uniforms.radius.value=x.radius,F.setRenderTarget(x.mapPass),F.clear(),F.renderBufferDirect(o,null,s,N,P,null),M.uniforms.shadow_pass.value=x.mapPass.texture,M.uniforms.resolution.value=x.mapSize,M.uniforms.radius.value=x.radius,F.setRenderTarget(x.map),F.clear(),F.renderBufferDirect(o,null,s,M,P,null)}function k(x,o,s,j){let V=null,d=s.isPointLight===!0?x.customDistanceMaterial:x.customDepthMaterial;if(d!==void 0)V=d;else if(V=s.isPointLight===!0?U:G,F.localClippingEnabled&&o.clipShadows===!0&&Array.isArray(o.clippingPlanes)&&o.clippingPlanes.length!==0||o.displacementMap&&o.displacementScale!==0||o.alphaMap&&o.alphaTest>0||o.map&&o.alphaTest>0||o.alphaToCoverage===!0){let $0=V.uuid,X0=o.uuid,K0=z[$0];if(K0===void 0)K0={},z[$0]=K0;let J0=K0[X0];if(J0===void 0)J0=V.clone(),K0[X0]=J0,o.addEventListener("dispose",m);V=J0}if(V.visible=o.visible,V.wireframe=o.wireframe,j===YZ)V.side=o.shadowSide!==null?o.shadowSide:o.side;else V.side=o.shadowSide!==null?o.shadowSide:A[o.side];if(V.alphaMap=o.alphaMap,V.alphaTest=o.alphaToCoverage===!0?0.5:o.alphaTest,V.map=o.map,V.clipShadows=o.clipShadows,V.clippingPlanes=o.clippingPlanes,V.clipIntersection=o.clipIntersection,V.displacementMap=o.displacementMap,V.displacementScale=o.displacementScale,V.displacementBias=o.displacementBias,V.wireframeLinewidth=o.wireframeLinewidth,V.linewidth=o.linewidth,s.isPointLight===!0&&V.isMeshDistanceMaterial===!0){let $0=F.properties.get(V);$0.light=s}return V}function y(x,o,s,j,V){if(x.visible===!1)return;if(x.layers.test(o.layers)&&(x.isMesh||x.isLine||x.isPoints)){if((x.castShadow||x.receiveShadow&&V===YZ)&&(!x.frustumCulled||W.intersectsObject(x))){x.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,x.matrixWorld);let X0=_.update(x),K0=x.material;if(Array.isArray(K0)){let J0=X0.groups;for(let u=0,n=J0.length;u<n;u++){let Q0=J0[u],O0=K0[Q0.materialIndex];if(O0&&O0.visible){let t=k(x,O0,j,V);x.onBeforeShadow(F,x,o,s,X0,t,Q0),F.renderBufferDirect(s,null,X0,t,x,Q0),x.onAfterShadow(F,x,o,s,X0,t,Q0)}}}else if(K0.visible){let J0=k(x,K0,j,V);x.onBeforeShadow(F,x,o,s,X0,J0,null),F.renderBufferDirect(s,null,X0,J0,x,null),x.onAfterShadow(F,x,o,s,X0,J0,null)}}}let $0=x.children;for(let X0=0,K0=$0.length;X0<K0;X0++)y($0[X0],o,s,j,V)}function m(x){x.target.removeEventListener("dispose",m);for(let s in z){let j=z[s],V=x.target.uuid;if(V in j)j[V].dispose(),delete j[V]}}}var jk={[Pw]:Vw,[kw]:vw,[Sw]:bw,[AQ]:yw,[Vw]:Pw,[vw]:kw,[bw]:Sw,[yw]:AQ};function xk(F,_){function $(){let g=!1,h0=new T1,M0=null,L0=new T1(0,0,0,0);return{setMask:function(I0){if(M0!==I0&&!g)F.colorMask(I0,I0,I0,I0),M0=I0},setLocked:function(I0){g=I0},setClear:function(I0,Z0,m0,$F,iF){if(iF===!0)I0*=$F,Z0*=$F,m0*=$F;if(h0.set(I0,Z0,m0,$F),L0.equals(h0)===!1)F.clearColor(I0,Z0,m0,$F),L0.copy(h0)},reset:function(){g=!1,M0=null,L0.set(-1,0,0,0)}}}function W(){let g=!1,h0=!1,M0=null,L0=null,I0=null;return{setReversed:function(Z0){if(h0!==Z0){let m0=_.get("EXT_clip_control");if(Z0)m0.clipControlEXT(m0.LOWER_LEFT_EXT,m0.ZERO_TO_ONE_EXT);else m0.clipControlEXT(m0.LOWER_LEFT_EXT,m0.NEGATIVE_ONE_TO_ONE_EXT);h0=Z0;let $F=I0;I0=null,this.setClear($F)}},getReversed:function(){return h0},setTest:function(Z0){if(Z0)S0(F.DEPTH_TEST);else e0(F.DEPTH_TEST)},setMask:function(Z0){if(M0!==Z0&&!g)F.depthMask(Z0),M0=Z0},setFunc:function(Z0){if(h0)Z0=jk[Z0];if(L0!==Z0){switch(Z0){case Pw:F.depthFunc(F.NEVER);break;case Vw:F.depthFunc(F.ALWAYS);break;case kw:F.depthFunc(F.LESS);break;case AQ:F.depthFunc(F.LEQUAL);break;case Sw:F.depthFunc(F.EQUAL);break;case yw:F.depthFunc(F.GEQUAL);break;case vw:F.depthFunc(F.GREATER);break;case bw:F.depthFunc(F.NOTEQUAL);break;default:F.depthFunc(F.LEQUAL)}L0=Z0}},setLocked:function(Z0){g=Z0},setClear:function(Z0){if(I0!==Z0){if(h0)Z0=1-Z0;F.clearDepth(Z0),I0=Z0}},reset:function(){g=!1,M0=null,L0=null,I0=null,h0=!1}}}function H(){let g=!1,h0=null,M0=null,L0=null,I0=null,Z0=null,m0=null,$F=null,iF=null;return{setTest:function(nF){if(!g)if(nF)S0(F.STENCIL_TEST);else e0(F.STENCIL_TEST)},setMask:function(nF){if(h0!==nF&&!g)F.stencilMask(nF),h0=nF},setFunc:function(nF,K8,y6){if(M0!==nF||L0!==K8||I0!==y6)F.stencilFunc(nF,K8,y6),M0=nF,L0=K8,I0=y6},setOp:function(nF,K8,y6){if(Z0!==nF||m0!==K8||$F!==y6)F.stencilOp(nF,K8,y6),Z0=nF,m0=K8,$F=y6},setLocked:function(nF){g=nF},setClear:function(nF){if(iF!==nF)F.clearStencil(nF),iF=nF},reset:function(){g=!1,h0=null,M0=null,L0=null,I0=null,Z0=null,m0=null,$F=null,iF=null}}}let Y=new $,K=new W,G=new H,U=new WeakMap,z=new WeakMap,h={},A={},N=new WeakMap,M=[],T=null,P=!1,D=null,O=null,b=null,k=null,y=null,m=null,x=null,o=new lF(0,0,0),s=0,j=!1,V=null,d=null,$0=null,X0=null,K0=null,J0=F.getParameter(F.MAX_COMBINED_TEXTURE_IMAGE_UNITS),u=!1,n=0,Q0=F.getParameter(F.VERSION);if(Q0.indexOf("WebGL")!==-1)n=parseFloat(/^WebGL (\d)/.exec(Q0)[1]),u=n>=1;else if(Q0.indexOf("OpenGL ES")!==-1)n=parseFloat(/^OpenGL ES (\d)/.exec(Q0)[1]),u=n>=2;let O0=null,t={},T0=F.getParameter(F.SCISSOR_BOX),g0=F.getParameter(F.VIEWPORT),_F=new T1().fromArray(T0),c0=new T1().fromArray(g0);function D0(g,h0,M0,L0){let I0=new Uint8Array(4),Z0=F.createTexture();F.bindTexture(g,Z0),F.texParameteri(g,F.TEXTURE_MIN_FILTER,F.NEAREST),F.texParameteri(g,F.TEXTURE_MAG_FILTER,F.NEAREST);for(let m0=0;m0<M0;m0++)if(g===F.TEXTURE_3D||g===F.TEXTURE_2D_ARRAY)F.texImage3D(h0,0,F.RGBA,1,1,L0,0,F.RGBA,F.UNSIGNED_BYTE,I0);else F.texImage2D(h0+m0,0,F.RGBA,1,1,0,F.RGBA,F.UNSIGNED_BYTE,I0);return Z0}let P0={};P0[F.TEXTURE_2D]=D0(F.TEXTURE_2D,F.TEXTURE_2D,1),P0[F.TEXTURE_CUBE_MAP]=D0(F.TEXTURE_CUBE_MAP,F.TEXTURE_CUBE_MAP_POSITIVE_X,6),P0[F.TEXTURE_2D_ARRAY]=D0(F.TEXTURE_2D_ARRAY,F.TEXTURE_2D_ARRAY,1,1),P0[F.TEXTURE_3D]=D0(F.TEXTURE_3D,F.TEXTURE_3D,1,1),Y.setClear(0,0,0,1),K.setClear(1),G.setClear(0),S0(F.DEPTH_TEST),K.setFunc(AQ),XF(!1),a(S5),S0(F.CULL_FACE),jF(A9);function S0(g){if(h[g]!==!0)F.enable(g),h[g]=!0}function e0(g){if(h[g]!==!1)F.disable(g),h[g]=!1}function JF(g,h0){if(A[g]!==h0){if(F.bindFramebuffer(g,h0),A[g]=h0,g===F.DRAW_FRAMEBUFFER)A[F.FRAMEBUFFER]=h0;if(g===F.FRAMEBUFFER)A[F.DRAW_FRAMEBUFFER]=h0;return!0}return!1}function UF(g,h0){let M0=M,L0=!1;if(g){if(M0=N.get(h0),M0===void 0)M0=[],N.set(h0,M0);let I0=g.textures;if(M0.length!==I0.length||M0[0]!==F.COLOR_ATTACHMENT0){for(let Z0=0,m0=I0.length;Z0<m0;Z0++)M0[Z0]=F.COLOR_ATTACHMENT0+Z0;M0.length=I0.length,L0=!0}}else if(M0[0]!==F.BACK)M0[0]=F.BACK,L0=!0;if(L0)F.drawBuffers(M0)}function v0(g){if(T!==g)return F.useProgram(g),T=g,!0;return!1}let PF={[GZ]:F.FUNC_ADD,[IO]:F.FUNC_SUBTRACT,[TO]:F.FUNC_REVERSE_SUBTRACT};PF[LO]=F.MIN,PF[EO]=F.MAX;let OF={[CO]:F.ZERO,[PO]:F.ONE,[VO]:F.SRC_COLOR,[SO]:F.SRC_ALPHA,[gO]:F.SRC_ALPHA_SATURATE,[jO]:F.DST_COLOR,[vO]:F.DST_ALPHA,[kO]:F.ONE_MINUS_SRC_COLOR,[yO]:F.ONE_MINUS_SRC_ALPHA,[xO]:F.ONE_MINUS_DST_COLOR,[bO]:F.ONE_MINUS_DST_ALPHA,[uO]:F.CONSTANT_COLOR,[pO]:F.ONE_MINUS_CONSTANT_COLOR,[mO]:F.CONSTANT_ALPHA,[lO]:F.ONE_MINUS_CONSTANT_ALPHA};function jF(g,h0,M0,L0,I0,Z0,m0,$F,iF,nF){if(g===A9){if(P===!0)e0(F.BLEND),P=!1;return}if(P===!1)S0(F.BLEND),P=!0;if(g!==fO){if(g!==D||nF!==j){if(O!==GZ||y!==GZ)F.blendEquation(F.FUNC_ADD),O=GZ,y=GZ;if(nF)switch(g){case zQ:F.blendFuncSeparate(F.ONE,F.ONE_MINUS_SRC_ALPHA,F.ONE,F.ONE_MINUS_SRC_ALPHA);break;case y5:F.blendFunc(F.ONE,F.ONE);break;case v5:F.blendFuncSeparate(F.ZERO,F.ONE_MINUS_SRC_COLOR,F.ZERO,F.ONE);break;case b5:F.blendFuncSeparate(F.DST_COLOR,F.ONE_MINUS_SRC_ALPHA,F.ZERO,F.ONE);break;default:hF("WebGLState: Invalid blending: ",g);break}else switch(g){case zQ:F.blendFuncSeparate(F.SRC_ALPHA,F.ONE_MINUS_SRC_ALPHA,F.ONE,F.ONE_MINUS_SRC_ALPHA);break;case y5:F.blendFuncSeparate(F.SRC_ALPHA,F.ONE,F.ONE,F.ONE);break;case v5:hF("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case b5:hF("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:hF("WebGLState: Invalid blending: ",g);break}b=null,k=null,m=null,x=null,o.set(0,0,0),s=0,D=g,j=nF}return}if(I0=I0||h0,Z0=Z0||M0,m0=m0||L0,h0!==O||I0!==y)F.blendEquationSeparate(PF[h0],PF[I0]),O=h0,y=I0;if(M0!==b||L0!==k||Z0!==m||m0!==x)F.blendFuncSeparate(OF[M0],OF[L0],OF[Z0],OF[m0]),b=M0,k=L0,m=Z0,x=m0;if($F.equals(o)===!1||iF!==s)F.blendColor($F.r,$F.g,$F.b,iF),o.copy($F),s=iF;D=g,j=!1}function t0(g,h0){g.side===V7?e0(F.CULL_FACE):S0(F.CULL_FACE);let M0=g.side===w8;if(h0)M0=!M0;XF(M0),g.blending===zQ&&g.transparent===!1?jF(A9):jF(g.blending,g.blendEquation,g.blendSrc,g.blendDst,g.blendEquationAlpha,g.blendSrcAlpha,g.blendDstAlpha,g.blendColor,g.blendAlpha,g.premultipliedAlpha),K.setFunc(g.depthFunc),K.setTest(g.depthTest),K.setMask(g.depthWrite),Y.setMask(g.colorWrite);let L0=g.stencilWrite;if(G.setTest(L0),L0)G.setMask(g.stencilWriteMask),G.setFunc(g.stencilFunc,g.stencilRef,g.stencilFuncMask),G.setOp(g.stencilFail,g.stencilZFail,g.stencilZPass);AF(g.polygonOffset,g.polygonOffsetFactor,g.polygonOffsetUnits),g.alphaToCoverage===!0?S0(F.SAMPLE_ALPHA_TO_COVERAGE):e0(F.SAMPLE_ALPHA_TO_COVERAGE)}function XF(g){if(V!==g){if(g)F.frontFace(F.CW);else F.frontFace(F.CCW);V=g}}function a(g){if(g!==DO){if(S0(F.CULL_FACE),g!==d)if(g===S5)F.cullFace(F.BACK);else if(g===MO)F.cullFace(F.FRONT);else F.cullFace(F.FRONT_AND_BACK)}else e0(F.CULL_FACE);d=g}function C0(g){if(g!==$0){if(u)F.lineWidth(g);$0=g}}function AF(g,h0,M0){if(g){if(S0(F.POLYGON_OFFSET_FILL),X0!==h0||K0!==M0)F.polygonOffset(h0,M0),X0=h0,K0=M0}else e0(F.POLYGON_OFFSET_FILL)}function s0(g){if(g)S0(F.SCISSOR_TEST);else e0(F.SCISSOR_TEST)}function j0(g){if(g===void 0)g=F.TEXTURE0+J0-1;if(O0!==g)F.activeTexture(g),O0=g}function fF(g,h0,M0){if(M0===void 0)if(O0===null)M0=F.TEXTURE0+J0-1;else M0=O0;let L0=t[M0];if(L0===void 0)L0={type:void 0,texture:void 0},t[M0]=L0;if(L0.type!==g||L0.texture!==h0){if(O0!==M0)F.activeTexture(M0),O0=M0;F.bindTexture(g,h0||P0[g]),L0.type=g,L0.texture=h0}}function v(){let g=t[O0];if(g!==void 0&&g.type!==void 0)F.bindTexture(g.type,null),g.type=void 0,g.texture=void 0}function E(){try{F.compressedTexImage2D(...arguments)}catch(g){hF("WebGLState:",g)}}function Y0(){try{F.compressedTexImage3D(...arguments)}catch(g){hF("WebGLState:",g)}}function q0(){try{F.texSubImage2D(...arguments)}catch(g){hF("WebGLState:",g)}}function H0(){try{F.texSubImage3D(...arguments)}catch(g){hF("WebGLState:",g)}}function W0(){try{F.compressedTexSubImage2D(...arguments)}catch(g){hF("WebGLState:",g)}}function y0(){try{F.compressedTexSubImage3D(...arguments)}catch(g){hF("WebGLState:",g)}}function E0(){try{F.texStorage2D(...arguments)}catch(g){hF("WebGLState:",g)}}function n0(){try{F.texStorage3D(...arguments)}catch(g){hF("WebGLState:",g)}}function ZF(){try{F.texImage2D(...arguments)}catch(g){hF("WebGLState:",g)}}function V0(){try{F.texImage3D(...arguments)}catch(g){hF("WebGLState:",g)}}function b0(g){if(_F.equals(g)===!1)F.scissor(g.x,g.y,g.z,g.w),_F.copy(g)}function a0(g){if(c0.equals(g)===!1)F.viewport(g.x,g.y,g.z,g.w),c0.copy(g)}function L(g,h0){let M0=z.get(h0);if(M0===void 0)M0=new WeakMap,z.set(h0,M0);let L0=M0.get(g);if(L0===void 0)L0=F.getUniformBlockIndex(h0,g.name),M0.set(g,L0)}function p(g,h0){let L0=z.get(h0).get(g);if(U.get(h0)!==L0)F.uniformBlockBinding(h0,L0,g.__bindingPointIndex),U.set(h0,L0)}function N0(){F.disable(F.BLEND),F.disable(F.CULL_FACE),F.disable(F.DEPTH_TEST),F.disable(F.POLYGON_OFFSET_FILL),F.disable(F.SCISSOR_TEST),F.disable(F.STENCIL_TEST),F.disable(F.SAMPLE_ALPHA_TO_COVERAGE),F.blendEquation(F.FUNC_ADD),F.blendFunc(F.ONE,F.ZERO),F.blendFuncSeparate(F.ONE,F.ZERO,F.ONE,F.ZERO),F.blendColor(0,0,0,0),F.colorMask(!0,!0,!0,!0),F.clearColor(0,0,0,0),F.depthMask(!0),F.depthFunc(F.LESS),K.setReversed(!1),F.clearDepth(1),F.stencilMask(4294967295),F.stencilFunc(F.ALWAYS,0,4294967295),F.stencilOp(F.KEEP,F.KEEP,F.KEEP),F.clearStencil(0),F.cullFace(F.BACK),F.frontFace(F.CCW),F.polygonOffset(0,0),F.activeTexture(F.TEXTURE0),F.bindFramebuffer(F.FRAMEBUFFER,null),F.bindFramebuffer(F.DRAW_FRAMEBUFFER,null),F.bindFramebuffer(F.READ_FRAMEBUFFER,null),F.useProgram(null),F.lineWidth(1),F.scissor(0,0,F.canvas.width,F.canvas.height),F.viewport(0,0,F.canvas.width,F.canvas.height),h={},O0=null,t={},A={},N=new WeakMap,M=[],T=null,P=!1,D=null,O=null,b=null,k=null,y=null,m=null,x=null,o=new lF(0,0,0),s=0,j=!1,V=null,d=null,$0=null,X0=null,K0=null,_F.set(0,0,F.canvas.width,F.canvas.height),c0.set(0,0,F.canvas.width,F.canvas.height),Y.reset(),K.reset(),G.reset()}return{buffers:{color:Y,depth:K,stencil:G},enable:S0,disable:e0,bindFramebuffer:JF,drawBuffers:UF,useProgram:v0,setBlending:jF,setMaterial:t0,setFlipSided:XF,setCullFace:a,setLineWidth:C0,setPolygonOffset:AF,setScissorTest:s0,activeTexture:j0,bindTexture:fF,unbindTexture:v,compressedTexImage2D:E,compressedTexImage3D:Y0,texImage2D:ZF,texImage3D:V0,updateUBOMapping:L,uniformBlockBinding:p,texStorage2D:E0,texStorage3D:n0,texSubImage2D:q0,texSubImage3D:H0,compressedTexSubImage2D:W0,compressedTexSubImage3D:y0,scissor:b0,viewport:a0,reset:N0}}function gk(F,_,$,W,H,Y,K){let G=_.has("WEBGL_multisampled_render_to_texture")?_.get("WEBGL_multisampled_render_to_texture"):null,U=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),z=new DF,h=new WeakMap,A,N=new WeakMap,M=!1;try{M=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch(v){}function T(v,E){return M?new OffscreenCanvas(v,E):UQ("canvas")}function P(v,E,Y0){let q0=1,H0=fF(v);if(H0.width>Y0||H0.height>Y0)q0=Y0/Math.max(H0.width,H0.height);if(q0<1)if(typeof HTMLImageElement<"u"&&v instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&v instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&v instanceof ImageBitmap||typeof VideoFrame<"u"&&v instanceof VideoFrame){let W0=Math.floor(q0*H0.width),y0=Math.floor(q0*H0.height);if(A===void 0)A=T(W0,y0);let E0=E?T(W0,y0):A;return E0.width=W0,E0.height=y0,E0.getContext("2d").drawImage(v,0,0,W0,y0),zF("WebGLRenderer: Texture has been resized from ("+H0.width+"x"+H0.height+") to ("+W0+"x"+y0+")."),E0}else{if("data"in v)zF("WebGLRenderer: Image in DataTexture is too big ("+H0.width+"x"+H0.height+").");return v}return v}function D(v){return v.generateMipmaps}function O(v){F.generateMipmap(v)}function b(v){if(v.isWebGLCubeRenderTarget)return F.TEXTURE_CUBE_MAP;if(v.isWebGL3DRenderTarget)return F.TEXTURE_3D;if(v.isWebGLArrayRenderTarget||v.isCompressedArrayTexture)return F.TEXTURE_2D_ARRAY;return F.TEXTURE_2D}function k(v,E,Y0,q0,H0=!1){if(v!==null){if(F[v]!==void 0)return F[v];zF("WebGLRenderer: Attempt to use non-existing WebGL internal format '"+v+"'")}let W0=E;if(E===F.RED){if(Y0===F.FLOAT)W0=F.R32F;if(Y0===F.HALF_FLOAT)W0=F.R16F;if(Y0===F.UNSIGNED_BYTE)W0=F.R8}if(E===F.RED_INTEGER){if(Y0===F.UNSIGNED_BYTE)W0=F.R8UI;if(Y0===F.UNSIGNED_SHORT)W0=F.R16UI;if(Y0===F.UNSIGNED_INT)W0=F.R32UI;if(Y0===F.BYTE)W0=F.R8I;if(Y0===F.SHORT)W0=F.R16I;if(Y0===F.INT)W0=F.R32I}if(E===F.RG){if(Y0===F.FLOAT)W0=F.RG32F;if(Y0===F.HALF_FLOAT)W0=F.RG16F;if(Y0===F.UNSIGNED_BYTE)W0=F.RG8}if(E===F.RG_INTEGER){if(Y0===F.UNSIGNED_BYTE)W0=F.RG8UI;if(Y0===F.UNSIGNED_SHORT)W0=F.RG16UI;if(Y0===F.UNSIGNED_INT)W0=F.RG32UI;if(Y0===F.BYTE)W0=F.RG8I;if(Y0===F.SHORT)W0=F.RG16I;if(Y0===F.INT)W0=F.RG32I}if(E===F.RGB_INTEGER){if(Y0===F.UNSIGNED_BYTE)W0=F.RGB8UI;if(Y0===F.UNSIGNED_SHORT)W0=F.RGB16UI;if(Y0===F.UNSIGNED_INT)W0=F.RGB32UI;if(Y0===F.BYTE)W0=F.RGB8I;if(Y0===F.SHORT)W0=F.RGB16I;if(Y0===F.INT)W0=F.RGB32I}if(E===F.RGBA_INTEGER){if(Y0===F.UNSIGNED_BYTE)W0=F.RGBA8UI;if(Y0===F.UNSIGNED_SHORT)W0=F.RGBA16UI;if(Y0===F.UNSIGNED_INT)W0=F.RGBA32UI;if(Y0===F.BYTE)W0=F.RGBA8I;if(Y0===F.SHORT)W0=F.RGBA16I;if(Y0===F.INT)W0=F.RGBA32I}if(E===F.RGB){if(Y0===F.UNSIGNED_INT_5_9_9_9_REV)W0=F.RGB9_E5;if(Y0===F.UNSIGNED_INT_10F_11F_11F_REV)W0=F.R11F_G11F_B10F}if(E===F.RGBA){let y0=H0?EU:aF.getTransfer(q0);if(Y0===F.FLOAT)W0=F.RGBA32F;if(Y0===F.HALF_FLOAT)W0=F.RGBA16F;if(Y0===F.UNSIGNED_BYTE)W0=y0===G1?F.SRGB8_ALPHA8:F.RGBA8;if(Y0===F.UNSIGNED_SHORT_4_4_4_4)W0=F.RGBA4;if(Y0===F.UNSIGNED_SHORT_5_5_5_1)W0=F.RGB5_A1}if(W0===F.R16F||W0===F.R32F||W0===F.RG16F||W0===F.RG32F||W0===F.RGBA16F||W0===F.RGBA32F)_.get("EXT_color_buffer_float");return W0}function y(v,E){let Y0;if(v){if(E===null||E===Mq||E===BZ)Y0=F.DEPTH24_STENCIL8;else if(E===h9)Y0=F.DEPTH32F_STENCIL8;else if(E===NQ)Y0=F.DEPTH24_STENCIL8,zF("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")}else if(E===null||E===Mq||E===BZ)Y0=F.DEPTH_COMPONENT24;else if(E===h9)Y0=F.DEPTH_COMPONENT32F;else if(E===NQ)Y0=F.DEPTH_COMPONENT16;return Y0}function m(v,E){if(D(v)===!0||v.isFramebufferTexture&&v.minFilter!==Dq&&v.minFilter!==Y8)return Math.log2(Math.max(E.width,E.height))+1;else if(v.mipmaps!==void 0&&v.mipmaps.length>0)return v.mipmaps.length;else if(v.isCompressedTexture&&Array.isArray(v.image))return E.mipmaps.length;else return 1}function x(v){let E=v.target;if(E.removeEventListener("dispose",x),s(E),E.isVideoTexture)h.delete(E)}function o(v){let E=v.target;E.removeEventListener("dispose",o),V(E)}function s(v){let E=W.get(v);if(E.__webglInit===void 0)return;let Y0=v.source,q0=N.get(Y0);if(q0){let H0=q0[E.__cacheKey];if(H0.usedTimes--,H0.usedTimes===0)j(v);if(Object.keys(q0).length===0)N.delete(Y0)}W.remove(v)}function j(v){let E=W.get(v);F.deleteTexture(E.__webglTexture);let Y0=v.source,q0=N.get(Y0);delete q0[E.__cacheKey],K.memory.textures--}function V(v){let E=W.get(v);if(v.depthTexture)v.depthTexture.dispose(),W.remove(v.depthTexture);if(v.isWebGLCubeRenderTarget)for(let q0=0;q0<6;q0++){if(Array.isArray(E.__webglFramebuffer[q0]))for(let H0=0;H0<E.__webglFramebuffer[q0].length;H0++)F.deleteFramebuffer(E.__webglFramebuffer[q0][H0]);else F.deleteFramebuffer(E.__webglFramebuffer[q0]);if(E.__webglDepthbuffer)F.deleteRenderbuffer(E.__webglDepthbuffer[q0])}else{if(Array.isArray(E.__webglFramebuffer))for(let q0=0;q0<E.__webglFramebuffer.length;q0++)F.deleteFramebuffer(E.__webglFramebuffer[q0]);else F.deleteFramebuffer(E.__webglFramebuffer);if(E.__webglDepthbuffer)F.deleteRenderbuffer(E.__webglDepthbuffer);if(E.__webglMultisampledFramebuffer)F.deleteFramebuffer(E.__webglMultisampledFramebuffer);if(E.__webglColorRenderbuffer){for(let q0=0;q0<E.__webglColorRenderbuffer.length;q0++)if(E.__webglColorRenderbuffer[q0])F.deleteRenderbuffer(E.__webglColorRenderbuffer[q0])}if(E.__webglDepthRenderbuffer)F.deleteRenderbuffer(E.__webglDepthRenderbuffer)}let Y0=v.textures;for(let q0=0,H0=Y0.length;q0<H0;q0++){let W0=W.get(Y0[q0]);if(W0.__webglTexture)F.deleteTexture(W0.__webglTexture),K.memory.textures--;W.remove(Y0[q0])}W.remove(v)}let d=0;function $0(){d=0}function X0(){let v=d;if(v>=H.maxTextures)zF("WebGLTextures: Trying to use "+v+" texture units while this GPU supports only "+H.maxTextures);return d+=1,v}function K0(v){let E=[];return E.push(v.wrapS),E.push(v.wrapT),E.push(v.wrapR||0),E.push(v.magFilter),E.push(v.minFilter),E.push(v.anisotropy),E.push(v.internalFormat),E.push(v.format),E.push(v.type),E.push(v.generateMipmaps),E.push(v.premultiplyAlpha),E.push(v.flipY),E.push(v.unpackAlignment),E.push(v.colorSpace),E.join()}function J0(v,E){let Y0=W.get(v);if(v.isVideoTexture)s0(v);if(v.isRenderTargetTexture===!1&&v.isExternalTexture!==!0&&v.version>0&&Y0.__version!==v.version){let q0=v.image;if(q0===null)zF("WebGLRenderer: Texture marked for update but no image data found.");else if(q0.complete===!1)zF("WebGLRenderer: Texture marked for update but image is incomplete");else{P0(Y0,v,E);return}}else if(v.isExternalTexture)Y0.__webglTexture=v.sourceTexture?v.sourceTexture:null;$.bindTexture(F.TEXTURE_2D,Y0.__webglTexture,F.TEXTURE0+E)}function u(v,E){let Y0=W.get(v);if(v.isRenderTargetTexture===!1&&v.version>0&&Y0.__version!==v.version){P0(Y0,v,E);return}else if(v.isExternalTexture)Y0.__webglTexture=v.sourceTexture?v.sourceTexture:null;$.bindTexture(F.TEXTURE_2D_ARRAY,Y0.__webglTexture,F.TEXTURE0+E)}function n(v,E){let Y0=W.get(v);if(v.isRenderTargetTexture===!1&&v.version>0&&Y0.__version!==v.version){P0(Y0,v,E);return}$.bindTexture(F.TEXTURE_3D,Y0.__webglTexture,F.TEXTURE0+E)}function Q0(v,E){let Y0=W.get(v);if(v.isCubeDepthTexture!==!0&&v.version>0&&Y0.__version!==v.version){S0(Y0,v,E);return}$.bindTexture(F.TEXTURE_CUBE_MAP,Y0.__webglTexture,F.TEXTURE0+E)}let O0={[cO]:F.REPEAT,[gw]:F.CLAMP_TO_EDGE,[sO]:F.MIRRORED_REPEAT},t={[Dq]:F.NEAREST,[oO]:F.NEAREST_MIPMAP_NEAREST,[RQ]:F.NEAREST_MIPMAP_LINEAR,[Y8]:F.LINEAR,[uw]:F.LINEAR_MIPMAP_NEAREST,[UZ]:F.LINEAR_MIPMAP_LINEAR},T0={[Qf]:F.NEVER,[Xf]:F.ALWAYS,[Wf]:F.LESS,[iw]:F.LEQUAL,[Hf]:F.EQUAL,[nw]:F.GEQUAL,[wf]:F.GREATER,[Yf]:F.NOTEQUAL};function g0(v,E){if(E.type===h9&&_.has("OES_texture_float_linear")===!1&&(E.magFilter===Y8||E.magFilter===uw||E.magFilter===RQ||E.magFilter===UZ||E.minFilter===Y8||E.minFilter===uw||E.minFilter===RQ||E.minFilter===UZ))zF("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");if(F.texParameteri(v,F.TEXTURE_WRAP_S,O0[E.wrapS]),F.texParameteri(v,F.TEXTURE_WRAP_T,O0[E.wrapT]),v===F.TEXTURE_3D||v===F.TEXTURE_2D_ARRAY)F.texParameteri(v,F.TEXTURE_WRAP_R,O0[E.wrapR]);if(F.texParameteri(v,F.TEXTURE_MAG_FILTER,t[E.magFilter]),F.texParameteri(v,F.TEXTURE_MIN_FILTER,t[E.minFilter]),E.compareFunction)F.texParameteri(v,F.TEXTURE_COMPARE_MODE,F.COMPARE_REF_TO_TEXTURE),F.texParameteri(v,F.TEXTURE_COMPARE_FUNC,T0[E.compareFunction]);if(_.has("EXT_texture_filter_anisotropic")===!0){if(E.magFilter===Dq)return;if(E.minFilter!==RQ&&E.minFilter!==UZ)return;if(E.type===h9&&_.has("OES_texture_float_linear")===!1)return;if(E.anisotropy>1||W.get(E).__currentAnisotropy){let Y0=_.get("EXT_texture_filter_anisotropic");F.texParameterf(v,Y0.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(E.anisotropy,H.getMaxAnisotropy())),W.get(E).__currentAnisotropy=E.anisotropy}}}function _F(v,E){let Y0=!1;if(v.__webglInit===void 0)v.__webglInit=!0,E.addEventListener("dispose",x);let q0=E.source,H0=N.get(q0);if(H0===void 0)H0={},N.set(q0,H0);let W0=K0(E);if(W0!==v.__cacheKey){if(H0[W0]===void 0)H0[W0]={texture:F.createTexture(),usedTimes:0},K.memory.textures++,Y0=!0;H0[W0].usedTimes++;let y0=H0[v.__cacheKey];if(y0!==void 0){if(H0[v.__cacheKey].usedTimes--,y0.usedTimes===0)j(E)}v.__cacheKey=W0,v.__webglTexture=H0[W0].texture}return Y0}function c0(v,E,Y0){return Math.floor(Math.floor(v/Y0)/E)}function D0(v,E,Y0,q0){let W0=v.updateRanges;if(W0.length===0)$.texSubImage2D(F.TEXTURE_2D,0,0,0,E.width,E.height,Y0,q0,E.data);else{W0.sort((V0,b0)=>V0.start-b0.start);let y0=0;for(let V0=1;V0<W0.length;V0++){let b0=W0[y0],a0=W0[V0],L=b0.start+b0.count,p=c0(a0.start,E.width,4),N0=c0(b0.start,E.width,4);if(a0.start<=L+1&&p===N0&&c0(a0.start+a0.count-1,E.width,4)===p)b0.count=Math.max(b0.count,a0.start+a0.count-b0.start);else++y0,W0[y0]=a0}W0.length=y0+1;let E0=F.getParameter(F.UNPACK_ROW_LENGTH),n0=F.getParameter(F.UNPACK_SKIP_PIXELS),ZF=F.getParameter(F.UNPACK_SKIP_ROWS);F.pixelStorei(F.UNPACK_ROW_LENGTH,E.width);for(let V0=0,b0=W0.length;V0<b0;V0++){let a0=W0[V0],L=Math.floor(a0.start/4),p=Math.ceil(a0.count/4),N0=L%E.width,g=Math.floor(L/E.width),h0=p,M0=1;F.pixelStorei(F.UNPACK_SKIP_PIXELS,N0),F.pixelStorei(F.UNPACK_SKIP_ROWS,g),$.texSubImage2D(F.TEXTURE_2D,0,N0,g,h0,1,Y0,q0,E.data)}v.clearUpdateRanges(),F.pixelStorei(F.UNPACK_ROW_LENGTH,E0),F.pixelStorei(F.UNPACK_SKIP_PIXELS,n0),F.pixelStorei(F.UNPACK_SKIP_ROWS,ZF)}}function P0(v,E,Y0){let q0=F.TEXTURE_2D;if(E.isDataArrayTexture||E.isCompressedArrayTexture)q0=F.TEXTURE_2D_ARRAY;if(E.isData3DTexture)q0=F.TEXTURE_3D;let H0=_F(v,E),W0=E.source;$.bindTexture(q0,v.__webglTexture,F.TEXTURE0+Y0);let y0=W.get(W0);if(W0.version!==y0.__version||H0===!0){$.activeTexture(F.TEXTURE0+Y0);let E0=aF.getPrimaries(aF.workingColorSpace),n0=E.colorSpace===fJ?null:aF.getPrimaries(E.colorSpace),ZF=E.colorSpace===fJ||E0===n0?F.NONE:F.BROWSER_DEFAULT_WEBGL;F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,E.flipY),F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL,E.premultiplyAlpha),F.pixelStorei(F.UNPACK_ALIGNMENT,E.unpackAlignment),F.pixelStorei(F.UNPACK_COLORSPACE_CONVERSION_WEBGL,ZF);let V0=P(E.image,!1,H.maxTextureSize);V0=j0(E,V0);let b0=Y.convert(E.format,E.colorSpace),a0=Y.convert(E.type),L=k(E.internalFormat,b0,a0,E.colorSpace,E.isVideoTexture);g0(q0,E);let p,N0=E.mipmaps,g=E.isVideoTexture!==!0,h0=y0.__version===void 0||H0===!0,M0=W0.dataReady,L0=m(E,V0);if(E.isDepthTexture){if(L=y(E.format===OJ,E.type),h0)if(g)$.texStorage2D(F.TEXTURE_2D,1,L,V0.width,V0.height);else $.texImage2D(F.TEXTURE_2D,0,L,V0.width,V0.height,0,b0,a0,null)}else if(E.isDataTexture)if(N0.length>0){if(g&&h0)$.texStorage2D(F.TEXTURE_2D,L0,L,N0[0].width,N0[0].height);for(let I0=0,Z0=N0.length;I0<Z0;I0++)if(p=N0[I0],g){if(M0)$.texSubImage2D(F.TEXTURE_2D,I0,0,0,p.width,p.height,b0,a0,p.data)}else $.texImage2D(F.TEXTURE_2D,I0,L,p.width,p.height,0,b0,a0,p.data);E.generateMipmaps=!1}else if(g){if(h0)$.texStorage2D(F.TEXTURE_2D,L0,L,V0.width,V0.height);if(M0)D0(E,V0,b0,a0)}else $.texImage2D(F.TEXTURE_2D,0,L,V0.width,V0.height,0,b0,a0,V0.data);else if(E.isCompressedTexture)if(E.isCompressedArrayTexture){if(g&&h0)$.texStorage3D(F.TEXTURE_2D_ARRAY,L0,L,N0[0].width,N0[0].height,V0.depth);for(let I0=0,Z0=N0.length;I0<Z0;I0++)if(p=N0[I0],E.format!==k7)if(b0!==null)if(g){if(M0)if(E.layerUpdates.size>0){let m0=_B(p.width,p.height,E.format,E.type);for(let $F of E.layerUpdates){let iF=p.data.subarray($F*m0/p.data.BYTES_PER_ELEMENT,($F+1)*m0/p.data.BYTES_PER_ELEMENT);$.compressedTexSubImage3D(F.TEXTURE_2D_ARRAY,I0,0,0,$F,p.width,p.height,1,b0,iF)}E.clearLayerUpdates()}else $.compressedTexSubImage3D(F.TEXTURE_2D_ARRAY,I0,0,0,0,p.width,p.height,V0.depth,b0,p.data)}else $.compressedTexImage3D(F.TEXTURE_2D_ARRAY,I0,L,p.width,p.height,V0.depth,0,p.data,0,0);else zF("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else if(g){if(M0)$.texSubImage3D(F.TEXTURE_2D_ARRAY,I0,0,0,0,p.width,p.height,V0.depth,b0,a0,p.data)}else $.texImage3D(F.TEXTURE_2D_ARRAY,I0,L,p.width,p.height,V0.depth,0,b0,a0,p.data)}else{if(g&&h0)$.texStorage2D(F.TEXTURE_2D,L0,L,N0[0].width,N0[0].height);for(let I0=0,Z0=N0.length;I0<Z0;I0++)if(p=N0[I0],E.format!==k7)if(b0!==null)if(g){if(M0)$.compressedTexSubImage2D(F.TEXTURE_2D,I0,0,0,p.width,p.height,b0,p.data)}else $.compressedTexImage2D(F.TEXTURE_2D,I0,L,p.width,p.height,0,p.data);else zF("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else if(g){if(M0)$.texSubImage2D(F.TEXTURE_2D,I0,0,0,p.width,p.height,b0,a0,p.data)}else $.texImage2D(F.TEXTURE_2D,I0,L,p.width,p.height,0,b0,a0,p.data)}else if(E.isDataArrayTexture)if(g){if(h0)$.texStorage3D(F.TEXTURE_2D_ARRAY,L0,L,V0.width,V0.height,V0.depth);if(M0)if(E.layerUpdates.size>0){let I0=_B(V0.width,V0.height,E.format,E.type);for(let Z0 of E.layerUpdates){let m0=V0.data.subarray(Z0*I0/V0.data.BYTES_PER_ELEMENT,(Z0+1)*I0/V0.data.BYTES_PER_ELEMENT);$.texSubImage3D(F.TEXTURE_2D_ARRAY,0,0,0,Z0,V0.width,V0.height,1,b0,a0,m0)}E.clearLayerUpdates()}else $.texSubImage3D(F.TEXTURE_2D_ARRAY,0,0,0,0,V0.width,V0.height,V0.depth,b0,a0,V0.data)}else $.texImage3D(F.TEXTURE_2D_ARRAY,0,L,V0.width,V0.height,V0.depth,0,b0,a0,V0.data);else if(E.isData3DTexture)if(g){if(h0)$.texStorage3D(F.TEXTURE_3D,L0,L,V0.width,V0.height,V0.depth);if(M0)$.texSubImage3D(F.TEXTURE_3D,0,0,0,0,V0.width,V0.height,V0.depth,b0,a0,V0.data)}else $.texImage3D(F.TEXTURE_3D,0,L,V0.width,V0.height,V0.depth,0,b0,a0,V0.data);else if(E.isFramebufferTexture){if(h0)if(g)$.texStorage2D(F.TEXTURE_2D,L0,L,V0.width,V0.height);else{let{width:I0,height:Z0}=V0;for(let m0=0;m0<L0;m0++)$.texImage2D(F.TEXTURE_2D,m0,L,I0,Z0,0,b0,a0,null),I0>>=1,Z0>>=1}}else if(N0.length>0){if(g&&h0){let I0=fF(N0[0]);$.texStorage2D(F.TEXTURE_2D,L0,L,I0.width,I0.height)}for(let I0=0,Z0=N0.length;I0<Z0;I0++)if(p=N0[I0],g){if(M0)$.texSubImage2D(F.TEXTURE_2D,I0,0,0,b0,a0,p)}else $.texImage2D(F.TEXTURE_2D,I0,L,b0,a0,p);E.generateMipmaps=!1}else if(g){if(h0){let I0=fF(V0);$.texStorage2D(F.TEXTURE_2D,L0,L,I0.width,I0.height)}if(M0)$.texSubImage2D(F.TEXTURE_2D,0,0,0,b0,a0,V0)}else $.texImage2D(F.TEXTURE_2D,0,L,b0,a0,V0);if(D(E))O(q0);if(y0.__version=W0.version,E.onUpdate)E.onUpdate(E)}v.__version=E.version}function S0(v,E,Y0){if(E.image.length!==6)return;let q0=_F(v,E),H0=E.source;$.bindTexture(F.TEXTURE_CUBE_MAP,v.__webglTexture,F.TEXTURE0+Y0);let W0=W.get(H0);if(H0.version!==W0.__version||q0===!0){$.activeTexture(F.TEXTURE0+Y0);let y0=aF.getPrimaries(aF.workingColorSpace),E0=E.colorSpace===fJ?null:aF.getPrimaries(E.colorSpace),n0=E.colorSpace===fJ||y0===E0?F.NONE:F.BROWSER_DEFAULT_WEBGL;F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,E.flipY),F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL,E.premultiplyAlpha),F.pixelStorei(F.UNPACK_ALIGNMENT,E.unpackAlignment),F.pixelStorei(F.UNPACK_COLORSPACE_CONVERSION_WEBGL,n0);let ZF=E.isCompressedTexture||E.image[0].isCompressedTexture,V0=E.image[0]&&E.image[0].isDataTexture,b0=[];for(let Z0=0;Z0<6;Z0++){if(!ZF&&!V0)b0[Z0]=P(E.image[Z0],!0,H.maxCubemapSize);else b0[Z0]=V0?E.image[Z0].image:E.image[Z0];b0[Z0]=j0(E,b0[Z0])}let a0=b0[0],L=Y.convert(E.format,E.colorSpace),p=Y.convert(E.type),N0=k(E.internalFormat,L,p,E.colorSpace),g=E.isVideoTexture!==!0,h0=W0.__version===void 0||q0===!0,M0=H0.dataReady,L0=m(E,a0);g0(F.TEXTURE_CUBE_MAP,E);let I0;if(ZF){if(g&&h0)$.texStorage2D(F.TEXTURE_CUBE_MAP,L0,N0,a0.width,a0.height);for(let Z0=0;Z0<6;Z0++){I0=b0[Z0].mipmaps;for(let m0=0;m0<I0.length;m0++){let $F=I0[m0];if(E.format!==k7)if(L!==null)if(g){if(M0)$.compressedTexSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0,0,0,$F.width,$F.height,L,$F.data)}else $.compressedTexImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0,N0,$F.width,$F.height,0,$F.data);else zF("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");else if(g){if(M0)$.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0,0,0,$F.width,$F.height,L,p,$F.data)}else $.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0,N0,$F.width,$F.height,0,L,p,$F.data)}}}else{if(I0=E.mipmaps,g&&h0){if(I0.length>0)L0++;let Z0=fF(b0[0]);$.texStorage2D(F.TEXTURE_CUBE_MAP,L0,N0,Z0.width,Z0.height)}for(let Z0=0;Z0<6;Z0++)if(V0){if(g){if(M0)$.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,0,0,0,b0[Z0].width,b0[Z0].height,L,p,b0[Z0].data)}else $.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,0,N0,b0[Z0].width,b0[Z0].height,0,L,p,b0[Z0].data);for(let m0=0;m0<I0.length;m0++){let iF=I0[m0].image[Z0].image;if(g){if(M0)$.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0+1,0,0,iF.width,iF.height,L,p,iF.data)}else $.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0+1,N0,iF.width,iF.height,0,L,p,iF.data)}}else{if(g){if(M0)$.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,0,0,0,L,p,b0[Z0])}else $.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,0,N0,L,p,b0[Z0]);for(let m0=0;m0<I0.length;m0++){let $F=I0[m0];if(g){if(M0)$.texSubImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0+1,0,0,L,p,$F.image[Z0])}else $.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+Z0,m0+1,N0,L,p,$F.image[Z0])}}}if(D(E))O(F.TEXTURE_CUBE_MAP);if(W0.__version=H0.version,E.onUpdate)E.onUpdate(E)}v.__version=E.version}function e0(v,E,Y0,q0,H0,W0){let y0=Y.convert(Y0.format,Y0.colorSpace),E0=Y.convert(Y0.type),n0=k(Y0.internalFormat,y0,E0,Y0.colorSpace),ZF=W.get(E),V0=W.get(Y0);if(V0.__renderTarget=E,!ZF.__hasExternalTextures){let b0=Math.max(1,E.width>>W0),a0=Math.max(1,E.height>>W0);if(H0===F.TEXTURE_3D||H0===F.TEXTURE_2D_ARRAY)$.texImage3D(H0,W0,n0,b0,a0,E.depth,0,y0,E0,null);else $.texImage2D(H0,W0,n0,b0,a0,0,y0,E0,null)}if($.bindFramebuffer(F.FRAMEBUFFER,v),AF(E))G.framebufferTexture2DMultisampleEXT(F.FRAMEBUFFER,q0,H0,V0.__webglTexture,0,C0(E));else if(H0===F.TEXTURE_2D||H0>=F.TEXTURE_CUBE_MAP_POSITIVE_X&&H0<=F.TEXTURE_CUBE_MAP_NEGATIVE_Z)F.framebufferTexture2D(F.FRAMEBUFFER,q0,H0,V0.__webglTexture,W0);$.bindFramebuffer(F.FRAMEBUFFER,null)}function JF(v,E,Y0){if(F.bindRenderbuffer(F.RENDERBUFFER,v),E.depthBuffer){let q0=E.depthTexture,H0=q0&&q0.isDepthTexture?q0.type:null,W0=y(E.stencilBuffer,H0),y0=E.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT;if(AF(E))G.renderbufferStorageMultisampleEXT(F.RENDERBUFFER,C0(E),W0,E.width,E.height);else if(Y0)F.renderbufferStorageMultisample(F.RENDERBUFFER,C0(E),W0,E.width,E.height);else F.renderbufferStorage(F.RENDERBUFFER,W0,E.width,E.height);F.framebufferRenderbuffer(F.FRAMEBUFFER,y0,F.RENDERBUFFER,v)}else{let q0=E.textures;for(let H0=0;H0<q0.length;H0++){let W0=q0[H0],y0=Y.convert(W0.format,W0.colorSpace),E0=Y.convert(W0.type),n0=k(W0.internalFormat,y0,E0,W0.colorSpace);if(AF(E))G.renderbufferStorageMultisampleEXT(F.RENDERBUFFER,C0(E),n0,E.width,E.height);else if(Y0)F.renderbufferStorageMultisample(F.RENDERBUFFER,C0(E),n0,E.width,E.height);else F.renderbufferStorage(F.RENDERBUFFER,n0,E.width,E.height)}}F.bindRenderbuffer(F.RENDERBUFFER,null)}function UF(v,E,Y0){let q0=E.isWebGLCubeRenderTarget===!0;if($.bindFramebuffer(F.FRAMEBUFFER,v),!(E.depthTexture&&E.depthTexture.isDepthTexture))throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");let H0=W.get(E.depthTexture);if(H0.__renderTarget=E,!H0.__webglTexture||E.depthTexture.image.width!==E.width||E.depthTexture.image.height!==E.height)E.depthTexture.image.width=E.width,E.depthTexture.image.height=E.height,E.depthTexture.needsUpdate=!0;if(q0){if(H0.__webglInit===void 0)H0.__webglInit=!0,E.depthTexture.addEventListener("dispose",x);if(H0.__webglTexture===void 0){H0.__webglTexture=F.createTexture(),$.bindTexture(F.TEXTURE_CUBE_MAP,H0.__webglTexture),g0(F.TEXTURE_CUBE_MAP,E.depthTexture);let ZF=Y.convert(E.depthTexture.format),V0=Y.convert(E.depthTexture.type),b0;if(E.depthTexture.format===MJ)b0=F.DEPTH_COMPONENT24;else if(E.depthTexture.format===OJ)b0=F.DEPTH24_STENCIL8;for(let a0=0;a0<6;a0++)F.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+a0,0,b0,E.width,E.height,0,ZF,V0,null)}}else J0(E.depthTexture,0);let W0=H0.__webglTexture,y0=C0(E),E0=q0?F.TEXTURE_CUBE_MAP_POSITIVE_X+Y0:F.TEXTURE_2D,n0=E.depthTexture.format===OJ?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT;if(E.depthTexture.format===MJ)if(AF(E))G.framebufferTexture2DMultisampleEXT(F.FRAMEBUFFER,n0,E0,W0,0,y0);else F.framebufferTexture2D(F.FRAMEBUFFER,n0,E0,W0,0);else if(E.depthTexture.format===OJ)if(AF(E))G.framebufferTexture2DMultisampleEXT(F.FRAMEBUFFER,n0,E0,W0,0,y0);else F.framebufferTexture2D(F.FRAMEBUFFER,n0,E0,W0,0);else throw Error("Unknown depthTexture format")}function v0(v){let E=W.get(v),Y0=v.isWebGLCubeRenderTarget===!0;if(E.__boundDepthTexture!==v.depthTexture){let q0=v.depthTexture;if(E.__depthDisposeCallback)E.__depthDisposeCallback();if(q0){let H0=()=>{delete E.__boundDepthTexture,delete E.__depthDisposeCallback,q0.removeEventListener("dispose",H0)};q0.addEventListener("dispose",H0),E.__depthDisposeCallback=H0}E.__boundDepthTexture=q0}if(v.depthTexture&&!E.__autoAllocateDepthBuffer)if(Y0)for(let q0=0;q0<6;q0++)UF(E.__webglFramebuffer[q0],v,q0);else{let q0=v.texture.mipmaps;if(q0&&q0.length>0)UF(E.__webglFramebuffer[0],v,0);else UF(E.__webglFramebuffer,v,0)}else if(Y0){E.__webglDepthbuffer=[];for(let q0=0;q0<6;q0++)if($.bindFramebuffer(F.FRAMEBUFFER,E.__webglFramebuffer[q0]),E.__webglDepthbuffer[q0]===void 0)E.__webglDepthbuffer[q0]=F.createRenderbuffer(),JF(E.__webglDepthbuffer[q0],v,!1);else{let H0=v.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT,W0=E.__webglDepthbuffer[q0];F.bindRenderbuffer(F.RENDERBUFFER,W0),F.framebufferRenderbuffer(F.FRAMEBUFFER,H0,F.RENDERBUFFER,W0)}}else{let q0=v.texture.mipmaps;if(q0&&q0.length>0)$.bindFramebuffer(F.FRAMEBUFFER,E.__webglFramebuffer[0]);else $.bindFramebuffer(F.FRAMEBUFFER,E.__webglFramebuffer);if(E.__webglDepthbuffer===void 0)E.__webglDepthbuffer=F.createRenderbuffer(),JF(E.__webglDepthbuffer,v,!1);else{let H0=v.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT,W0=E.__webglDepthbuffer;F.bindRenderbuffer(F.RENDERBUFFER,W0),F.framebufferRenderbuffer(F.FRAMEBUFFER,H0,F.RENDERBUFFER,W0)}}$.bindFramebuffer(F.FRAMEBUFFER,null)}function PF(v,E,Y0){let q0=W.get(v);if(E!==void 0)e0(q0.__webglFramebuffer,v,v.texture,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,0);if(Y0!==void 0)v0(v)}function OF(v){let E=v.texture,Y0=W.get(v),q0=W.get(E);v.addEventListener("dispose",o);let H0=v.textures,W0=v.isWebGLCubeRenderTarget===!0,y0=H0.length>1;if(!y0){if(q0.__webglTexture===void 0)q0.__webglTexture=F.createTexture();q0.__version=E.version,K.memory.textures++}if(W0){Y0.__webglFramebuffer=[];for(let E0=0;E0<6;E0++)if(E.mipmaps&&E.mipmaps.length>0){Y0.__webglFramebuffer[E0]=[];for(let n0=0;n0<E.mipmaps.length;n0++)Y0.__webglFramebuffer[E0][n0]=F.createFramebuffer()}else Y0.__webglFramebuffer[E0]=F.createFramebuffer()}else{if(E.mipmaps&&E.mipmaps.length>0){Y0.__webglFramebuffer=[];for(let E0=0;E0<E.mipmaps.length;E0++)Y0.__webglFramebuffer[E0]=F.createFramebuffer()}else Y0.__webglFramebuffer=F.createFramebuffer();if(y0)for(let E0=0,n0=H0.length;E0<n0;E0++){let ZF=W.get(H0[E0]);if(ZF.__webglTexture===void 0)ZF.__webglTexture=F.createTexture(),K.memory.textures++}if(v.samples>0&&AF(v)===!1){Y0.__webglMultisampledFramebuffer=F.createFramebuffer(),Y0.__webglColorRenderbuffer=[],$.bindFramebuffer(F.FRAMEBUFFER,Y0.__webglMultisampledFramebuffer);for(let E0=0;E0<H0.length;E0++){let n0=H0[E0];Y0.__webglColorRenderbuffer[E0]=F.createRenderbuffer(),F.bindRenderbuffer(F.RENDERBUFFER,Y0.__webglColorRenderbuffer[E0]);let ZF=Y.convert(n0.format,n0.colorSpace),V0=Y.convert(n0.type),b0=k(n0.internalFormat,ZF,V0,n0.colorSpace,v.isXRRenderTarget===!0),a0=C0(v);F.renderbufferStorageMultisample(F.RENDERBUFFER,a0,b0,v.width,v.height),F.framebufferRenderbuffer(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0+E0,F.RENDERBUFFER,Y0.__webglColorRenderbuffer[E0])}if(F.bindRenderbuffer(F.RENDERBUFFER,null),v.depthBuffer)Y0.__webglDepthRenderbuffer=F.createRenderbuffer(),JF(Y0.__webglDepthRenderbuffer,v,!0);$.bindFramebuffer(F.FRAMEBUFFER,null)}}if(W0){$.bindTexture(F.TEXTURE_CUBE_MAP,q0.__webglTexture),g0(F.TEXTURE_CUBE_MAP,E);for(let E0=0;E0<6;E0++)if(E.mipmaps&&E.mipmaps.length>0)for(let n0=0;n0<E.mipmaps.length;n0++)e0(Y0.__webglFramebuffer[E0][n0],v,E,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+E0,n0);else e0(Y0.__webglFramebuffer[E0],v,E,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+E0,0);if(D(E))O(F.TEXTURE_CUBE_MAP);$.unbindTexture()}else if(y0){for(let E0=0,n0=H0.length;E0<n0;E0++){let ZF=H0[E0],V0=W.get(ZF),b0=F.TEXTURE_2D;if(v.isWebGL3DRenderTarget||v.isWebGLArrayRenderTarget)b0=v.isWebGL3DRenderTarget?F.TEXTURE_3D:F.TEXTURE_2D_ARRAY;if($.bindTexture(b0,V0.__webglTexture),g0(b0,ZF),e0(Y0.__webglFramebuffer,v,ZF,F.COLOR_ATTACHMENT0+E0,b0,0),D(ZF))O(b0)}$.unbindTexture()}else{let E0=F.TEXTURE_2D;if(v.isWebGL3DRenderTarget||v.isWebGLArrayRenderTarget)E0=v.isWebGL3DRenderTarget?F.TEXTURE_3D:F.TEXTURE_2D_ARRAY;if($.bindTexture(E0,q0.__webglTexture),g0(E0,E),E.mipmaps&&E.mipmaps.length>0)for(let n0=0;n0<E.mipmaps.length;n0++)e0(Y0.__webglFramebuffer[n0],v,E,F.COLOR_ATTACHMENT0,E0,n0);else e0(Y0.__webglFramebuffer,v,E,F.COLOR_ATTACHMENT0,E0,0);if(D(E))O(E0);$.unbindTexture()}if(v.depthBuffer)v0(v)}function jF(v){let E=v.textures;for(let Y0=0,q0=E.length;Y0<q0;Y0++){let H0=E[Y0];if(D(H0)){let W0=b(v),y0=W.get(H0).__webglTexture;$.bindTexture(W0,y0),O(W0),$.unbindTexture()}}}let t0=[],XF=[];function a(v){if(v.samples>0){if(AF(v)===!1){let{textures:E,width:Y0,height:q0}=v,H0=F.COLOR_BUFFER_BIT,W0=v.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT,y0=W.get(v),E0=E.length>1;if(E0)for(let ZF=0;ZF<E.length;ZF++)$.bindFramebuffer(F.FRAMEBUFFER,y0.__webglMultisampledFramebuffer),F.framebufferRenderbuffer(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0+ZF,F.RENDERBUFFER,null),$.bindFramebuffer(F.FRAMEBUFFER,y0.__webglFramebuffer),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0+ZF,F.TEXTURE_2D,null,0);$.bindFramebuffer(F.READ_FRAMEBUFFER,y0.__webglMultisampledFramebuffer);let n0=v.texture.mipmaps;if(n0&&n0.length>0)$.bindFramebuffer(F.DRAW_FRAMEBUFFER,y0.__webglFramebuffer[0]);else $.bindFramebuffer(F.DRAW_FRAMEBUFFER,y0.__webglFramebuffer);for(let ZF=0;ZF<E.length;ZF++){if(v.resolveDepthBuffer){if(v.depthBuffer)H0|=F.DEPTH_BUFFER_BIT;if(v.stencilBuffer&&v.resolveStencilBuffer)H0|=F.STENCIL_BUFFER_BIT}if(E0){F.framebufferRenderbuffer(F.READ_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.RENDERBUFFER,y0.__webglColorRenderbuffer[ZF]);let V0=W.get(E[ZF]).__webglTexture;F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,V0,0)}if(F.blitFramebuffer(0,0,Y0,q0,0,0,Y0,q0,H0,F.NEAREST),U===!0){if(t0.length=0,XF.length=0,t0.push(F.COLOR_ATTACHMENT0+ZF),v.depthBuffer&&v.resolveDepthBuffer===!1)t0.push(W0),XF.push(W0),F.invalidateFramebuffer(F.DRAW_FRAMEBUFFER,XF);F.invalidateFramebuffer(F.READ_FRAMEBUFFER,t0)}}if($.bindFramebuffer(F.READ_FRAMEBUFFER,null),$.bindFramebuffer(F.DRAW_FRAMEBUFFER,null),E0)for(let ZF=0;ZF<E.length;ZF++){$.bindFramebuffer(F.FRAMEBUFFER,y0.__webglMultisampledFramebuffer),F.framebufferRenderbuffer(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0+ZF,F.RENDERBUFFER,y0.__webglColorRenderbuffer[ZF]);let V0=W.get(E[ZF]).__webglTexture;$.bindFramebuffer(F.FRAMEBUFFER,y0.__webglFramebuffer),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0+ZF,F.TEXTURE_2D,V0,0)}$.bindFramebuffer(F.DRAW_FRAMEBUFFER,y0.__webglMultisampledFramebuffer)}else if(v.depthBuffer&&v.resolveDepthBuffer===!1&&U){let E=v.stencilBuffer?F.DEPTH_STENCIL_ATTACHMENT:F.DEPTH_ATTACHMENT;F.invalidateFramebuffer(F.DRAW_FRAMEBUFFER,[E])}}}function C0(v){return Math.min(H.maxSamples,v.samples)}function AF(v){let E=W.get(v);return v.samples>0&&_.has("WEBGL_multisampled_render_to_texture")===!0&&E.__useRenderToTexture!==!1}function s0(v){let E=K.render.frame;if(h.get(v)!==E)h.set(v,E),v.update()}function j0(v,E){let{colorSpace:Y0,format:q0,type:H0}=v;if(v.isCompressedTexture===!0||v.isVideoTexture===!0)return E;if(Y0!==DQ&&Y0!==fJ)if(aF.getTransfer(Y0)===G1){if(q0!==k7||H0!==e8)zF("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.")}else hF("WebGLTextures: Unsupported texture color space:",Y0);return E}function fF(v){if(typeof HTMLImageElement<"u"&&v instanceof HTMLImageElement)z.width=v.naturalWidth||v.width,z.height=v.naturalHeight||v.height;else if(typeof VideoFrame<"u"&&v instanceof VideoFrame)z.width=v.displayWidth,z.height=v.displayHeight;else z.width=v.width,z.height=v.height;return z}this.allocateTextureUnit=X0,this.resetTextureUnits=$0,this.setTexture2D=J0,this.setTexture2DArray=u,this.setTexture3D=n,this.setTextureCube=Q0,this.rebindTextures=PF,this.setupRenderTarget=OF,this.updateRenderTargetMipmap=jF,this.updateMultisampleRenderTarget=a,this.setupDepthRenderbuffer=v0,this.setupFrameBufferTexture=e0,this.useMultisampledRTT=AF,this.isReversedDepthBuffer=function(){return $.buffers.depth.getReversed()}}function uk(F,_){function $(W,H=fJ){let Y,K=aF.getTransfer(H);if(W===e8)return F.UNSIGNED_BYTE;if(W===i5)return F.UNSIGNED_SHORT_4_4_4_4;if(W===n5)return F.UNSIGNED_SHORT_5_5_5_1;if(W===tO)return F.UNSIGNED_INT_5_9_9_9_REV;if(W===eO)return F.UNSIGNED_INT_10F_11F_11F_REV;if(W===aO)return F.BYTE;if(W===rO)return F.SHORT;if(W===NQ)return F.UNSIGNED_SHORT;if(W===d5)return F.INT;if(W===Mq)return F.UNSIGNED_INT;if(W===h9)return F.FLOAT;if(W===R9)return F.HALF_FLOAT;if(W===Ff)return F.ALPHA;if(W===qf)return F.RGB;if(W===k7)return F.RGBA;if(W===MJ)return F.DEPTH_COMPONENT;if(W===OJ)return F.DEPTH_STENCIL;if(W===Jf)return F.RED;if(W===c5)return F.RED_INTEGER;if(W===zZ)return F.RG;if(W===s5)return F.RG_INTEGER;if(W===o5)return F.RGBA_INTEGER;if(W===pw||W===mw||W===lw||W===dw)if(K===G1)if(Y=_.get("WEBGL_compressed_texture_s3tc_srgb"),Y!==null){if(W===pw)return Y.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(W===mw)return Y.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(W===lw)return Y.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(W===dw)return Y.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(Y=_.get("WEBGL_compressed_texture_s3tc"),Y!==null){if(W===pw)return Y.COMPRESSED_RGB_S3TC_DXT1_EXT;if(W===mw)return Y.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(W===lw)return Y.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(W===dw)return Y.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(W===a5||W===r5||W===t5||W===e5)if(Y=_.get("WEBGL_compressed_texture_pvrtc"),Y!==null){if(W===a5)return Y.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(W===r5)return Y.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(W===t5)return Y.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(W===e5)return Y.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(W===FU||W===qU||W===JU||W===_U||W===ZU||W===$U||W===QU)if(Y=_.get("WEBGL_compressed_texture_etc"),Y!==null){if(W===FU||W===qU)return K===G1?Y.COMPRESSED_SRGB8_ETC2:Y.COMPRESSED_RGB8_ETC2;if(W===JU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:Y.COMPRESSED_RGBA8_ETC2_EAC;if(W===_U)return Y.COMPRESSED_R11_EAC;if(W===ZU)return Y.COMPRESSED_SIGNED_R11_EAC;if(W===$U)return Y.COMPRESSED_RG11_EAC;if(W===QU)return Y.COMPRESSED_SIGNED_RG11_EAC}else return null;if(W===WU||W===HU||W===wU||W===YU||W===XU||W===GU||W===KU||W===UU||W===BU||W===zU||W===AU||W===hU||W===RU||W===NU)if(Y=_.get("WEBGL_compressed_texture_astc"),Y!==null){if(W===WU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:Y.COMPRESSED_RGBA_ASTC_4x4_KHR;if(W===HU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:Y.COMPRESSED_RGBA_ASTC_5x4_KHR;if(W===wU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:Y.COMPRESSED_RGBA_ASTC_5x5_KHR;if(W===YU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:Y.COMPRESSED_RGBA_ASTC_6x5_KHR;if(W===XU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:Y.COMPRESSED_RGBA_ASTC_6x6_KHR;if(W===GU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:Y.COMPRESSED_RGBA_ASTC_8x5_KHR;if(W===KU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:Y.COMPRESSED_RGBA_ASTC_8x6_KHR;if(W===UU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:Y.COMPRESSED_RGBA_ASTC_8x8_KHR;if(W===BU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:Y.COMPRESSED_RGBA_ASTC_10x5_KHR;if(W===zU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:Y.COMPRESSED_RGBA_ASTC_10x6_KHR;if(W===AU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:Y.COMPRESSED_RGBA_ASTC_10x8_KHR;if(W===hU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:Y.COMPRESSED_RGBA_ASTC_10x10_KHR;if(W===RU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:Y.COMPRESSED_RGBA_ASTC_12x10_KHR;if(W===NU)return K===G1?Y.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:Y.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(W===DU||W===MU||W===OU)if(Y=_.get("EXT_texture_compression_bptc"),Y!==null){if(W===DU)return K===G1?Y.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:Y.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(W===MU)return Y.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(W===OU)return Y.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(W===fU||W===IU||W===TU||W===LU)if(Y=_.get("EXT_texture_compression_rgtc"),Y!==null){if(W===fU)return Y.COMPRESSED_RED_RGTC1_EXT;if(W===IU)return Y.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(W===TU)return Y.COMPRESSED_RED_GREEN_RGTC2_EXT;if(W===LU)return Y.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;if(W===BZ)return F.UNSIGNED_INT_24_8;return F[W]!==void 0?F[W]:null}return{convert:$}}var pk=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,mk=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class ef{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(F,_){if(this.texture===null){let $=new JY(F.texture);if(F.depthNear!==_.depthNear||F.depthFar!==_.depthFar)this.depthNear=F.depthNear,this.depthFar=F.depthFar;this.texture=$}}getMesh(F){if(this.texture!==null){if(this.mesh===null){let _=F.cameras[0].viewport,$=new V8({vertexShader:pk,fragmentShader:mk,uniforms:{depthColor:{value:this.texture},depthWidth:{value:_.z},depthHeight:{value:_.w}}});this.mesh=new X8(new LQ(20,20),$)}}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class F2 extends N9{constructor(F,_){super();let $=this,W=null,H=1,Y=null,K="local-floor",G=1,U=null,z=null,h=null,A=null,N=null,M=null,T=typeof XRWebGLBinding<"u",P=new ef,D={},O=_.getContextAttributes(),b=null,k=null,y=[],m=[],x=new DF,o=null,s=new V6;s.viewport=new T1;let j=new V6;j.viewport=new T1;let V=[s,j],d=new FB,$0=null,X0=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(D0){let P0=y[D0];if(P0===void 0)P0=new fQ,y[D0]=P0;return P0.getTargetRaySpace()},this.getControllerGrip=function(D0){let P0=y[D0];if(P0===void 0)P0=new fQ,y[D0]=P0;return P0.getGripSpace()},this.getHand=function(D0){let P0=y[D0];if(P0===void 0)P0=new fQ,y[D0]=P0;return P0.getHandSpace()};function K0(D0){let P0=m.indexOf(D0.inputSource);if(P0===-1)return;let S0=y[P0];if(S0!==void 0)S0.update(D0.inputSource,D0.frame,U||Y),S0.dispatchEvent({type:D0.type,data:D0.inputSource})}function J0(){W.removeEventListener("select",K0),W.removeEventListener("selectstart",K0),W.removeEventListener("selectend",K0),W.removeEventListener("squeeze",K0),W.removeEventListener("squeezestart",K0),W.removeEventListener("squeezeend",K0),W.removeEventListener("end",J0),W.removeEventListener("inputsourceschange",u);for(let D0=0;D0<y.length;D0++){let P0=m[D0];if(P0===null)continue;m[D0]=null,y[D0].disconnect(P0)}$0=null,X0=null,P.reset();for(let D0 in D)delete D[D0];F.setRenderTarget(b),N=null,A=null,h=null,W=null,k=null,c0.stop(),$.isPresenting=!1,F.setPixelRatio(o),F.setSize(x.width,x.height,!1),$.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(D0){if(H=D0,$.isPresenting===!0)zF("WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(D0){if(K=D0,$.isPresenting===!0)zF("WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return U||Y},this.setReferenceSpace=function(D0){U=D0},this.getBaseLayer=function(){return A!==null?A:N},this.getBinding=function(){if(h===null&&T)h=new XRWebGLBinding(W,_);return h},this.getFrame=function(){return M},this.getSession=function(){return W},this.setSession=async function(D0){if(W=D0,W!==null){if(b=F.getRenderTarget(),W.addEventListener("select",K0),W.addEventListener("selectstart",K0),W.addEventListener("selectend",K0),W.addEventListener("squeeze",K0),W.addEventListener("squeezestart",K0),W.addEventListener("squeezeend",K0),W.addEventListener("end",J0),W.addEventListener("inputsourceschange",u),O.xrCompatible!==!0)await _.makeXRCompatible();if(o=F.getPixelRatio(),F.getSize(x),!(T&&("createProjectionLayer"in XRWebGLBinding.prototype))){let S0={antialias:O.antialias,alpha:!0,depth:O.depth,stencil:O.stencil,framebufferScaleFactor:H};N=new XRWebGLLayer(W,_,S0),W.updateRenderState({baseLayer:N}),F.setPixelRatio(1),F.setSize(N.framebufferWidth,N.framebufferHeight,!1),k=new P8(N.framebufferWidth,N.framebufferHeight,{format:k7,type:e8,colorSpace:F.outputColorSpace,stencilBuffer:O.stencil,resolveDepthBuffer:N.ignoreDepthValues===!1,resolveStencilBuffer:N.ignoreDepthValues===!1})}else{let S0=null,e0=null,JF=null;if(O.depth)JF=O.stencil?_.DEPTH24_STENCIL8:_.DEPTH_COMPONENT24,S0=O.stencil?OJ:MJ,e0=O.stencil?BZ:Mq;let UF={colorFormat:_.RGBA8,depthFormat:JF,scaleFactor:H};h=this.getBinding(),A=h.createProjectionLayer(UF),W.updateRenderState({layers:[A]}),F.setPixelRatio(1),F.setSize(A.textureWidth,A.textureHeight,!1),k=new P8(A.textureWidth,A.textureHeight,{format:k7,type:e8,depthTexture:new EJ(A.textureWidth,A.textureHeight,e0,void 0,void 0,void 0,void 0,void 0,void 0,S0),stencilBuffer:O.stencil,colorSpace:F.outputColorSpace,samples:O.antialias?4:0,resolveDepthBuffer:A.ignoreDepthValues===!1,resolveStencilBuffer:A.ignoreDepthValues===!1})}k.isXRRenderTarget=!0,this.setFoveation(G),U=null,Y=await W.requestReferenceSpace(K),c0.setContext(W),c0.start(),$.isPresenting=!0,$.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(W!==null)return W.environmentBlendMode},this.getDepthTexture=function(){return P.getDepthTexture()};function u(D0){for(let P0=0;P0<D0.removed.length;P0++){let S0=D0.removed[P0],e0=m.indexOf(S0);if(e0>=0)m[e0]=null,y[e0].disconnect(S0)}for(let P0=0;P0<D0.added.length;P0++){let S0=D0.added[P0],e0=m.indexOf(S0);if(e0===-1){for(let UF=0;UF<y.length;UF++)if(UF>=m.length){m.push(S0),e0=UF;break}else if(m[UF]===null){m[UF]=S0,e0=UF;break}if(e0===-1)break}let JF=y[e0];if(JF)JF.connect(S0)}}let n=new w0,Q0=new w0;function O0(D0,P0,S0){n.setFromMatrixPosition(P0.matrixWorld),Q0.setFromMatrixPosition(S0.matrixWorld);let e0=n.distanceTo(Q0),JF=P0.projectionMatrix.elements,UF=S0.projectionMatrix.elements,v0=JF[14]/(JF[10]-1),PF=JF[14]/(JF[10]+1),OF=(JF[9]+1)/JF[5],jF=(JF[9]-1)/JF[5],t0=(JF[8]-1)/JF[0],XF=(UF[8]+1)/UF[0],a=v0*t0,C0=v0*XF,AF=e0/(-t0+XF),s0=AF*-t0;if(P0.matrixWorld.decompose(D0.position,D0.quaternion,D0.scale),D0.translateX(s0),D0.translateZ(AF),D0.matrixWorld.compose(D0.position,D0.quaternion,D0.scale),D0.matrixWorldInverse.copy(D0.matrixWorld).invert(),JF[10]===-1)D0.projectionMatrix.copy(P0.projectionMatrix),D0.projectionMatrixInverse.copy(P0.projectionMatrixInverse);else{let j0=v0+AF,fF=PF+AF,v=a-s0,E=C0+(e0-s0),Y0=OF*PF/fF*j0,q0=jF*PF/fF*j0;D0.projectionMatrix.makePerspective(v,E,Y0,q0,j0,fF),D0.projectionMatrixInverse.copy(D0.projectionMatrix).invert()}}function t(D0,P0){if(P0===null)D0.matrixWorld.copy(D0.matrix);else D0.matrixWorld.multiplyMatrices(P0.matrixWorld,D0.matrix);D0.matrixWorldInverse.copy(D0.matrixWorld).invert()}this.updateCamera=function(D0){if(W===null)return;let{near:P0,far:S0}=D0;if(P.texture!==null){if(P.depthNear>0)P0=P.depthNear;if(P.depthFar>0)S0=P.depthFar}if(d.near=j.near=s.near=P0,d.far=j.far=s.far=S0,$0!==d.near||X0!==d.far)W.updateRenderState({depthNear:d.near,depthFar:d.far}),$0=d.near,X0=d.far;d.layers.mask=D0.layers.mask|6,s.layers.mask=d.layers.mask&3,j.layers.mask=d.layers.mask&5;let e0=D0.parent,JF=d.cameras;t(d,e0);for(let UF=0;UF<JF.length;UF++)t(JF[UF],e0);if(JF.length===2)O0(d,s,j);else d.projectionMatrix.copy(s.projectionMatrix);T0(D0,d,e0)};function T0(D0,P0,S0){if(S0===null)D0.matrix.copy(P0.matrixWorld);else D0.matrix.copy(S0.matrixWorld),D0.matrix.invert(),D0.matrix.multiply(P0.matrixWorld);if(D0.matrix.decompose(D0.position,D0.quaternion,D0.scale),D0.updateMatrixWorld(!0),D0.projectionMatrix.copy(P0.projectionMatrix),D0.projectionMatrixInverse.copy(P0.projectionMatrixInverse),D0.isPerspectiveCamera)D0.fov=wZ*2*Math.atan(1/D0.projectionMatrix.elements[5]),D0.zoom=1}this.getCamera=function(){return d},this.getFoveation=function(){if(A===null&&N===null)return;return G},this.setFoveation=function(D0){if(G=D0,A!==null)A.fixedFoveation=D0;if(N!==null&&N.fixedFoveation!==void 0)N.fixedFoveation=D0},this.hasDepthSensing=function(){return P.texture!==null},this.getDepthSensingMesh=function(){return P.getMesh(d)},this.getCameraTexture=function(D0){return D[D0]};let g0=null;function _F(D0,P0){if(z=P0.getViewerPose(U||Y),M=P0,z!==null){let S0=z.views;if(N!==null)F.setRenderTargetFramebuffer(k,N.framebuffer),F.setRenderTarget(k);let e0=!1;if(S0.length!==d.cameras.length)d.cameras.length=0,e0=!0;for(let PF=0;PF<S0.length;PF++){let OF=S0[PF],jF=null;if(N!==null)jF=N.getViewport(OF);else{let XF=h.getViewSubImage(A,OF);if(jF=XF.viewport,PF===0)F.setRenderTargetTextures(k,XF.colorTexture,XF.depthStencilTexture),F.setRenderTarget(k)}let t0=V[PF];if(t0===void 0)t0=new V6,t0.layers.enable(PF),t0.viewport=new T1,V[PF]=t0;if(t0.matrix.fromArray(OF.transform.matrix),t0.matrix.decompose(t0.position,t0.quaternion,t0.scale),t0.projectionMatrix.fromArray(OF.projectionMatrix),t0.projectionMatrixInverse.copy(t0.projectionMatrix).invert(),t0.viewport.set(jF.x,jF.y,jF.width,jF.height),PF===0)d.matrix.copy(t0.matrix),d.matrix.decompose(d.position,d.quaternion,d.scale);if(e0===!0)d.cameras.push(t0)}let JF=W.enabledFeatures;if(JF&&JF.includes("depth-sensing")&&W.depthUsage=="gpu-optimized"&&T){h=$.getBinding();let PF=h.getDepthInformation(S0[0]);if(PF&&PF.isValid&&PF.texture)P.init(PF,W.renderState)}if(JF&&JF.includes("camera-access")&&T){F.state.unbindTexture(),h=$.getBinding();for(let PF=0;PF<S0.length;PF++){let OF=S0[PF].camera;if(OF){let jF=D[OF];if(!jF)jF=new JY,D[OF]=jF;let t0=h.getCameraImage(OF);jF.sourceTexture=t0}}}}for(let S0=0;S0<y.length;S0++){let e0=m[S0],JF=y[S0];if(e0!==null&&JF!==void 0)JF.update(e0,P0,U||Y)}if(g0)g0(D0,P0);if(P0.detectedPlanes)$.dispatchEvent({type:"planesdetected",data:P0});M=null}let c0=new mf;c0.setAnimationLoop(_F),this.setAnimationLoop=function(D0){g0=D0},this.dispose=function(){}}}var kJ=new r8,lk=new N1;function dk(F,_){function $(D,O){if(D.matrixAutoUpdate===!0)D.updateMatrix();O.value.copy(D.matrix)}function W(D,O){if(O.color.getRGB(D.fogColor.value,xU(F)),O.isFog)D.fogNear.value=O.near,D.fogFar.value=O.far;else if(O.isFogExp2)D.fogDensity.value=O.density}function H(D,O,b,k,y){if(O.isMeshBasicMaterial)Y(D,O);else if(O.isMeshLambertMaterial)Y(D,O);else if(O.isMeshToonMaterial)Y(D,O),A(D,O);else if(O.isMeshPhongMaterial)Y(D,O),h(D,O);else if(O.isMeshStandardMaterial){if(Y(D,O),N(D,O),O.isMeshPhysicalMaterial)M(D,O,y)}else if(O.isMeshMatcapMaterial)Y(D,O),T(D,O);else if(O.isMeshDepthMaterial)Y(D,O);else if(O.isMeshDistanceMaterial)Y(D,O),P(D,O);else if(O.isMeshNormalMaterial)Y(D,O);else if(O.isLineBasicMaterial){if(K(D,O),O.isLineDashedMaterial)G(D,O)}else if(O.isPointsMaterial)U(D,O,b,k);else if(O.isSpriteMaterial)z(D,O);else if(O.isShadowMaterial)D.color.value.copy(O.color),D.opacity.value=O.opacity;else if(O.isShaderMaterial)O.uniformsNeedUpdate=!1}function Y(D,O){if(D.opacity.value=O.opacity,O.color)D.diffuse.value.copy(O.color);if(O.emissive)D.emissive.value.copy(O.emissive).multiplyScalar(O.emissiveIntensity);if(O.map)D.map.value=O.map,$(O.map,D.mapTransform);if(O.alphaMap)D.alphaMap.value=O.alphaMap,$(O.alphaMap,D.alphaMapTransform);if(O.bumpMap){if(D.bumpMap.value=O.bumpMap,$(O.bumpMap,D.bumpMapTransform),D.bumpScale.value=O.bumpScale,O.side===w8)D.bumpScale.value*=-1}if(O.normalMap){if(D.normalMap.value=O.normalMap,$(O.normalMap,D.normalMapTransform),D.normalScale.value.copy(O.normalScale),O.side===w8)D.normalScale.value.negate()}if(O.displacementMap)D.displacementMap.value=O.displacementMap,$(O.displacementMap,D.displacementMapTransform),D.displacementScale.value=O.displacementScale,D.displacementBias.value=O.displacementBias;if(O.emissiveMap)D.emissiveMap.value=O.emissiveMap,$(O.emissiveMap,D.emissiveMapTransform);if(O.specularMap)D.specularMap.value=O.specularMap,$(O.specularMap,D.specularMapTransform);if(O.alphaTest>0)D.alphaTest.value=O.alphaTest;let b=_.get(O),k=b.envMap,y=b.envMapRotation;if(k){if(D.envMap.value=k,kJ.copy(y),kJ.x*=-1,kJ.y*=-1,kJ.z*=-1,k.isCubeTexture&&k.isRenderTargetTexture===!1)kJ.y*=-1,kJ.z*=-1;D.envMapRotation.value.setFromMatrix4(lk.makeRotationFromEuler(kJ)),D.flipEnvMap.value=k.isCubeTexture&&k.isRenderTargetTexture===!1?-1:1,D.reflectivity.value=O.reflectivity,D.ior.value=O.ior,D.refractionRatio.value=O.refractionRatio}if(O.lightMap)D.lightMap.value=O.lightMap,D.lightMapIntensity.value=O.lightMapIntensity,$(O.lightMap,D.lightMapTransform);if(O.aoMap)D.aoMap.value=O.aoMap,D.aoMapIntensity.value=O.aoMapIntensity,$(O.aoMap,D.aoMapTransform)}function K(D,O){if(D.diffuse.value.copy(O.color),D.opacity.value=O.opacity,O.map)D.map.value=O.map,$(O.map,D.mapTransform)}function G(D,O){D.dashSize.value=O.dashSize,D.totalSize.value=O.dashSize+O.gapSize,D.scale.value=O.scale}function U(D,O,b,k){if(D.diffuse.value.copy(O.color),D.opacity.value=O.opacity,D.size.value=O.size*b,D.scale.value=k*0.5,O.map)D.map.value=O.map,$(O.map,D.uvTransform);if(O.alphaMap)D.alphaMap.value=O.alphaMap,$(O.alphaMap,D.alphaMapTransform);if(O.alphaTest>0)D.alphaTest.value=O.alphaTest}function z(D,O){if(D.diffuse.value.copy(O.color),D.opacity.value=O.opacity,D.rotation.value=O.rotation,O.map)D.map.value=O.map,$(O.map,D.mapTransform);if(O.alphaMap)D.alphaMap.value=O.alphaMap,$(O.alphaMap,D.alphaMapTransform);if(O.alphaTest>0)D.alphaTest.value=O.alphaTest}function h(D,O){D.specular.value.copy(O.specular),D.shininess.value=Math.max(O.shininess,0.0001)}function A(D,O){if(O.gradientMap)D.gradientMap.value=O.gradientMap}function N(D,O){if(D.metalness.value=O.metalness,O.metalnessMap)D.metalnessMap.value=O.metalnessMap,$(O.metalnessMap,D.metalnessMapTransform);if(D.roughness.value=O.roughness,O.roughnessMap)D.roughnessMap.value=O.roughnessMap,$(O.roughnessMap,D.roughnessMapTransform);if(O.envMap)D.envMapIntensity.value=O.envMapIntensity}function M(D,O,b){if(D.ior.value=O.ior,O.sheen>0){if(D.sheenColor.value.copy(O.sheenColor).multiplyScalar(O.sheen),D.sheenRoughness.value=O.sheenRoughness,O.sheenColorMap)D.sheenColorMap.value=O.sheenColorMap,$(O.sheenColorMap,D.sheenColorMapTransform);if(O.sheenRoughnessMap)D.sheenRoughnessMap.value=O.sheenRoughnessMap,$(O.sheenRoughnessMap,D.sheenRoughnessMapTransform)}if(O.clearcoat>0){if(D.clearcoat.value=O.clearcoat,D.clearcoatRoughness.value=O.clearcoatRoughness,O.clearcoatMap)D.clearcoatMap.value=O.clearcoatMap,$(O.clearcoatMap,D.clearcoatMapTransform);if(O.clearcoatRoughnessMap)D.clearcoatRoughnessMap.value=O.clearcoatRoughnessMap,$(O.clearcoatRoughnessMap,D.clearcoatRoughnessMapTransform);if(O.clearcoatNormalMap){if(D.clearcoatNormalMap.value=O.clearcoatNormalMap,$(O.clearcoatNormalMap,D.clearcoatNormalMapTransform),D.clearcoatNormalScale.value.copy(O.clearcoatNormalScale),O.side===w8)D.clearcoatNormalScale.value.negate()}}if(O.dispersion>0)D.dispersion.value=O.dispersion;if(O.iridescence>0){if(D.iridescence.value=O.iridescence,D.iridescenceIOR.value=O.iridescenceIOR,D.iridescenceThicknessMinimum.value=O.iridescenceThicknessRange[0],D.iridescenceThicknessMaximum.value=O.iridescenceThicknessRange[1],O.iridescenceMap)D.iridescenceMap.value=O.iridescenceMap,$(O.iridescenceMap,D.iridescenceMapTransform);if(O.iridescenceThicknessMap)D.iridescenceThicknessMap.value=O.iridescenceThicknessMap,$(O.iridescenceThicknessMap,D.iridescenceThicknessMapTransform)}if(O.transmission>0){if(D.transmission.value=O.transmission,D.transmissionSamplerMap.value=b.texture,D.transmissionSamplerSize.value.set(b.width,b.height),O.transmissionMap)D.transmissionMap.value=O.transmissionMap,$(O.transmissionMap,D.transmissionMapTransform);if(D.thickness.value=O.thickness,O.thicknessMap)D.thicknessMap.value=O.thicknessMap,$(O.thicknessMap,D.thicknessMapTransform);D.attenuationDistance.value=O.attenuationDistance,D.attenuationColor.value.copy(O.attenuationColor)}if(O.anisotropy>0){if(D.anisotropyVector.value.set(O.anisotropy*Math.cos(O.anisotropyRotation),O.anisotropy*Math.sin(O.anisotropyRotation)),O.anisotropyMap)D.anisotropyMap.value=O.anisotropyMap,$(O.anisotropyMap,D.anisotropyMapTransform)}if(D.specularIntensity.value=O.specularIntensity,D.specularColor.value.copy(O.specularColor),O.specularColorMap)D.specularColorMap.value=O.specularColorMap,$(O.specularColorMap,D.specularColorMapTransform);if(O.specularIntensityMap)D.specularIntensityMap.value=O.specularIntensityMap,$(O.specularIntensityMap,D.specularIntensityMapTransform)}function T(D,O){if(O.matcap)D.matcap.value=O.matcap}function P(D,O){let b=_.get(O).light;D.referencePosition.value.setFromMatrixPosition(b.matrixWorld),D.nearDistance.value=b.shadow.camera.near,D.farDistance.value=b.shadow.camera.far}return{refreshFogUniforms:W,refreshMaterialUniforms:H}}function ik(F,_,$,W){let H={},Y={},K=[],G=F.getParameter(F.MAX_UNIFORM_BUFFER_BINDINGS);function U(b,k){let y=k.program;W.uniformBlockBinding(b,y)}function z(b,k){let y=H[b.id];if(y===void 0)T(b),y=h(b),H[b.id]=y,b.addEventListener("dispose",D);let m=k.program;W.updateUBOMapping(b,m);let x=_.render.frame;if(Y[b.id]!==x)N(b),Y[b.id]=x}function h(b){let k=A();b.__bindingPointIndex=k;let y=F.createBuffer(),m=b.__size,x=b.usage;return F.bindBuffer(F.UNIFORM_BUFFER,y),F.bufferData(F.UNIFORM_BUFFER,m,x),F.bindBuffer(F.UNIFORM_BUFFER,null),F.bindBufferBase(F.UNIFORM_BUFFER,k,y),y}function A(){for(let b=0;b<G;b++)if(K.indexOf(b)===-1)return K.push(b),b;return hF("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function N(b){let k=H[b.id],y=b.uniforms,m=b.__cache;F.bindBuffer(F.UNIFORM_BUFFER,k);for(let x=0,o=y.length;x<o;x++){let s=Array.isArray(y[x])?y[x]:[y[x]];for(let j=0,V=s.length;j<V;j++){let d=s[j];if(M(d,x,j,m)===!0){let $0=d.__offset,X0=Array.isArray(d.value)?d.value:[d.value],K0=0;for(let J0=0;J0<X0.length;J0++){let u=X0[J0],n=P(u);if(typeof u==="number"||typeof u==="boolean")d.__data[0]=u,F.bufferSubData(F.UNIFORM_BUFFER,$0+K0,d.__data);else if(u.isMatrix3)d.__data[0]=u.elements[0],d.__data[1]=u.elements[1],d.__data[2]=u.elements[2],d.__data[3]=0,d.__data[4]=u.elements[3],d.__data[5]=u.elements[4],d.__data[6]=u.elements[5],d.__data[7]=0,d.__data[8]=u.elements[6],d.__data[9]=u.elements[7],d.__data[10]=u.elements[8],d.__data[11]=0;else u.toArray(d.__data,K0),K0+=n.storage/Float32Array.BYTES_PER_ELEMENT}F.bufferSubData(F.UNIFORM_BUFFER,$0,d.__data)}}}F.bindBuffer(F.UNIFORM_BUFFER,null)}function M(b,k,y,m){let x=b.value,o=k+"_"+y;if(m[o]===void 0){if(typeof x==="number"||typeof x==="boolean")m[o]=x;else m[o]=x.clone();return!0}else{let s=m[o];if(typeof x==="number"||typeof x==="boolean"){if(s!==x)return m[o]=x,!0}else if(s.equals(x)===!1)return s.copy(x),!0}return!1}function T(b){let k=b.uniforms,y=0,m=16;for(let o=0,s=k.length;o<s;o++){let j=Array.isArray(k[o])?k[o]:[k[o]];for(let V=0,d=j.length;V<d;V++){let $0=j[V],X0=Array.isArray($0.value)?$0.value:[$0.value];for(let K0=0,J0=X0.length;K0<J0;K0++){let u=X0[K0],n=P(u),Q0=y%m,O0=Q0%n.boundary,t=Q0+O0;if(y+=O0,t!==0&&m-t<n.storage)y+=m-t;$0.__data=new Float32Array(n.storage/Float32Array.BYTES_PER_ELEMENT),$0.__offset=y,y+=n.storage}}}let x=y%m;if(x>0)y+=m-x;return b.__size=y,b.__cache={},this}function P(b){let k={boundary:0,storage:0};if(typeof b==="number"||typeof b==="boolean")k.boundary=4,k.storage=4;else if(b.isVector2)k.boundary=8,k.storage=8;else if(b.isVector3||b.isColor)k.boundary=16,k.storage=12;else if(b.isVector4)k.boundary=16,k.storage=16;else if(b.isMatrix3)k.boundary=48,k.storage=48;else if(b.isMatrix4)k.boundary=64,k.storage=64;else if(b.isTexture)zF("WebGLRenderer: Texture samplers can not be part of an uniforms group.");else zF("WebGLRenderer: Unsupported uniform value type.",b);return k}function D(b){let k=b.target;k.removeEventListener("dispose",D);let y=K.indexOf(k.__bindingPointIndex);K.splice(y,1),F.deleteBuffer(H[k.id]),delete H[k.id],delete Y[k.id]}function O(){for(let b in H)F.deleteBuffer(H[b]);K=[],H={},Y={}}return{bind:U,update:z,dispose:O}}var nk=new Uint16Array([12469,15057,12620,14925,13266,14620,13807,14376,14323,13990,14545,13625,14713,13328,14840,12882,14931,12528,14996,12233,15039,11829,15066,11525,15080,11295,15085,10976,15082,10705,15073,10495,13880,14564,13898,14542,13977,14430,14158,14124,14393,13732,14556,13410,14702,12996,14814,12596,14891,12291,14937,11834,14957,11489,14958,11194,14943,10803,14921,10506,14893,10278,14858,9960,14484,14039,14487,14025,14499,13941,14524,13740,14574,13468,14654,13106,14743,12678,14818,12344,14867,11893,14889,11509,14893,11180,14881,10751,14852,10428,14812,10128,14765,9754,14712,9466,14764,13480,14764,13475,14766,13440,14766,13347,14769,13070,14786,12713,14816,12387,14844,11957,14860,11549,14868,11215,14855,10751,14825,10403,14782,10044,14729,9651,14666,9352,14599,9029,14967,12835,14966,12831,14963,12804,14954,12723,14936,12564,14917,12347,14900,11958,14886,11569,14878,11247,14859,10765,14828,10401,14784,10011,14727,9600,14660,9289,14586,8893,14508,8533,15111,12234,15110,12234,15104,12216,15092,12156,15067,12010,15028,11776,14981,11500,14942,11205,14902,10752,14861,10393,14812,9991,14752,9570,14682,9252,14603,8808,14519,8445,14431,8145,15209,11449,15208,11451,15202,11451,15190,11438,15163,11384,15117,11274,15055,10979,14994,10648,14932,10343,14871,9936,14803,9532,14729,9218,14645,8742,14556,8381,14461,8020,14365,7603,15273,10603,15272,10607,15267,10619,15256,10631,15231,10614,15182,10535,15118,10389,15042,10167,14963,9787,14883,9447,14800,9115,14710,8665,14615,8318,14514,7911,14411,7507,14279,7198,15314,9675,15313,9683,15309,9712,15298,9759,15277,9797,15229,9773,15166,9668,15084,9487,14995,9274,14898,8910,14800,8539,14697,8234,14590,7790,14479,7409,14367,7067,14178,6621,15337,8619,15337,8631,15333,8677,15325,8769,15305,8871,15264,8940,15202,8909,15119,8775,15022,8565,14916,8328,14804,8009,14688,7614,14569,7287,14448,6888,14321,6483,14088,6171,15350,7402,15350,7419,15347,7480,15340,7613,15322,7804,15287,7973,15229,8057,15148,8012,15046,7846,14933,7611,14810,7357,14682,7069,14552,6656,14421,6316,14251,5948,14007,5528,15356,5942,15356,5977,15353,6119,15348,6294,15332,6551,15302,6824,15249,7044,15171,7122,15070,7050,14949,6861,14818,6611,14679,6349,14538,6067,14398,5651,14189,5311,13935,4958,15359,4123,15359,4153,15356,4296,15353,4646,15338,5160,15311,5508,15263,5829,15188,6042,15088,6094,14966,6001,14826,5796,14678,5543,14527,5287,14377,4985,14133,4586,13869,4257,15360,1563,15360,1642,15358,2076,15354,2636,15341,3350,15317,4019,15273,4429,15203,4732,15105,4911,14981,4932,14836,4818,14679,4621,14517,4386,14359,4156,14083,3795,13808,3437,15360,122,15360,137,15358,285,15355,636,15344,1274,15322,2177,15281,2765,15215,3223,15120,3451,14995,3569,14846,3567,14681,3466,14511,3305,14344,3121,14037,2800,13753,2467,15360,0,15360,1,15359,21,15355,89,15346,253,15325,479,15287,796,15225,1148,15133,1492,15008,1749,14856,1882,14685,1886,14506,1783,14324,1608,13996,1398,13702,1183]),S7=null;function ck(){if(S7===null)S7=new uU(nk,16,16,zZ,R9),S7.name="DFG_LUT",S7.minFilter=Y8,S7.magFilter=Y8,S7.wrapS=gw,S7.wrapT=gw,S7.generateMipmaps=!1,S7.needsUpdate=!0;return S7}class KB{constructor(F={}){let{canvas:_=Gf(),context:$=null,depth:W=!0,stencil:H=!1,alpha:Y=!1,antialias:K=!1,premultipliedAlpha:G=!0,preserveDrawingBuffer:U=!1,powerPreference:z="default",failIfMajorPerformanceCaveat:h=!1,reversedDepthBuffer:A=!1,outputBufferType:N=e8}=F;this.isWebGLRenderer=!0;let M;if($!==null){if(typeof WebGLRenderingContext<"u"&&$ instanceof WebGLRenderingContext)throw Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");M=$.getContextAttributes().alpha}else M=Y;let T=N,P=new Set([o5,s5,c5]),D=new Set([e8,Mq,NQ,BZ,i5,n5]),O=new Uint32Array(4),b=new Int32Array(4),k=null,y=null,m=[],x=[],o=null;this.domElement=_,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=t8,this.toneMappingExposure=1,this.transmissionResolutionScale=1;let s=this,j=!1;this._outputColorSpace=$f;let V=0,d=0,$0=null,X0=-1,K0=null,J0=new T1,u=new T1,n=null,Q0=new lF(0),O0=0,t=_.width,T0=_.height,g0=1,_F=null,c0=null,D0=new T1(0,0,t,T0),P0=new T1(0,0,t,T0),S0=!1,e0=new IQ,JF=!1,UF=!1,v0=new N1,PF=new w0,OF=new T1,jF={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0},t0=!1;function XF(){return $0===null?g0:1}let a=$;function C0(S,_0){return _.getContext(S,_0)}try{let S={alpha:!0,depth:W,stencil:H,antialias:K,premultipliedAlpha:G,preserveDrawingBuffer:U,powerPreference:z,failIfMajorPerformanceCaveat:h};if("setAttribute"in _)_.setAttribute("data-engine",`three.js r${NO}`);if(_.addEventListener("webglcontextlost",m0,!1),_.addEventListener("webglcontextrestored",$F,!1),_.addEventListener("webglcontextcreationerror",iF,!1),a===null){if(a=C0("webgl2",S),a===null)if(C0("webgl2"))throw Error("Error creating WebGL context with your selected attributes.");else throw Error("Error creating WebGL context.")}}catch(S){throw hF("WebGLRenderer: "+S.message),S}let AF,s0,j0,fF,v,E,Y0,q0,H0,W0,y0,E0,n0,ZF,V0,b0,a0,L,p,N0,g,h0,M0,L0;function I0(){if(AF=new FV(a),AF.init(),h0=new uk(a,AF),s0=new iP(a,AF,F,h0),j0=new xk(a,AF),s0.reversedDepthBuffer&&A)j0.buffers.depth.setReversed(!0);fF=new _V(a),v=new Ok,E=new gk(a,AF,j0,v,s0,h0,fF),Y0=new cP(s),q0=new eP(s),H0=new WE(a),M0=new lP(a,H0),W0=new qV(a,H0,fF,M0),y0=new $V(a,W0,H0,fF),p=new ZV(a,s0,E),b0=new nP(v),E0=new Mk(s,Y0,q0,AF,s0,M0,b0),n0=new dk(s,v),ZF=new Ik,V0=new Vk(AF),L=new mP(s,Y0,q0,j0,y0,M,G),a0=new bk(s,y0,s0),L0=new ik(a,fF,s0,j0),N0=new dP(a,AF,fF),g=new JV(a,AF,fF),fF.programs=E0.programs,s.capabilities=s0,s.extensions=AF,s.properties=v,s.renderLists=ZF,s.shadowMap=a0,s.state=j0,s.info=fF}if(I0(),T!==e8)o=new WV(T,_.width,_.height,W,H);let Z0=new F2(s,a);this.xr=Z0,this.getContext=function(){return a},this.getContextAttributes=function(){return a.getContextAttributes()},this.forceContextLoss=function(){let S=AF.get("WEBGL_lose_context");if(S)S.loseContext()},this.forceContextRestore=function(){let S=AF.get("WEBGL_lose_context");if(S)S.restoreContext()},this.getPixelRatio=function(){return g0},this.setPixelRatio=function(S){if(S===void 0)return;g0=S,this.setSize(t,T0,!1)},this.getSize=function(S){return S.set(t,T0)},this.setSize=function(S,_0,z0=!0){if(Z0.isPresenting){zF("WebGLRenderer: Can't change size while VR device is presenting.");return}if(t=S,T0=_0,_.width=Math.floor(S*g0),_.height=Math.floor(_0*g0),z0===!0)_.style.width=S+"px",_.style.height=_0+"px";if(o!==null)o.setSize(_.width,_.height);this.setViewport(0,0,S,_0)},this.getDrawingBufferSize=function(S){return S.set(t*g0,T0*g0).floor()},this.setDrawingBufferSize=function(S,_0,z0){t=S,T0=_0,g0=z0,_.width=Math.floor(S*z0),_.height=Math.floor(_0*z0),this.setViewport(0,0,S,_0)},this.setEffects=function(S){if(T===e8){console.error("THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.");return}if(S){for(let _0=0;_0<S.length;_0++)if(S[_0].isOutputPass===!0){console.warn("THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.");break}}o.setEffects(S||[])},this.getCurrentViewport=function(S){return S.copy(J0)},this.getViewport=function(S){return S.copy(D0)},this.setViewport=function(S,_0,z0,B0){if(S.isVector4)D0.set(S.x,S.y,S.z,S.w);else D0.set(S,_0,z0,B0);j0.viewport(J0.copy(D0).multiplyScalar(g0).round())},this.getScissor=function(S){return S.copy(P0)},this.setScissor=function(S,_0,z0,B0){if(S.isVector4)P0.set(S.x,S.y,S.z,S.w);else P0.set(S,_0,z0,B0);j0.scissor(u.copy(P0).multiplyScalar(g0).round())},this.getScissorTest=function(){return S0},this.setScissorTest=function(S){j0.setScissorTest(S0=S)},this.setOpaqueSort=function(S){_F=S},this.setTransparentSort=function(S){c0=S},this.getClearColor=function(S){return S.copy(L.getClearColor())},this.setClearColor=function(){L.setClearColor(...arguments)},this.getClearAlpha=function(){return L.getClearAlpha()},this.setClearAlpha=function(){L.setClearAlpha(...arguments)},this.clear=function(S=!0,_0=!0,z0=!0){let B0=0;if(S){let G0=!1;if($0!==null){let u0=$0.texture.format;G0=P.has(u0)}if(G0){let u0=$0.texture.type,o0=D.has(u0),l0=L.getClearColor(),r0=L.getClearAlpha(),FF=l0.r,GF=l0.g,wF=l0.b;if(o0)O[0]=FF,O[1]=GF,O[2]=wF,O[3]=r0,a.clearBufferuiv(a.COLOR,0,O);else b[0]=FF,b[1]=GF,b[2]=wF,b[3]=r0,a.clearBufferiv(a.COLOR,0,b)}else B0|=a.COLOR_BUFFER_BIT}if(_0)B0|=a.DEPTH_BUFFER_BIT;if(z0)B0|=a.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295);a.clear(B0)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){_.removeEventListener("webglcontextlost",m0,!1),_.removeEventListener("webglcontextrestored",$F,!1),_.removeEventListener("webglcontextcreationerror",iF,!1),L.dispose(),ZF.dispose(),V0.dispose(),v.dispose(),Y0.dispose(),q0.dispose(),y0.dispose(),M0.dispose(),L0.dispose(),E0.dispose(),Z0.dispose(),Z0.removeEventListener("sessionstart",kZ),Z0.removeEventListener("sessionend",iQ),y8.stop()};function m0(S){S.preventDefault(),kU("WebGLRenderer: Context Lost."),j=!0}function $F(){kU("WebGLRenderer: Context Restored."),j=!1;let S=fF.autoReset,_0=a0.enabled,z0=a0.autoUpdate,B0=a0.needsUpdate,G0=a0.type;I0(),fF.autoReset=S,a0.enabled=_0,a0.autoUpdate=z0,a0.needsUpdate=B0,a0.type=G0}function iF(S){hF("WebGLRenderer: A WebGL context could not be created. Reason: ",S.statusMessage)}function nF(S){let _0=S.target;_0.removeEventListener("dispose",nF),K8(_0)}function K8(S){y6(S),v.remove(S)}function y6(S){let _0=v.get(S).programs;if(_0!==void 0){if(_0.forEach(function(z0){E0.releaseProgram(z0)}),S.isShaderMaterial)E0.releaseShaderCache(S)}}this.renderBufferDirect=function(S,_0,z0,B0,G0,u0){if(_0===null)_0=jF;let o0=G0.isMesh&&G0.matrixWorld.determinant()<0,l0=nQ(S,_0,z0,B0,G0);j0.setMaterial(B0,o0);let r0=z0.index,FF=1;if(B0.wireframe===!0){if(r0=W0.getWireframeAttribute(z0),r0===void 0)return;FF=2}let GF=z0.drawRange,wF=z0.attributes.position,kF=GF.start*FF,tF=(GF.start+GF.count)*FF;if(u0!==null)kF=Math.max(kF,u0.start*FF),tF=Math.min(tF,(u0.start+u0.count)*FF);if(r0!==null)kF=Math.max(kF,0),tF=Math.min(tF,r0.count);else if(wF!==void 0&&wF!==null)kF=Math.max(kF,0),tF=Math.min(tF,wF.count);let K1=tF-kF;if(K1<0||K1===1/0)return;M0.setup(G0,B0,l0,z0,r0);let U1,q1=N0;if(r0!==null)U1=H0.get(r0),q1=g,q1.setIndex(U1);if(G0.isMesh)if(B0.wireframe===!0)j0.setLineWidth(B0.wireframeLinewidth*XF()),q1.setMode(a.LINES);else q1.setMode(a.TRIANGLES);else if(G0.isLine){let HF=B0.linewidth;if(HF===void 0)HF=1;if(j0.setLineWidth(HF*XF()),G0.isLineSegments)q1.setMode(a.LINES);else if(G0.isLineLoop)q1.setMode(a.LINE_LOOP);else q1.setMode(a.LINE_STRIP)}else if(G0.isPoints)q1.setMode(a.POINTS);else if(G0.isSprite)q1.setMode(a.TRIANGLES);if(G0.isBatchedMesh)if(G0._multiDrawInstances!==null)HZ("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),q1.renderMultiDrawInstances(G0._multiDrawStarts,G0._multiDrawCounts,G0._multiDrawCount,G0._multiDrawInstances);else if(!AF.get("WEBGL_multi_draw")){let{_multiDrawStarts:HF,_multiDrawCounts:rF,_multiDrawCount:sF}=G0,Y6=r0?H0.get(r0).bytesPerElement:1,J7=v.get(B0).currentProgram.getUniforms();for(let c1=0;c1<sF;c1++)J7.setValue(a,"_gl_DrawID",c1),q1.render(HF[c1]/Y6,rF[c1])}else q1.renderMultiDraw(G0._multiDrawStarts,G0._multiDrawCounts,G0._multiDrawCount);else if(G0.isInstancedMesh)q1.renderInstances(kF,K1,G0.count);else if(z0.isInstancedBufferGeometry){let HF=z0._maxInstanceCount!==void 0?z0._maxInstanceCount:1/0,rF=Math.min(z0.instanceCount,HF);q1.renderInstances(kF,K1,rF)}else q1.render(kF,K1)};function Cq(S,_0,z0){if(S.transparent===!0&&S.side===V7&&S.forceSinglePass===!1)S.side=w8,S.needsUpdate=!0,kq(S,_0,z0),S.side=XZ,S.needsUpdate=!0,kq(S,_0,z0),S.side=V7;else kq(S,_0,z0)}this.compile=function(S,_0,z0=null){if(z0===null)z0=S;if(y=V0.get(z0),y.init(_0),x.push(y),z0.traverseVisible(function(G0){if(G0.isLight&&G0.layers.test(_0.layers)){if(y.pushLight(G0),G0.castShadow)y.pushShadow(G0)}}),S!==z0)S.traverseVisible(function(G0){if(G0.isLight&&G0.layers.test(_0.layers)){if(y.pushLight(G0),G0.castShadow)y.pushShadow(G0)}});y.setupLights();let B0=new Set;return S.traverse(function(G0){if(!(G0.isMesh||G0.isPoints||G0.isLine||G0.isSprite))return;let u0=G0.material;if(u0)if(Array.isArray(u0))for(let o0=0;o0<u0.length;o0++){let l0=u0[o0];Cq(l0,z0,G0),B0.add(l0)}else Cq(u0,z0,G0),B0.add(u0)}),y=x.pop(),B0},this.compileAsync=function(S,_0,z0=null){let B0=this.compile(S,_0,z0);return new Promise((G0)=>{function u0(){if(B0.forEach(function(o0){if(v.get(o0).currentProgram.isReady())B0.delete(o0)}),B0.size===0){G0(S);return}setTimeout(u0,10)}if(AF.get("KHR_parallel_shader_compile")!==null)u0();else setTimeout(u0,10)})};let i6=null;function v6(S){if(i6)i6(S)}function kZ(){y8.stop()}function iQ(){y8.start()}let y8=new mf;if(y8.setAnimationLoop(v6),typeof self<"u")y8.setContext(self);this.setAnimationLoop=function(S){i6=S,Z0.setAnimationLoop(S),S===null?y8.stop():y8.start()},Z0.addEventListener("sessionstart",kZ),Z0.addEventListener("sessionend",iQ),this.render=function(S,_0){if(_0!==void 0&&_0.isCamera!==!0){hF("WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(j===!0)return;let z0=Z0.enabled===!0&&Z0.isPresenting===!0,B0=o!==null&&($0===null||z0)&&o.begin(s,$0);if(S.matrixWorldAutoUpdate===!0)S.updateMatrixWorld();if(_0.parent===null&&_0.matrixWorldAutoUpdate===!0)_0.updateMatrixWorld();if(Z0.enabled===!0&&Z0.isPresenting===!0&&(o===null||o.isCompositing()===!1)){if(Z0.cameraAutoUpdate===!0)Z0.updateCamera(_0);_0=Z0.getCamera()}if(S.isScene===!0)S.onBeforeRender(s,S,_0,$0);if(y=V0.get(S,x.length),y.init(_0),x.push(y),v0.multiplyMatrices(_0.projectionMatrix,_0.matrixWorldInverse),e0.setFromProjectionMatrix(v0,PU,_0.reversedDepth),UF=this.localClippingEnabled,JF=b0.init(this.clippingPlanes,UF),k=ZF.get(S,m.length),k.init(),m.push(k),Z0.enabled===!0&&Z0.isPresenting===!0){let o0=s.xr.getDepthSensingMesh();if(o0!==null)lJ(o0,_0,-1/0,s.sortObjects)}if(lJ(S,_0,0,s.sortObjects),k.finish(),s.sortObjects===!0)k.sort(_F,c0);if(t0=Z0.enabled===!1||Z0.isPresenting===!1||Z0.hasDepthSensing()===!1,t0)L.addToRenderList(k,S);if(this.info.render.frame++,JF===!0)b0.beginShadows();let G0=y.state.shadowsArray;if(a0.render(G0,S,_0),JF===!0)b0.endShadows();if(this.info.autoReset===!0)this.info.reset();if((B0&&o.hasRenderPass())===!1){let{opaque:o0,transmissive:l0}=k;if(y.setupLights(),_0.isArrayCamera){let r0=_0.cameras;if(l0.length>0)for(let FF=0,GF=r0.length;FF<GF;FF++){let wF=r0[FF];R6(o0,l0,S,wF)}if(t0)L.render(S);for(let FF=0,GF=r0.length;FF<GF;FF++){let wF=r0[FF];Pq(k,S,wF,wF.viewport)}}else{if(l0.length>0)R6(o0,l0,S,_0);if(t0)L.render(S);Pq(k,S,_0)}}if($0!==null&&d===0)E.updateMultisampleRenderTarget($0),E.updateRenderTargetMipmap($0);if(B0)o.end(s);if(S.isScene===!0)S.onAfterRender(s,S,_0);if(M0.resetDefaultState(),X0=-1,K0=null,x.pop(),x.length>0){if(y=x[x.length-1],JF===!0)b0.setGlobalState(s.clippingPlanes,y.state.camera)}else y=null;if(m.pop(),m.length>0)k=m[m.length-1];else k=null};function lJ(S,_0,z0,B0){if(S.visible===!1)return;if(S.layers.test(_0.layers)){if(S.isGroup)z0=S.renderOrder;else if(S.isLOD){if(S.autoUpdate===!0)S.update(_0)}else if(S.isLight){if(y.pushLight(S),S.castShadow)y.pushShadow(S)}else if(S.isSprite){if(!S.frustumCulled||e0.intersectsSprite(S)){if(B0)OF.setFromMatrixPosition(S.matrixWorld).applyMatrix4(v0);let o0=y0.update(S),l0=S.material;if(l0.visible)k.push(S,o0,l0,z0,OF.z,null)}}else if(S.isMesh||S.isLine||S.isPoints){if(!S.frustumCulled||e0.intersectsObject(S)){let o0=y0.update(S),l0=S.material;if(B0){if(S.boundingSphere!==void 0){if(S.boundingSphere===null)S.computeBoundingSphere();OF.copy(S.boundingSphere.center)}else{if(o0.boundingSphere===null)o0.computeBoundingSphere();OF.copy(o0.boundingSphere.center)}OF.applyMatrix4(S.matrixWorld).applyMatrix4(v0)}if(Array.isArray(l0)){let r0=o0.groups;for(let FF=0,GF=r0.length;FF<GF;FF++){let wF=r0[FF],kF=l0[wF.materialIndex];if(kF&&kF.visible)k.push(S,o0,kF,z0,OF.z,wF)}}else if(l0.visible)k.push(S,o0,l0,z0,OF.z,null)}}}let u0=S.children;for(let o0=0,l0=u0.length;o0<l0;o0++)lJ(u0[o0],_0,z0,B0)}function Pq(S,_0,z0,B0){let{opaque:G0,transmissive:u0,transparent:o0}=S;if(y.setupLightsView(z0),JF===!0)b0.setGlobalState(s.clippingPlanes,z0);if(B0)j0.viewport(J0.copy(B0));if(G0.length>0)Vq(G0,_0,z0);if(u0.length>0)Vq(u0,_0,z0);if(o0.length>0)Vq(o0,_0,z0);j0.buffers.depth.setTest(!0),j0.buffers.depth.setMask(!0),j0.buffers.color.setMask(!0),j0.setPolygonOffset(!1)}function R6(S,_0,z0,B0){if((z0.isScene===!0?z0.overrideMaterial:null)!==null)return;if(y.state.transmissionRenderTarget[B0.id]===void 0){let kF=AF.has("EXT_color_buffer_half_float")||AF.has("EXT_color_buffer_float");y.state.transmissionRenderTarget[B0.id]=new P8(1,1,{generateMipmaps:!0,type:kF?R9:e8,minFilter:UZ,samples:s0.samples,stencilBuffer:H,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:aF.workingColorSpace})}let u0=y.state.transmissionRenderTarget[B0.id],o0=B0.viewport||J0;u0.setSize(o0.z*s.transmissionResolutionScale,o0.w*s.transmissionResolutionScale);let l0=s.getRenderTarget(),r0=s.getActiveCubeFace(),FF=s.getActiveMipmapLevel();if(s.setRenderTarget(u0),s.getClearColor(Q0),O0=s.getClearAlpha(),O0<1)s.setClearColor(16777215,0.5);if(s.clear(),t0)L.render(z0);let GF=s.toneMapping;s.toneMapping=t8;let wF=B0.viewport;if(B0.viewport!==void 0)B0.viewport=void 0;if(y.setupLightsView(B0),JF===!0)b0.setGlobalState(s.clippingPlanes,B0);if(Vq(S,z0,B0),E.updateMultisampleRenderTarget(u0),E.updateRenderTargetMipmap(u0),AF.has("WEBGL_multisampled_render_to_texture")===!1){let kF=!1;for(let tF=0,K1=_0.length;tF<K1;tF++){let U1=_0[tF],{object:q1,geometry:HF,material:rF,group:sF}=U1;if(rF.side===V7&&q1.layers.test(B0.layers)){let Y6=rF.side;rF.side=w8,rF.needsUpdate=!0,dJ(q1,z0,B0,HF,rF,sF),rF.side=Y6,rF.needsUpdate=!0,kF=!0}}if(kF===!0)E.updateMultisampleRenderTarget(u0),E.updateRenderTargetMipmap(u0)}if(s.setRenderTarget(l0,r0,FF),s.setClearColor(Q0,O0),wF!==void 0)B0.viewport=wF;s.toneMapping=GF}function Vq(S,_0,z0){let B0=_0.isScene===!0?_0.overrideMaterial:null;for(let G0=0,u0=S.length;G0<u0;G0++){let o0=S[G0],{object:l0,geometry:r0,group:FF}=o0,GF=o0.material;if(GF.allowOverride===!0&&B0!==null)GF=B0;if(l0.layers.test(z0.layers))dJ(l0,_0,z0,r0,GF,FF)}}function dJ(S,_0,z0,B0,G0,u0){if(S.onBeforeRender(s,_0,z0,B0,G0,u0),S.modelViewMatrix.multiplyMatrices(z0.matrixWorldInverse,S.matrixWorld),S.normalMatrix.getNormalMatrix(S.modelViewMatrix),G0.onBeforeRender(s,_0,z0,B0,S,u0),G0.transparent===!0&&G0.side===V7&&G0.forceSinglePass===!1)G0.side=w8,G0.needsUpdate=!0,s.renderBufferDirect(z0,_0,B0,G0,S,u0),G0.side=XZ,G0.needsUpdate=!0,s.renderBufferDirect(z0,_0,B0,G0,S,u0),G0.side=V7;else s.renderBufferDirect(z0,_0,B0,G0,S,u0);S.onAfterRender(s,_0,z0,B0,G0,u0)}function kq(S,_0,z0){if(_0.isScene!==!0)_0=jF;let B0=v.get(S),G0=y.state.lights,u0=y.state.shadowsArray,o0=G0.state.version,l0=E0.getParameters(S,G0.state,u0,_0,z0),r0=E0.getProgramCacheKey(l0),FF=B0.programs;if(B0.environment=S.isMeshStandardMaterial?_0.environment:null,B0.fog=_0.fog,B0.envMap=(S.isMeshStandardMaterial?q0:Y0).get(S.envMap||B0.environment),B0.envMapRotation=B0.environment!==null&&S.envMap===null?_0.environmentRotation:S.envMapRotation,FF===void 0)S.addEventListener("dispose",nF),FF=new Map,B0.programs=FF;let GF=FF.get(r0);if(GF!==void 0){if(B0.currentProgram===GF&&B0.lightsStateVersion===o0)return SZ(S,l0),GF}else l0.uniforms=E0.getUniforms(S),S.onBeforeCompile(l0,s),GF=E0.acquireProgram(l0,r0),FF.set(r0,GF),B0.uniforms=l0.uniforms;let wF=B0.uniforms;if(!S.isShaderMaterial&&!S.isRawShaderMaterial||S.clipping===!0)wF.clippingPlanes=b0.uniform;if(SZ(S,l0),B0.needsLights=cQ(S),B0.lightsStateVersion=o0,B0.needsLights)wF.ambientLightColor.value=G0.state.ambient,wF.lightProbe.value=G0.state.probe,wF.directionalLights.value=G0.state.directional,wF.directionalLightShadows.value=G0.state.directionalShadow,wF.spotLights.value=G0.state.spot,wF.spotLightShadows.value=G0.state.spotShadow,wF.rectAreaLights.value=G0.state.rectArea,wF.ltc_1.value=G0.state.rectAreaLTC1,wF.ltc_2.value=G0.state.rectAreaLTC2,wF.pointLights.value=G0.state.point,wF.pointLightShadows.value=G0.state.pointShadow,wF.hemisphereLights.value=G0.state.hemi,wF.directionalShadowMap.value=G0.state.directionalShadowMap,wF.directionalShadowMatrix.value=G0.state.directionalShadowMatrix,wF.spotShadowMap.value=G0.state.spotShadowMap,wF.spotLightMatrix.value=G0.state.spotLightMatrix,wF.spotLightMap.value=G0.state.spotLightMap,wF.pointShadowMap.value=G0.state.pointShadowMap,wF.pointShadowMatrix.value=G0.state.pointShadowMatrix;return B0.currentProgram=GF,B0.uniformsList=null,GF}function iJ(S){if(S.uniformsList===null){let _0=S.currentProgram.getUniforms();S.uniformsList=yQ.seqWithValue(_0.seq,S.uniforms)}return S.uniformsList}function SZ(S,_0){let z0=v.get(S);z0.outputColorSpace=_0.outputColorSpace,z0.batching=_0.batching,z0.batchingColor=_0.batchingColor,z0.instancing=_0.instancing,z0.instancingColor=_0.instancingColor,z0.instancingMorph=_0.instancingMorph,z0.skinning=_0.skinning,z0.morphTargets=_0.morphTargets,z0.morphNormals=_0.morphNormals,z0.morphColors=_0.morphColors,z0.morphTargetsCount=_0.morphTargetsCount,z0.numClippingPlanes=_0.numClippingPlanes,z0.numIntersection=_0.numClipIntersection,z0.vertexAlphas=_0.vertexAlphas,z0.vertexTangents=_0.vertexTangents,z0.toneMapping=_0.toneMapping}function nQ(S,_0,z0,B0,G0){if(_0.isScene!==!0)_0=jF;E.resetTextureUnits();let u0=_0.fog,o0=B0.isMeshStandardMaterial?_0.environment:null,l0=$0===null?s.outputColorSpace:$0.isXRRenderTarget===!0?$0.texture.colorSpace:DQ,r0=(B0.isMeshStandardMaterial?q0:Y0).get(B0.envMap||o0),FF=B0.vertexColors===!0&&!!z0.attributes.color&&z0.attributes.color.itemSize===4,GF=!!z0.attributes.tangent&&(!!B0.normalMap||B0.anisotropy>0),wF=!!z0.morphAttributes.position,kF=!!z0.morphAttributes.normal,tF=!!z0.morphAttributes.color,K1=t8;if(B0.toneMapped){if($0===null||$0.isXRRenderTarget===!0)K1=s.toneMapping}let U1=z0.morphAttributes.position||z0.morphAttributes.normal||z0.morphAttributes.color,q1=U1!==void 0?U1.length:0,HF=v.get(B0),rF=y.state.lights;if(JF===!0){if(UF===!0||S!==K0){let P1=S===K0&&B0.id===X0;b0.setState(B0,S,P1)}}let sF=!1;if(B0.version===HF.__version){if(HF.needsLights&&HF.lightsStateVersion!==rF.state.version)sF=!0;else if(HF.outputColorSpace!==l0)sF=!0;else if(G0.isBatchedMesh&&HF.batching===!1)sF=!0;else if(!G0.isBatchedMesh&&HF.batching===!0)sF=!0;else if(G0.isBatchedMesh&&HF.batchingColor===!0&&G0.colorTexture===null)sF=!0;else if(G0.isBatchedMesh&&HF.batchingColor===!1&&G0.colorTexture!==null)sF=!0;else if(G0.isInstancedMesh&&HF.instancing===!1)sF=!0;else if(!G0.isInstancedMesh&&HF.instancing===!0)sF=!0;else if(G0.isSkinnedMesh&&HF.skinning===!1)sF=!0;else if(!G0.isSkinnedMesh&&HF.skinning===!0)sF=!0;else if(G0.isInstancedMesh&&HF.instancingColor===!0&&G0.instanceColor===null)sF=!0;else if(G0.isInstancedMesh&&HF.instancingColor===!1&&G0.instanceColor!==null)sF=!0;else if(G0.isInstancedMesh&&HF.instancingMorph===!0&&G0.morphTexture===null)sF=!0;else if(G0.isInstancedMesh&&HF.instancingMorph===!1&&G0.morphTexture!==null)sF=!0;else if(HF.envMap!==r0)sF=!0;else if(B0.fog===!0&&HF.fog!==u0)sF=!0;else if(HF.numClippingPlanes!==void 0&&(HF.numClippingPlanes!==b0.numPlanes||HF.numIntersection!==b0.numIntersection))sF=!0;else if(HF.vertexAlphas!==FF)sF=!0;else if(HF.vertexTangents!==GF)sF=!0;else if(HF.morphTargets!==wF)sF=!0;else if(HF.morphNormals!==kF)sF=!0;else if(HF.morphColors!==tF)sF=!0;else if(HF.toneMapping!==K1)sF=!0;else if(HF.morphTargetsCount!==q1)sF=!0}else sF=!0,HF.__version=B0.version;let Y6=HF.currentProgram;if(sF===!0)Y6=kq(B0,_0,G0);let J7=!1,c1=!1,v8=!1,$1=Y6.getUniforms(),_6=HF.uniforms;if(j0.useProgram(Y6.program))J7=!0,c1=!0,v8=!0;if(B0.id!==X0)X0=B0.id,c1=!0;if(J7||K0!==S){if(j0.buffers.depth.getReversed()&&S.reversedDepth!==!0)S._reversedDepth=!0,S.updateProjectionMatrix();$1.setValue(a,"projectionMatrix",S.projectionMatrix),$1.setValue(a,"viewMatrix",S.matrixWorldInverse);let Z6=$1.map.cameraPosition;if(Z6!==void 0)Z6.setValue(a,PF.setFromMatrixPosition(S.matrixWorld));if(s0.logarithmicDepthBuffer)$1.setValue(a,"logDepthBufFC",2/(Math.log(S.far+1)/Math.LN2));if(B0.isMeshPhongMaterial||B0.isMeshToonMaterial||B0.isMeshLambertMaterial||B0.isMeshBasicMaterial||B0.isMeshStandardMaterial||B0.isShaderMaterial)$1.setValue(a,"isOrthographic",S.isOrthographicCamera===!0);if(K0!==S)K0=S,c1=!0,v8=!0}if(HF.needsLights){if(rF.state.directionalShadowMap.length>0)$1.setValue(a,"directionalShadowMap",rF.state.directionalShadowMap,E);if(rF.state.spotShadowMap.length>0)$1.setValue(a,"spotShadowMap",rF.state.spotShadowMap,E);if(rF.state.pointShadowMap.length>0)$1.setValue(a,"pointShadowMap",rF.state.pointShadowMap,E)}if(G0.isSkinnedMesh){$1.setOptional(a,G0,"bindMatrix"),$1.setOptional(a,G0,"bindMatrixInverse");let P1=G0.skeleton;if(P1){if(P1.boneTexture===null)P1.computeBoneTexture();$1.setValue(a,"boneTexture",P1.boneTexture,E)}}if(G0.isBatchedMesh){if($1.setOptional(a,G0,"batchingTexture"),$1.setValue(a,"batchingTexture",G0._matricesTexture,E),$1.setOptional(a,G0,"batchingIdTexture"),$1.setValue(a,"batchingIdTexture",G0._indirectTexture,E),$1.setOptional(a,G0,"batchingColorTexture"),G0._colorsTexture!==null)$1.setValue(a,"batchingColorTexture",G0._colorsTexture,E)}let N6=z0.morphAttributes;if(N6.position!==void 0||N6.normal!==void 0||N6.color!==void 0)p.update(G0,z0,Y6);if(c1||HF.receiveShadow!==G0.receiveShadow)HF.receiveShadow=G0.receiveShadow,$1.setValue(a,"receiveShadow",G0.receiveShadow);if(B0.isMeshGouraudMaterial&&B0.envMap!==null)_6.envMap.value=r0,_6.flipEnvMap.value=r0.isCubeTexture&&r0.isRenderTargetTexture===!1?-1:1;if(B0.isMeshStandardMaterial&&B0.envMap===null&&_0.environment!==null)_6.envMapIntensity.value=_0.environmentIntensity;if(_6.dfgLUT!==void 0)_6.dfgLUT.value=ck();if(c1){if($1.setValue(a,"toneMappingExposure",s.toneMappingExposure),HF.needsLights)T9(_6,v8);if(u0&&B0.fog===!0)n0.refreshFogUniforms(_6,u0);n0.refreshMaterialUniforms(_6,B0,g0,T0,y.state.transmissionRenderTarget[S.id]),yQ.upload(a,iJ(HF),_6,E)}if(B0.isShaderMaterial&&B0.uniformsNeedUpdate===!0)yQ.upload(a,iJ(HF),_6,E),B0.uniformsNeedUpdate=!1;if(B0.isSpriteMaterial)$1.setValue(a,"center",G0.center);if($1.setValue(a,"modelViewMatrix",G0.modelViewMatrix),$1.setValue(a,"normalMatrix",G0.normalMatrix),$1.setValue(a,"modelMatrix",G0.matrixWorld),B0.isShaderMaterial||B0.isRawShaderMaterial){let P1=B0.uniformsGroups;for(let Z6=0,yZ=P1.length;Z6<yZ;Z6++){let x7=P1[Z6];L0.update(x7,Y6),L0.bind(x7,Y6)}}return Y6}function T9(S,_0){S.ambientLightColor.needsUpdate=_0,S.lightProbe.needsUpdate=_0,S.directionalLights.needsUpdate=_0,S.directionalLightShadows.needsUpdate=_0,S.pointLights.needsUpdate=_0,S.pointLightShadows.needsUpdate=_0,S.spotLights.needsUpdate=_0,S.spotLightShadows.needsUpdate=_0,S.rectAreaLights.needsUpdate=_0,S.hemisphereLights.needsUpdate=_0}function cQ(S){return S.isMeshLambertMaterial||S.isMeshToonMaterial||S.isMeshPhongMaterial||S.isMeshStandardMaterial||S.isShadowMaterial||S.isShaderMaterial&&S.lights===!0}this.getActiveCubeFace=function(){return V},this.getActiveMipmapLevel=function(){return d},this.getRenderTarget=function(){return $0},this.setRenderTargetTextures=function(S,_0,z0){let B0=v.get(S);if(B0.__autoAllocateDepthBuffer=S.resolveDepthBuffer===!1,B0.__autoAllocateDepthBuffer===!1)B0.__useRenderToTexture=!1;v.get(S.texture).__webglTexture=_0,v.get(S.depthTexture).__webglTexture=B0.__autoAllocateDepthBuffer?void 0:z0,B0.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(S,_0){let z0=v.get(S);z0.__webglFramebuffer=_0,z0.__useDefaultFramebuffer=_0===void 0};let sQ=a.createFramebuffer();this.setRenderTarget=function(S,_0=0,z0=0){$0=S,V=_0,d=z0;let B0=null,G0=!1,u0=!1;if(S){let l0=v.get(S);if(l0.__useDefaultFramebuffer!==void 0){j0.bindFramebuffer(a.FRAMEBUFFER,l0.__webglFramebuffer),J0.copy(S.viewport),u.copy(S.scissor),n=S.scissorTest,j0.viewport(J0),j0.scissor(u),j0.setScissorTest(n),X0=-1;return}else if(l0.__webglFramebuffer===void 0)E.setupRenderTarget(S);else if(l0.__hasExternalTextures)E.rebindTextures(S,v.get(S.texture).__webglTexture,v.get(S.depthTexture).__webglTexture);else if(S.depthBuffer){let GF=S.depthTexture;if(l0.__boundDepthTexture!==GF){if(GF!==null&&v.has(GF)&&(S.width!==GF.image.width||S.height!==GF.image.height))throw Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");E.setupDepthRenderbuffer(S)}}let r0=S.texture;if(r0.isData3DTexture||r0.isDataArrayTexture||r0.isCompressedArrayTexture)u0=!0;let FF=v.get(S).__webglFramebuffer;if(S.isWebGLCubeRenderTarget){if(Array.isArray(FF[_0]))B0=FF[_0][z0];else B0=FF[_0];G0=!0}else if(S.samples>0&&E.useMultisampledRTT(S)===!1)B0=v.get(S).__webglMultisampledFramebuffer;else if(Array.isArray(FF))B0=FF[z0];else B0=FF;J0.copy(S.viewport),u.copy(S.scissor),n=S.scissorTest}else J0.copy(D0).multiplyScalar(g0).floor(),u.copy(P0).multiplyScalar(g0).floor(),n=S0;if(z0!==0)B0=sQ;if(j0.bindFramebuffer(a.FRAMEBUFFER,B0))j0.drawBuffers(S,B0);if(j0.viewport(J0),j0.scissor(u),j0.setScissorTest(n),G0){let l0=v.get(S.texture);a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+_0,l0.__webglTexture,z0)}else if(u0){let l0=_0;for(let r0=0;r0<S.textures.length;r0++){let FF=v.get(S.textures[r0]);a.framebufferTextureLayer(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0+r0,FF.__webglTexture,z0,l0)}}else if(S!==null&&z0!==0){let l0=v.get(S.texture);a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,l0.__webglTexture,z0)}X0=-1},this.readRenderTargetPixels=function(S,_0,z0,B0,G0,u0,o0,l0=0){if(!(S&&S.isWebGLRenderTarget)){hF("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let r0=v.get(S).__webglFramebuffer;if(S.isWebGLCubeRenderTarget&&o0!==void 0)r0=r0[o0];if(r0){j0.bindFramebuffer(a.FRAMEBUFFER,r0);try{let FF=S.textures[l0],GF=FF.format,wF=FF.type;if(!s0.textureFormatReadable(GF)){hF("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!s0.textureTypeReadable(wF)){hF("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}if(_0>=0&&_0<=S.width-B0&&(z0>=0&&z0<=S.height-G0)){if(S.textures.length>1)a.readBuffer(a.COLOR_ATTACHMENT0+l0);a.readPixels(_0,z0,B0,G0,h0.convert(GF),h0.convert(wF),u0)}}finally{let FF=$0!==null?v.get($0).__webglFramebuffer:null;j0.bindFramebuffer(a.FRAMEBUFFER,FF)}}},this.readRenderTargetPixelsAsync=async function(S,_0,z0,B0,G0,u0,o0,l0=0){if(!(S&&S.isWebGLRenderTarget))throw Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let r0=v.get(S).__webglFramebuffer;if(S.isWebGLCubeRenderTarget&&o0!==void 0)r0=r0[o0];if(r0)if(_0>=0&&_0<=S.width-B0&&(z0>=0&&z0<=S.height-G0)){j0.bindFramebuffer(a.FRAMEBUFFER,r0);let FF=S.textures[l0],GF=FF.format,wF=FF.type;if(!s0.textureFormatReadable(GF))throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!s0.textureTypeReadable(wF))throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");let kF=a.createBuffer();if(a.bindBuffer(a.PIXEL_PACK_BUFFER,kF),a.bufferData(a.PIXEL_PACK_BUFFER,u0.byteLength,a.STREAM_READ),S.textures.length>1)a.readBuffer(a.COLOR_ATTACHMENT0+l0);a.readPixels(_0,z0,B0,G0,h0.convert(GF),h0.convert(wF),0);let tF=$0!==null?v.get($0).__webglFramebuffer:null;j0.bindFramebuffer(a.FRAMEBUFFER,tF);let K1=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);return a.flush(),await Kf(a,K1,4),a.bindBuffer(a.PIXEL_PACK_BUFFER,kF),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,u0),a.deleteBuffer(kF),a.deleteSync(K1),u0}else throw Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(S,_0=null,z0=0){let B0=Math.pow(2,-z0),G0=Math.floor(S.image.width*B0),u0=Math.floor(S.image.height*B0),o0=_0!==null?_0.x:0,l0=_0!==null?_0.y:0;E.setTexture2D(S,0),a.copyTexSubImage2D(a.TEXTURE_2D,z0,0,0,o0,l0,G0,u0),j0.unbindTexture()};let oQ=a.createFramebuffer(),aQ=a.createFramebuffer();if(this.copyTextureToTexture=function(S,_0,z0=null,B0=null,G0=0,u0=null){if(u0===null)if(G0!==0)HZ("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),u0=G0,G0=0;else u0=0;let o0,l0,r0,FF,GF,wF,kF,tF,K1,U1=S.isCompressedTexture?S.mipmaps[u0]:S.image;if(z0!==null)o0=z0.max.x-z0.min.x,l0=z0.max.y-z0.min.y,r0=z0.isBox3?z0.max.z-z0.min.z:1,FF=z0.min.x,GF=z0.min.y,wF=z0.isBox3?z0.min.z:0;else{let N6=Math.pow(2,-G0);if(o0=Math.floor(U1.width*N6),l0=Math.floor(U1.height*N6),S.isDataArrayTexture)r0=U1.depth;else if(S.isData3DTexture)r0=Math.floor(U1.depth*N6);else r0=1;FF=0,GF=0,wF=0}if(B0!==null)kF=B0.x,tF=B0.y,K1=B0.z;else kF=0,tF=0,K1=0;let q1=h0.convert(_0.format),HF=h0.convert(_0.type),rF;if(_0.isData3DTexture)E.setTexture3D(_0,0),rF=a.TEXTURE_3D;else if(_0.isDataArrayTexture||_0.isCompressedArrayTexture)E.setTexture2DArray(_0,0),rF=a.TEXTURE_2D_ARRAY;else E.setTexture2D(_0,0),rF=a.TEXTURE_2D;a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,_0.flipY),a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,_0.premultiplyAlpha),a.pixelStorei(a.UNPACK_ALIGNMENT,_0.unpackAlignment);let sF=a.getParameter(a.UNPACK_ROW_LENGTH),Y6=a.getParameter(a.UNPACK_IMAGE_HEIGHT),J7=a.getParameter(a.UNPACK_SKIP_PIXELS),c1=a.getParameter(a.UNPACK_SKIP_ROWS),v8=a.getParameter(a.UNPACK_SKIP_IMAGES);a.pixelStorei(a.UNPACK_ROW_LENGTH,U1.width),a.pixelStorei(a.UNPACK_IMAGE_HEIGHT,U1.height),a.pixelStorei(a.UNPACK_SKIP_PIXELS,FF),a.pixelStorei(a.UNPACK_SKIP_ROWS,GF),a.pixelStorei(a.UNPACK_SKIP_IMAGES,wF);let $1=S.isDataArrayTexture||S.isData3DTexture,_6=_0.isDataArrayTexture||_0.isData3DTexture;if(S.isDepthTexture){let N6=v.get(S),P1=v.get(_0),Z6=v.get(N6.__renderTarget),yZ=v.get(P1.__renderTarget);j0.bindFramebuffer(a.READ_FRAMEBUFFER,Z6.__webglFramebuffer),j0.bindFramebuffer(a.DRAW_FRAMEBUFFER,yZ.__webglFramebuffer);for(let x7=0;x7<r0;x7++){if($1)a.framebufferTextureLayer(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,v.get(S).__webglTexture,G0,wF+x7),a.framebufferTextureLayer(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0,v.get(_0).__webglTexture,u0,K1+x7);a.blitFramebuffer(FF,GF,o0,l0,kF,tF,o0,l0,a.DEPTH_BUFFER_BIT,a.NEAREST)}j0.bindFramebuffer(a.READ_FRAMEBUFFER,null),j0.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}else if(G0!==0||S.isRenderTargetTexture||v.has(S)){let N6=v.get(S),P1=v.get(_0);j0.bindFramebuffer(a.READ_FRAMEBUFFER,oQ),j0.bindFramebuffer(a.DRAW_FRAMEBUFFER,aQ);for(let Z6=0;Z6<r0;Z6++){if($1)a.framebufferTextureLayer(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,N6.__webglTexture,G0,wF+Z6);else a.framebufferTexture2D(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,N6.__webglTexture,G0);if(_6)a.framebufferTextureLayer(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0,P1.__webglTexture,u0,K1+Z6);else a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,P1.__webglTexture,u0);if(G0!==0)a.blitFramebuffer(FF,GF,o0,l0,kF,tF,o0,l0,a.COLOR_BUFFER_BIT,a.NEAREST);else if(_6)a.copyTexSubImage3D(rF,u0,kF,tF,K1+Z6,FF,GF,o0,l0);else a.copyTexSubImage2D(rF,u0,kF,tF,FF,GF,o0,l0)}j0.bindFramebuffer(a.READ_FRAMEBUFFER,null),j0.bindFramebuffer(a.DRAW_FRAMEBUFFER,null)}else if(_6)if(S.isDataTexture||S.isData3DTexture)a.texSubImage3D(rF,u0,kF,tF,K1,o0,l0,r0,q1,HF,U1.data);else if(_0.isCompressedArrayTexture)a.compressedTexSubImage3D(rF,u0,kF,tF,K1,o0,l0,r0,q1,U1.data);else a.texSubImage3D(rF,u0,kF,tF,K1,o0,l0,r0,q1,HF,U1);else if(S.isDataTexture)a.texSubImage2D(a.TEXTURE_2D,u0,kF,tF,o0,l0,q1,HF,U1.data);else if(S.isCompressedTexture)a.compressedTexSubImage2D(a.TEXTURE_2D,u0,kF,tF,U1.width,U1.height,q1,U1.data);else a.texSubImage2D(a.TEXTURE_2D,u0,kF,tF,o0,l0,q1,HF,U1);if(a.pixelStorei(a.UNPACK_ROW_LENGTH,sF),a.pixelStorei(a.UNPACK_IMAGE_HEIGHT,Y6),a.pixelStorei(a.UNPACK_SKIP_PIXELS,J7),a.pixelStorei(a.UNPACK_SKIP_ROWS,c1),a.pixelStorei(a.UNPACK_SKIP_IMAGES,v8),u0===0&&_0.generateMipmaps)a.generateMipmap(rF);j0.unbindTexture()},this.initRenderTarget=function(S){if(v.get(S).__webglFramebuffer===void 0)E.setupRenderTarget(S)},this.initTexture=function(S){if(S.isCubeTexture)E.setTextureCube(S,0);else if(S.isData3DTexture)E.setTexture3D(S,0);else if(S.isDataArrayTexture||S.isCompressedArrayTexture)E.setTexture2DArray(S,0);else E.setTexture2D(S,0);j0.unbindTexture()},this.resetState=function(){V=0,d=0,$0=null,j0.reset(),M0.reset()},typeof __THREE_DEVTOOLS__<"u")__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return PU}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(F){this._outputColorSpace=F;let _=this.getContext();_.drawingBufferColorSpace=aF._getDrawingBufferColorSpace(F),_.unpackColorSpace=aF._getUnpackColorSpace()}}var q2={type:"change"},BB={type:"start"},_2={type:"end"},UY=new TJ,J2=new a8,ok=Math.cos(70*yU.DEG2RAD),n1=new w0,d6=2*Math.PI,w1={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},UB=0.000001;class zB extends wY{constructor(F,_=null){super(F,_);if(this.state=w1.NONE,this.target=new w0,this.cursor=new w0,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=0.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:Rq.ROTATE,MIDDLE:Rq.DOLLY,RIGHT:Rq.PAN},this.touches={ONE:Nq.ROTATE,TWO:Nq.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new w0,this._lastQuaternion=new F7,this._lastTargetPosition=new w0,this._quat=new F7().setFromUnitVectors(F.up,new w0(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new PQ,this._sphericalDelta=new PQ,this._scale=1,this._panOffset=new w0,this._rotateStart=new DF,this._rotateEnd=new DF,this._rotateDelta=new DF,this._panStart=new DF,this._panEnd=new DF,this._panDelta=new DF,this._dollyStart=new DF,this._dollyEnd=new DF,this._dollyDelta=new DF,this._dollyDirection=new w0,this._mouse=new DF,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=rk.bind(this),this._onPointerDown=ak.bind(this),this._onPointerUp=tk.bind(this),this._onContextMenu=$S.bind(this),this._onMouseWheel=qS.bind(this),this._onKeyDown=JS.bind(this),this._onTouchStart=_S.bind(this),this._onTouchMove=ZS.bind(this),this._onMouseDown=ek.bind(this),this._onMouseMove=FS.bind(this),this._interceptControlDown=QS.bind(this),this._interceptControlUp=WS.bind(this),this.domElement!==null)this.connect(this.domElement);this.update()}connect(F){super.connect(F),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(F){F.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=F}stopListenToKeyEvents(){if(this._domElementKeyEvents!==null)this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(q2),this.update(),this.state=w1.NONE}update(F=null){let _=this.object.position;if(n1.copy(_).sub(this.target),n1.applyQuaternion(this._quat),this._spherical.setFromVector3(n1),this.autoRotate&&this.state===w1.NONE)this._rotateLeft(this._getAutoRotationAngle(F));if(this.enableDamping)this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor;else this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi;let $=this.minAzimuthAngle,W=this.maxAzimuthAngle;if(isFinite($)&&isFinite(W)){if($<-Math.PI)$+=d6;else if($>Math.PI)$-=d6;if(W<-Math.PI)W+=d6;else if(W>Math.PI)W-=d6;if($<=W)this._spherical.theta=Math.max($,Math.min(W,this._spherical.theta));else this._spherical.theta=this._spherical.theta>($+W)/2?Math.max($,this._spherical.theta):Math.min(W,this._spherical.theta)}if(this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),this.enableDamping===!0)this.target.addScaledVector(this._panOffset,this.dampingFactor);else this.target.add(this._panOffset);this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let H=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{let Y=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),H=Y!=this._spherical.radius}if(n1.setFromSpherical(this._spherical),n1.applyQuaternion(this._quatInverse),_.copy(this.target).add(n1),this.object.lookAt(this.target),this.enableDamping===!0)this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor);else this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0);if(this.zoomToCursor&&this._performCursorZoom){let Y=null;if(this.object.isPerspectiveCamera){let K=n1.length();Y=this._clampDistance(K*this._scale);let G=K-Y;this.object.position.addScaledVector(this._dollyDirection,G),this.object.updateMatrixWorld(),H=!!G}else if(this.object.isOrthographicCamera){let K=new w0(this._mouse.x,this._mouse.y,0);K.unproject(this.object);let G=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),H=G!==this.object.zoom;let U=new w0(this._mouse.x,this._mouse.y,0);U.unproject(this.object),this.object.position.sub(U).add(K),this.object.updateMatrixWorld(),Y=n1.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;if(Y!==null)if(this.screenSpacePanning)this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(Y).add(this.object.position);else if(UY.origin.copy(this.object.position),UY.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(UY.direction))<ok)this.object.lookAt(this.target);else J2.setFromNormalAndCoplanarPoint(this.object.up,this.target),UY.intersectPlane(J2,this.target)}else if(this.object.isOrthographicCamera){let Y=this.object.zoom;if(this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),Y!==this.object.zoom)this.object.updateProjectionMatrix(),H=!0}if(this._scale=1,this._performCursorZoom=!1,H||this._lastPosition.distanceToSquared(this.object.position)>UB||8*(1-this._lastQuaternion.dot(this.object.quaternion))>UB||this._lastTargetPosition.distanceToSquared(this.target)>UB)return this.dispatchEvent(q2),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0;return!1}_getAutoRotationAngle(F){if(F!==null)return d6/60*this.autoRotateSpeed*F;else return d6/60/60*this.autoRotateSpeed}_getZoomScale(F){let _=Math.abs(F*0.01);return Math.pow(0.95,this.zoomSpeed*_)}_rotateLeft(F){this._sphericalDelta.theta-=F}_rotateUp(F){this._sphericalDelta.phi-=F}_panLeft(F,_){n1.setFromMatrixColumn(_,0),n1.multiplyScalar(-F),this._panOffset.add(n1)}_panUp(F,_){if(this.screenSpacePanning===!0)n1.setFromMatrixColumn(_,1);else n1.setFromMatrixColumn(_,0),n1.crossVectors(this.object.up,n1);n1.multiplyScalar(F),this._panOffset.add(n1)}_pan(F,_){let $=this.domElement;if(this.object.isPerspectiveCamera){let W=this.object.position;n1.copy(W).sub(this.target);let H=n1.length();H*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*F*H/$.clientHeight,this.object.matrix),this._panUp(2*_*H/$.clientHeight,this.object.matrix)}else if(this.object.isOrthographicCamera)this._panLeft(F*(this.object.right-this.object.left)/this.object.zoom/$.clientWidth,this.object.matrix),this._panUp(_*(this.object.top-this.object.bottom)/this.object.zoom/$.clientHeight,this.object.matrix);else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1}_dollyOut(F){if(this.object.isPerspectiveCamera||this.object.isOrthographicCamera)this._scale/=F;else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1}_dollyIn(F){if(this.object.isPerspectiveCamera||this.object.isOrthographicCamera)this._scale*=F;else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1}_updateZoomParameters(F,_){if(!this.zoomToCursor)return;this._performCursorZoom=!0;let $=this.domElement.getBoundingClientRect(),W=F-$.left,H=_-$.top,Y=$.width,K=$.height;this._mouse.x=W/Y*2-1,this._mouse.y=-(H/K)*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(F){return Math.max(this.minDistance,Math.min(this.maxDistance,F))}_handleMouseDownRotate(F){this._rotateStart.set(F.clientX,F.clientY)}_handleMouseDownDolly(F){this._updateZoomParameters(F.clientX,F.clientX),this._dollyStart.set(F.clientX,F.clientY)}_handleMouseDownPan(F){this._panStart.set(F.clientX,F.clientY)}_handleMouseMoveRotate(F){this._rotateEnd.set(F.clientX,F.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);let _=this.domElement;this._rotateLeft(d6*this._rotateDelta.x/_.clientHeight),this._rotateUp(d6*this._rotateDelta.y/_.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(F){if(this._dollyEnd.set(F.clientX,F.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0)this._dollyOut(this._getZoomScale(this._dollyDelta.y));else if(this._dollyDelta.y<0)this._dollyIn(this._getZoomScale(this._dollyDelta.y));this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(F){this._panEnd.set(F.clientX,F.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(F){if(this._updateZoomParameters(F.clientX,F.clientY),F.deltaY<0)this._dollyIn(this._getZoomScale(F.deltaY));else if(F.deltaY>0)this._dollyOut(this._getZoomScale(F.deltaY));this.update()}_handleKeyDown(F){let _=!1;switch(F.code){case this.keys.UP:if(F.ctrlKey||F.metaKey||F.shiftKey){if(this.enableRotate)this._rotateUp(d6*this.keyRotateSpeed/this.domElement.clientHeight)}else if(this.enablePan)this._pan(0,this.keyPanSpeed);_=!0;break;case this.keys.BOTTOM:if(F.ctrlKey||F.metaKey||F.shiftKey){if(this.enableRotate)this._rotateUp(-d6*this.keyRotateSpeed/this.domElement.clientHeight)}else if(this.enablePan)this._pan(0,-this.keyPanSpeed);_=!0;break;case this.keys.LEFT:if(F.ctrlKey||F.metaKey||F.shiftKey){if(this.enableRotate)this._rotateLeft(d6*this.keyRotateSpeed/this.domElement.clientHeight)}else if(this.enablePan)this._pan(this.keyPanSpeed,0);_=!0;break;case this.keys.RIGHT:if(F.ctrlKey||F.metaKey||F.shiftKey){if(this.enableRotate)this._rotateLeft(-d6*this.keyRotateSpeed/this.domElement.clientHeight)}else if(this.enablePan)this._pan(-this.keyPanSpeed,0);_=!0;break}if(_)F.preventDefault(),this.update()}_handleTouchStartRotate(F){if(this._pointers.length===1)this._rotateStart.set(F.pageX,F.pageY);else{let _=this._getSecondPointerPosition(F),$=0.5*(F.pageX+_.x),W=0.5*(F.pageY+_.y);this._rotateStart.set($,W)}}_handleTouchStartPan(F){if(this._pointers.length===1)this._panStart.set(F.pageX,F.pageY);else{let _=this._getSecondPointerPosition(F),$=0.5*(F.pageX+_.x),W=0.5*(F.pageY+_.y);this._panStart.set($,W)}}_handleTouchStartDolly(F){let _=this._getSecondPointerPosition(F),$=F.pageX-_.x,W=F.pageY-_.y,H=Math.sqrt($*$+W*W);this._dollyStart.set(0,H)}_handleTouchStartDollyPan(F){if(this.enableZoom)this._handleTouchStartDolly(F);if(this.enablePan)this._handleTouchStartPan(F)}_handleTouchStartDollyRotate(F){if(this.enableZoom)this._handleTouchStartDolly(F);if(this.enableRotate)this._handleTouchStartRotate(F)}_handleTouchMoveRotate(F){if(this._pointers.length==1)this._rotateEnd.set(F.pageX,F.pageY);else{let $=this._getSecondPointerPosition(F),W=0.5*(F.pageX+$.x),H=0.5*(F.pageY+$.y);this._rotateEnd.set(W,H)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);let _=this.domElement;this._rotateLeft(d6*this._rotateDelta.x/_.clientHeight),this._rotateUp(d6*this._rotateDelta.y/_.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(F){if(this._pointers.length===1)this._panEnd.set(F.pageX,F.pageY);else{let _=this._getSecondPointerPosition(F),$=0.5*(F.pageX+_.x),W=0.5*(F.pageY+_.y);this._panEnd.set($,W)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(F){let _=this._getSecondPointerPosition(F),$=F.pageX-_.x,W=F.pageY-_.y,H=Math.sqrt($*$+W*W);this._dollyEnd.set(0,H),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);let Y=(F.pageX+_.x)*0.5,K=(F.pageY+_.y)*0.5;this._updateZoomParameters(Y,K)}_handleTouchMoveDollyPan(F){if(this.enableZoom)this._handleTouchMoveDolly(F);if(this.enablePan)this._handleTouchMovePan(F)}_handleTouchMoveDollyRotate(F){if(this.enableZoom)this._handleTouchMoveDolly(F);if(this.enableRotate)this._handleTouchMoveRotate(F)}_addPointer(F){this._pointers.push(F.pointerId)}_removePointer(F){delete this._pointerPositions[F.pointerId];for(let _=0;_<this._pointers.length;_++)if(this._pointers[_]==F.pointerId){this._pointers.splice(_,1);return}}_isTrackingPointer(F){for(let _=0;_<this._pointers.length;_++)if(this._pointers[_]==F.pointerId)return!0;return!1}_trackPointer(F){let _=this._pointerPositions[F.pointerId];if(_===void 0)_=new DF,this._pointerPositions[F.pointerId]=_;_.set(F.pageX,F.pageY)}_getSecondPointerPosition(F){let _=F.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[_]}_customWheelEvent(F){let _=F.deltaMode,$={clientX:F.clientX,clientY:F.clientY,deltaY:F.deltaY};switch(_){case 1:$.deltaY*=16;break;case 2:$.deltaY*=100;break}if(F.ctrlKey&&!this._controlActive)$.deltaY*=10;return $}}function ak(F){if(this.enabled===!1)return;if(this._pointers.length===0)this.domElement.setPointerCapture(F.pointerId),this.domElement.ownerDocument.addEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.addEventListener("pointerup",this._onPointerUp);if(this._isTrackingPointer(F))return;if(this._addPointer(F),F.pointerType==="touch")this._onTouchStart(F);else this._onMouseDown(F)}function rk(F){if(this.enabled===!1)return;if(F.pointerType==="touch")this._onTouchMove(F);else this._onMouseMove(F)}function tk(F){switch(this._removePointer(F),this._pointers.length){case 0:this.domElement.releasePointerCapture(F.pointerId),this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(_2),this.state=w1.NONE;break;case 1:let _=this._pointers[0],$=this._pointerPositions[_];this._onTouchStart({pointerId:_,pageX:$.x,pageY:$.y});break}}function ek(F){let _;switch(F.button){case 0:_=this.mouseButtons.LEFT;break;case 1:_=this.mouseButtons.MIDDLE;break;case 2:_=this.mouseButtons.RIGHT;break;default:_=-1}switch(_){case Rq.DOLLY:if(this.enableZoom===!1)return;this._handleMouseDownDolly(F),this.state=w1.DOLLY;break;case Rq.ROTATE:if(F.ctrlKey||F.metaKey||F.shiftKey){if(this.enablePan===!1)return;this._handleMouseDownPan(F),this.state=w1.PAN}else{if(this.enableRotate===!1)return;this._handleMouseDownRotate(F),this.state=w1.ROTATE}break;case Rq.PAN:if(F.ctrlKey||F.metaKey||F.shiftKey){if(this.enableRotate===!1)return;this._handleMouseDownRotate(F),this.state=w1.ROTATE}else{if(this.enablePan===!1)return;this._handleMouseDownPan(F),this.state=w1.PAN}break;default:this.state=w1.NONE}if(this.state!==w1.NONE)this.dispatchEvent(BB)}function FS(F){switch(this.state){case w1.ROTATE:if(this.enableRotate===!1)return;this._handleMouseMoveRotate(F);break;case w1.DOLLY:if(this.enableZoom===!1)return;this._handleMouseMoveDolly(F);break;case w1.PAN:if(this.enablePan===!1)return;this._handleMouseMovePan(F);break}}function qS(F){if(this.enabled===!1||this.enableZoom===!1||this.state!==w1.NONE)return;F.preventDefault(),this.dispatchEvent(BB),this._handleMouseWheel(this._customWheelEvent(F)),this.dispatchEvent(_2)}function JS(F){if(this.enabled===!1)return;this._handleKeyDown(F)}function _S(F){switch(this._trackPointer(F),this._pointers.length){case 1:switch(this.touches.ONE){case Nq.ROTATE:if(this.enableRotate===!1)return;this._handleTouchStartRotate(F),this.state=w1.TOUCH_ROTATE;break;case Nq.PAN:if(this.enablePan===!1)return;this._handleTouchStartPan(F),this.state=w1.TOUCH_PAN;break;default:this.state=w1.NONE}break;case 2:switch(this.touches.TWO){case Nq.DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchStartDollyPan(F),this.state=w1.TOUCH_DOLLY_PAN;break;case Nq.DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchStartDollyRotate(F),this.state=w1.TOUCH_DOLLY_ROTATE;break;default:this.state=w1.NONE}break;default:this.state=w1.NONE}if(this.state!==w1.NONE)this.dispatchEvent(BB)}function ZS(F){switch(this._trackPointer(F),this.state){case w1.TOUCH_ROTATE:if(this.enableRotate===!1)return;this._handleTouchMoveRotate(F),this.update();break;case w1.TOUCH_PAN:if(this.enablePan===!1)return;this._handleTouchMovePan(F),this.update();break;case w1.TOUCH_DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchMoveDollyPan(F),this.update();break;case w1.TOUCH_DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchMoveDollyRotate(F),this.update();break;default:this.state=w1.NONE}}function $S(F){if(this.enabled===!1)return;F.preventDefault()}function QS(F){if(F.key==="Control")this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0})}function WS(F){if(F.key==="Control")this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0})}var VZ=U6(d_(),1);var MB={};Qw(MB,{unescapeMd:()=>yS,unescapeAll:()=>M9,normalizeReference:()=>xJ,lib:()=>pS,isWhiteSpace:()=>vJ,isValidEntityCode:()=>IY,isString:()=>fY,isSpace:()=>dF,isPunctChar:()=>bJ,isMdAsciiPunct:()=>jJ,has:()=>CS,fromCodePoint:()=>jQ,escapeRE:()=>uS,escapeHtml:()=>O9,assign:()=>IZ,arrayReplaceAt:()=>DB});var RY={};Qw(RY,{parse:()=>bQ,format:()=>OZ,encode:()=>AY,decode:()=>vQ});var Z2={};function HS(F){let _=Z2[F];if(_)return _;_=Z2[F]=[];for(let $=0;$<128;$++){let W=String.fromCharCode($);_.push(W)}for(let $=0;$<F.length;$++){let W=F.charCodeAt($);_[W]="%"+("0"+W.toString(16).toUpperCase()).slice(-2)}return _}function BY(F,_){if(typeof _!=="string")_=BY.defaultChars;let $=HS(_);return F.replace(/(%[a-f0-9]{2})+/gi,function(W){let H="";for(let Y=0,K=W.length;Y<K;Y+=3){let G=parseInt(W.slice(Y+1,Y+3),16);if(G<128){H+=$[G];continue}if((G&224)===192&&Y+3<K){let U=parseInt(W.slice(Y+4,Y+6),16);if((U&192)===128){let z=G<<6&1984|U&63;if(z<128)H+="";else H+=String.fromCharCode(z);Y+=3;continue}}if((G&240)===224&&Y+6<K){let U=parseInt(W.slice(Y+4,Y+6),16),z=parseInt(W.slice(Y+7,Y+9),16);if((U&192)===128&&(z&192)===128){let h=G<<12&61440|U<<6&4032|z&63;if(h<2048||h>=55296&&h<=57343)H+="";else H+=String.fromCharCode(h);Y+=6;continue}}if((G&248)===240&&Y+9<K){let U=parseInt(W.slice(Y+4,Y+6),16),z=parseInt(W.slice(Y+7,Y+9),16),h=parseInt(W.slice(Y+10,Y+12),16);if((U&192)===128&&(z&192)===128&&(h&192)===128){let A=G<<18&1835008|U<<12&258048|z<<6&4032|h&63;if(A<65536||A>1114111)H+="";else A-=65536,H+=String.fromCharCode(55296+(A>>10),56320+(A&1023));Y+=9;continue}}H+=""}return H})}BY.defaultChars=";/?:@&=+$,#";BY.componentChars="";var vQ=BY;var $2={};function wS(F){let _=$2[F];if(_)return _;_=$2[F]=[];for(let $=0;$<128;$++){let W=String.fromCharCode($);if(/^[0-9a-z]$/i.test(W))_.push(W);else _.push("%"+("0"+$.toString(16).toUpperCase()).slice(-2))}for(let $=0;$<F.length;$++)_[F.charCodeAt($)]=F[$];return _}function zY(F,_,$){if(typeof _!=="string")$=_,_=zY.defaultChars;if(typeof $>"u")$=!0;let W=wS(_),H="";for(let Y=0,K=F.length;Y<K;Y++){let G=F.charCodeAt(Y);if($&&G===37&&Y+2<K){if(/^[0-9a-f]{2}$/i.test(F.slice(Y+1,Y+3))){H+=F.slice(Y,Y+3),Y+=2;continue}}if(G<128){H+=W[G];continue}if(G>=55296&&G<=57343){if(G>=55296&&G<=56319&&Y+1<K){let U=F.charCodeAt(Y+1);if(U>=56320&&U<=57343){H+=encodeURIComponent(F[Y]+F[Y+1]),Y++;continue}}H+="%EF%BF%BD";continue}H+=encodeURIComponent(F[Y])}return H}zY.defaultChars=";/?:@&=+$,-_.!~*'()#";zY.componentChars="-_.!~*'()";var AY=zY;function OZ(F){let _="";if(_+=F.protocol||"",_+=F.slashes?"//":"",_+=F.auth?F.auth+"@":"",F.hostname&&F.hostname.indexOf(":")!==-1)_+="["+F.hostname+"]";else _+=F.hostname||"";return _+=F.port?":"+F.port:"",_+=F.pathname||"",_+=F.search||"",_+=F.hash||"",_}function hY(){this.protocol=null,this.slashes=null,this.auth=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.pathname=null}var YS=/^([a-z0-9.+-]+:)/i,XS=/:[0-9]*$/,GS=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,KS=["<",">",'"',"`"," ","\r",`
`,"\t"],US=["{","}","|","\\","^","`"].concat(KS),BS=["'"].concat(US),Q2=["%","/","?",";","#"].concat(BS),W2=["/","?","#"],zS=255,H2=/^[+a-z0-9A-Z_-]{0,63}$/,AS=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,w2={javascript:!0,"javascript:":!0},Y2={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0};function hS(F,_){if(F&&F instanceof hY)return F;let $=new hY;return $.parse(F,_),$}hY.prototype.parse=function(F,_){let $,W,H,Y=F;if(Y=Y.trim(),!_&&F.split("#").length===1){let z=GS.exec(Y);if(z){if(this.pathname=z[1],z[2])this.search=z[2];return this}}let K=YS.exec(Y);if(K)K=K[0],$=K.toLowerCase(),this.protocol=K,Y=Y.substr(K.length);if(_||K||Y.match(/^\/\/[^@\/]+@[^@\/]+/)){if(H=Y.substr(0,2)==="//",H&&!(K&&w2[K]))Y=Y.substr(2),this.slashes=!0}if(!w2[K]&&(H||K&&!Y2[K])){let z=-1;for(let T=0;T<W2.length;T++)if(W=Y.indexOf(W2[T]),W!==-1&&(z===-1||W<z))z=W;let h,A;if(z===-1)A=Y.lastIndexOf("@");else A=Y.lastIndexOf("@",z);if(A!==-1)h=Y.slice(0,A),Y=Y.slice(A+1),this.auth=h;z=-1;for(let T=0;T<Q2.length;T++)if(W=Y.indexOf(Q2[T]),W!==-1&&(z===-1||W<z))z=W;if(z===-1)z=Y.length;if(Y[z-1]===":")z--;let N=Y.slice(0,z);Y=Y.slice(z),this.parseHost(N),this.hostname=this.hostname||"";let M=this.hostname[0]==="["&&this.hostname[this.hostname.length-1]==="]";if(!M){let T=this.hostname.split(/\./);for(let P=0,D=T.length;P<D;P++){let O=T[P];if(!O)continue;if(!O.match(H2)){let b="";for(let k=0,y=O.length;k<y;k++)if(O.charCodeAt(k)>127)b+="x";else b+=O[k];if(!b.match(H2)){let k=T.slice(0,P),y=T.slice(P+1),m=O.match(AS);if(m)k.push(m[1]),y.unshift(m[2]);if(y.length)Y=y.join(".")+Y;this.hostname=k.join(".");break}}}}if(this.hostname.length>zS)this.hostname="";if(M)this.hostname=this.hostname.substr(1,this.hostname.length-2)}let G=Y.indexOf("#");if(G!==-1)this.hash=Y.substr(G),Y=Y.slice(0,G);let U=Y.indexOf("?");if(U!==-1)this.search=Y.substr(U),Y=Y.slice(0,U);if(Y)this.pathname=Y;if(Y2[$]&&this.hostname&&!this.pathname)this.pathname="";return this};hY.prototype.parseHost=function(F){let _=XS.exec(F);if(_){if(_=_[0],_!==":")this.port=_.substr(1);F=F.substr(0,F.length-_.length)}if(F)this.hostname=F};var bQ=hS;var AB={};Qw(AB,{Z:()=>OY,S:()=>MY,P:()=>fZ,Cf:()=>X2,Cc:()=>DY,Any:()=>NY});var NY=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;var DY=/[\0-\x1F\x7F-\x9F]/;var X2=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;var fZ=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;var MY=/[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;var OY=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;var G2=new Uint16Array("<\x00\x00\x00\x00\x00\x00EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;\uD835\uDD04ravepha;acr;d;gpon;f;\uD835\uDD38plyFunction;ingcsr;\uD835\uDC9Cign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;\uD835\uDD05pf;\uD835\uDD39eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;\uD835\uDC9Ep;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;\uD835\uDD07afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\x00\x00\x00\x00f;\uD835\uDD3B;DEot;qual;bleCDLRUVontourIntegrao\x00\x00nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\x00\x00rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\x00\x00ightVector;eeVector;ector;Bar;ight\x00eeVector;ector;Bar;ee;Arrow;ctr;\uD835\uDC9Frok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;\uD835\uDD08raveement;apcr;ty\x00\x00mallSquare;erySmallSquare;gpon;f;\uD835\uDD3Csilon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;\uD835\uDD09lled\x00\x00mallSquare;erySmallSquare;\x00\x00\x00f;\uD835\uDD3DAll;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;\uD835\uDD0A;pf;\uD835\uDD3EeaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;\uD835\uDCA2;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\x00f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\x00;egrral;section;isibleCTomma;imes;gpton;f;\uD835\uDD40a;cr;ilde;\x00cy;lcfosuiyrc;;r;\uD835\uDD0Dpf;\uD835\uDD41\x00r;\uD835\uDCA5rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;\uD835\uDD0Epf;\uD835\uDD42cr;\uD835\uDCA6JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\x00bleBracket;n\x00eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;\uD835\uDD0F;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;\uD835\uDD43erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;\uD835\uDD10nusPlus;pf;\uD835\uDD44c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;\uD835\uDD11Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;\uD835\uDCA9ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;\uD835\uDD12raveaeicr;ga;cron;pf;\uD835\uDD46enCurlyDQoubleQuote;uote;;clr;\uD835\uDCAAashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;\uD835\uDD13i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;\uD835\uDCAB;UfosOT\"r;\uD835\uDD14pf;cr;\uD835\uDCACBEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\x00bleBracket;n\x00eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;\uD835\uDD16ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\uD835\uDD4A\x00\x00t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;\uD835\uDCAEar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;\uD835\uDD17ei\x00efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;\uD835\uDD4BipleDot;ctr;\uD835\uDCAFrok;\x00\x00\x00\x00\x00\x00\x00cruter;ocir;r\x00y;ve;iyrc;blac;r;\uD835\uDD18raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;\uD835\uDD4CADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;\uD835\uDCB0ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;\uD835\uDD19pf;\uD835\uDD4Dcr;\uD835\uDCB1dash;cefosirc;dge;r;\uD835\uDD1Apf;\uD835\uDD4Ecr;\uD835\uDCB2fiosr;\uD835\uDD1B;pf;\uD835\uDD4Fcr;\uD835\uDCB3AIUacfosucy;cy;cy;cuteiyrc;;r;\uD835\uDD1Cpf;\uD835\uDD50cr;\uD835\uDCB4ml;Hacdefoscy;cute;ayron;;ot;\x00oWidta;r;pf;cr;\uD835\uDCB5\x00\x00\x00\x00\x00\x00\x00cutereve;;Ediuy;;rcte;lig;r;\uD835\uDD1Eraveepfpsym;ha;apcclr;g;\x00\x00;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;\uD835\uDD52;Eaeiop;cir;;d;s;rox;eingctyr;\uD835\uDCB6;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;\uD835\uDD1Fgcostuvwaiurc;pdptot;lus;imes;\x00\x00cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\x00\x00;;4;ck;eo;q=uiv;t;ptwxf;\uD835\uDD53;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;\uD835\uDCB7mi;m;el;bh;sub;l;etp;Ee;;q\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\x00s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;\uD835\uDD20ceiy;ck;mark;r;Ecefms;;elq;e\x00\x00rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\x00on;e;q\x00\x00a;t;;flemxente\x00;dot;nfry;\uD835\uDD54o;sr;aorr;ss;cur;\uD835\uDCB8bp;e;;e;dot;delprvwarrlr;;\x00\x00r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\x00\x00reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;\uD835\uDD21arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\x00\x00rn;op;lptuwlar;f;\uD835\uDD55;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\x00\x00rn;op;cotry;\uD835\uDCB9;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;\uD835\uDD22;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;\uD835\uDD56alsr;sl;us;i;lvon;csuviorc\x00\x00antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\x00\x00\x00\x00\x00\x00\x00llingdotsey;male;ilrlig;\x00\x00g;ig;;\uD835\uDD23lig;lig;fjaltt;ig;ns;of;\x00f;\uD835\uDD57ak;v;artint;aocs\x00\x00;;;;\x00;;\x00\x00;;5;\x00;;8;l;wn;cr;\uD835\uDCBBEabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;\uD835\uDD24;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;\uD835\uDD58cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\x00pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;\uD835\uDD25sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;\uD835\uDD59bar;cltr;\uD835\uDCBDasrok;bpull;hen\x00\x00\x00\x00\x00\x00cute;iyrc;cxy;clfr;\uD835\uDD26rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;\uD835\uDD5Aa;uestcir;\uD835\uDCBEn;Edsv;ot;;v;;ilde;\x00cy;lcfmosuiyrc;;r;\uD835\uDD27ath;pf;\uD835\uDD5B\x00r;\uD835\uDCBFrcy;kcy;acfghjosppa;v;eydil;;r;\uD835\uDD28reen;cy;cy;pf;\uD835\uDD5Ccr;\uD835\uDCC0ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\x00\x00\x00\x00\x00\x00\x00\x00\x00ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;\uD835\uDD29;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;\uD835\uDD5Dus;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;\uD835\uDCC1m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;\uD835\uDD2Ao;cdnro;acdsir;otus;bd;u;p;dpels;f;\uD835\uDD5Ectr;\uD835\uDCC2pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\x00pmp;eaeouy\x00;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;\uD835\uDD2BEest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;\uD835\uDD5F;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;\uD835\uDCC3ort\x00\x00arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00csuteiyr;c;abioslac;v;old;lig;crir;;\uD835\uDD2C\x00\x00\x00n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;\uD835\uDD60aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\x00\x00\x00\x00\x00\x00\x00\x00\x00r;ast;lle\x00\x00m;;y;rcimptnt;od;il;enk;r;\uD835\uDD2Dimo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;\uD835\uDD61nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;\uD835\uDCC5;ncsp;fiopsur;\uD835\uDD2Epf;\uD835\uDD62rime;cr;\uD835\uDCC6aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;\uD835\uDD2Faordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;\uD835\uDD63us;imes;apr;gt;olint;arachqquo;r;\uD835\uDCC7buo;rhirremes;i;efltri;luhar;;\x00\x00\x00\x00\x00\x00\x00cute;qu;Eaceinpsy;\x00;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;o\uD835\uDD30acoyrp;hycy;;rt\x00\x00iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;\uD835\uDD64adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;\uD835\uDCC8tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00get;;raeyron;dil;;lrec;r;\uD835\uDD31eiko\x00e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;o\uD835\uDD65rk;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;\uD835\uDCC9;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\x00y;ve;iyrc;abhrlac;airsht;;\uD835\uDD32raverlrlk;ct\x00\x00rn;erop;ri;alcr;gpon;f;\uD835\uDD66adhlsuownarpoonlrefighi;hlonparrows;cit\x00\x00rn;erop;ng;ri;cr;\uD835\uDCCAdirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;\uD835\uDD33trsubppf;\uD835\uDD67rotrcur;\uD835\uDCCBbpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;\uD835\uDD34pf;\uD835\uDD68;eatcr;\uD835\uDCCC\x00\x00\x00\x00\x00\x00\x00trr;\uD835\uDD35Aarr;Aarrais;dptfl;\uD835\uDD69imAarrcqr;\uD835\uDCCDptracefiosucuyte;iyrc;;nr;\uD835\uDD36cy;pf;\uD835\uDD6Acr;\uD835\uDCCEcmy;lacdefhioswcute;ayron;;ot;ettra;r;\uD835\uDD37cy;grarr;pf;\uD835\uDD6Bcr;\uD835\uDCCFjn;j;".split("").map((F)=>F.charCodeAt(0)));var K2=new Uint16Array("aglq\t\x15\x18\x1B\x0F\x00\x00\x12p;os;t;t;uot;".split("").map((F)=>F.charCodeAt(0)));var hB,RS=new Map([[0,65533],[128,8364],[130,8218],[131,402],[132,8222],[133,8230],[134,8224],[135,8225],[136,710],[137,8240],[138,352],[139,8249],[140,338],[142,381],[145,8216],[146,8217],[147,8220],[148,8221],[149,8226],[150,8211],[151,8212],[152,732],[153,8482],[154,353],[155,8250],[156,339],[158,382],[159,376]]),U2=(hB=String.fromCodePoint)!==null&&hB!==void 0?hB:function(F){let _="";if(F>65535)F-=65536,_+=String.fromCharCode(F>>>10&1023|55296),F=56320|F&1023;return _+=String.fromCharCode(F),_};function B2(F){var _;if(F>=55296&&F<=57343||F>1114111)return 65533;return(_=RS.get(F))!==null&&_!==void 0?_:F}var J6;(function(F){F[F.NUM=35]="NUM",F[F.SEMI=59]="SEMI",F[F.EQUALS=61]="EQUALS",F[F.ZERO=48]="ZERO",F[F.NINE=57]="NINE",F[F.LOWER_A=97]="LOWER_A",F[F.LOWER_F=102]="LOWER_F",F[F.LOWER_X=120]="LOWER_X",F[F.LOWER_Z=122]="LOWER_Z",F[F.UPPER_A=65]="UPPER_A",F[F.UPPER_F=70]="UPPER_F",F[F.UPPER_Z=90]="UPPER_Z"})(J6||(J6={}));var NS=32,Iq;(function(F){F[F.VALUE_LENGTH=49152]="VALUE_LENGTH",F[F.BRANCH_LENGTH=16256]="BRANCH_LENGTH",F[F.JUMP_TABLE=127]="JUMP_TABLE"})(Iq||(Iq={}));function RB(F){return F>=J6.ZERO&&F<=J6.NINE}function DS(F){return F>=J6.UPPER_A&&F<=J6.UPPER_F||F>=J6.LOWER_A&&F<=J6.LOWER_F}function MS(F){return F>=J6.UPPER_A&&F<=J6.UPPER_Z||F>=J6.LOWER_A&&F<=J6.LOWER_Z||RB(F)}function OS(F){return F===J6.EQUALS||MS(F)}var q6;(function(F){F[F.EntityStart=0]="EntityStart",F[F.NumericStart=1]="NumericStart",F[F.NumericDecimal=2]="NumericDecimal",F[F.NumericHex=3]="NumericHex",F[F.NamedEntity=4]="NamedEntity"})(q6||(q6={}));var D9;(function(F){F[F.Legacy=0]="Legacy",F[F.Strict=1]="Strict",F[F.Attribute=2]="Attribute"})(D9||(D9={}));class NB{constructor(F,_,$){this.decodeTree=F,this.emitCodePoint=_,this.errors=$,this.state=q6.EntityStart,this.consumed=1,this.result=0,this.treeIndex=0,this.excess=1,this.decodeMode=D9.Strict}startEntity(F){this.decodeMode=F,this.state=q6.EntityStart,this.result=0,this.treeIndex=0,this.excess=1,this.consumed=1}write(F,_){switch(this.state){case q6.EntityStart:{if(F.charCodeAt(_)===J6.NUM)return this.state=q6.NumericStart,this.consumed+=1,this.stateNumericStart(F,_+1);return this.state=q6.NamedEntity,this.stateNamedEntity(F,_)}case q6.NumericStart:return this.stateNumericStart(F,_);case q6.NumericDecimal:return this.stateNumericDecimal(F,_);case q6.NumericHex:return this.stateNumericHex(F,_);case q6.NamedEntity:return this.stateNamedEntity(F,_)}}stateNumericStart(F,_){if(_>=F.length)return-1;if((F.charCodeAt(_)|NS)===J6.LOWER_X)return this.state=q6.NumericHex,this.consumed+=1,this.stateNumericHex(F,_+1);return this.state=q6.NumericDecimal,this.stateNumericDecimal(F,_)}addToNumericResult(F,_,$,W){if(_!==$){let H=$-_;this.result=this.result*Math.pow(W,H)+parseInt(F.substr(_,H),W),this.consumed+=H}}stateNumericHex(F,_){let $=_;while(_<F.length){let W=F.charCodeAt(_);if(RB(W)||DS(W))_+=1;else return this.addToNumericResult(F,$,_,16),this.emitNumericEntity(W,3)}return this.addToNumericResult(F,$,_,16),-1}stateNumericDecimal(F,_){let $=_;while(_<F.length){let W=F.charCodeAt(_);if(RB(W))_+=1;else return this.addToNumericResult(F,$,_,10),this.emitNumericEntity(W,2)}return this.addToNumericResult(F,$,_,10),-1}emitNumericEntity(F,_){var $;if(this.consumed<=_)return($=this.errors)===null||$===void 0||$.absenceOfDigitsInNumericCharacterReference(this.consumed),0;if(F===J6.SEMI)this.consumed+=1;else if(this.decodeMode===D9.Strict)return 0;if(this.emitCodePoint(B2(this.result),this.consumed),this.errors){if(F!==J6.SEMI)this.errors.missingSemicolonAfterCharacterReference();this.errors.validateNumericCharacterReference(this.result)}return this.consumed}stateNamedEntity(F,_){let{decodeTree:$}=this,W=$[this.treeIndex],H=(W&Iq.VALUE_LENGTH)>>14;for(;_<F.length;_++,this.excess++){let Y=F.charCodeAt(_);if(this.treeIndex=fS($,W,this.treeIndex+Math.max(1,H),Y),this.treeIndex<0)return this.result===0||this.decodeMode===D9.Attribute&&(H===0||OS(Y))?0:this.emitNotTerminatedNamedEntity();if(W=$[this.treeIndex],H=(W&Iq.VALUE_LENGTH)>>14,H!==0){if(Y===J6.SEMI)return this.emitNamedEntityData(this.treeIndex,H,this.consumed+this.excess);if(this.decodeMode!==D9.Strict)this.result=this.treeIndex,this.consumed+=this.excess,this.excess=0}}return-1}emitNotTerminatedNamedEntity(){var F;let{result:_,decodeTree:$}=this,W=($[_]&Iq.VALUE_LENGTH)>>14;return this.emitNamedEntityData(_,W,this.consumed),(F=this.errors)===null||F===void 0||F.missingSemicolonAfterCharacterReference(),this.consumed}emitNamedEntityData(F,_,$){let{decodeTree:W}=this;if(this.emitCodePoint(_===1?W[F]&~Iq.VALUE_LENGTH:W[F+1],$),_===3)this.emitCodePoint(W[F+2],$);return $}end(){var F;switch(this.state){case q6.NamedEntity:return this.result!==0&&(this.decodeMode!==D9.Attribute||this.result===this.treeIndex)?this.emitNotTerminatedNamedEntity():0;case q6.NumericDecimal:return this.emitNumericEntity(0,2);case q6.NumericHex:return this.emitNumericEntity(0,3);case q6.NumericStart:return(F=this.errors)===null||F===void 0||F.absenceOfDigitsInNumericCharacterReference(this.consumed),0;case q6.EntityStart:return 0}}}function z2(F){let _="",$=new NB(F,(W)=>_+=U2(W));return function(H,Y){let K=0,G=0;while((G=H.indexOf("&",G))>=0){_+=H.slice(K,G),$.startEntity(Y);let z=$.write(H,G+1);if(z<0){K=G+$.end();break}K=G+z,G=z===0?K+1:K}let U=_+H.slice(K);return _="",U}}function fS(F,_,$,W){let H=(_&Iq.BRANCH_LENGTH)>>7,Y=_&Iq.JUMP_TABLE;if(H===0)return Y!==0&&W===Y?$:-1;if(Y){let U=W-Y;return U<0||U>=H?-1:F[$+U]-1}let K=$,G=K+H-1;while(K<=G){let U=K+G>>>1,z=F[U];if(z<W)K=U+1;else if(z>W)G=U-1;else return F[U+H]}return-1}var IS=z2(G2),ap=z2(K2);function yJ(F,_=D9.Legacy){return IS(F,_)}var A2;(function(F){F[F.XML=0]="XML",F[F.HTML=1]="HTML"})(A2||(A2={}));var h2;(function(F){F[F.UTF8=0]="UTF8",F[F.ASCII=1]="ASCII",F[F.Extensive=2]="Extensive",F[F.Attribute=3]="Attribute",F[F.Text=4]="Text"})(h2||(h2={}));function LS(F){return Object.prototype.toString.call(F)}function fY(F){return LS(F)==="[object String]"}var ES=Object.prototype.hasOwnProperty;function CS(F,_){return ES.call(F,_)}function IZ(F){return Array.prototype.slice.call(arguments,1).forEach(function($){if(!$)return;if(typeof $!=="object")throw TypeError($+"must be object");Object.keys($).forEach(function(W){F[W]=$[W]})}),F}function DB(F,_,$){return[].concat(F.slice(0,_),$,F.slice(_+1))}function IY(F){if(F>=55296&&F<=57343)return!1;if(F>=64976&&F<=65007)return!1;if((F&65535)===65535||(F&65535)===65534)return!1;if(F>=0&&F<=8)return!1;if(F===11)return!1;if(F>=14&&F<=31)return!1;if(F>=127&&F<=159)return!1;if(F>1114111)return!1;return!0}function jQ(F){if(F>65535){F-=65536;let _=55296+(F>>10),$=56320+(F&1023);return String.fromCharCode(_,$)}return String.fromCharCode(F)}var N2=/\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g,PS=/&([a-z#][a-z0-9]{1,31});/gi,VS=new RegExp(N2.source+"|"+PS.source,"gi"),kS=/^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;function SS(F,_){if(_.charCodeAt(0)===35&&kS.test(_)){let W=_[1].toLowerCase()==="x"?parseInt(_.slice(2),16):parseInt(_.slice(1),10);if(IY(W))return jQ(W);return F}let $=yJ(F);if($!==F)return $;return F}function yS(F){if(F.indexOf("\\")<0)return F;return F.replace(N2,"$1")}function M9(F){if(F.indexOf("\\")<0&&F.indexOf("&")<0)return F;return F.replace(VS,function(_,$,W){if($)return $;return SS(_,W)})}var vS=/[&<>"]/,bS=/[&<>"]/g,jS={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"};function xS(F){return jS[F]}function O9(F){if(vS.test(F))return F.replace(bS,xS);return F}var gS=/[.?*+^$[\]\\(){}|-]/g;function uS(F){return F.replace(gS,"\\$&")}function dF(F){switch(F){case 9:case 32:return!0}return!1}function vJ(F){if(F>=8192&&F<=8202)return!0;switch(F){case 9:case 10:case 11:case 12:case 13:case 32:case 160:case 5760:case 8239:case 8287:case 12288:return!0}return!1}function bJ(F){return fZ.test(F)||MY.test(F)}function jJ(F){switch(F){case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:case 41:case 42:case 43:case 44:case 45:case 46:case 47:case 58:case 59:case 60:case 61:case 62:case 63:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 124:case 125:case 126:return!0;default:return!1}}function xJ(F){if(F=F.trim().replace(/\s+/g," "),"".toLowerCase()==="")F=F.replace(//g,"");return F.toLowerCase().toUpperCase()}var pS={mdurl:RY,ucmicro:AB};var TB={};Qw(TB,{parseLinkTitle:()=>IB,parseLinkLabel:()=>OB,parseLinkDestination:()=>fB});function OB(F,_,$){let W,H,Y,K,G=F.posMax,U=F.pos;F.pos=_+1,W=1;while(F.pos<G){if(Y=F.src.charCodeAt(F.pos),Y===93){if(W--,W===0){H=!0;break}}if(K=F.pos,F.md.inline.skipToken(F),Y===91){if(K===F.pos-1)W++;else if($)return F.pos=U,-1}}let z=-1;if(H)z=F.pos;return F.pos=U,z}function fB(F,_,$){let W,H=_,Y={ok:!1,pos:0,str:""};if(F.charCodeAt(H)===60){H++;while(H<$){if(W=F.charCodeAt(H),W===10)return Y;if(W===60)return Y;if(W===62)return Y.pos=H+1,Y.str=M9(F.slice(_+1,H)),Y.ok=!0,Y;if(W===92&&H+1<$){H+=2;continue}H++}return Y}let K=0;while(H<$){if(W=F.charCodeAt(H),W===32)break;if(W<32||W===127)break;if(W===92&&H+1<$){if(F.charCodeAt(H+1)===32)break;H+=2;continue}if(W===40){if(K++,K>32)return Y}if(W===41){if(K===0)break;K--}H++}if(_===H)return Y;if(K!==0)return Y;return Y.str=M9(F.slice(_,H)),Y.pos=H,Y.ok=!0,Y}function IB(F,_,$,W){let H,Y=_,K={ok:!1,can_continue:!1,pos:0,str:"",marker:0};if(W)K.str=W.str,K.marker=W.marker;else{if(Y>=$)return K;let G=F.charCodeAt(Y);if(G!==34&&G!==39&&G!==40)return K;if(_++,Y++,G===40)G=41;K.marker=G}while(Y<$){if(H=F.charCodeAt(Y),H===K.marker)return K.pos=Y+1,K.str+=M9(F.slice(_,Y)),K.ok=!0,K;else if(H===40&&K.marker===41)return K;else if(H===92&&Y+1<$)Y++;Y++}return K.can_continue=!0,K.str+=M9(F.slice(_,Y)),K}var v7={};v7.code_inline=function(F,_,$,W,H){let Y=F[_];return"<code"+H.renderAttrs(Y)+">"+O9(Y.content)+"</code>"};v7.code_block=function(F,_,$,W,H){let Y=F[_];return"<pre"+H.renderAttrs(Y)+"><code>"+O9(F[_].content)+`</code></pre>
`};v7.fence=function(F,_,$,W,H){let Y=F[_],K=Y.info?M9(Y.info).trim():"",G="",U="";if(K){let h=K.split(/(\s+)/g);G=h[0],U=h.slice(2).join("")}let z;if($.highlight)z=$.highlight(Y.content,G,U)||O9(Y.content);else z=O9(Y.content);if(z.indexOf("<pre")===0)return z+`
`;if(K){let h=Y.attrIndex("class"),A=Y.attrs?Y.attrs.slice():[];if(h<0)A.push(["class",$.langPrefix+G]);else A[h]=A[h].slice(),A[h][1]+=" "+$.langPrefix+G;let N={attrs:A};return`<pre><code${H.renderAttrs(N)}>${z}</code></pre>
`}return`<pre><code${H.renderAttrs(Y)}>${z}</code></pre>
`};v7.image=function(F,_,$,W,H){let Y=F[_];return Y.attrs[Y.attrIndex("alt")][1]=H.renderInlineAsText(Y.children,$,W),H.renderToken(F,_,$)};v7.hardbreak=function(F,_,$){return $.xhtmlOut?`<br />
`:`<br>
`};v7.softbreak=function(F,_,$){return $.breaks?$.xhtmlOut?`<br />
`:`<br>
`:`
`};v7.text=function(F,_){return O9(F[_].content)};v7.html_block=function(F,_){return F[_].content};v7.html_inline=function(F,_){return F[_].content};function TZ(){this.rules=IZ({},v7)}TZ.prototype.renderAttrs=function(_){let $,W,H;if(!_.attrs)return"";H="";for($=0,W=_.attrs.length;$<W;$++)H+=" "+O9(_.attrs[$][0])+'="'+O9(_.attrs[$][1])+'"';return H};TZ.prototype.renderToken=function(_,$,W){let H=_[$],Y="";if(H.hidden)return"";if(H.block&&H.nesting!==-1&&$&&_[$-1].hidden)Y+=`
`;if(Y+=(H.nesting===-1?"</":"<")+H.tag,Y+=this.renderAttrs(H),H.nesting===0&&W.xhtmlOut)Y+=" /";let K=!1;if(H.block){if(K=!0,H.nesting===1){if($+1<_.length){let G=_[$+1];if(G.type==="inline"||G.hidden)K=!1;else if(G.nesting===-1&&G.tag===H.tag)K=!1}}}return Y+=K?`>
`:">",Y};TZ.prototype.renderInline=function(F,_,$){let W="",H=this.rules;for(let Y=0,K=F.length;Y<K;Y++){let G=F[Y].type;if(typeof H[G]<"u")W+=H[G](F,Y,_,$,this);else W+=this.renderToken(F,Y,_)}return W};TZ.prototype.renderInlineAsText=function(F,_,$){let W="";for(let H=0,Y=F.length;H<Y;H++)switch(F[H].type){case"text":W+=F[H].content;break;case"image":W+=this.renderInlineAsText(F[H].children,_,$);break;case"html_inline":case"html_block":W+=F[H].content;break;case"softbreak":case"hardbreak":W+=`
`;break;default:}return W};TZ.prototype.render=function(F,_,$){let W="",H=this.rules;for(let Y=0,K=F.length;Y<K;Y++){let G=F[Y].type;if(G==="inline")W+=this.renderInline(F[Y].children,_,$);else if(typeof H[G]<"u")W+=H[G](F,Y,_,$,this);else W+=this.renderToken(F,Y,_,$)}return W};var D2=TZ;function q7(){this.__rules__=[],this.__cache__=null}q7.prototype.__find__=function(F){for(let _=0;_<this.__rules__.length;_++)if(this.__rules__[_].name===F)return _;return-1};q7.prototype.__compile__=function(){let F=this,_=[""];F.__rules__.forEach(function($){if(!$.enabled)return;$.alt.forEach(function(W){if(_.indexOf(W)<0)_.push(W)})}),F.__cache__={},_.forEach(function($){F.__cache__[$]=[],F.__rules__.forEach(function(W){if(!W.enabled)return;if($&&W.alt.indexOf($)<0)return;F.__cache__[$].push(W.fn)})})};q7.prototype.at=function(F,_,$){let W=this.__find__(F),H=$||{};if(W===-1)throw Error("Parser rule not found: "+F);this.__rules__[W].fn=_,this.__rules__[W].alt=H.alt||[],this.__cache__=null};q7.prototype.before=function(F,_,$,W){let H=this.__find__(F),Y=W||{};if(H===-1)throw Error("Parser rule not found: "+F);this.__rules__.splice(H,0,{name:_,enabled:!0,fn:$,alt:Y.alt||[]}),this.__cache__=null};q7.prototype.after=function(F,_,$,W){let H=this.__find__(F),Y=W||{};if(H===-1)throw Error("Parser rule not found: "+F);this.__rules__.splice(H+1,0,{name:_,enabled:!0,fn:$,alt:Y.alt||[]}),this.__cache__=null};q7.prototype.push=function(F,_,$){let W=$||{};this.__rules__.push({name:F,enabled:!0,fn:_,alt:W.alt||[]}),this.__cache__=null};q7.prototype.enable=function(F,_){if(!Array.isArray(F))F=[F];let $=[];return F.forEach(function(W){let H=this.__find__(W);if(H<0){if(_)return;throw Error("Rules manager: invalid rule name "+W)}this.__rules__[H].enabled=!0,$.push(W)},this),this.__cache__=null,$};q7.prototype.enableOnly=function(F,_){if(!Array.isArray(F))F=[F];this.__rules__.forEach(function($){$.enabled=!1}),this.enable(F,_)};q7.prototype.disable=function(F,_){if(!Array.isArray(F))F=[F];let $=[];return F.forEach(function(W){let H=this.__find__(W);if(H<0){if(_)return;throw Error("Rules manager: invalid rule name "+W)}this.__rules__[H].enabled=!1,$.push(W)},this),this.__cache__=null,$};q7.prototype.getRules=function(F){if(this.__cache__===null)this.__compile__();return this.__cache__[F]||[]};var gJ=q7;function LZ(F,_,$){this.type=F,this.tag=_,this.attrs=null,this.map=null,this.nesting=$,this.level=0,this.children=null,this.content="",this.markup="",this.info="",this.meta=null,this.block=!1,this.hidden=!1}LZ.prototype.attrIndex=function(_){if(!this.attrs)return-1;let $=this.attrs;for(let W=0,H=$.length;W<H;W++)if($[W][0]===_)return W;return-1};LZ.prototype.attrPush=function(_){if(this.attrs)this.attrs.push(_);else this.attrs=[_]};LZ.prototype.attrSet=function(_,$){let W=this.attrIndex(_),H=[_,$];if(W<0)this.attrPush(H);else this.attrs[W]=H};LZ.prototype.attrGet=function(_){let $=this.attrIndex(_),W=null;if($>=0)W=this.attrs[$][1];return W};LZ.prototype.attrJoin=function(_,$){let W=this.attrIndex(_);if(W<0)this.attrPush([_,$]);else this.attrs[W][1]=this.attrs[W][1]+" "+$};var f9=LZ;function M2(F,_,$){this.src=F,this.env=$,this.tokens=[],this.inlineMode=!1,this.md=_}M2.prototype.Token=f9;var O2=M2;var mS=/\r\n?|\n/g,lS=/\0/g;function LB(F){let _;_=F.src.replace(mS,`
`),_=_.replace(lS,""),F.src=_}function EB(F){let _;if(F.inlineMode)_=new F.Token("inline","",0),_.content=F.src,_.map=[0,1],_.children=[],F.tokens.push(_);else F.md.block.parse(F.src,F.md,F.env,F.tokens)}function CB(F){let _=F.tokens;for(let $=0,W=_.length;$<W;$++){let H=_[$];if(H.type==="inline")F.md.inline.parse(H.content,F.md,F.env,H.children)}}function dS(F){return/^<a[>\s]/i.test(F)}function iS(F){return/^<\/a\s*>/i.test(F)}function PB(F){let _=F.tokens;if(!F.md.options.linkify)return;for(let $=0,W=_.length;$<W;$++){if(_[$].type!=="inline"||!F.md.linkify.pretest(_[$].content))continue;let H=_[$].children,Y=0;for(let K=H.length-1;K>=0;K--){let G=H[K];if(G.type==="link_close"){K--;while(H[K].level!==G.level&&H[K].type!=="link_open")K--;continue}if(G.type==="html_inline"){if(dS(G.content)&&Y>0)Y--;if(iS(G.content))Y++}if(Y>0)continue;if(G.type==="text"&&F.md.linkify.test(G.content)){let U=G.content,z=F.md.linkify.match(U),h=[],A=G.level,N=0;if(z.length>0&&z[0].index===0&&K>0&&H[K-1].type==="text_special")z=z.slice(1);for(let M=0;M<z.length;M++){let T=z[M].url,P=F.md.normalizeLink(T);if(!F.md.validateLink(P))continue;let D=z[M].text;if(!z[M].schema)D=F.md.normalizeLinkText("http://"+D).replace(/^http:\/\//,"");else if(z[M].schema==="mailto:"&&!/^mailto:/i.test(D))D=F.md.normalizeLinkText("mailto:"+D).replace(/^mailto:/,"");else D=F.md.normalizeLinkText(D);let O=z[M].index;if(O>N){let m=new F.Token("text","",0);m.content=U.slice(N,O),m.level=A,h.push(m)}let b=new F.Token("link_open","a",1);b.attrs=[["href",P]],b.level=A++,b.markup="linkify",b.info="auto",h.push(b);let k=new F.Token("text","",0);k.content=D,k.level=A,h.push(k);let y=new F.Token("link_close","a",-1);y.level=--A,y.markup="linkify",y.info="auto",h.push(y),N=z[M].lastIndex}if(N<U.length){let M=new F.Token("text","",0);M.content=U.slice(N),M.level=A,h.push(M)}_[$].children=H=DB(H,K,h)}}}}var f2=/\+-|\.\.|\?\?\?\?|!!!!|,,|--/,nS=/\((c|tm|r)\)/i,cS=/\((c|tm|r)\)/ig,sS={c:"",r:"",tm:""};function oS(F,_){return sS[_.toLowerCase()]}function aS(F){let _=0;for(let $=F.length-1;$>=0;$--){let W=F[$];if(W.type==="text"&&!_)W.content=W.content.replace(cS,oS);if(W.type==="link_open"&&W.info==="auto")_--;if(W.type==="link_close"&&W.info==="auto")_++}}function rS(F){let _=0;for(let $=F.length-1;$>=0;$--){let W=F[$];if(W.type==="text"&&!_){if(f2.test(W.content))W.content=W.content.replace(/\+-/g,"").replace(/\.{2,}/g,"").replace(/([?!])/g,"$1..").replace(/([?!]){4,}/g,"$1$1$1").replace(/,{2,}/g,",").replace(/(^|[^-])---(?=[^-]|$)/mg,"$1").replace(/(^|\s)--(?=\s|$)/mg,"$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg,"$1")}if(W.type==="link_open"&&W.info==="auto")_--;if(W.type==="link_close"&&W.info==="auto")_++}}function VB(F){let _;if(!F.md.options.typographer)return;for(_=F.tokens.length-1;_>=0;_--){if(F.tokens[_].type!=="inline")continue;if(nS.test(F.tokens[_].content))aS(F.tokens[_].children);if(f2.test(F.tokens[_].content))rS(F.tokens[_].children)}}var tS=/['"]/,I2=/['"]/g,T2="";function TY(F,_,$){return F.slice(0,_)+$+F.slice(_+1)}function eS(F,_){let $,W=[];for(let H=0;H<F.length;H++){let Y=F[H],K=F[H].level;for($=W.length-1;$>=0;$--)if(W[$].level<=K)break;if(W.length=$+1,Y.type!=="text")continue;let G=Y.content,U=0,z=G.length;F:while(U<z){I2.lastIndex=U;let h=I2.exec(G);if(!h)break;let A=!0,N=!0;U=h.index+1;let M=h[0]==="'",T=32;if(h.index-1>=0)T=G.charCodeAt(h.index-1);else for($=H-1;$>=0;$--){if(F[$].type==="softbreak"||F[$].type==="hardbreak")break;if(!F[$].content)continue;T=F[$].content.charCodeAt(F[$].content.length-1);break}let P=32;if(U<z)P=G.charCodeAt(U);else for($=H+1;$<F.length;$++){if(F[$].type==="softbreak"||F[$].type==="hardbreak")break;if(!F[$].content)continue;P=F[$].content.charCodeAt(0);break}let D=jJ(T)||bJ(String.fromCharCode(T)),O=jJ(P)||bJ(String.fromCharCode(P)),b=vJ(T),k=vJ(P);if(k)A=!1;else if(O){if(!(b||D))A=!1}if(b)N=!1;else if(D){if(!(k||O))N=!1}if(P===34&&h[0]==='"'){if(T>=48&&T<=57)N=A=!1}if(A&&N)A=D,N=O;if(!A&&!N){if(M)Y.content=TY(Y.content,h.index,T2);continue}if(N)for($=W.length-1;$>=0;$--){let y=W[$];if(W[$].level<K)break;if(y.single===M&&W[$].level===K){y=W[$];let m,x;if(M)m=_.md.options.quotes[2],x=_.md.options.quotes[3];else m=_.md.options.quotes[0],x=_.md.options.quotes[1];if(Y.content=TY(Y.content,h.index,x),F[y.token].content=TY(F[y.token].content,y.pos,m),U+=x.length-1,y.token===H)U+=m.length-1;G=Y.content,z=G.length,W.length=$;continue F}}if(A)W.push({token:H,pos:h.index,single:M,level:K});else if(N&&M)Y.content=TY(Y.content,h.index,T2)}}}function kB(F){if(!F.md.options.typographer)return;for(let _=F.tokens.length-1;_>=0;_--){if(F.tokens[_].type!=="inline"||!tS.test(F.tokens[_].content))continue;eS(F.tokens[_].children,F)}}function SB(F){let _,$,W=F.tokens,H=W.length;for(let Y=0;Y<H;Y++){if(W[Y].type!=="inline")continue;let K=W[Y].children,G=K.length;for(_=0;_<G;_++)if(K[_].type==="text_special")K[_].type="text";for(_=$=0;_<G;_++)if(K[_].type==="text"&&_+1<G&&K[_+1].type==="text")K[_+1].content=K[_].content+K[_+1].content;else{if(_!==$)K[$]=K[_];$++}if(_!==$)K.length=$}}var yB=[["normalize",LB],["block",EB],["inline",CB],["linkify",PB],["replacements",VB],["smartquotes",kB],["text_join",SB]];function vB(){this.ruler=new gJ;for(let F=0;F<yB.length;F++)this.ruler.push(yB[F][0],yB[F][1])}vB.prototype.process=function(F){let _=this.ruler.getRules("");for(let $=0,W=_.length;$<W;$++)_[$](F)};vB.prototype.State=O2;var L2=vB;function b7(F,_,$,W){this.src=F,this.md=_,this.env=$,this.tokens=W,this.bMarks=[],this.eMarks=[],this.tShift=[],this.sCount=[],this.bsCount=[],this.blkIndent=0,this.line=0,this.lineMax=0,this.tight=!1,this.ddIndent=-1,this.listIndent=-1,this.parentType="root",this.level=0;let H=this.src;for(let Y=0,K=0,G=0,U=0,z=H.length,h=!1;K<z;K++){let A=H.charCodeAt(K);if(!h)if(dF(A)){if(G++,A===9)U+=4-U%4;else U++;continue}else h=!0;if(A===10||K===z-1){if(A!==10)K++;this.bMarks.push(Y),this.eMarks.push(K),this.tShift.push(G),this.sCount.push(U),this.bsCount.push(0),h=!1,G=0,U=0,Y=K+1}}this.bMarks.push(H.length),this.eMarks.push(H.length),this.tShift.push(0),this.sCount.push(0),this.bsCount.push(0),this.lineMax=this.bMarks.length-1}b7.prototype.push=function(F,_,$){let W=new f9(F,_,$);if(W.block=!0,$<0)this.level--;if(W.level=this.level,$>0)this.level++;return this.tokens.push(W),W};b7.prototype.isEmpty=function(_){return this.bMarks[_]+this.tShift[_]>=this.eMarks[_]};b7.prototype.skipEmptyLines=function(_){for(let $=this.lineMax;_<$;_++)if(this.bMarks[_]+this.tShift[_]<this.eMarks[_])break;return _};b7.prototype.skipSpaces=function(_){for(let $=this.src.length;_<$;_++){let W=this.src.charCodeAt(_);if(!dF(W))break}return _};b7.prototype.skipSpacesBack=function(_,$){if(_<=$)return _;while(_>$)if(!dF(this.src.charCodeAt(--_)))return _+1;return _};b7.prototype.skipChars=function(_,$){for(let W=this.src.length;_<W;_++)if(this.src.charCodeAt(_)!==$)break;return _};b7.prototype.skipCharsBack=function(_,$,W){if(_<=W)return _;while(_>W)if($!==this.src.charCodeAt(--_))return _+1;return _};b7.prototype.getLines=function(_,$,W,H){if(_>=$)return"";let Y=Array($-_);for(let K=0,G=_;G<$;G++,K++){let U=0,z=this.bMarks[G],h=z,A;if(G+1<$||H)A=this.eMarks[G]+1;else A=this.eMarks[G];while(h<A&&U<W){let N=this.src.charCodeAt(h);if(dF(N))if(N===9)U+=4-(U+this.bsCount[G])%4;else U++;else if(h-z<this.tShift[G])U++;else break;h++}if(U>W)Y[K]=Array(U-W+1).join(" ")+this.src.slice(h,A);else Y[K]=this.src.slice(h,A)}return Y.join("")};b7.prototype.Token=f9;var E2=b7;var Fy=65536;function bB(F,_){let $=F.bMarks[_]+F.tShift[_],W=F.eMarks[_];return F.src.slice($,W)}function C2(F){let _=[],$=F.length,W=0,H=F.charCodeAt(W),Y=!1,K=0,G="";while(W<$){if(H===124)if(!Y)_.push(G+F.substring(K,W)),G="",K=W+1;else G+=F.substring(K,W-1),K=W;Y=H===92,W++,H=F.charCodeAt(W)}return _.push(G+F.substring(K)),_}function jB(F,_,$,W){if(_+2>$)return!1;let H=_+1;if(F.sCount[H]<F.blkIndent)return!1;if(F.sCount[H]-F.blkIndent>=4)return!1;let Y=F.bMarks[H]+F.tShift[H];if(Y>=F.eMarks[H])return!1;let K=F.src.charCodeAt(Y++);if(K!==124&&K!==45&&K!==58)return!1;if(Y>=F.eMarks[H])return!1;let G=F.src.charCodeAt(Y++);if(G!==124&&G!==45&&G!==58&&!dF(G))return!1;if(K===45&&dF(G))return!1;while(Y<F.eMarks[H]){let y=F.src.charCodeAt(Y);if(y!==124&&y!==45&&y!==58&&!dF(y))return!1;Y++}let U=bB(F,_+1),z=U.split("|"),h=[];for(let y=0;y<z.length;y++){let m=z[y].trim();if(!m)if(y===0||y===z.length-1)continue;else return!1;if(!/^:?-+:?$/.test(m))return!1;if(m.charCodeAt(m.length-1)===58)h.push(m.charCodeAt(0)===58?"center":"right");else if(m.charCodeAt(0)===58)h.push("left");else h.push("")}if(U=bB(F,_).trim(),U.indexOf("|")===-1)return!1;if(F.sCount[_]-F.blkIndent>=4)return!1;if(z=C2(U),z.length&&z[0]==="")z.shift();if(z.length&&z[z.length-1]==="")z.pop();let A=z.length;if(A===0||A!==h.length)return!1;if(W)return!0;let N=F.parentType;F.parentType="table";let M=F.md.block.ruler.getRules("blockquote"),T=F.push("table_open","table",1),P=[_,0];T.map=P;let D=F.push("thead_open","thead",1);D.map=[_,_+1];let O=F.push("tr_open","tr",1);O.map=[_,_+1];for(let y=0;y<z.length;y++){let m=F.push("th_open","th",1);if(h[y])m.attrs=[["style","text-align:"+h[y]]];let x=F.push("inline","",0);x.content=z[y].trim(),x.children=[],F.push("th_close","th",-1)}F.push("tr_close","tr",-1),F.push("thead_close","thead",-1);let b,k=0;for(H=_+2;H<$;H++){if(F.sCount[H]<F.blkIndent)break;let y=!1;for(let x=0,o=M.length;x<o;x++)if(M[x](F,H,$,!0)){y=!0;break}if(y)break;if(U=bB(F,H).trim(),!U)break;if(F.sCount[H]-F.blkIndent>=4)break;if(z=C2(U),z.length&&z[0]==="")z.shift();if(z.length&&z[z.length-1]==="")z.pop();if(k+=A-z.length,k>Fy)break;if(H===_+2){let x=F.push("tbody_open","tbody",1);x.map=b=[_+2,0]}let m=F.push("tr_open","tr",1);m.map=[H,H+1];for(let x=0;x<A;x++){let o=F.push("td_open","td",1);if(h[x])o.attrs=[["style","text-align:"+h[x]]];let s=F.push("inline","",0);s.content=z[x]?z[x].trim():"",s.children=[],F.push("td_close","td",-1)}F.push("tr_close","tr",-1)}if(b)F.push("tbody_close","tbody",-1),b[1]=H;return F.push("table_close","table",-1),P[1]=H,F.parentType=N,F.line=H,!0}function xB(F,_,$){if(F.sCount[_]-F.blkIndent<4)return!1;let W=_+1,H=W;while(W<$){if(F.isEmpty(W)){W++;continue}if(F.sCount[W]-F.blkIndent>=4){W++,H=W;continue}break}F.line=H;let Y=F.push("code_block","code",0);return Y.content=F.getLines(_,H,4+F.blkIndent,!1)+`
`,Y.map=[_,F.line],!0}function gB(F,_,$,W){let H=F.bMarks[_]+F.tShift[_],Y=F.eMarks[_];if(F.sCount[_]-F.blkIndent>=4)return!1;if(H+3>Y)return!1;let K=F.src.charCodeAt(H);if(K!==126&&K!==96)return!1;let G=H;H=F.skipChars(H,K);let U=H-G;if(U<3)return!1;let z=F.src.slice(G,H),h=F.src.slice(H,Y);if(K===96){if(h.indexOf(String.fromCharCode(K))>=0)return!1}if(W)return!0;let A=_,N=!1;for(;;){if(A++,A>=$)break;if(H=G=F.bMarks[A]+F.tShift[A],Y=F.eMarks[A],H<Y&&F.sCount[A]<F.blkIndent)break;if(F.src.charCodeAt(H)!==K)continue;if(F.sCount[A]-F.blkIndent>=4)continue;if(H=F.skipChars(H,K),H-G<U)continue;if(H=F.skipSpaces(H),H<Y)continue;N=!0;break}U=F.sCount[_],F.line=A+(N?1:0);let M=F.push("fence","code",0);return M.info=h,M.content=F.getLines(_+1,A,U,!0),M.markup=z,M.map=[_,F.line],!0}function uB(F,_,$,W){let H=F.bMarks[_]+F.tShift[_],Y=F.eMarks[_],K=F.lineMax;if(F.sCount[_]-F.blkIndent>=4)return!1;if(F.src.charCodeAt(H)!==62)return!1;if(W)return!0;let G=[],U=[],z=[],h=[],A=F.md.block.ruler.getRules("blockquote"),N=F.parentType;F.parentType="blockquote";let M=!1,T;for(T=_;T<$;T++){let k=F.sCount[T]<F.blkIndent;if(H=F.bMarks[T]+F.tShift[T],Y=F.eMarks[T],H>=Y)break;if(F.src.charCodeAt(H++)===62&&!k){let m=F.sCount[T]+1,x,o;if(F.src.charCodeAt(H)===32)H++,m++,o=!1,x=!0;else if(F.src.charCodeAt(H)===9)if(x=!0,(F.bsCount[T]+m)%4===3)H++,m++,o=!1;else o=!0;else x=!1;let s=m;G.push(F.bMarks[T]),F.bMarks[T]=H;while(H<Y){let j=F.src.charCodeAt(H);if(dF(j))if(j===9)s+=4-(s+F.bsCount[T]+(o?1:0))%4;else s++;else break;H++}M=H>=Y,U.push(F.bsCount[T]),F.bsCount[T]=F.sCount[T]+1+(x?1:0),z.push(F.sCount[T]),F.sCount[T]=s-m,h.push(F.tShift[T]),F.tShift[T]=H-F.bMarks[T];continue}if(M)break;let y=!1;for(let m=0,x=A.length;m<x;m++)if(A[m](F,T,$,!0)){y=!0;break}if(y){if(F.lineMax=T,F.blkIndent!==0)G.push(F.bMarks[T]),U.push(F.bsCount[T]),h.push(F.tShift[T]),z.push(F.sCount[T]),F.sCount[T]-=F.blkIndent;break}G.push(F.bMarks[T]),U.push(F.bsCount[T]),h.push(F.tShift[T]),z.push(F.sCount[T]),F.sCount[T]=-1}let P=F.blkIndent;F.blkIndent=0;let D=F.push("blockquote_open","blockquote",1);D.markup=">";let O=[_,0];D.map=O,F.md.block.tokenize(F,_,T);let b=F.push("blockquote_close","blockquote",-1);b.markup=">",F.lineMax=K,F.parentType=N,O[1]=F.line;for(let k=0;k<h.length;k++)F.bMarks[k+_]=G[k],F.tShift[k+_]=h[k],F.sCount[k+_]=z[k],F.bsCount[k+_]=U[k];return F.blkIndent=P,!0}function pB(F,_,$,W){let H=F.eMarks[_];if(F.sCount[_]-F.blkIndent>=4)return!1;let Y=F.bMarks[_]+F.tShift[_],K=F.src.charCodeAt(Y++);if(K!==42&&K!==45&&K!==95)return!1;let G=1;while(Y<H){let z=F.src.charCodeAt(Y++);if(z!==K&&!dF(z))return!1;if(z===K)G++}if(G<3)return!1;if(W)return!0;F.line=_+1;let U=F.push("hr","hr",0);return U.map=[_,F.line],U.markup=Array(G+1).join(String.fromCharCode(K)),!0}function P2(F,_){let $=F.eMarks[_],W=F.bMarks[_]+F.tShift[_],H=F.src.charCodeAt(W++);if(H!==42&&H!==45&&H!==43)return-1;if(W<$){let Y=F.src.charCodeAt(W);if(!dF(Y))return-1}return W}function V2(F,_){let $=F.bMarks[_]+F.tShift[_],W=F.eMarks[_],H=$;if(H+1>=W)return-1;let Y=F.src.charCodeAt(H++);if(Y<48||Y>57)return-1;for(;;){if(H>=W)return-1;if(Y=F.src.charCodeAt(H++),Y>=48&&Y<=57){if(H-$>=10)return-1;continue}if(Y===41||Y===46)break;return-1}if(H<W){if(Y=F.src.charCodeAt(H),!dF(Y))return-1}return H}function qy(F,_){let $=F.level+2;for(let W=_+2,H=F.tokens.length-2;W<H;W++)if(F.tokens[W].level===$&&F.tokens[W].type==="paragraph_open")F.tokens[W+2].hidden=!0,F.tokens[W].hidden=!0,W+=2}function mB(F,_,$,W){let H,Y,K,G,U=_,z=!0;if(F.sCount[U]-F.blkIndent>=4)return!1;if(F.listIndent>=0&&F.sCount[U]-F.listIndent>=4&&F.sCount[U]<F.blkIndent)return!1;let h=!1;if(W&&F.parentType==="paragraph"){if(F.sCount[U]>=F.blkIndent)h=!0}let A,N,M;if((M=V2(F,U))>=0){if(A=!0,K=F.bMarks[U]+F.tShift[U],N=Number(F.src.slice(K,M-1)),h&&N!==1)return!1}else if((M=P2(F,U))>=0)A=!1;else return!1;if(h){if(F.skipSpaces(M)>=F.eMarks[U])return!1}if(W)return!0;let T=F.src.charCodeAt(M-1),P=F.tokens.length;if(A){if(G=F.push("ordered_list_open","ol",1),N!==1)G.attrs=[["start",N]]}else G=F.push("bullet_list_open","ul",1);let D=[U,0];G.map=D,G.markup=String.fromCharCode(T);let O=!1,b=F.md.block.ruler.getRules("list"),k=F.parentType;F.parentType="list";while(U<$){Y=M,H=F.eMarks[U];let y=F.sCount[U]+M-(F.bMarks[U]+F.tShift[U]),m=y;while(Y<H){let J0=F.src.charCodeAt(Y);if(J0===9)m+=4-(m+F.bsCount[U])%4;else if(J0===32)m++;else break;Y++}let x=Y,o;if(x>=H)o=1;else o=m-y;if(o>4)o=1;let s=y+o;G=F.push("list_item_open","li",1),G.markup=String.fromCharCode(T);let j=[U,0];if(G.map=j,A)G.info=F.src.slice(K,M-1);let V=F.tight,d=F.tShift[U],$0=F.sCount[U],X0=F.listIndent;if(F.listIndent=F.blkIndent,F.blkIndent=s,F.tight=!0,F.tShift[U]=x-F.bMarks[U],F.sCount[U]=m,x>=H&&F.isEmpty(U+1))F.line=Math.min(F.line+2,$);else F.md.block.tokenize(F,U,$,!0);if(!F.tight||O)z=!1;if(O=F.line-U>1&&F.isEmpty(F.line-1),F.blkIndent=F.listIndent,F.listIndent=X0,F.tShift[U]=d,F.sCount[U]=$0,F.tight=V,G=F.push("list_item_close","li",-1),G.markup=String.fromCharCode(T),U=F.line,j[1]=U,U>=$)break;if(F.sCount[U]<F.blkIndent)break;if(F.sCount[U]-F.blkIndent>=4)break;let K0=!1;for(let J0=0,u=b.length;J0<u;J0++)if(b[J0](F,U,$,!0)){K0=!0;break}if(K0)break;if(A){if(M=V2(F,U),M<0)break;K=F.bMarks[U]+F.tShift[U]}else if(M=P2(F,U),M<0)break;if(T!==F.src.charCodeAt(M-1))break}if(A)G=F.push("ordered_list_close","ol",-1);else G=F.push("bullet_list_close","ul",-1);if(G.markup=String.fromCharCode(T),D[1]=U,F.line=U,F.parentType=k,z)qy(F,P);return!0}function lB(F,_,$,W){let H=F.bMarks[_]+F.tShift[_],Y=F.eMarks[_],K=_+1;if(F.sCount[_]-F.blkIndent>=4)return!1;if(F.src.charCodeAt(H)!==91)return!1;function G(b){let k=F.lineMax;if(b>=k||F.isEmpty(b))return null;let y=!1;if(F.sCount[b]-F.blkIndent>3)y=!0;if(F.sCount[b]<0)y=!0;if(!y){let o=F.md.block.ruler.getRules("reference"),s=F.parentType;F.parentType="reference";let j=!1;for(let V=0,d=o.length;V<d;V++)if(o[V](F,b,k,!0)){j=!0;break}if(F.parentType=s,j)return null}let m=F.bMarks[b]+F.tShift[b],x=F.eMarks[b];return F.src.slice(m,x+1)}let U=F.src.slice(H,Y+1);Y=U.length;let z=-1;for(H=1;H<Y;H++){let b=U.charCodeAt(H);if(b===91)return!1;else if(b===93){z=H;break}else if(b===10){let k=G(K);if(k!==null)U+=k,Y=U.length,K++}else if(b===92){if(H++,H<Y&&U.charCodeAt(H)===10){let k=G(K);if(k!==null)U+=k,Y=U.length,K++}}}if(z<0||U.charCodeAt(z+1)!==58)return!1;for(H=z+2;H<Y;H++){let b=U.charCodeAt(H);if(b===10){let k=G(K);if(k!==null)U+=k,Y=U.length,K++}else if(dF(b));else break}let h=F.md.helpers.parseLinkDestination(U,H,Y);if(!h.ok)return!1;let A=F.md.normalizeLink(h.str);if(!F.md.validateLink(A))return!1;H=h.pos;let N=H,M=K,T=H;for(;H<Y;H++){let b=U.charCodeAt(H);if(b===10){let k=G(K);if(k!==null)U+=k,Y=U.length,K++}else if(dF(b));else break}let P=F.md.helpers.parseLinkTitle(U,H,Y);while(P.can_continue){let b=G(K);if(b===null)break;U+=b,H=Y,Y=U.length,K++,P=F.md.helpers.parseLinkTitle(U,H,Y,P)}let D;if(H<Y&&T!==H&&P.ok)D=P.str,H=P.pos;else D="",H=N,K=M;while(H<Y){let b=U.charCodeAt(H);if(!dF(b))break;H++}if(H<Y&&U.charCodeAt(H)!==10){if(D){D="",H=N,K=M;while(H<Y){let b=U.charCodeAt(H);if(!dF(b))break;H++}}}if(H<Y&&U.charCodeAt(H)!==10)return!1;let O=xJ(U.slice(1,z));if(!O)return!1;if(W)return!0;if(typeof F.env.references>"u")F.env.references={};if(typeof F.env.references[O]>"u")F.env.references[O]={title:D,href:A};return F.line=K,!0}var k2=["address","article","aside","base","basefont","blockquote","body","caption","center","col","colgroup","dd","details","dialog","dir","div","dl","dt","fieldset","figcaption","figure","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hr","html","iframe","legend","li","link","main","menu","menuitem","nav","noframes","ol","optgroup","option","p","param","search","section","summary","table","tbody","td","tfoot","th","thead","title","tr","track","ul"];var Jy=`(?:[^"'=<>\`\\x00-\\x20]+|'[^']*'|"[^"]*")`,_y="(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*"+Jy+")?)",S2="<[A-Za-z][A-Za-z0-9\\-]*"+_y+"*\\s*\\/?>";var y2=new RegExp("^(?:"+S2+"|<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>|<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->|<[?][\\s\\S]*?[?]>|<![A-Za-z][^>]*>|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>)"),v2=new RegExp("^(?:"+S2+"|<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>)");var EZ=[[/^<(script|pre|style|textarea)(?=(\s|>|$))/i,/<\/(script|pre|style|textarea)>/i,!0],[/^<!--/,/-->/,!0],[/^<\?/,/\?>/,!0],[/^<![A-Z]/,/>/,!0],[/^<!\[CDATA\[/,/\]\]>/,!0],[new RegExp("^</?("+k2.join("|")+")(?=(\\s|/?>|$))","i"),/^$/,!0],[new RegExp(v2.source+"\\s*$"),/^$/,!1]];function dB(F,_,$,W){let H=F.bMarks[_]+F.tShift[_],Y=F.eMarks[_];if(F.sCount[_]-F.blkIndent>=4)return!1;if(!F.md.options.html)return!1;if(F.src.charCodeAt(H)!==60)return!1;let K=F.src.slice(H,Y),G=0;for(;G<EZ.length;G++)if(EZ[G][0].test(K))break;if(G===EZ.length)return!1;if(W)return EZ[G][2];let U=_+1;if(!EZ[G][1].test(K))for(;U<$;U++){if(F.sCount[U]<F.blkIndent)break;if(H=F.bMarks[U]+F.tShift[U],Y=F.eMarks[U],K=F.src.slice(H,Y),EZ[G][1].test(K)){if(K.length!==0)U++;break}}F.line=U;let z=F.push("html_block","",0);return z.map=[_,U],z.content=F.getLines(_,U,F.blkIndent,!0),!0}function iB(F,_,$,W){let H=F.bMarks[_]+F.tShift[_],Y=F.eMarks[_];if(F.sCount[_]-F.blkIndent>=4)return!1;let K=F.src.charCodeAt(H);if(K!==35||H>=Y)return!1;let G=1;K=F.src.charCodeAt(++H);while(K===35&&H<Y&&G<=6)G++,K=F.src.charCodeAt(++H);if(G>6||H<Y&&!dF(K))return!1;if(W)return!0;Y=F.skipSpacesBack(Y,H);let U=F.skipCharsBack(Y,35,H);if(U>H&&dF(F.src.charCodeAt(U-1)))Y=U;F.line=_+1;let z=F.push("heading_open","h"+String(G),1);z.markup="########".slice(0,G),z.map=[_,F.line];let h=F.push("inline","",0);h.content=F.src.slice(H,Y).trim(),h.map=[_,F.line],h.children=[];let A=F.push("heading_close","h"+String(G),-1);return A.markup="########".slice(0,G),!0}function nB(F,_,$){let W=F.md.block.ruler.getRules("paragraph");if(F.sCount[_]-F.blkIndent>=4)return!1;let H=F.parentType;F.parentType="paragraph";let Y=0,K,G=_+1;for(;G<$&&!F.isEmpty(G);G++){if(F.sCount[G]-F.blkIndent>3)continue;if(F.sCount[G]>=F.blkIndent){let M=F.bMarks[G]+F.tShift[G],T=F.eMarks[G];if(M<T){if(K=F.src.charCodeAt(M),K===45||K===61){if(M=F.skipChars(M,K),M=F.skipSpaces(M),M>=T){Y=K===61?1:2;break}}}}if(F.sCount[G]<0)continue;let N=!1;for(let M=0,T=W.length;M<T;M++)if(W[M](F,G,$,!0)){N=!0;break}if(N)break}if(!Y)return!1;let U=F.getLines(_,G,F.blkIndent,!1).trim();F.line=G+1;let z=F.push("heading_open","h"+String(Y),1);z.markup=String.fromCharCode(K),z.map=[_,F.line];let h=F.push("inline","",0);h.content=U,h.map=[_,F.line-1],h.children=[];let A=F.push("heading_close","h"+String(Y),-1);return A.markup=String.fromCharCode(K),F.parentType=H,!0}function cB(F,_,$){let W=F.md.block.ruler.getRules("paragraph"),H=F.parentType,Y=_+1;F.parentType="paragraph";for(;Y<$&&!F.isEmpty(Y);Y++){if(F.sCount[Y]-F.blkIndent>3)continue;if(F.sCount[Y]<0)continue;let z=!1;for(let h=0,A=W.length;h<A;h++)if(W[h](F,Y,$,!0)){z=!0;break}if(z)break}let K=F.getLines(_,Y,F.blkIndent,!1).trim();F.line=Y;let G=F.push("paragraph_open","p",1);G.map=[_,F.line];let U=F.push("inline","",0);return U.content=K,U.map=[_,F.line],U.children=[],F.push("paragraph_close","p",-1),F.parentType=H,!0}var LY=[["table",jB,["paragraph","reference"]],["code",xB],["fence",gB,["paragraph","reference","blockquote","list"]],["blockquote",uB,["paragraph","reference","blockquote","list"]],["hr",pB,["paragraph","reference","blockquote","list"]],["list",mB,["paragraph","reference","blockquote"]],["reference",lB],["html_block",dB,["paragraph","reference","blockquote"]],["heading",iB,["paragraph","reference","blockquote"]],["lheading",nB],["paragraph",cB]];function EY(){this.ruler=new gJ;for(let F=0;F<LY.length;F++)this.ruler.push(LY[F][0],LY[F][1],{alt:(LY[F][2]||[]).slice()})}EY.prototype.tokenize=function(F,_,$){let W=this.ruler.getRules(""),H=W.length,Y=F.md.options.maxNesting,K=_,G=!1;while(K<$){if(F.line=K=F.skipEmptyLines(K),K>=$)break;if(F.sCount[K]<F.blkIndent)break;if(F.level>=Y){F.line=$;break}let U=F.line,z=!1;for(let h=0;h<H;h++)if(z=W[h](F,K,$,!1),z){if(U>=F.line)throw Error("block rule didn't increment state.line");break}if(!z)throw Error("none of the block rules matched");if(F.tight=!G,F.isEmpty(F.line-1))G=!0;if(K=F.line,K<$&&F.isEmpty(K))G=!0,K++,F.line=K}};EY.prototype.parse=function(F,_,$,W){if(!F)return;let H=new this.State(F,_,$,W);this.tokenize(H,H.line,H.lineMax)};EY.prototype.State=E2;var b2=EY;function xQ(F,_,$,W){this.src=F,this.env=$,this.md=_,this.tokens=W,this.tokens_meta=Array(W.length),this.pos=0,this.posMax=this.src.length,this.level=0,this.pending="",this.pendingLevel=0,this.cache={},this.delimiters=[],this._prev_delimiters=[],this.backticks={},this.backticksScanned=!1,this.linkLevel=0}xQ.prototype.pushPending=function(){let F=new f9("text","",0);return F.content=this.pending,F.level=this.pendingLevel,this.tokens.push(F),this.pending="",F};xQ.prototype.push=function(F,_,$){if(this.pending)this.pushPending();let W=new f9(F,_,$),H=null;if($<0)this.level--,this.delimiters=this._prev_delimiters.pop();if(W.level=this.level,$>0)this.level++,this._prev_delimiters.push(this.delimiters),this.delimiters=[],H={delimiters:this.delimiters};return this.pendingLevel=this.level,this.tokens.push(W),this.tokens_meta.push(H),W};xQ.prototype.scanDelims=function(F,_){let $=this.posMax,W=this.src.charCodeAt(F),H=F>0?this.src.charCodeAt(F-1):32,Y=F;while(Y<$&&this.src.charCodeAt(Y)===W)Y++;let K=Y-F,G=Y<$?this.src.charCodeAt(Y):32,U=jJ(H)||bJ(String.fromCharCode(H)),z=jJ(G)||bJ(String.fromCharCode(G)),h=vJ(H),A=vJ(G),N=!A&&(!z||h||U),M=!h&&(!U||A||z);return{can_open:N&&(_||!M||U),can_close:M&&(_||!N||z),length:K}};xQ.prototype.Token=f9;var j2=xQ;function Zy(F){switch(F){case 10:case 33:case 35:case 36:case 37:case 38:case 42:case 43:case 45:case 58:case 60:case 61:case 62:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 125:case 126:return!0;default:return!1}}function sB(F,_){let $=F.pos;while($<F.posMax&&!Zy(F.src.charCodeAt($)))$++;if($===F.pos)return!1;if(!_)F.pending+=F.src.slice(F.pos,$);return F.pos=$,!0}var $y=/(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;function oB(F,_){if(!F.md.options.linkify)return!1;if(F.linkLevel>0)return!1;let{pos:$,posMax:W}=F;if($+3>W)return!1;if(F.src.charCodeAt($)!==58)return!1;if(F.src.charCodeAt($+1)!==47)return!1;if(F.src.charCodeAt($+2)!==47)return!1;let H=F.pending.match($y);if(!H)return!1;let Y=H[1],K=F.md.linkify.matchAtStart(F.src.slice($-Y.length));if(!K)return!1;let G=K.url;if(G.length<=Y.length)return!1;G=G.replace(/\*+$/,"");let U=F.md.normalizeLink(G);if(!F.md.validateLink(U))return!1;if(!_){F.pending=F.pending.slice(0,-Y.length);let z=F.push("link_open","a",1);z.attrs=[["href",U]],z.markup="linkify",z.info="auto";let h=F.push("text","",0);h.content=F.md.normalizeLinkText(G);let A=F.push("link_close","a",-1);A.markup="linkify",A.info="auto"}return F.pos+=G.length-Y.length,!0}function aB(F,_){let $=F.pos;if(F.src.charCodeAt($)!==10)return!1;let W=F.pending.length-1,H=F.posMax;if(!_)if(W>=0&&F.pending.charCodeAt(W)===32)if(W>=1&&F.pending.charCodeAt(W-1)===32){let Y=W-1;while(Y>=1&&F.pending.charCodeAt(Y-1)===32)Y--;F.pending=F.pending.slice(0,Y),F.push("hardbreak","br",0)}else F.pending=F.pending.slice(0,-1),F.push("softbreak","br",0);else F.push("softbreak","br",0);$++;while($<H&&dF(F.src.charCodeAt($)))$++;return F.pos=$,!0}var rB=[];for(let F=0;F<256;F++)rB.push(0);"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(F){rB[F.charCodeAt(0)]=1});function tB(F,_){let{pos:$,posMax:W}=F;if(F.src.charCodeAt($)!==92)return!1;if($++,$>=W)return!1;let H=F.src.charCodeAt($);if(H===10){if(!_)F.push("hardbreak","br",0);$++;while($<W){if(H=F.src.charCodeAt($),!dF(H))break;$++}return F.pos=$,!0}let Y=F.src[$];if(H>=55296&&H<=56319&&$+1<W){let G=F.src.charCodeAt($+1);if(G>=56320&&G<=57343)Y+=F.src[$+1],$++}let K="\\"+Y;if(!_){let G=F.push("text_special","",0);if(H<256&&rB[H]!==0)G.content=Y;else G.content=K;G.markup=K,G.info="escape"}return F.pos=$+1,!0}function eB(F,_){let $=F.pos;if(F.src.charCodeAt($)!==96)return!1;let H=$;$++;let Y=F.posMax;while($<Y&&F.src.charCodeAt($)===96)$++;let K=F.src.slice(H,$),G=K.length;if(F.backticksScanned&&(F.backticks[G]||0)<=H){if(!_)F.pending+=K;return F.pos+=G,!0}let U=$,z;while((z=F.src.indexOf("`",U))!==-1){U=z+1;while(U<Y&&F.src.charCodeAt(U)===96)U++;let h=U-z;if(h===G){if(!_){let A=F.push("code_inline","code",0);A.markup=K,A.content=F.src.slice($,z).replace(/\n/g," ").replace(/^ (.+) $/,"$1")}return F.pos=U,!0}F.backticks[h]=z}if(F.backticksScanned=!0,!_)F.pending+=K;return F.pos+=G,!0}function Qy(F,_){let $=F.pos,W=F.src.charCodeAt($);if(_)return!1;if(W!==126)return!1;let H=F.scanDelims(F.pos,!0),Y=H.length,K=String.fromCharCode(W);if(Y<2)return!1;let G;if(Y%2)G=F.push("text","",0),G.content=K,Y--;for(let U=0;U<Y;U+=2)G=F.push("text","",0),G.content=K+K,F.delimiters.push({marker:W,length:0,token:F.tokens.length-1,end:-1,open:H.can_open,close:H.can_close});return F.pos+=H.length,!0}function x2(F,_){let $,W=[],H=_.length;for(let Y=0;Y<H;Y++){let K=_[Y];if(K.marker!==126)continue;if(K.end===-1)continue;let G=_[K.end];if($=F.tokens[K.token],$.type="s_open",$.tag="s",$.nesting=1,$.markup="~~",$.content="",$=F.tokens[G.token],$.type="s_close",$.tag="s",$.nesting=-1,$.markup="~~",$.content="",F.tokens[G.token-1].type==="text"&&F.tokens[G.token-1].content==="~")W.push(G.token-1)}while(W.length){let Y=W.pop(),K=Y+1;while(K<F.tokens.length&&F.tokens[K].type==="s_close")K++;if(K--,Y!==K)$=F.tokens[K],F.tokens[K]=F.tokens[Y],F.tokens[Y]=$}}function Wy(F){let _=F.tokens_meta,$=F.tokens_meta.length;x2(F,F.delimiters);for(let W=0;W<$;W++)if(_[W]&&_[W].delimiters)x2(F,_[W].delimiters)}var Fz={tokenize:Qy,postProcess:Wy};function Hy(F,_){let $=F.pos,W=F.src.charCodeAt($);if(_)return!1;if(W!==95&&W!==42)return!1;let H=F.scanDelims(F.pos,W===42);for(let Y=0;Y<H.length;Y++){let K=F.push("text","",0);K.content=String.fromCharCode(W),F.delimiters.push({marker:W,length:H.length,token:F.tokens.length-1,end:-1,open:H.can_open,close:H.can_close})}return F.pos+=H.length,!0}function g2(F,_){let $=_.length;for(let W=$-1;W>=0;W--){let H=_[W];if(H.marker!==95&&H.marker!==42)continue;if(H.end===-1)continue;let Y=_[H.end],K=W>0&&_[W-1].end===H.end+1&&_[W-1].marker===H.marker&&_[W-1].token===H.token-1&&_[H.end+1].token===Y.token+1,G=String.fromCharCode(H.marker),U=F.tokens[H.token];U.type=K?"strong_open":"em_open",U.tag=K?"strong":"em",U.nesting=1,U.markup=K?G+G:G,U.content="";let z=F.tokens[Y.token];if(z.type=K?"strong_close":"em_close",z.tag=K?"strong":"em",z.nesting=-1,z.markup=K?G+G:G,z.content="",K)F.tokens[_[W-1].token].content="",F.tokens[_[H.end+1].token].content="",W--}}function wy(F){let _=F.tokens_meta,$=F.tokens_meta.length;g2(F,F.delimiters);for(let W=0;W<$;W++)if(_[W]&&_[W].delimiters)g2(F,_[W].delimiters)}var qz={tokenize:Hy,postProcess:wy};function Jz(F,_){let $,W,H,Y,K="",G="",U=F.pos,z=!0;if(F.src.charCodeAt(F.pos)!==91)return!1;let{pos:h,posMax:A}=F,N=F.pos+1,M=F.md.helpers.parseLinkLabel(F,F.pos,!0);if(M<0)return!1;let T=M+1;if(T<A&&F.src.charCodeAt(T)===40){z=!1,T++;for(;T<A;T++)if($=F.src.charCodeAt(T),!dF($)&&$!==10)break;if(T>=A)return!1;if(U=T,H=F.md.helpers.parseLinkDestination(F.src,T,F.posMax),H.ok){if(K=F.md.normalizeLink(H.str),F.md.validateLink(K))T=H.pos;else K="";U=T;for(;T<A;T++)if($=F.src.charCodeAt(T),!dF($)&&$!==10)break;if(H=F.md.helpers.parseLinkTitle(F.src,T,F.posMax),T<A&&U!==T&&H.ok){G=H.str,T=H.pos;for(;T<A;T++)if($=F.src.charCodeAt(T),!dF($)&&$!==10)break}}if(T>=A||F.src.charCodeAt(T)!==41)z=!0;T++}if(z){if(typeof F.env.references>"u")return!1;if(T<A&&F.src.charCodeAt(T)===91)if(U=T+1,T=F.md.helpers.parseLinkLabel(F,T),T>=0)W=F.src.slice(U,T++);else T=M+1;else T=M+1;if(!W)W=F.src.slice(N,M);if(Y=F.env.references[xJ(W)],!Y)return F.pos=h,!1;K=Y.href,G=Y.title}if(!_){F.pos=N,F.posMax=M;let P=F.push("link_open","a",1),D=[["href",K]];if(P.attrs=D,G)D.push(["title",G]);F.linkLevel++,F.md.inline.tokenize(F),F.linkLevel--,F.push("link_close","a",-1)}return F.pos=T,F.posMax=A,!0}function _z(F,_){let $,W,H,Y,K,G,U,z,h="",A=F.pos,N=F.posMax;if(F.src.charCodeAt(F.pos)!==33)return!1;if(F.src.charCodeAt(F.pos+1)!==91)return!1;let M=F.pos+2,T=F.md.helpers.parseLinkLabel(F,F.pos+1,!1);if(T<0)return!1;if(Y=T+1,Y<N&&F.src.charCodeAt(Y)===40){Y++;for(;Y<N;Y++)if($=F.src.charCodeAt(Y),!dF($)&&$!==10)break;if(Y>=N)return!1;if(z=Y,G=F.md.helpers.parseLinkDestination(F.src,Y,F.posMax),G.ok)if(h=F.md.normalizeLink(G.str),F.md.validateLink(h))Y=G.pos;else h="";z=Y;for(;Y<N;Y++)if($=F.src.charCodeAt(Y),!dF($)&&$!==10)break;if(G=F.md.helpers.parseLinkTitle(F.src,Y,F.posMax),Y<N&&z!==Y&&G.ok){U=G.str,Y=G.pos;for(;Y<N;Y++)if($=F.src.charCodeAt(Y),!dF($)&&$!==10)break}else U="";if(Y>=N||F.src.charCodeAt(Y)!==41)return F.pos=A,!1;Y++}else{if(typeof F.env.references>"u")return!1;if(Y<N&&F.src.charCodeAt(Y)===91)if(z=Y+1,Y=F.md.helpers.parseLinkLabel(F,Y),Y>=0)H=F.src.slice(z,Y++);else Y=T+1;else Y=T+1;if(!H)H=F.src.slice(M,T);if(K=F.env.references[xJ(H)],!K)return F.pos=A,!1;h=K.href,U=K.title}if(!_){W=F.src.slice(M,T);let P=[];F.md.inline.parse(W,F.md,F.env,P);let D=F.push("image","img",0),O=[["src",h],["alt",""]];if(D.attrs=O,D.children=P,D.content=W,U)O.push(["title",U])}return F.pos=Y,F.posMax=N,!0}var Yy=/^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/,Xy=/^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;function Zz(F,_){let $=F.pos;if(F.src.charCodeAt($)!==60)return!1;let{pos:W,posMax:H}=F;for(;;){if(++$>=H)return!1;let K=F.src.charCodeAt($);if(K===60)return!1;if(K===62)break}let Y=F.src.slice(W+1,$);if(Xy.test(Y)){let K=F.md.normalizeLink(Y);if(!F.md.validateLink(K))return!1;if(!_){let G=F.push("link_open","a",1);G.attrs=[["href",K]],G.markup="autolink",G.info="auto";let U=F.push("text","",0);U.content=F.md.normalizeLinkText(Y);let z=F.push("link_close","a",-1);z.markup="autolink",z.info="auto"}return F.pos+=Y.length+2,!0}if(Yy.test(Y)){let K=F.md.normalizeLink("mailto:"+Y);if(!F.md.validateLink(K))return!1;if(!_){let G=F.push("link_open","a",1);G.attrs=[["href",K]],G.markup="autolink",G.info="auto";let U=F.push("text","",0);U.content=F.md.normalizeLinkText(Y);let z=F.push("link_close","a",-1);z.markup="autolink",z.info="auto"}return F.pos+=Y.length+2,!0}return!1}function Gy(F){return/^<a[>\s]/i.test(F)}function Ky(F){return/^<\/a\s*>/i.test(F)}function Uy(F){let _=F|32;return _>=97&&_<=122}function $z(F,_){if(!F.md.options.html)return!1;let{posMax:$,pos:W}=F;if(F.src.charCodeAt(W)!==60||W+2>=$)return!1;let H=F.src.charCodeAt(W+1);if(H!==33&&H!==63&&H!==47&&!Uy(H))return!1;let Y=F.src.slice(W).match(y2);if(!Y)return!1;if(!_){let K=F.push("html_inline","",0);if(K.content=Y[0],Gy(K.content))F.linkLevel++;if(Ky(K.content))F.linkLevel--}return F.pos+=Y[0].length,!0}var By=/^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,zy=/^&([a-z][a-z0-9]{1,31});/i;function Qz(F,_){let{pos:$,posMax:W}=F;if(F.src.charCodeAt($)!==38)return!1;if($+1>=W)return!1;if(F.src.charCodeAt($+1)===35){let Y=F.src.slice($).match(By);if(Y){if(!_){let K=Y[1][0].toLowerCase()==="x"?parseInt(Y[1].slice(1),16):parseInt(Y[1],10),G=F.push("text_special","",0);G.content=IY(K)?jQ(K):jQ(65533),G.markup=Y[0],G.info="entity"}return F.pos+=Y[0].length,!0}}else{let Y=F.src.slice($).match(zy);if(Y){let K=yJ(Y[0]);if(K!==Y[0]){if(!_){let G=F.push("text_special","",0);G.content=K,G.markup=Y[0],G.info="entity"}return F.pos+=Y[0].length,!0}}}return!1}function u2(F){let _={},$=F.length;if(!$)return;let W=0,H=-2,Y=[];for(let K=0;K<$;K++){let G=F[K];if(Y.push(0),F[W].marker!==G.marker||H!==G.token-1)W=K;if(H=G.token,G.length=G.length||0,!G.close)continue;if(!_.hasOwnProperty(G.marker))_[G.marker]=[-1,-1,-1,-1,-1,-1];let U=_[G.marker][(G.open?3:0)+G.length%3],z=W-Y[W]-1,h=z;for(;z>U;z-=Y[z]+1){let A=F[z];if(A.marker!==G.marker)continue;if(A.open&&A.end<0){let N=!1;if(A.close||G.open){if((A.length+G.length)%3===0){if(A.length%3!==0||G.length%3!==0)N=!0}}if(!N){let M=z>0&&!F[z-1].open?Y[z-1]+1:0;Y[K]=K-z+M,Y[z]=M,G.open=!1,A.end=K,A.close=!1,h=-1,H=-2;break}}}if(h!==-1)_[G.marker][(G.open?3:0)+(G.length||0)%3]=h}}function Wz(F){let _=F.tokens_meta,$=F.tokens_meta.length;u2(F.delimiters);for(let W=0;W<$;W++)if(_[W]&&_[W].delimiters)u2(_[W].delimiters)}function Hz(F){let _,$,W=0,H=F.tokens,Y=F.tokens.length;for(_=$=0;_<Y;_++){if(H[_].nesting<0)W--;if(H[_].level=W,H[_].nesting>0)W++;if(H[_].type==="text"&&_+1<Y&&H[_+1].type==="text")H[_+1].content=H[_].content+H[_+1].content;else{if(_!==$)H[$]=H[_];$++}}if(_!==$)H.length=$}var wz=[["text",sB],["linkify",oB],["newline",aB],["escape",tB],["backticks",eB],["strikethrough",Fz.tokenize],["emphasis",qz.tokenize],["link",Jz],["image",_z],["autolink",Zz],["html_inline",$z],["entity",Qz]],Yz=[["balance_pairs",Wz],["strikethrough",Fz.postProcess],["emphasis",qz.postProcess],["fragments_join",Hz]];function gQ(){this.ruler=new gJ;for(let F=0;F<wz.length;F++)this.ruler.push(wz[F][0],wz[F][1]);this.ruler2=new gJ;for(let F=0;F<Yz.length;F++)this.ruler2.push(Yz[F][0],Yz[F][1])}gQ.prototype.skipToken=function(F){let _=F.pos,$=this.ruler.getRules(""),W=$.length,H=F.md.options.maxNesting,Y=F.cache;if(typeof Y[_]<"u"){F.pos=Y[_];return}let K=!1;if(F.level<H){for(let G=0;G<W;G++)if(F.level++,K=$[G](F,!0),F.level--,K){if(_>=F.pos)throw Error("inline rule didn't increment state.pos");break}}else F.pos=F.posMax;if(!K)F.pos++;Y[_]=F.pos};gQ.prototype.tokenize=function(F){let _=this.ruler.getRules(""),$=_.length,W=F.posMax,H=F.md.options.maxNesting;while(F.pos<W){let Y=F.pos,K=!1;if(F.level<H){for(let G=0;G<$;G++)if(K=_[G](F,!1),K){if(Y>=F.pos)throw Error("inline rule didn't increment state.pos");break}}if(K){if(F.pos>=W)break;continue}F.pending+=F.src[F.pos++]}if(F.pending)F.pushPending()};gQ.prototype.parse=function(F,_,$,W){let H=new this.State(F,_,$,W);this.tokenize(H);let Y=this.ruler2.getRules(""),K=Y.length;for(let G=0;G<K;G++)Y[G](H)};gQ.prototype.State=j2;var p2=gQ;function Xz(F){let _={};F=F||{},_.src_Any=NY.source,_.src_Cc=DY.source,_.src_Z=OY.source,_.src_P=fZ.source,_.src_ZPCc=[_.src_Z,_.src_P,_.src_Cc].join("|"),_.src_ZCc=[_.src_Z,_.src_Cc].join("|");let $="[><]";return _.src_pseudo_letter="(?:(?!"+$+"|"+_.src_ZPCc+")"+_.src_Any+")",_.src_ip4="(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)",_.src_auth="(?:(?:(?!"+_.src_ZCc+"|[@/\\[\\]()]).)+@)?",_.src_port="(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?",_.src_host_terminator="(?=$|"+$+"|"+_.src_ZPCc+")(?!"+(F["---"]?"-(?!--)|":"-|")+"_|:\\d|\\.-|\\.(?!$|"+_.src_ZPCc+"))",_.src_path="(?:[/?#](?:(?!"+_.src_ZCc+"|"+$+`|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!`+_.src_ZCc+"|\\]).)*\\]|\\((?:(?!"+_.src_ZCc+"|[)]).)*\\)|\\{(?:(?!"+_.src_ZCc+"|[}]).)*\\}|\\\"(?:(?!"+_.src_ZCc+'|["]).)+\\"|\\\'(?:(?!'+_.src_ZCc+"|[']).)+\\'|\\'(?="+_.src_pseudo_letter+"|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!"+_.src_ZCc+"|[.]|$)|"+(F["---"]?"\\-(?!--(?:[^-]|$))(?:-*)|":"\\-+|")+",(?!"+_.src_ZCc+"|$)|;(?!"+_.src_ZCc+"|$)|\\!+(?!"+_.src_ZCc+"|[!]|$)|\\?(?!"+_.src_ZCc+"|[?]|$))+|\\/)?",_.src_email_name="[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\\"\\.a-zA-Z0-9_]*",_.src_xn="xn--[a-z0-9\\-]{1,59}",_.src_domain_root="(?:"+_.src_xn+"|"+_.src_pseudo_letter+"{1,63})",_.src_domain="(?:"+_.src_xn+"|(?:"+_.src_pseudo_letter+")|(?:"+_.src_pseudo_letter+"(?:-|"+_.src_pseudo_letter+"){0,61}"+_.src_pseudo_letter+"))",_.src_host="(?:(?:(?:(?:"+_.src_domain+")\\.)*"+_.src_domain+"))",_.tpl_host_fuzzy="(?:"+_.src_ip4+"|(?:(?:(?:"+_.src_domain+")\\.)+(?:%TLDS%)))",_.tpl_host_no_ip_fuzzy="(?:(?:(?:"+_.src_domain+")\\.)+(?:%TLDS%))",_.src_host_strict=_.src_host+_.src_host_terminator,_.tpl_host_fuzzy_strict=_.tpl_host_fuzzy+_.src_host_terminator,_.src_host_port_strict=_.src_host+_.src_port+_.src_host_terminator,_.tpl_host_port_fuzzy_strict=_.tpl_host_fuzzy+_.src_port+_.src_host_terminator,_.tpl_host_port_no_ip_fuzzy_strict=_.tpl_host_no_ip_fuzzy+_.src_port+_.src_host_terminator,_.tpl_host_fuzzy_test="localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:"+_.src_ZPCc+"|>|$))",_.tpl_email_fuzzy="(^|"+$+'|"|\\(|'+_.src_ZCc+")("+_.src_email_name+"@"+_.tpl_host_fuzzy_strict+")",_.tpl_link_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|]|"+_.src_ZPCc+"))"+"((?![$+<=>^`|])"+_.tpl_host_port_fuzzy_strict+_.src_path+")",_.tpl_link_no_ip_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|]|"+_.src_ZPCc+"))"+"((?![$+<=>^`|])"+_.tpl_host_port_no_ip_fuzzy_strict+_.src_path+")",_}function Gz(F){return Array.prototype.slice.call(arguments,1).forEach(function($){if(!$)return;Object.keys($).forEach(function(W){F[W]=$[W]})}),F}function PY(F){return Object.prototype.toString.call(F)}function Ay(F){return PY(F)==="[object String]"}function hy(F){return PY(F)==="[object Object]"}function Ry(F){return PY(F)==="[object RegExp]"}function m2(F){return PY(F)==="[object Function]"}function Ny(F){return F.replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}var d2={fuzzyLink:!0,fuzzyEmail:!0,fuzzyIP:!1};function Dy(F){return Object.keys(F||{}).reduce(function(_,$){return _||d2.hasOwnProperty($)},!1)}var My={"http:":{validate:function(F,_,$){let W=F.slice(_);if(!$.re.http)$.re.http=new RegExp("^\\/\\/"+$.re.src_auth+$.re.src_host_port_strict+$.re.src_path,"i");if($.re.http.test(W))return W.match($.re.http)[0].length;return 0}},"https:":"http:","ftp:":"http:","//":{validate:function(F,_,$){let W=F.slice(_);if(!$.re.no_http)$.re.no_http=new RegExp("^"+$.re.src_auth+"(?:localhost|(?:(?:"+$.re.src_domain+")\\.)+"+$.re.src_domain_root+")"+$.re.src_port+$.re.src_host_terminator+$.re.src_path,"i");if($.re.no_http.test(W)){if(_>=3&&F[_-3]===":")return 0;if(_>=3&&F[_-3]==="/")return 0;return W.match($.re.no_http)[0].length}return 0}},"mailto:":{validate:function(F,_,$){let W=F.slice(_);if(!$.re.mailto)$.re.mailto=new RegExp("^"+$.re.src_email_name+"@"+$.re.src_host_strict,"i");if($.re.mailto.test(W))return W.match($.re.mailto)[0].length;return 0}}},Oy="a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",fy="biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");function Iy(F){F.__index__=-1,F.__text_cache__=""}function Ty(F){return function(_,$){let W=_.slice($);if(F.test(W))return W.match(F)[0].length;return 0}}function l2(){return function(F,_){_.normalize(F)}}function CY(F){let _=F.re=Xz(F.__opts__),$=F.__tlds__.slice();if(F.onCompile(),!F.__tlds_replaced__)$.push(Oy);$.push(_.src_xn),_.src_tlds=$.join("|");function W(G){return G.replace("%TLDS%",_.src_tlds)}_.email_fuzzy=RegExp(W(_.tpl_email_fuzzy),"i"),_.link_fuzzy=RegExp(W(_.tpl_link_fuzzy),"i"),_.link_no_ip_fuzzy=RegExp(W(_.tpl_link_no_ip_fuzzy),"i"),_.host_fuzzy_test=RegExp(W(_.tpl_host_fuzzy_test),"i");let H=[];F.__compiled__={};function Y(G,U){throw Error('(LinkifyIt) Invalid schema "'+G+'": '+U)}Object.keys(F.__schemas__).forEach(function(G){let U=F.__schemas__[G];if(U===null)return;let z={validate:null,link:null};if(F.__compiled__[G]=z,hy(U)){if(Ry(U.validate))z.validate=Ty(U.validate);else if(m2(U.validate))z.validate=U.validate;else Y(G,U);if(m2(U.normalize))z.normalize=U.normalize;else if(!U.normalize)z.normalize=l2();else Y(G,U);return}if(Ay(U)){H.push(G);return}Y(G,U)}),H.forEach(function(G){if(!F.__compiled__[F.__schemas__[G]])return;F.__compiled__[G].validate=F.__compiled__[F.__schemas__[G]].validate,F.__compiled__[G].normalize=F.__compiled__[F.__schemas__[G]].normalize}),F.__compiled__[""]={validate:null,normalize:l2()};let K=Object.keys(F.__compiled__).filter(function(G){return G.length>0&&F.__compiled__[G]}).map(Ny).join("|");F.re.schema_test=RegExp("(^|(?!_)(?:[><]|"+_.src_ZPCc+"))("+K+")","i"),F.re.schema_search=RegExp("(^|(?!_)(?:[><]|"+_.src_ZPCc+"))("+K+")","ig"),F.re.schema_at_start=RegExp("^"+F.re.schema_search.source,"i"),F.re.pretest=RegExp("("+F.re.schema_test.source+")|("+F.re.host_fuzzy_test.source+")|@","i"),Iy(F)}function Ly(F,_){let{__index__:$,__last_index__:W}=F,H=F.__text_cache__.slice($,W);this.schema=F.__schema__.toLowerCase(),this.index=$+_,this.lastIndex=W+_,this.raw=H,this.text=H,this.url=H}function Kz(F,_){let $=new Ly(F,_);return F.__compiled__[$.schema].normalize($,F),$}function G8(F,_){if(!(this instanceof G8))return new G8(F,_);if(!_){if(Dy(F))_=F,F={}}this.__opts__=Gz({},d2,_),this.__index__=-1,this.__last_index__=-1,this.__schema__="",this.__text_cache__="",this.__schemas__=Gz({},My,F),this.__compiled__={},this.__tlds__=fy,this.__tlds_replaced__=!1,this.re={},CY(this)}G8.prototype.add=function(_,$){return this.__schemas__[_]=$,CY(this),this};G8.prototype.set=function(_){return this.__opts__=Gz(this.__opts__,_),this};G8.prototype.test=function(_){if(this.__text_cache__=_,this.__index__=-1,!_.length)return!1;let $,W,H,Y,K,G,U,z,h;if(this.re.schema_test.test(_)){U=this.re.schema_search,U.lastIndex=0;while(($=U.exec(_))!==null)if(Y=this.testSchemaAt(_,$[2],U.lastIndex),Y){this.__schema__=$[2],this.__index__=$.index+$[1].length,this.__last_index__=$.index+$[0].length+Y;break}}if(this.__opts__.fuzzyLink&&this.__compiled__["http:"]){if(z=_.search(this.re.host_fuzzy_test),z>=0){if(this.__index__<0||z<this.__index__){if((W=_.match(this.__opts__.fuzzyIP?this.re.link_fuzzy:this.re.link_no_ip_fuzzy))!==null){if(K=W.index+W[1].length,this.__index__<0||K<this.__index__)this.__schema__="",this.__index__=K,this.__last_index__=W.index+W[0].length}}}}if(this.__opts__.fuzzyEmail&&this.__compiled__["mailto:"]){if(h=_.indexOf("@"),h>=0){if((H=_.match(this.re.email_fuzzy))!==null){if(K=H.index+H[1].length,G=H.index+H[0].length,this.__index__<0||K<this.__index__||K===this.__index__&&G>this.__last_index__)this.__schema__="mailto:",this.__index__=K,this.__last_index__=G}}}return this.__index__>=0};G8.prototype.pretest=function(_){return this.re.pretest.test(_)};G8.prototype.testSchemaAt=function(_,$,W){if(!this.__compiled__[$.toLowerCase()])return 0;return this.__compiled__[$.toLowerCase()].validate(_,W,this)};G8.prototype.match=function(_){let $=[],W=0;if(this.__index__>=0&&this.__text_cache__===_)$.push(Kz(this,W)),W=this.__last_index__;let H=W?_.slice(W):_;while(this.test(H))$.push(Kz(this,W)),H=H.slice(this.__last_index__),W+=this.__last_index__;if($.length)return $;return null};G8.prototype.matchAtStart=function(_){if(this.__text_cache__=_,this.__index__=-1,!_.length)return null;let $=this.re.schema_at_start.exec(_);if(!$)return null;let W=this.testSchemaAt(_,$[2],$[0].length);if(!W)return null;return this.__schema__=$[2],this.__index__=$.index+$[1].length,this.__last_index__=$.index+$[0].length+W,Kz(this,0)};G8.prototype.tlds=function(_,$){if(_=Array.isArray(_)?_:[_],!$)return this.__tlds__=_.slice(),this.__tlds_replaced__=!0,CY(this),this;return this.__tlds__=this.__tlds__.concat(_).sort().filter(function(W,H,Y){return W!==Y[H-1]}).reverse(),CY(this),this};G8.prototype.normalize=function(_){if(!_.schema)_.url="http://"+_.url;if(_.schema==="mailto:"&&!/^mailto:/i.test(_.url))_.url="mailto:"+_.url};G8.prototype.onCompile=function(){};var i2=G8;var Ey=/^xn--/,Cy=/[^\0-\x7F]/,Py=/[\x2E\u3002\uFF0E\uFF61]/g,Vy={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"};var j7=Math.floor,Uz=String.fromCharCode;function Tq(F){throw RangeError(Vy[F])}function ky(F,_){let $=[],W=F.length;while(W--)$[W]=_(F[W]);return $}function c2(F,_){let $=F.split("@"),W="";if($.length>1)W=$[0]+"@",F=$[1];F=F.replace(Py,".");let H=F.split("."),Y=ky(H,_).join(".");return W+Y}function s2(F){let _=[],$=0,W=F.length;while($<W){let H=F.charCodeAt($++);if(H>=55296&&H<=56319&&$<W){let Y=F.charCodeAt($++);if((Y&64512)==56320)_.push(((H&1023)<<10)+(Y&1023)+65536);else _.push(H),$--}else _.push(H)}return _}var Sy=(F)=>String.fromCodePoint(...F),yy=function(F){if(F>=48&&F<58)return 26+(F-48);if(F>=65&&F<91)return F-65;if(F>=97&&F<123)return F-97;return 36},n2=function(F,_){return F+22+75*(F<26)-((_!=0)<<5)},o2=function(F,_,$){let W=0;F=$?j7(F/700):F>>1,F+=j7(F/_);for(;F>455;W+=36)F=j7(F/35);return j7(W+36*F/(F+38))},a2=function(F){let _=[],$=F.length,W=0,H=128,Y=72,K=F.lastIndexOf("-");if(K<0)K=0;for(let G=0;G<K;++G){if(F.charCodeAt(G)>=128)Tq("not-basic");_.push(F.charCodeAt(G))}for(let G=K>0?K+1:0;G<$;){let U=W;for(let h=1,A=36;;A+=36){if(G>=$)Tq("invalid-input");let N=yy(F.charCodeAt(G++));if(N>=36)Tq("invalid-input");if(N>j7((2147483647-W)/h))Tq("overflow");W+=N*h;let M=A<=Y?1:A>=Y+26?26:A-Y;if(N<M)break;let T=36-M;if(h>j7(2147483647/T))Tq("overflow");h*=T}let z=_.length+1;if(Y=o2(W-U,z,U==0),j7(W/z)>2147483647-H)Tq("overflow");H+=j7(W/z),W%=z,_.splice(W++,0,H)}return String.fromCodePoint(..._)},r2=function(F){let _=[];F=s2(F);let $=F.length,W=128,H=0,Y=72;for(let U of F)if(U<128)_.push(Uz(U));let K=_.length,G=K;if(K)_.push("-");while(G<$){let U=2147483647;for(let h of F)if(h>=W&&h<U)U=h;let z=G+1;if(U-W>j7((2147483647-H)/z))Tq("overflow");H+=(U-W)*z,W=U;for(let h of F){if(h<W&&++H>2147483647)Tq("overflow");if(h===W){let A=H;for(let N=36;;N+=36){let M=N<=Y?1:N>=Y+26?26:N-Y;if(A<M)break;let T=A-M,P=36-M;_.push(Uz(n2(M+T%P,0))),A=j7(T/P)}_.push(Uz(n2(A,0))),Y=o2(H,z,G===K),H=0,++G}}++H,++W}return _.join("")},vy=function(F){return c2(F,function(_){return Ey.test(_)?a2(_.slice(4).toLowerCase()):_})},by=function(F){return c2(F,function(_){return Cy.test(_)?"xn--"+r2(_):_})},jy={version:"2.3.1",ucs2:{decode:s2,encode:Sy},decode:a2,encode:r2,toASCII:by,toUnicode:vy};var Bz=jy;var t2={options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"",highlight:null,maxNesting:100},components:{core:{},block:{},inline:{}}};var e2={options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"",highlight:null,maxNesting:20},components:{core:{rules:["normalize","block","inline","text_join"]},block:{rules:["paragraph"]},inline:{rules:["text"],rules2:["balance_pairs","fragments_join"]}}};var FI={options:{html:!0,xhtmlOut:!0,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"",highlight:null,maxNesting:20},components:{core:{rules:["normalize","block","inline","text_join"]},block:{rules:["blockquote","code","fence","heading","hr","html_block","lheading","list","reference","paragraph"]},inline:{rules:["autolink","backticks","emphasis","entity","escape","html_inline","image","link","newline","text"],rules2:["balance_pairs","emphasis","fragments_join"]}}};var xy={default:t2,zero:e2,commonmark:FI},gy=/^(vbscript|javascript|file|data):/,uy=/^data:image\/(gif|png|jpeg|webp);/;function py(F){let _=F.trim().toLowerCase();return gy.test(_)?uy.test(_):!0}var qI=["http:","https:","mailto:"];function my(F){let _=bQ(F,!0);if(_.hostname){if(!_.protocol||qI.indexOf(_.protocol)>=0)try{_.hostname=Bz.toASCII(_.hostname)}catch($){}}return AY(OZ(_))}function ly(F){let _=bQ(F,!0);if(_.hostname){if(!_.protocol||qI.indexOf(_.protocol)>=0)try{_.hostname=Bz.toUnicode(_.hostname)}catch($){}}return vQ(OZ(_),vQ.defaultChars+"%")}function S8(F,_){if(!(this instanceof S8))return new S8(F,_);if(!_){if(!fY(F))_=F||{},F="default"}if(this.inline=new p2,this.block=new b2,this.core=new L2,this.renderer=new D2,this.linkify=new i2,this.validateLink=py,this.normalizeLink=my,this.normalizeLinkText=ly,this.utils=MB,this.helpers=IZ({},TB),this.options={},this.configure(F),_)this.set(_)}S8.prototype.set=function(F){return IZ(this.options,F),this};S8.prototype.configure=function(F){let _=this;if(fY(F)){let $=F;if(F=xy[$],!F)throw Error('Wrong `markdown-it` preset "'+$+'", check name')}if(!F)throw Error("Wrong `markdown-it` preset, can't be empty");if(F.options)_.set(F.options);if(F.components)Object.keys(F.components).forEach(function($){if(F.components[$].rules)_[$].ruler.enableOnly(F.components[$].rules);if(F.components[$].rules2)_[$].ruler2.enableOnly(F.components[$].rules2)});return this};S8.prototype.enable=function(F,_){let $=[];if(!Array.isArray(F))F=[F];["core","block","inline"].forEach(function(H){$=$.concat(this[H].ruler.enable(F,!0))},this),$=$.concat(this.inline.ruler2.enable(F,!0));let W=F.filter(function(H){return $.indexOf(H)<0});if(W.length&&!_)throw Error("MarkdownIt. Failed to enable unknown rule(s): "+W);return this};S8.prototype.disable=function(F,_){let $=[];if(!Array.isArray(F))F=[F];["core","block","inline"].forEach(function(H){$=$.concat(this[H].ruler.disable(F,!0))},this),$=$.concat(this.inline.ruler2.disable(F,!0));let W=F.filter(function(H){return $.indexOf(H)<0});if(W.length&&!_)throw Error("MarkdownIt. Failed to disable unknown rule(s): "+W);return this};S8.prototype.use=function(F){let _=[this].concat(Array.prototype.slice.call(arguments,1));return F.apply(F,_),this};S8.prototype.parse=function(F,_){if(typeof F!=="string")throw Error("Input data should be a String");let $=new this.core.State(F,this,_);return this.core.process($),$.tokens};S8.prototype.render=function(F,_){return _=_||{},this.renderer.render(this.parse(F,_),this.options,_)};S8.prototype.parseInline=function(F,_){let $=new this.core.State(F,this,_);return $.inlineMode=!0,this.core.process($),$.tokens};S8.prototype.renderInline=function(F,_){return _=_||{},this.renderer.render(this.parseInline(F,_),this.options,_)};var zz=S8;var II=U6(fI(),1);var mQ=II.default;var fz=U6(LI(),1),Oz=U6(lQ(),1);mQ.registerLanguage("lean",fz.default);mQ.registerLanguage("lean4",fz.default);function yv(F){if(typeof window>"u"||!window.katex)return F;let _=F.replace(/\\\[([\s\S]*?)\\\]/g,($,W)=>{try{return`<div class="math-block my-4">${window.katex.renderToString(W.trim(),{displayMode:!0,throwOnError:!1})}</div>`}catch(H){return console.error("KaTeX display error:",H,W),`<div class="text-red-500">[Math Error: ${W}]</div>`}});return _=_.replace(/\\\((.*?)\\\)/g,($,W)=>{try{return window.katex.renderToString(W.trim(),{displayMode:!1,throwOnError:!1})}catch(H){return console.error("KaTeX inline error:",H,W),`<span class="text-red-500">[Math Error: ${W}]</span>`}}),_=_.replace(/\$\$([\s\S]*?)\$\$/g,($,W)=>{try{return`<div class="math-block my-4">${window.katex.renderToString(W.trim(),{displayMode:!0,throwOnError:!1})}</div>`}catch(H){return console.error("KaTeX display $$ error:",H,W),`<div class="text-red-500">[Math Error: ${W}]</div>`}}),_=_.replace(/(?<!\$)\$(?!\$)([^\$\n]+?)\$(?!\$)/g,($,W)=>{try{return window.katex.renderToString(W.trim(),{displayMode:!1,throwOnError:!1})}catch(H){return console.error("KaTeX inline $ error:",H,W),`<span class="text-red-500">[Math Error: ${W}]</span>`}}),_}function EI({content:F,className:_}){let[$,W]=VZ.useState(!1);VZ.useEffect(()=>{let Y=()=>{if(typeof window<"u"&&window.katex)return W(!0),!0;return!1};if(!Y()){let K=setInterval(()=>{if(Y())clearInterval(K)},100);return()=>clearInterval(K)}},[]);let H=VZ.useMemo(()=>{if(!$)return"";let Y=yv(F),K=new zz({html:!0,linkify:!0,typographer:!0,highlight:function(G,U){let z=U||"lean";if(mQ.getLanguage(z))try{return'<pre class="hljs"><code>'+mQ.highlight(G,{language:z,ignoreIllegals:!0}).value+"</code></pre>"}catch(h){}return'<pre class="hljs"><code>'+K.utils.escapeHtml(G)+"</code></pre>"}});return K.render(Y)},[F,$]);if(!$)return Oz.jsxDEV("div",{className:"text-stone-400 text-sm animate-pulse",children:"Loading..."},void 0,!1,void 0,this);return Oz.jsxDEV("div",{className:`mdx-content prose prose-stone prose-sm max-w-none ${_||""}`,dangerouslySetInnerHTML:{__html:H}},void 0,!1,void 0,this)}var D1={};D1[1]="# Generalizing proofs in Lean: `Harmonic.GeneralizeProofs`\n\nThis section defines a customized version of Mathlibs `generalize_proofs` tactic. The goal of the tactic is to **remove proof-term dependencies from definitional equality** by turning those proofs into explicit arguments. In large formalizations (like the Sensitivity Conjecture), this prevents Lean from getting stuck on the same proposition, but different proof objects, and makes rewriting and definitional reduction far more robust.\n\nBelow is a guided tour of what the code does and why it matters.\n\n## Big picture: what `generalize_proofs` does\n\nLeans definitional equality treats proofs as data. When you build terms that depend on a proof (for example, a dependent `Subtype`, `Finset` membership proof, or a lemma packaged into a structure), the *exact proof term* can affect whether two expressions are definitionally equal. Two mathematically identical proofs can still be different terms, and that can block rewriting or `simp` from closing a goal.\n\n`generalize_proofs` fixes this by:\n\n1. Scanning a term (the goal or selected hypotheses).\n2. Finding proof terms that occur inside it.\n3. Abstracting those proofs into fresh variables.\n4. Replacing the original proof terms with those variables.\n\nAfter the tactic, your goal is definitionally equal to a version that no longer hardcodes those proof objects. This makes subsequent transformations and rewrites *proof-irrelevant in practice*, even when Leans kernel still distinguishes proof terms.\n\n## Walkthrough of the implementation\n\n### 1. `mkLambdaFVarsUsedOnly'`\n```lean\n-- Like Mathlibs helper, but keeps all fvars (usedOnly := false).\ndef mkLambdaFVarsUsedOnly' (fvars : Array Expr) (e : Expr) : MetaM (Array Expr  Expr)\n```\nThis function wraps an expression in lambdas over a list of free variables, but **does not drop unused binders** (`usedOnly := false`). This is crucial when abstracting proofs: a proof might be needed for type-checking even if it is not syntactically referenced after reduction. Keeping all binders avoids accidentally losing dependencies.\n\n### 2. `abstractProofs'`\n```lean\npartial def abstractProofs' (e : Expr) (ty? : Option Expr) : MAbs Expr\n```\nThis is the main traversal. It walks the expression tree and, whenever it encounters a proof term, it:\n\n- Beta-reduces and normalizes the proof.\n- Lambda-abstracts over the current local proof variables.\n- Stores the generalized proof term in an internal cache (`MAbs.insertProof`).\n- Replaces the original proof occurrence with an application of the generalized proof to the local proof variables.\n\nThe result is an expression where each proof is lifted out and can be introduced as a fresh hypothesis later.\n\nTwo key details:\n\n- **`config.maxDepth`**: limits recursion for performance; beyond that, it leaves the term as-is.\n- **`config.abstract`**: if false and a proof depends on locals, it wont be abstracted. This preserves behavior in sensitive contexts.\n\n### 3. `withGeneralizedProofs'`\n```lean\npartial def withGeneralizedProofs' {} ... (e : Expr) (ty? : Option Expr)\n    (k : Array Expr  Array Expr  Expr  MGen ) : MGen \n```\nThis wraps `abstractProofs'` and **materializes** the generalizations as new local hypotheses:\n\n- It runs `abstractProofs'` to collect the proof terms that should be abstracted.\n- For each collected proof type, it creates a new local hypothesis.\n- It replaces proof occurrences in the expression with those new fvars.\n\nThe callback `k` then receives:\n\n- `fvars`: the new proof variables introduced,\n- `pfs`: the generalized proof terms (as lambda-expressions),\n- `e'`: the updated expression with abstracted proofs.\n\n### 4. `generalizeProofsCore'`\n```lean\npartial def generalizeProofsCore'\n    (g : MVarId) (fvars rfvars : Array FVarId) (target : Bool)\n```\nThis is the core tactic logic. It:\n\n1. Reverts the selected hypotheses (or all hypotheses if `location` is `*`).\n2. Re-introduces them one-by-one.\n3. While re-introducing, it runs `withGeneralizedProofs'` on each type to generalize proofs inside the binder type.\n4. Optionally generalizes proofs in the **target** (if `target = true`).\n\nTheres also a specialized path for let-bound proofs and proof hypotheses already in the context (`propToFVar`) to reuse existing proof variables rather than introduce duplicates.\n\n### 5. `generalizeProofs'` and the elaborator\n```lean\nelab (name := generalizeProofsElab'') \"generalize_proofs\" ...\n```\nThis installs the tactic so it behaves like Mathlibs `generalize_proofs`, but uses the modified helpers above. You can call it as:\n\n- `generalize_proofs`  generalize proofs in all hypotheses and the target.\n- `generalize_proofs at h1 h2`  only in specific hypotheses.\n- `generalize_proofs at *`  all hypotheses.\n\nThe optional binder identifiers let you name the newly introduced proof variables.\n\n## Why this matters for the Sensitivity Conjecture proof\n\nThe Sensitivity Conjecture formalization involves deep chains of dependent definitionsfinite sets, subtypes, and structures whose fields contain proof objects (e.g., membership proofs, bound proofs, and proof-carrying indices). In such environments:\n\n- Many expressions are **definitionally equal only if their internal proof terms match exactly**.\n- Rewriting and simplification can get stuck because proof terms differ even though the propositions are equivalent.\n- Tactics that rely on definitional equality (like `simp`, `cases`, `rfl`, or automation) can fail unexpectedly or create fragile proof scripts.\n\n`Harmonic.GeneralizeProofs.generalize_proofs` eliminates these issues by **making those proof terms explicit parameters**. Once a proof is an argument rather than hidden inside a definition, Lean stops requiring exact proof-term equality to reduce or rewrite. In practice, this makes the large, compositional steps in the Sensitivity Conjecture proof *stable and predictable*.\n\n### Intuition in one sentence\nYou can think of `generalize_proofs` as proof-irrelevance on demand: it rewrites a goal so that the proof objects stop mattering for definitional equality, which is exactly what you want in a long, dependent proof like the Sensitivity Conjecture.\n\n## Minimal example (conceptual)\n\nSuppose you have a term that depends on two different proofs of the same fact. Those proofs are not definitionally equal, so rewriting fails. After `generalize_proofs`, both are replaced by a fresh variable, and definitional equality no longer cares which proof was used.\n\nThis is precisely the kind of technical friction the Sensitivity Conjecture proof would otherwise face repeatedly.\n";D1[2]=`# Section 2: Sensitivity in Lean

This section defines the *sensitivity* of a Boolean function  the central concept in the Sensitivity Conjecture.

## What sensitivity measures

For a Boolean function \\(f : \\{0,1\\}^n \\to \\{0,1\\}\\), the **sensitivity** of \`f\` is the maximum, over all inputs \`x\`, of how many single-bit flips change the output. Informally:

- Fix an input \`x\`.
- Flip exactly one coordinate to get a neighbor \`y\`.
- Count how many such neighbors change \`f\`'s value.
- Sensitivity is the maximum of that count over all \`x\`.

So sensitivity measures how locally "fragile" the function is: if many one-bit changes flip the output, \`f\` is highly sensitive at that input.

## The Lean definition

The code in this section is:

\`\`\`lean
def sensitivity {n : } (f : (Fin n  Bool)  Bool) :  :=
  Finset.sup Finset.univ (fun x =>
    Finset.card
      (Finset.filter
        (fun y =>
          (Finset.card (Finset.filter (fun i => x i  y i) Finset.univ) = 1)
           f x  f y)
        Finset.univ))
\`\`\`

Let's unpack this in pieces.

### Term-level definition (no tactics)

This snippet is written entirely in **term mode** (a direct expression), not in tactic mode. There are **no tactics** here  no \`by\`, \`simp\`, \`linarith\`, etc. Everything is a nested expression that Lean can typecheck without any proof scripting.

### Types and inputs

- \`n : \` is the input size.
- An input vector \`x\` is represented as a function \`Fin n  Bool\`, i.e., a Boolean value for each index \`0, 1, ..., n-1\`.
- The Boolean function is \`f : (Fin n  Bool)  Bool\`.

Additional Lean details:

- \`def sensitivity {n : } (f : (Fin n  Bool)  Bool) :  := ...\`
  - \`def\` introduces a new constant with a definition.
  - \`{n : }\` uses **implicit binder** syntax: the curly braces mean Lean will usually infer \`n\`.
  - \`(f : (Fin n  Bool)  Bool)\` is an **explicit binder**: \`f\` must be supplied.
  - \`: \` states the **result type** of the definition.
  - \`:=\` separates the name/signature from the defining expression.
  - Parentheses are used for grouping types and binders; arrows \`\` associate to the right.

**Correspondence with standard notation**: In the mathematical literature, inputs are elements of \`{0,1}^n\`. In Lean, we use \`Fin n  Bool\` with the convention:
- \`false\` corresponds to \`0\`
- \`true\` corresponds to \`1\`

So a Boolean vector like \`(0, 1, 1, 0)\` becomes the function \`fun i => if i = 1  i = 2 then true else false\`.

### Finsets and \`Finset.univ\`

Lean uses finite sets (\`Finset\`) to quantify over all elements of a finite type. Here:

- \`Finset.univ\` over \`Fin n  Bool\` is the set of all Boolean vectors of length \`n\`.
- \`Finset.univ\` over \`Fin n\` is the set of all indices \`0..n-1\`.
- \`Finset\` is a data type for finite sets with decidable equality; it carries a list-like representation plus proofs that duplicates are removed.

**Why this works**: Lean knows that \`Fin n  Bool\` is a finite type via the \`Fintype\` instance for function types. Specifically, \`Fintype.card (Fin n  Bool) = 2^n\` because there are 2 choices (true/false) for each of the \`n\` positions. This instance allows \`Finset.univ\` to enumerate all \`2^n\` Boolean vectors.

### Counting Hamming distance 1

Inside the definition, this fragment:

\`\`\`lean
Finset.card (Finset.filter (fun i => x i  y i) Finset.univ)
\`\`\`

counts the number of indices \`i\` where \`x i\` differs from \`y i\`. This is the Hamming distance between \`x\` and \`y\`.

Lean syntax details here:

- \`fun i => ...\` is a **lambda expression** (anonymous function). The \`=>\` introduces the body.
- \`x i\` is **function application**: \`x\` is a function \`Fin n  Bool\`, so \`x i\` is a \`Bool\`.
- \`\` is notation for \`Not ( = )\`, producing a **proposition** (\`Prop\`). For \`Bool\`, Lean uses the \`DecidableEq\` instance to decide equality.
- \`Finset.filter\` expects a **decidable predicate** \`  Prop\`; the system infers decidability for \`x i  y i\`.
- \`Finset.card\` returns a **natural number** (\`\`) counting elements of the filtered finset.

The condition

\`\`\`lean
(... = 1)
\`\`\`

forces \`y\` to differ from \`x\` in exactly one coordinate.

### Counting sensitive neighbors

The inner filter is:

\`\`\`lean
Finset.filter (fun y => (distance = 1)  f x  f y) Finset.univ
\`\`\`

So for a fixed \`x\`, it keeps all \`y\` with Hamming distance 1 from \`x\` and where \`f\` flips value. Then:

\`\`\`lean
Finset.card (...)
\`\`\`

counts how many such \`y\` exist. This is the **sensitivity of \`f\` at \`x\`**.

Lean syntax details in this predicate:

- \`\` is logical **conjunction** (\`And\`) in \`Prop\`.
- \`f x\` applies the Boolean function to an input, so \`f x : Bool\`.
- \`f x  f y\` is a proposition about Boolean inequality (not a Boolean XOR).
- The whole predicate \`(... = 1)  f x  f y\` lives in \`Prop\` and is used by \`Finset.filter\`.

### Taking the maximum

Finally,

\`\`\`lean
Finset.sup Finset.univ (fun x => ...)
\`\`\`

computes the supremum of that count across all inputs \`x\`. This yields the overall sensitivity of \`f\`.

Lean syntax details here:

- \`Finset.sup\` takes a finset and a function; its second argument is the \`fun x => ...\` lambda.
- The \`x\` bound by \`fun x =>\` is implicitly typed as \`Fin n  Bool\` because \`Finset.univ\` ranges over that type.
- Lean uses **typeclass inference** to pick the \`sup\` operation for \`\` and the bottom element \`\`.

**Technical note on \`Finset.sup\`**: This is the lattice supremum operation. For natural numbers (\`\`), the lattice supremum is simply the maximum. The function \`Finset.sup\` requires a \`SemilatticeSup\` instance with a bottom element \`\`; for \`\`, this bottom is \`0\`. If the set is empty, \`Finset.sup\` returns \` = 0\`. For nonempty sets, you could equivalently use \`Finset.sup'\` which doesn't need the bottom element but requires a nonemptiness proof.

## Worked example: the OR function

Let \`n = 3\` and define \`f\` to be the OR function:

\`\`\`lean
def or3 : (Fin 3  Bool)  Bool := fun x => x 0 || x 1 || x 2
\`\`\`

In standard notation, \`or3(x, x, x) = x  x  x\`, which is \`true\` if any bit is \`true\`.

**Analyzing sensitivity at each input:**

- \`x = (false, false, false)\` (the all-zeros input):
  - Neighbors are \`(true, false, false)\`, \`(false, true, false)\`, \`(false, false, true)\`
  - All three neighbors have \`or3 = true\`, while \`or3 x = false\`
  - So sensitivity at this input is **3**

- \`x = (true, true, true)\` (the all-ones input):
  - Neighbors are \`(false, true, true)\`, \`(true, false, true)\`, \`(true, true, false)\`
  - All three neighbors still have \`or3 = true\`, same as \`or3 x = true\`
  - So sensitivity at this input is **0**

- \`x = (true, false, false)\`:
  - Neighbors: \`(false, false, false)\` has \`or3 = false\`  \`or3 x = true\` 
  - Neighbors: \`(true, true, false)\` and \`(true, false, true)\` have \`or3 = true\` = \`or3 x\`
  - So sensitivity at this input is **1**

The maximum over all 8 inputs is **3**, achieved at the all-zeros input. Thus \`sensitivity or3 = 3\`.

In Lean, the definition enumerates all \`x : Fin 3  Bool\` (8 inputs), counts sensitive neighbors for each, and takes the maximum via \`Finset.sup\`.

## Lean syntax cheat sheet

- \`def name := ...\` introduces a definition.
- \`{n : }\` is an implicit argument (Lean can usually infer it).
- \`(Fin n  Bool)\` is the type of Boolean vectors of length \`n\`.
- \`fun x => ...\` is an anonymous function; \`=>\` separates its body.
- \`x i\` is function application; there are no commas for arguments.
- \`:=\` introduces a definition body.
- \`=\` is propositional equality; \`\` is \`Not ( = )\`.
- \`\` is logical conjunction in \`Prop\`.
- \`Finset.filter\` keeps elements that satisfy a predicate.
- \`Finset.card\` counts elements in a finite set.
- \`Finset.sup\` takes the maximum of a function over a finite set.

## Formal mathematical definition

For completeness, here is the standard mathematical definition that the Lean code encodes:

**Definition**: The **sensitivity at input \\(x\\)** is:
\\[
s(f, x) = |\\{i \\in [n] : f(x) \\neq f(x^{\\oplus i})\\}|
\\]
where \\(x^{\\oplus i}\\) denotes \\(x\\) with the \\(i\\)-th bit flipped.

**Definition**: The **sensitivity of \\(f\\)** is:
\\[
s(f) = \\max_{x \\in \\{0,1\\}^n} s(f, x)
\\]

The Lean definition directly implements this: \`Finset.filter\` computes the set \\(\\{i : f(x) \\neq f(x^{\\oplus i})\\}\\), \`Finset.card\` computes its cardinality, and \`Finset.sup\` computes the maximum.

## Summary

- The definition computes the maximum number of one-bit flips that change \\(f\\).
- It uses \`Finset.univ\` to enumerate all inputs and all indices.
- The Hamming distance test \`= 1\` enforces single-bit flips.
- The final \`Finset.sup\` takes the maximum over all inputs.

This is a direct, faithful Lean translation of the standard mathematical definition of sensitivity.
`;D1[3]="# Section 3: The Parity Character _S\n\nThis section defines the Boolean character \\(\\chi_S(x)\\), a basic building block of Fourier analysis on the Boolean cube \\(\\{0,1\\}^n\\).\n\n## Definition in math form\n\nThe Lean code defines:\n\n```lean\ndef chi {n : } (S : Finset (Fin n)) (x : Fin n  Bool) :  :=\n  if (Finset.filter (fun i => x i) S).card % 2 = 0 then 1 else -1\n```\n\nLean syntax walkthrough (no tactics are used here; it's a single definition):\n- `def chi ... :=` introduces a new definition named `chi` and gives its body after `:=`.\n- `{n : }` is an implicit parameter (Lean will usually infer `n`), and `` is the natural numbers type.\n- `(S : Finset (Fin n))` means `S` is a finite set of indices; `Fin n` is the type of numbers `0, 1, ..., n-1`.\n- `(x : Fin n  Bool)` means `x` is a function taking an index `i : Fin n` to a Boolean value; `` is the function type arrow.\n- `: ` is the return type; the output is a real number.\n- `if ... then ... else ...` is a term-level conditional; Lean uses a decidable test here and returns `1` or `-1` accordingly.\n- `Finset.filter (fun i => x i) S` filters `S` by the predicate `fun i => x i`; `fun i => ...` is a lambda (anonymous function).\n- `.card` is field notation for `Finset.card`, giving the number of elements.\n- `% 2` is modulus on naturals; `= 0` checks whether the remainder is zero (even parity).\n- `1` and `-1` are numerals interpreted as reals because the whole expression has type ``.\n\nTranslated to math, if we view a Boolean input \\(x : \\{0,1\\}^n\\) and a subset \\(S \\subseteq [n]\\), then\n\n\\[\n\\chi_S(x) = (-1)^{|\\{ i \\in S : x_i = 1 \\}|}.\n\\]\n\nIn words: count how many indices in \\(S\\) have value 1 under \\(x\\). If that count is even, \\(\\chi_S(x) = 1\\); if it is odd, \\(\\chi_S(x) = -1\\).\n\nThe code expresses exactly this parity test:\n- `Finset.filter (fun i => x i) S` is the subset of \\(S\\) where \\(x_i\\) is true.\n- `.card % 2` takes the parity of that count.\n- Even parity gives `1`, odd parity gives `-1`.\n\nAdditional Lean details tied to that line:\n- `x i` is function application (apply `x` to index `i`); parentheses are used when chaining applications.\n- `Finset.filter` expects a Boolean predicate, so `x i` is used directly (no `x i = true` needed).\n- `card` returns a natural number, so `% 2` computes the remainder mod 2 on ``.\n- The equality `= 0` is a proposition Lean can decide, which is what powers the `if`.\n\n## Why it always returns 1\n\nBecause \\(\\chi_S(x)\\) is defined as a parity test, it has only two possible outcomes:\n- If the count of ones in \\(S\\) is even, then \\(\\chi_S(x)=1\\).\n- If the count is odd, then \\(\\chi_S(x)=-1\\).\n\nThere is no other possibility. Parity only distinguishes even vs. odd, so the output is always \\(+1\\) or \\(-1\\).\n\nAnother way to see this is through the exponent form:\n\\[\n\\chi_S(x) = (-1)^{k}, \\quad k = |\\{ i \\in S : x_i = 1 \\}|.\n\\]\nWhen \\(k\\) is even, \\((-1)^k=1\\); when \\(k\\) is odd, \\((-1)^k=-1\\).\n\n## Role in Fourier analysis on the Boolean cube\n\nThe characters \\(\\chi_S\\) form the Fourier basis for functions \\(f : \\{0,1\\}^n \\to \\mathbb{R}\\). Concretely:\n\n- The collection \\(\\{\\chi_S : S \\subseteq [n]\\}\\) is an orthonormal basis under the inner product\n  \\[\n  \\langle f, g \\rangle = \\mathbb{E}_x[f(x)g(x)] = \\frac{1}{2^n} \\sum_{x \\in \\{0,1\\}^n} f(x)g(x),\n  \\]\n  where \\(x\\) is uniformly random in \\(\\{0,1\\}^n\\).\n\n**Orthonormality proof sketch**: To show \\(\\langle \\chi_S, \\chi_T \\rangle = \\delta_{S,T}\\):\n- When \\(S = T\\): \\(\\chi_S(x)^2 = 1\\) for all \\(x\\), so \\(\\mathbb{E}[\\chi_S^2] = 1\\).\n- When \\(S \\neq T\\): Let \\(i \\in S \\triangle T\\) (the symmetric difference). For each assignment to coordinates outside \\(\\{i\\}\\), flipping \\(x_i\\) flips the sign of \\(\\chi_S(x)\\chi_T(x)\\). Since exactly half the inputs have \\(x_i = 0\\) and half have \\(x_i = 1\\), the contributions cancel, giving \\(\\mathbb{E}[\\chi_S \\chi_T] = 0\\).\n\n- Every function can be expanded as\n  \\[\n  f(x) = \\sum_{S \\subseteq [n]} \\hat f(S) \\chi_S(x).\n  \\]\n\n- The Fourier coefficient for subset \\(S\\) is exactly the expectation noted in the Lean comment:\n  \\[\n  \\hat f(S) = \\mathbb{E}_x\\big[f(x)\\,\\chi_S(x)\\big].\n  \\]\n\nIntuitively, \\(\\chi_S\\) measures the parity of \\(x\\) on the coordinates in \\(S\\). Multiplying by \\(\\chi_S(x)\\) and averaging over all \\(x\\) tells us how much of that parity pattern is present in \\(f\\). Large coefficients indicate that \\(f\\) correlates with the parity on \\(S\\).\n\nFinally, the **Fourier degree** (or simply **degree**) of a function \\(f : \\{0,1\\}^n \\to \\mathbb{R}\\) is the largest size \\(|S|\\) for which \\(\\hat f(S)\\neq 0\\). This is the maximum order of parity interaction appearing in the Fourier expansion. For a Boolean function \\(f : \\{0,1\\}^n \\to \\{0,1\\}\\), we treat the output as real-valued (0 or 1) and apply the same definition. By convention, the constant zero function has degree 0 (or sometimes ).\n\n## Summary\n\n- \\(\\chi_S(x)\\) is defined as \\((-1)^{|\\{i \\in S : x_i = 1\\}|}\\), computed via a parity test.\n- It always returns \\(+1\\) or \\(-1\\).\n- The characters \\(\\chi_S\\) form an orthonormal Fourier basis on the Boolean cube.\n- Fourier coefficients measure correlation with parity patterns.\n- The degree of a Boolean function is the largest set size with a nonzero Fourier coefficient.\n";D1[4]="# Section 4: Fourier Coefficients, Degree, and Sensitivity\n\nThis section introduces two definitions in Lean:\n\n```lean\nnoncomputable def fourier_coeff {n : } (f : (Fin n  Bool)  Bool) (S : Finset (Fin n)) :  :=\n  (Finset.sum Finset.univ (fun x => (if f x then 1 else 0) * chi S x)) / 2^n\n\nnoncomputable def degree {n : } (f : (Fin n  Bool)  Bool) :  :=\n  Finset.sup (Finset.filter (fun S => fourier_coeff f S  0) Finset.univ) Finset.card\n```\n\n### Lean syntax walkthrough of the two definitions\n\nThere are no tactics in these snippets (no `by`, `simp`, `ring`, etc.). Both lines are *definitions* written in termstyle Lean. Here is a Leanfocused explanation of every construct and symbol you see:\n\n- `noncomputable` tells Lean this definition may rely on classical choice or realnumber operations that are not algorithmically computable. It allows the definition but marks it as noncomputable code.\n- `def` introduces a new constant with a name and a type.\n- `fourier_coeff` / `degree` are the names being defined.\n- `{n : }` is an **implicit argument**: `n` is a natural number (type ``), and Lean can usually infer it from context. Curly braces mean you dont have to pass `n` explicitly.\n- `(f : (Fin n  Bool)  Bool)` is an explicit argument. The type `(Fin n  Bool)` is the type of Boolean strings of length `n` (functions from `Fin n` to `Bool`), so `f` is a Boolean function on `n` bits.\n- `(S : Finset (Fin n))` is another explicit argument: `S` is a finite set of indices from `Fin n`.\n- `: ` or `: ` after the arguments is the **result type** of the definition.\n- `:=` introduces the **definition body** (the term that has the given type).\n- `Finset` is Leans finiteset type (with decidable membership and finiteness baked in).\n- `Finset.univ` is the universal finite set over a finite type. Here, `Finset.univ` is the set of *all* `x : Fin n  Bool` in the sum, or all `S : Finset (Fin n)` in the `filter`.\n- `Finset.sum` is the finite sum operator: `Finset.sum A g` means ` x in A, g x`.\n- `fun x => ...` is a lambda (anonymous function). So `fun x => ...` defines the summand for each `x`.\n- `if f x then 1 else 0` is Leans `if-then-else` expression, here returning a real number. Because the target type is ``, the numerals `1` and `0` are interpreted as real numbers.\n- `*` is multiplication in ``, coming from the instance `Mul `.\n- `chi S x` is an application of the previouslydefined `chi` to `S` and `x`.\n- `/` is division in ``.\n- `2^n` uses `^` (power). Here the base `2` is coerced into ``, and the exponent `n` is a natural number, so the result is a real number.\n- `Finset.sup` computes the supremum (maximum) of a function over a finite set, in a lattice (here ``).\n- `Finset.filter (fun S => ...) Finset.univ` filters a finite set by a predicate. The predicate is `fun S => fourier_coeff f S  0`.\n- `` is notequal. Since `fourier_coeff f S : `, the comparison is in ``.\n- `Finset.card` is the cardinality function on finite sets. As a function, it is applied by `Finset.sup` to each `S`.\n\nBelow is a webtutorial explanation of what these definitions mean and how they connect to sensitivity.\n\n---\n\n## 1. Boolean functions as realvalued functions\n\nA Boolean function `f : (Fin n  Bool)  Bool` takes an `n`bit input and returns a Boolean output. The Fourier analysis of Boolean functions usually works with realvalued functions, so the code converts the output to a real number using:\n\n```lean\n(if f x then 1 else 0)\n```\n\nThis maps `false  0` and `true  1`. (Sometimes the literature uses `{-1, +1}` instead; here we stick to `{0,1}` because that's exactly what the code does.)\n\n---\n\n## 2. Fourier coefficients in the code\n\n### The definition\n\n```lean\nfourier_coeff f S =\n  (sum over all x) ((if f x then 1 else 0) * chi S x) / 2^n\n```\n\nThis is the average value of `f(x) * chi_S(x)` over all inputs `x`.\n\n### What is `chi S x`?\n\n`chi S x` is the parity character defined in **Section 3**:\n\n```lean\nchi S x = (-1)^{|{i  S : x i = true}|}\n```\n\nIt returns `+1` if an even number of coordinates in `S` are true, and `-1` if odd. This is the standard Fourier basis function for Boolean analysis.\n\n### Expectation interpretation\n\nThe Fourier coefficient is the expectation of `f(x)  _S(x)` under the uniform distribution:\n\n```\nfourier_coeff f S = \uD835\uDD3C_x[f(x)  _S(x)] = (1/2^n)  _{x  {0,1}^n} f(x)  _S(x)\n```\n\nwhere `f(x)` is treated as 0 or 1 (the `{0,1}` encoding). This measures how much `f` \"aligns\" with the parity pattern on `S`.\n\n---\n\n## 3. Degree from Fourier support\n\nThe second definition uses the Fourier coefficients to define the **degree**:\n\n```lean\ndegree f =\n  sup (card S) over all S with fourier_coeff f S  0\n```\n\nIn words:\n\n- Look at every subset `S` of variables.\n- Keep only those where the Fourier coefficient is nonzero.\n- Take the maximum size of such a set.\n\nThis is exactly the **Fourier degree**: the largest subset size for which the Fourier expansion has a nonzero coefficient.\n\n**Convention for edge cases**: If `f` is the constant zero function, then all Fourier coefficients are zero, and `Finset.sup` over an empty set returns `0` (the lattice bottom for ``). So the constant zero function has degree 0. The constant one function has `fourier_coeff f  = 1  0` and all other coefficients zero, so it also has degree 0.\n\n### Intuition\n\n- Low degree means the function is wellapproximated by smallinteraction terms (few variables at a time).\n- High degree means the function needs large, global parity patterns to describe it.\n\n---\n\n## 4. Connection to sensitivity\n\n**Sensitivity** measures how many singlebit flips can change the function's value at a given input. For a Boolean function `f`, the sensitivity at input `x` counts how many coordinates `i` satisfy:\n\n```\n  f(x)  f(x with bit i flipped)\n```\n\nThe maximum of that count over all `x` is the sensitivity of `f`.\n\n### Why Fourier degree matters\n\nFourier analysis provides a powerful bridge between algebraic structure and combinatorial measures like sensitivity:\n\n- A nonzero Fourier coefficient on a large set `S` means the function depends (in a parity sense) on many variables at once.\n- That kind of global dependence tends to force the function to be sensitive to bit flips.\n\nMore concretely:\n\n- If a function has **high Fourier degree**, then there must be some input where many variables matter. That often implies higher sensitivity.\n- Conversely, if the function has very low sensitivity everywhere, the Fourier expansion tends to concentrate on small sets, leading to low degree.\n\nThis is the basic intuition behind the **Sensitivity Conjecture** (now a theorem, proved by Huang 2019):\n\n**Theorem (Sensitivity Conjecture)**: For any Boolean function `f : {0,1}^n  {0,1}`,\n```\nsensitivity(f)  (degree(f))\n```\n\nThis says that high Fourier degree implies high sensitivity. The Lean formalization in this project proves exactly this inequality. The converse direction (`degree(f)  sensitivity(f)^2`) is easier and was known earlier; together they show that sensitivity and degree are polynomially related.\n\n---\n\n## 5. Takeaway\n\n- `fourier_coeff f S` is the normalized correlation of `f` with the parity character on `S`.\n- `degree f` is the maximum size of a subset with a nonzero Fourier coefficient.\n- High degree captures global interactions among many variables.\n- Sensitivity captures how fragile `f` is to individual bit flips.\n- Fourier degree and sensitivity are tightly linked, making Fourier analysis a natural tool for studying sensitivity.\n\n---\n\nIf you want, the next step is to look at how `chi S x` is defined in the Lean code and how the `{0,1}` output encoding compares to the more common `{1,+1}` normalizationthis will clarify constants and sign conventions in later lemmas.\n";D1[5]=`# Section 5: Type Equivalences for the Huang Matrix Indexing

This section defines three explicit type equivalences in Lean. They are not just abstract conveniences: they are exactly the "index bookkeeping" needed to describe the recursive block structure of the Huang matrix when rows/columns are indexed by Boolean hypercube vertices.

Below is what each definition does, how it works, and why it matters for the Huang matrix.

---

## 1) \`boolProdEquivSum_custom\` : \`Bool      \`

**Lean definition**
\`\`\`lean
def boolProdEquivSum_custom { : Type*} : Bool       where
  toFun := fun p => if p.1 then Sum.inr p.2 else Sum.inl p.2
  invFun := fun s => match s with
    | Sum.inl a => (false, a)
    | Sum.inr a => (true, a)
  left_inv := by
    rintro  _ | _, _  <;> simp +decide
  right_inv := by
    rintro (a | a) <;> rfl
\`\`\`

### What it means
- A pair \`(b, a)\` with \`b : Bool\` and \`a : \` can be seen as **"choose left or right copy of "** depending on \`b\`.
- Thus \`Bool  \` is equivalent to \`  \` (a sum of two copies of \`\`).

### How it works
- **Forward map**: send \`(true, a)\` to \`Sum.inr a\` and \`(false, a)\` to \`Sum.inl a\`.
- **Inverse map**: send \`Sum.inl a\` back to \`(false, a)\`, and \`Sum.inr a\` back to \`(true, a)\`.
- The proofs \`left_inv\` and \`right_inv\` show these two functions undo each other.

### Lean details (constructs, syntax, tactics)
- \`def ... : ... where\` defines a structure instance by giving its fields. Here the structure is \`Equiv\`, with fields \`toFun\`, \`invFun\`, \`left_inv\`, \`right_inv\`.
- \`{ : Type*}\` uses implicit arguments and universe polymorphism. \`Type*\` means "any universe level."
- \`Bool      \` uses \`\` for product types and \`\` for sum types; \`\` is the type of equivalences (\`Equiv\`).
- \`toFun := fun p => ...\` uses a lambda; \`p.1\` and \`p.2\` are projections from a pair.
- \`if p.1 then ... else ...\` is boolean \`if\`, and \`Sum.inl\`/\`Sum.inr\` are constructors for the left/right sum.
- \`invFun := fun s => match s with | Sum.inl a => ... | Sum.inr a => ...\` is pattern matching; each branch returns a pair \`(Bool, )\`.
- \`left_inv := by ...\` and \`right_inv := by ...\` enter tactic mode with \`by\`, producing proofs.
- \`rintro  _ | _, _ \` is a pattern-matching intro in tactic mode:
  - \`..., ...\` matches a pair.
  - \`_ | _\` is a pattern for \`Bool\` (cases \`false | true\`), so this splits on the boolean component.
  - The second \`_\` matches the \`\` component.
- \`<;>\` is "tactic sequencing on all goals." It applies the following tactic to each goal produced by \`rintro\`.
- \`simp +decide\` runs the simplifier, and \`+decide\` adds \`decide\` lemmas to solve boolean conditions.
- \`rintro (a | a)\` pattern-matches on a sum (left or right). \`rfl\` closes goals by reflexivity of definitional equality.

### Why it matters
When you split the Boolean hypercube by the first coordinate, every vertex is "either in the 0-slice or the 1-slice." The sum type \`  \` captures exactly this "either/or" split, which is perfect for block matrices: the two summands correspond to two diagonal blocks.

---

## 2) \`finSuccEquiv_custom\` : \`(Fin (n+1)  )    (Fin n  )\`

**Lean definition**
\`\`\`lean
def finSuccEquiv_custom (n : ) ( : Type*) : (Fin (n + 1)  )    (Fin n  ) where
  toFun f := (f 0, f  Fin.succ)
  invFun p := Fin.cons p.1 p.2
  left_inv f := by
    ext i
    refine Fin.cases ?_ ?_ i <;> simp
  right_inv p := by
    ext <;> simp
\`\`\`

### What it means
- A function \`f : Fin (n+1)  \` is completely determined by:
  1) its value at \`0\`, and
  2) its values on the remaining indices \`{1, , n}\` (which are in bijection with \`Fin n\`).
- So such a function is equivalent to a pair \`(, Fin n  )\`.

### How it works
- **Forward map**: \`f  (f 0, f  Fin.succ)\`.
  - \`Fin.succ : Fin n  Fin (n+1)\` is the canonical injection that maps \`i\` to \`i+1\`.
  - So \`f  Fin.succ\` is the "tail" of \`f\`, giving values at indices \`1, 2, ..., n\`.
- **Inverse map**: \`Fin.cons p.1 p.2\` rebuilds a function from a head value \`p.1\` and tail \`p.2\`.
  - \`Fin.cons :   (Fin n  )  (Fin (n+1)  )\` prepends a head to a tail.
- The proof uses \`Fin.cases\` to split the index into "zero" vs. "successor."
  - \`Fin.cases\` is case analysis: given a goal for \`Fin (n+1)\`, prove it for \`0\` and for \`succ i\`.

### Lean details (constructs, syntax, tactics)
- \`(Fin (n + 1)  )    (Fin n  )\` is an \`Equiv\` between function types and a product.
- \`\` is the type of natural numbers in Lean. \`n + 1\` is syntactic sugar for \`Nat.succ n\`.
- \`toFun f := (f 0, f  Fin.succ)\` uses function application and composition:
  - \`f 0\` is the value of \`f\` at the element \`0 : Fin (n+1)\`.
  - \`\` is function composition; \`f  Fin.succ\` is a function \`Fin n  \`.
- \`invFun p := Fin.cons p.1 p.2\` uses \`Fin.cons\`, which constructs a function on \`Fin (n+1)\` by giving the value at \`0\` and a function on successors.
- \`left_inv f := by\` and \`right_inv p := by\` are proofs in tactic mode.
- \`ext i\` invokes the extensionality tactic for functions: to show two functions are equal, it introduces an index \`i\` and reduces to pointwise equality.
- \`refine Fin.cases ?_ ?_ i\` performs case analysis on \`i : Fin (n+1)\`:
  - The two goals correspond to the \`0\` case and the \`succ\` case.
  - \`?_\` are placeholders for the subproofs; Lean creates new goals for them.
- \`<;> simp\` simplifies both generated goals. \`simp\` uses definitional reductions like \`Fin.cases\` and \`Fin.cons\` to show the equalities.
- \`right_inv\` uses \`ext\` with no explicit binder (\`ext\`) and \`simp\` to discharge the pair equality by componentwise simplification.

### Why it matters
Vertices of the Boolean hypercube of dimension \`n+1\` are functions \`Fin (n+1)  Bool\`. This equivalence lets you pull out the first coordinate explicitly as a separate piece. It is the fundamental "peel off the first bit" operation.

---

## 3) \`finSuccEquiv_huang_custom\` : \`(Fin (n+1)  Bool)  (Fin n  Bool)  (Fin n  Bool)\`

**Lean definition**
\`\`\`lean
def finSuccEquiv_huang_custom (n : ) : (Fin (n + 1)  Bool)  (Fin n  Bool)  (Fin n  Bool) :=
  Equiv.trans
    (finSuccEquiv_custom n Bool)
    (boolProdEquivSum_custom)
\`\`\`

### What it means
This simply **composes** the previous two equivalences:
1) First, split a Boolean function on \`Fin (n+1)\` into \`(Bool, Fin n  Bool)\`.
2) Then turn \`(Bool, Fin n  Bool)\` into a sum of two copies of \`Fin n  Bool\`.

So we get a clean equivalence:

\`\`\`
(Fin (n+1)  Bool)    (Fin n  Bool)  (Fin n  Bool)
\`\`\`

**Summand ordering convention**: The composition sends:
- \`(false, tail)\` to \`Sum.inl tail\`  the "left" or "top" block
- \`(true, tail)\` to \`Sum.inr tail\`  the "right" or "bottom" block

This means vertices with first coordinate \`false\` go to \`Sum.inl\`, and vertices with first coordinate \`true\` go to \`Sum.inr\`. This ordering determines which block of the matrix corresponds to which summand.

### Lean details (constructs, syntax)
- The return type is an explicit \`Equiv\` between function types and a sum type.
- \`:=\` assigns the definition body. The right-hand side is an expression (not tactic mode).
- \`Equiv.trans\` composes equivalences: if \`e : A  B\` and \`e : B  C\`, then \`Equiv.trans e e : A  C\`.
- \`(finSuccEquiv_custom n Bool)\` instantiates the generic equivalence at \` := Bool\`.
- \`(boolProdEquivSum_custom)\` is used with its implicit parameter \`\` inferred as \`Fin n  Bool\`.
- Indentation and parentheses are purely syntactic; they group arguments and make the composition readable.

### Why it matters for the Huang matrix
The Huang matrix \`A_n\` is indexed by Boolean hypercube vertices, i.e.

\`\`\`
indices_n := Fin n  Bool
\`\`\`

The recursion for \`A_{n+1}\` is a **block matrix** with four \`2^n  2^n\` blocks:

- top-left: \`A_n\`
- top-right: \`I\`
- bottom-left: \`I\`
- bottom-right: \`-A_n\`

To even *state* this block structure in Lean, you must identify the index set for dimension \`n+1\` with **two copies** of the index set for dimension \`n\`.

That is exactly what \`finSuccEquiv_huang_custom\` gives you:

\`\`\`
indices_{n+1}    indices_n  indices_n
\`\`\`

Once you have this equivalence, you can:
- reindex rows and columns of \`A_{n+1}\` into "upper" and "lower" halves,
- align those halves with the two copies of \`indices_n\`, and
- express the recursion as a block matrix in a type-correct way.

Without this explicit equivalence, the block recursion is only informal. With it, Lean can treat \`A_{n+1}\` as a matrix indexed by a sum type and accept the block decomposition.

---

## Summary
- \`boolProdEquivSum_custom\` turns a Boolean choice into a sum type.
- \`finSuccEquiv_custom\` peels off the first coordinate of a function on \`Fin (n+1)\`.
- \`finSuccEquiv_huang_custom\` combines both to split the Boolean hypercube into two copies of the \`n\`-dimensional hypercube.

This is precisely the indexing trick needed to define the Huang matrix recursion as a block matrix in Lean.
`;D1[6]="# Section 6: Recursive Block Definition of the Huang Matrix\n\nThis section defines a family of matrices `huang_matrix (n : )` over `` indexed by Boolean vectors of length `n`.\n\n```lean\ndef huang_matrix (n : ) : Matrix (Fin n  Bool) (Fin n  Bool)  :=\n  match n with\n  | 0 => 0\n  | n + 1 => Matrix.reindex (finSuccEquiv_huang_custom n).symm (finSuccEquiv_huang_custom n).symm\n      (Matrix.fromBlocks (huang_matrix n) (1 : Matrix _ _ ) (1 : Matrix _ _ ) (-huang_matrix n))\n```\n\nLean parsing notes for the definition above:\n\n- `def` introduces a new constant. Here `huang_matrix` is a definition (not a theorem) that computes a matrix from `n`.\n- `(n : )` is a binder with an explicit type annotation; `` is Lean's natural numbers.\n- `:` introduces the return type. `Matrix   ` is the type of matrices with row index type ``, column index type ``, and entries in ``.\n- `:=` separates the name/signature from the defining expression.\n- `match n with` is Lean's pattern matching syntax; the subsequent `|` branches are the cases.\n- `| 0 => 0` uses the numeral `0` overloaded at the matrix type; Lean infers it as the zero matrix because the expected type is `Matrix (Fin 0  Bool) (Fin 0  Bool) `.\n- `| n + 1 => ...` is the successor case; `n` is a new binder for the predecessor in this branch.\n- The two occurrences of `.symm` are field projections on an equivalence: if `e :   `, then `e.symm :   `.\n- `Matrix.reindex` changes row/column index types using equivalences; it is not changing entries, just how indices are named.\n- `Matrix.fromBlocks A B C D` expects four matrices of compatible sizes and forms a 22 block matrix.\n- The `(1 : Matrix _ _ )` are type ascriptions; `_` is a placeholder for inferred index types, and `1` is the multiplicative identity matrix at that type.\n- `-huang_matrix n` is unary negation in the additive group of matrices.\n\nBelow is a web-style explanation of the recursive block matrix construction.\n\n## 1. What the type says\n\n`Matrix (Fin n  Bool) (Fin n  Bool) ` is a square matrix whose rows and columns are indexed by functions `Fin n  Bool`, i.e. Boolean vectors of length `n`.\n\nSo for each `n`, `huang_matrix n` is a `2^n  2^n` real matrix, but it is indexed by *functions* rather than integer indices.\n\n**Why 2^n?** The type `Fin n  Bool` is a function type with `2^n` elements: there are 2 choices (true/false) for each of the `n` positions. Lean's `Fintype` instance computes `Fintype.card (Fin n  Bool) = 2^n` via `Fintype.card_pi`.\n\nLean syntax notes for this type:\n\n- `Fin n` is the finite type `{0, 1, ..., n-1}`. The arrow `` is the function type constructor, so `Fin n  Bool` is the type of Boolean-valued functions on `Fin n`.\n- The function arrow is right-associative, but here it is parenthesized to make the matrix indices explicit.\n- `Matrix` in Lean is a type synonym for functions `    R`, so `Matrix (Fin n  Bool) (Fin n  Bool) ` is really `(Fin n  Bool)  (Fin n  Bool)  `.\n- The `` is `Real`, imported from Lean's standard library; it signals we are working in the real matrix ring.\n\n## 2. Base case: `n = 0`\n\n```lean\n| 0 => 0\n```\n\nWhen `n = 0`, the index type `Fin 0  Bool` has exactly one element (the empty function), so the matrix is `1  1`. The definition returns `0`, the zero matrix of that size.\n\nLean parsing notes for the base case:\n\n- The pattern `0` matches the literal zero constructor of ``.\n- The `=>` arrow separates pattern from branch expression.\n- The literal `0` is polymorphic: it is from the `OfNat` typeclass and is specialized to the zero matrix because of the expected type of the match expression.\n\n**Note**: This means `H_0 = [0]`, the 11 zero matrix. This satisfies `H_0 = 0I` (since 0 = 0 and 0I = 0 for the 11 identity). The formula `H_n = nI` holds with `n = 0`.\n\n## 3. Recursive case: `n + 1`\n\n```lean\n| n + 1 => Matrix.reindex ... (Matrix.fromBlocks ...)\n```\n\nThe recursive step builds `huang_matrix (n+1)` as a **22 block matrix**, where each block is itself a matrix indexed by Boolean vectors of length `n`.\n\nLean parsing notes for the successor case:\n\n- The pattern `n + 1` is syntactic sugar for `Nat.succ n`, so `n` is bound as the predecessor.\n- Because the branch expression is expected to have type `Matrix (Fin (n+1)  Bool) (Fin (n+1)  Bool) `, Lean will infer index types for `fromBlocks` and `reindex` accordingly.\n- Parentheses are used to group the arguments to `Matrix.reindex` and `Matrix.fromBlocks`; function application is left-associative in Lean.\n\n### 3.1 The block structure\n\nThe key expression is:\n\n```lean\nMatrix.fromBlocks (huang_matrix n) (1 : Matrix _ _ )\n                  (1 : Matrix _ _ ) (-huang_matrix n)\n```\n\n`Matrix.fromBlocks A B C D` builds the block matrix\n\n```\n[ A  B ]\n[ C  D ]\n```\n\nHere:\n\n- `A` is `huang_matrix n`\n- `D` is `-huang_matrix n`\n- `B` and `C` are both `1`, the identity matrix of appropriate size\n\n**Lean notation**: In Lean's matrix library, `1 : Matrix   R` denotes the identity matrix (diagonal 1s, off-diagonal 0s), not the all-ones matrix. This is the multiplicative identity in the matrix ring. The type annotation `: Matrix _ _ ` ensures Lean infers the correct size from context.\n\nLean syntax notes for this block expression:\n\n- `Matrix.fromBlocks` expects all four matrices to have the same row/column index types within their blocks; the underscores `_` are placeholders that Lean fills in using unification.\n- The type ascription `(1 : Matrix _ _ )` is required because without it `1` could be any type with a `One` instance; the ascription pins it to a matrix identity.\n- Unary `-` is notation for `Neg.neg`; its matrix instance negates every entry.\n\nSo the recursive definition is:\n\n```\nH_{n+1} = [  H_n     I ]\n          [   I   -H_n ]\n```\n\nThis is a classic recursive block construction, similar in spirit to Hadamard-type recurrences but with identity matrices on the off-diagonals and a sign flip on the bottom-right block.\n\n### 3.2 Where the indices live\n\n`fromBlocks` naturally produces a matrix indexed by a *sum type* of indices:\n\n```\n(Fin n  Bool)  (Fin n  Bool)\n```\n\nThat is, it expects row and column indices to be either a \"left\" index (top block) or a \"right\" index (bottom block).\n\nBut we want the final result indexed by `Fin (n+1)  Bool` (Boolean vectors of length `n+1`).\n\n### 3.3 Reindexing with an equivalence\n\nThat is why we wrap the block matrix with `Matrix.reindex`:\n\n```lean\nMatrix.reindex (finSuccEquiv_huang_custom n).symm\n               (finSuccEquiv_huang_custom n).symm\n               (Matrix.fromBlocks ...)\n```\n\n- `finSuccEquiv_huang_custom n` is an equivalence between\n  `Fin (n+1)  Bool` and `(Fin n  Bool)  (Fin n  Bool)`\n  (defined in **Section 5**). It splits a length-`n+1` Boolean vector into the first bit choosing left (`Sum.inl` for `false`) or right (`Sum.inr` for `true`), with the remaining `n` bits giving the index within that block.\n- The `.symm` uses the inverse direction because `fromBlocks` already lives in the sum-indexed world.\n\nSo `reindex` converts the block-indexed matrix into one indexed by Boolean vectors of length `n+1`.\n\nLean syntax notes for `reindex` and equivalences:\n\n- `` is `Sum` (disjoint union). Lean writes `Sum.inl` and `Sum.inr` for the two injections.\n- An equivalence `e :   ` is a structure with fields `toFun`, `invFun`, and proofs of left/right inverse; `e.symm` flips the direction.\n- `Matrix.reindex e e M` takes two equivalences for rows and columns and produces a matrix with new indices; it transports the function `M` along those equivalences.\n- The two `finSuccEquiv_huang_custom n` calls are identical but used for rows and columns separately; the symmetry is explicit in the code.\n\n## 4. Why this is a recursive block definition\n\nPutting it all together:\n\n- `H_0` is the zero 11 matrix.\n- `H_{n+1}` is built from `H_n` in a 22 block pattern:\n  - top-left is `H_n`\n  - bottom-right is `-H_n`\n  - off-diagonals are identity matrices\n- a reindexing step converts block indices into Boolean-vector indices\n\nThis is a canonical recursive block matrix definition: you double the dimension by stacking four blocks, two of which are the previous matrix (one with a sign flip), and two of which are identity matrices.\n\n## 5. The accompanying statement\n\nThe comment at the end hints at a key property of the Huang matrices:\n\n```lean\n/-\nThe square of the Huang matrix A_n is n times the identity matrix.\n-/\n```\n\nSo the recursion is set up to make `H_n^2 = n * I` true for all `n`. The block form makes it possible to prove this by induction, since block multiplication decomposes into the same four-block pattern.\n\n---\n\n**Summary:** `huang_matrix` is defined recursively by a 22 block construction, with off-diagonal identities, a sign flip on the bottom-right, and a reindexing step to convert the block sum indices into Boolean-vector indices. This is the Lean encoding of a structured matrix recurrence that supports an inductive proof of its algebraic properties.\n";D1[7]="# Section 7: Why A = nI for the Huang Matrix, and What That Means for Eigenvalues\n\nThis section proves a key identity for the Huang matrix `huang_matrix n`:\n\n```\n(huang_matrix n)^2 = n * I\n```\n\nwhere `I` is the identity matrix of the same size. In Lean, this appears as:\n\n```lean\ntheorem huang_matrix_sq (n : ) :\n  (huang_matrix n) ^ 2 = (n : )  (1 : Matrix (Fin n  Bool) (Fin n  Bool) )\n```\n\n**Lean notation**:\n- `theorem` introduces a named lemma with a statement and a proof\n- `(n : )` declares the input `n` as a natural number; `:` is type ascription\n- `^ 2` is `pow` on matrices: `M ^ 2 = M  M` (matrix multiplication)\n- `(n : )` coerces the natural number `n` to a real number\n- `` is scalar multiplication (smul): `r  M` multiplies every entry of matrix `M` by scalar `r`\n- `1 : Matrix _ _ ` is the identity matrix (diagonal 1s, off-diagonal 0s), not all-ones\n- `Matrix (Fin n  Bool) (Fin n  Bool) ` is the type of real matrices indexed by `Fin n  Bool` on rows and columns\n- `Fin n` is the type `{0, 1, ..., n-1}`; `Fin n  Bool` is an `n`-bit string\n- Parentheses `(...)` control precedence; Lean is explicit about grouping\n\nThe matrix is indexed by `Fin n -> Bool`, so it has size `2^n x 2^n`. The proof uses induction on `n` and the special block structure of the Huang matrix.\n\n## Big picture\n\nThe Huang matrix is built recursively using a block form. At a high level, if we write\n\n```\nA_{n+1} = [ A_n   I\n            I    -A_n ]\n```\n\nthen squaring this block matrix gives\n\n```\nA_{n+1}^2 = [ A_n^2 + I   0\n              0     A_n^2 + I ]\n```\n\nBy the induction hypothesis, `A_n^2 = n I`, so each diagonal block becomes `(n+1) I`. That yields\n\n```\nA_{n+1}^2 = (n+1) I\n```\n\nThis is exactly what the Lean proof encodes.\n\n## Step-by-step reading of the Lean proof\n\n### 1) Induction on n\n\nThe proof starts with:\n\n```lean\ninduction' n with n ih;\n```\n\n- Base case `n = 0`: the matrix `H_0` is the 11 zero matrix `[0]` (see Section 6). Its square is `[0]`, and `0  I = [0]`, so `H_0 = 0  I` \n- Inductive step: assume the result holds for `n`, prove it for `n+1`.\n- `induction'` is a Mathlib tactic that performs induction and lets you name the new variable and hypothesis\n- `with n ih` means: in the inductive step, the predecessor is named `n` and the induction hypothesis is named `ih`\n- The trailing `;` lets the following tactic script apply to both the base and inductive cases\n\n### 2) Use the block definition\n\nThe Huang matrix is defined recursively. The proof names that definition:\n\n```lean\nhave h_def : huang_matrix (n + 1) =\n  Matrix.reindex ... (Matrix.fromBlocks (huang_matrix n) 1 1 (-huang_matrix n)) := by rfl\n```\n\nTwo details:\n\n- `Matrix.fromBlocks` builds the block matrix `[A_n I; I -A_n]`.\n- `Matrix.reindex` just reorders indices so the block form matches the indexing by `(Fin (n+1) -> Bool)`. It does not change the algebraic content.\n- `have h_def : ... := ...` introduces a local lemma named `h_def` with a proof\n- `:= by rfl` proves the statement by definitional equality (`rfl` = \"reflexivity\"), which works when both sides unfold to the same definition\n- The unary `-` on `huang_matrix n` is entrywise negation\n- `1` inside `fromBlocks` is the identity matrix at the appropriate size; Lean inserts typeclass instances for matrix operations automatically\n\n### 3) Square the block matrix\n\nThe proof then expands the square of the block matrix:\n\n```lean\n(Matrix.fromBlocks A I I (-A))^2\n  = Matrix.fromBlocks ((n+1)I) 0 0 ((n+1)I)\n```\n\nThis is the critical calculation. Let's expand the block multiplication explicitly:\n\n\\[\n\\begin{bmatrix} A & I \\\\ I & -A \\end{bmatrix}\n\\begin{bmatrix} A & I \\\\ I & -A \\end{bmatrix}\n= \\begin{bmatrix} A^2 + I & AI - IA \\\\ IA - AI & I + A^2 \\end{bmatrix}\n= \\begin{bmatrix} A^2 + I & 0 \\\\ 0 & A^2 + I \\end{bmatrix}\n\\]\n\n**Off-diagonal cancellation**: Since \\(AI = IA = A\\) (identity commutes with everything), we have \\(AI + I(-A) = A - A = 0\\).\n\n**Diagonal blocks**: Both diagonal blocks are \\(A^2 + I\\). By the induction hypothesis \\(A^2 = nI\\), so:\n\\[\nA^2 + I = nI + I = (n+1)I\n\\]\n\nTherefore:\n\\[\nA_{n+1}^2 = \\begin{bmatrix} (n+1)I & 0 \\\\ 0 & (n+1)I \\end{bmatrix} = (n+1)I\n\\]\n\nLean typically achieves this with:\n- `simp` to rewrite `A  I`, `I  A`, and `A  (-A)` using matrix identities\n- `simp [ih]` to apply the induction hypothesis `ih : (huang_matrix n)^2 = (n : )  I`\n- `simp` with `Matrix.fromBlocks` multiplication lemmas to reduce off-diagonal blocks to `0`\n- A ring- or arithmetic-simplification step to turn `n + 1` into `(n + 1 : )` after coercions\n\n### 4) Reindexing and extensionality\n\nThe remainder of the Lean code uses `simp`, `ext`, and a case split on `i = j` to conclude the final equality after reindexing. This is bookkeeping to align the matrix entries with the identity matrix definition.\n\n- `ext i j` uses extensionality: two matrices are equal if all corresponding entries are equal\n- A case split is written `by_cases h : i = j`; it creates two goals, one with `h : i = j` and one with `h : i  j`\n- In the `i = j` case, the goal reduces to the diagonal entry being `(n+1)`; in the `i  j` case, it reduces to `0 = 0`\n- `simp [h]` or `simp [h, Matrix.one_apply]` uses the hypothesis `h` to simplify identity-matrix entries\n- `Matrix.reindex` applies an equivalence of index types; `simp` knows it preserves entries up to that equivalence\n\n## Why \\(A^2 = nI\\) matters: eigenvalues\n\nIf a square matrix \\(A\\) satisfies \\(A^2 = nI\\), then every eigenvalue \\(\\lambda\\) must satisfy \\(\\lambda^2 = n\\).\n\n**Proof**: If \\(Av = \\lambda v\\) for some nonzero vector \\(v\\), then:\n\\[\nA^2 v = A(Av) = A(\\lambda v) = \\lambda(Av) = \\lambda^2 v\n\\]\n\nBut \\(A^2 = nI\\) also implies \\(A^2 v = nv\\). Therefore:\n\\[\n\\lambda^2 v = nv\n\\]\n\nSince \\(v \\neq 0\\), we conclude \\(\\lambda^2 = n\\).\n\n### Consequences\n\n- Over \\(\\mathbb{R}\\), the only possible eigenvalues are \\(+\\sqrt{n}\\) and \\(-\\sqrt{n}\\).\n- The spectrum is symmetric: if \\(\\lambda\\) is an eigenvalue, so is \\(-\\lambda\\).\n- The matrix is diagonalizable over \\(\\mathbb{R}\\) if it is symmetric. The Huang matrix is symmetric (proved in **Section 12**), so it has an orthonormal eigenbasis with eigenvalues \\(\\pm\\sqrt{n}\\).\n\n## Summary\n\nThe proof shows that the Huang matrix is an involution up to scaling: squaring it gives a scalar multiple of the identity. This immediately pins down the eigenvalues to the square roots of `n`, which is exactly why the comment at the end of the Lean file says: \"The eigenvalues of the Huang matrix square to n.\"\n";D1[8]="# Section 8: Eigenvalues of the Huang Matrix\n\nThis section proves a clean characterization of the eigenvalues of the Huang matrix. The key idea is that the matrix squares to a scalar multiple of the identity. From that, any eigenvalue must satisfy a simple quadratic equation.\n\n## The Lean statement\n\n```lean\ntheorem huang_matrix_eigenvalues {n : } { : }\n  (h : Module.End.HasEigenvalue (Matrix.toLin' (huang_matrix n)) ) :\n   ^ 2 = n := by\n  ...\n```\n\nRead this as: for any natural number `n` and real number ``, if `` is an eigenvalue of the linear map corresponding to `huang_matrix n`, then `^2 = n`.\n\nLean syntax notes:\n- `theorem` introduces a named proposition with a proof.\n- `{n : } { : }` are implicit arguments (Lean can infer them). `` is naturals, `` reals.\n- `(h : Module.End.HasEigenvalue ...)` is an explicit argument named `h` with its type.\n- `Matrix.toLin'` coerces a matrix into a linear map; `huang_matrix n` is the matrix at size `n`.\n- ` ^ 2` is exponentiation in a semiring; `:` separates the statement from its proof.\n- `:= by` starts a tactic proof block.\n\n## Mathematical idea\n\nLet `A` be the Huang matrix. The earlier lemma `huang_matrix_sq n` says\n\n```\nA^2 = n I.\n```\n\nIf `v` is an eigenvector for eigenvalue ``, then\n\n```\nA v =  v.\n```\n\nApply `A` again:\n\n```\nA^2 v = A (A v) = A ( v) =  (A v) =  ( v) = ^2 v.\n```\n\nBut `A^2 = n I`, so\n\n```\nA^2 v = n v.\n```\n\nTherefore\n\n```\n^2 v = n v.\n```\n\nSince `v` is a nonzero eigenvector, we can cancel `v` and conclude\n\n```\n^2 = n.\n```\n\nThis is exactly what the theorem states: every eigenvalue must be a square root of `n` (over the reals, this means ` = n`).\n\n## How the Lean proof mirrors the math\n\n### 1) Extract an eigenvector\n\n```lean\nobtain  v, hv  := h.exists_hasEigenvector;\n```\n\nFrom `HasEigenvalue`, we get an eigenvector `v` with proof `hv` that it is nonzero and satisfies the eigenvector equation.\n\nLean syntax notes:\n- `obtain  v, hv  := ...` destructs an existential or sigma type, binding the witness `v` and proof `hv`.\n- `h.exists_hasEigenvector` is a lemma: from `HasEigenvalue`, you can extract a `HasEigenvector`.\n- ` v, hv ` is tuple/constructor syntax for dependent pairs.\n\n### 2) Apply the squared matrix identity\n\n```lean\nhave h_sq : (Matrix.toLin' (huang_matrix n)) (Matrix.toLin' (huang_matrix n) v)\n  = (n : )  v := by\n  convert congr_arg (fun x => x.mulVec v) <| huang_matrix_sq n using 1;\n   simp +decide [sq];\n   simp +decide [Matrix.smul_eq_diagonal_mul];\n```\n\nHere the proof applies the matrix identity `A^2 = n I` to the vector `v`. The `convert` step rewrites the identity in the form needed for `mulVec`, and `simp` handles the algebraic reshaping.\n\nLean syntax notes:\n- `have h_sq : ... := by` introduces a local lemma named `h_sq` with an explicit type.\n- `(n : )` is a type ascription, coercing `n` from `` to ``.\n- `` is scalar multiplication.\n- `convert` asks Lean to change the goal to a definitionaly equal one; `using 1` tells it how many definitional reductions are allowed.\n- `congr_arg (fun x => x.mulVec v)` applies a function to both sides of an equation; here it maps a matrix to its `mulVec` action on `v`.\n- `<|` is right-associative application (same as parentheses).\n- `simp` is the simplifier; `+decide` allows it to discharge decidable propositions; `[sq]` and `[Matrix.smul_eq_diagonal_mul]` are simp-lemma sets.\n\n### 3) Use the eigenvector equation\n\n```lean\nhave h_eigen : (Matrix.toLin' (huang_matrix n)) v =   v := by\n  cases hv; aesop;\n```\n\nThis is the direct eigenvector equation `A v =  v`.\n\nLean syntax notes:\n- `cases hv` splits the `HasEigenvector` proof into its fields (equation and nonzero).\n- `aesop` is an automation tactic that solves straightforward goals by combining lemmas.\n\n### 4) Combine both and cancel the vector\n\n```lean\nsimp_all +decide [sq];\nexact smul_left_injective _ hv.2 <| by\n  simpa [mul_assoc, smul_smul] using h_sq;\n```\n\nAfter rewriting, Lean shows `^2  v = n  v`. The lemma `smul_left_injective` lets us cancel the nonzero vector `v` (the nonzero proof is `hv.2`), leaving `^2 = n`.\n\nLean syntax notes:\n- `simp_all` simplifies using all local hypotheses; `+decide` again lets it close decidable side-goals.\n- `exact` finishes the goal by giving a term/proof.\n- `smul_left_injective _ hv.2` says scalar multiplication by a nonzero vector is injective; `hv.2` is the second component of `hv` (the nonzero proof). `hv.1` would be the eigenvector equation.\n- `by ...` after `<|` is a nested tactic block supplying the final proof term.\n- `simpa` is `simp` plus closing the goal; `using h_sq` rewrites with the previously proven `h_sq`.\n- `[mul_assoc, smul_smul]` are rewrite lemmas for associativity of multiplication and scalar multiplication.\n\n## Takeaway\n\nThe eigenvalues of the Huang matrix are completely determined by its squaring relation:\n\n```\nA^2 = n I  =>  ^2 = n.\n```\n\nSo eigenvalues are characterized by the equation `^2 = n`. This is the standard algebraic pattern: if a matrix squares to a scalar multiple of the identity, every eigenvalue squares to that scalar.\n\n---\n\n*(The comment at the end hints at defining the sorted list of eigenvalues as the sorted roots of the characteristic polynomial, but the proof here focuses only on the equation `^2 = n`.)*\n";D1[9]=`# Section 9: Sorted Eigenvalues and Interlacing

This section introduces a few Lean definitions and lemmas that set up a web-style treatment of eigenvalue ordering and the classic interlacing pattern. The code is short, but it lays key groundwork: how to sort eigenvalues, how to express interlacing as a list property, and how symmetry ties to Hermitian structure.

## 1. Sorting eigenvalues from the characteristic polynomial

\`\`\`lean
noncomputable def sorted_eigenvalues_list {n : } (A : Matrix (Fin n) (Fin n) ) : List  :=
  (A.charpoly.roots).sort (  )
\`\`\`

**Idea.** A matrix has a characteristic polynomial \`A.charpoly\`, whose roots are the eigenvalues (with multiplicity). The definition above collects those roots into a list and then sorts them using the usual order \`\` on real numbers.

**Lean syntax notes.**
- \`noncomputable def\` introduces a definition that uses classical (non-constructive) choice. Lean allows it, but it cannot be executed as a program.
- \`{n : }\` is an implicit argument (Lean will infer it), while \`(A : Matrix (Fin n) (Fin n) )\` is an explicit argument with type annotation.
- \`:=\` starts the definition body.
- \`List \` is the list type over real numbers.
- \`(A.charpoly.roots)\` is a list of roots (with multiplicity) of the characteristic polynomial.
- \`.sort (  )\` sorts using the comparator \`\`. The notation \`\` is an anonymous argument placeholder; \`(  )\` is shorthand for \`fun x y => x  y\`.

**Why \`noncomputable\`?** Extracting roots from a polynomial over \`\` is not computable in Lean's constructive sense. The definition is still valid mathematically, but it must be marked \`noncomputable\`.

**Takeaway.** \`sorted_eigenvalues_list A\` is a sorted list of the eigenvalues of \`A\`, coming directly from the characteristic polynomial.

## 2. Interlacing as a list predicate

\`\`\`lean
/--
A predicate asserting that list M interlaces list L.
-/
def interlacing (L M : List ) : Prop :=
  L.length = M.length + 1 
   i : Fin M.length, L[i]!  M[i]!  M[i]!  L[i.1 + 1]!
\`\`\`

**Definition.** The predicate says:

- \`L\` has one more element than \`M\`.
- Each element of \`M\` lies between consecutive elements of \`L\`.

Concretely, if \`L = [, , ..., ]\` and \`M = [, ..., _{n-1}]\`, then

\`\`\`
        ...  _{n-1}  _{n-1}  .
\`\`\`

**Lean indexing details.**
- \`L[i]!\` means "the \`i\`-th entry of \`L\`", using \`get!\` (which is safe here because the lengths line up).
- \`i : Fin M.length\` is a finite index guaranteed to be in bounds.
- \`i.1 + 1\` is the successor index in the ambient \`Nat\`.

**Lean syntax notes.**
- \`def interlacing (L M : List ) : Prop :=\` defines a proposition-valued predicate.
- \`\` is conjunction, \`\` is universal quantification.
- \`Fin M.length\` is the type of natural numbers \`i\` with \`i < M.length\`.
- \`L[i]!\` is the "unsafe" indexer, but it is safe here because \`i\` is a \`Fin\` index.
- \`i.1\` projects the underlying \`Nat\` from a \`Fin\` value.

This is the standard formalization of interlacing for ordered lists.

## 3. Symmetric vs. Hermitian (over \`\`)

\`\`\`lean
/--
A real matrix is symmetric if and only if it is Hermitian.
-/
theorem isSymm_iff_isHermitian_real {n : Type*} [Fintype n] (A : Matrix n n ) :
  A.IsSymm  A.IsHermitian := by
  rw [Matrix.IsSymm, Matrix.IsHermitian, Matrix.conjTranspose, Matrix.transpose]
  simp
  rfl
\`\`\`

**Idea.** In real matrices, conjugate transpose is just transpose, so "Hermitian" is the same as "symmetric." The proof unfolds definitions and simplifies.

This lemma is crucial because many spectral theorems in mathlib are stated for Hermitian matrices, but we want to apply them to symmetric real matrices.

**Lean syntax notes.**
- \`theorem ... : A.IsSymm  A.IsHermitian := by\` starts a proof; \`by\` introduces tactic mode.
- \`{n : Type*} [Fintype n]\` declares an implicit type and a typeclass instance; \`Fintype\` provides a finite enumeration of \`n\`.
- \`rw [...]\` rewrites the goal using definitional equalities listed in the bracket.
- \`simp\` simplifies using rewriting rules and simp lemmas.
- \`rfl\` closes a goal that is definitionally equal to itself (reflexivity).

## 4. Sorted eigenvalues for symmetric matrices

\`\`\`lean
/--
The sorted eigenvalues of a symmetric matrix.
-/
noncomputable def sorted_eigenvalues {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) : List  :=
  let hA' : A.IsHermitian := (isSymm_iff_isHermitian_real A).mp hA
  (List.ofFn (hA'.eigenvalues)).mergeSort (  )
\`\`\`

**Idea.** For symmetric (Hermitian) matrices, mathlib gives a function \`eigenvalues\` that returns the eigenvalues as a function \`Fin n  \`. We convert this function to a list using \`List.ofFn\` and sort with \`mergeSort\`.

- \`hA'\` is the same matrix, but typed as Hermitian.
- \`mergeSort\` produces a sorted list of length \`n\`.

This definition is the "canonical" sorted eigenvalue list for symmetric real matrices.

**Lean syntax notes.**
- \`let hA' : A.IsHermitian := ...\` introduces a local definition with an explicit type.
- \`(isSymm_iff_isHermitian_real A).mp hA\` uses \`.mp\` to take the forward direction of an \`\` proof.
- \`List.ofFn\` turns a function \`Fin n  \` into a list of length \`n\`.
- \`mergeSort\` is a stable sorting function; \`(  )\` is the comparator.

## 5. Length of the sorted eigenvalue list

\`\`\`lean
/--
The number of sorted eigenvalues is n.
-/
theorem sorted_eigenvalues_length {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
  (sorted_eigenvalues A hA).length = n := by
    unfold sorted_eigenvalues; aesop;
\`\`\`

**Idea.** The list produced from \`Fin n  \` has exactly \`n\` entries. After sorting, the length is preserved, so the result remains \`n\`.

The proof uses \`aesop\` to discharge the bookkeeping automatically.

**Lean syntax notes.**
- \`unfold sorted_eigenvalues\` expands the definition so the goal can be simplified.
- \`;\` sequences tactics; here it applies \`aesop\` after \`unfold\` and to any remaining goals.
- \`aesop\` is an automation tactic that solves many routine goals by search.

## 6. Symmetry and the dot product

\`\`\`lean
/--
For a symmetric matrix A, <Ax, y> = <x, Ay>.
-/
theorem dotProduct_mulVec_symm {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) (x y : Fin n  ) :
  dotProduct (A.mulVec x) y = dotProduct x (A.mulVec y) := by
    simp +decide [ Matrix.mulVec, dotProduct, mul_comm ];
    simp +decide only [Finset.mul_sum _ _ _, mul_left_comm, mul_comm];
    rw [ Finset.sum_comm ];
    conv_rhs => rw [  hA ] ;
    rfl
\`\`\`

**Idea.** Symmetric matrices are self-adjoint, so they can "move" between slots of the dot product. This lemma is a concrete dot-product identity that is frequently used when proving variational characterizations of eigenvalues.

The proof is a sequence of algebraic rewrites: expand the dot product, commute sums, and use the symmetry \`hA\` to swap indices.

**Lean syntax notes.**
- \`simp +decide\` runs the simplifier and also allows \`decide\` to resolve propositional goals.
- \`simp ... only [...]\` restricts simp to the listed lemmas.
- \`rw [Finset.sum_comm]\` rewrites using commutativity of finite sums.
- \`conv_rhs => ...\` opens a "conversion" block to rewrite just the right-hand side.
- \`rw [ hA]\` uses the symmetry proof to replace \`A\` with its transpose.
- \`rfl\` finishes once both sides are definitionally equal.

## 7. Where this is headed

The file ends with a comment marker:

\`\`\`lean
/--
The max-min value for the k-th eigenvalue.
-/
\`\`\`

This indicates the next step: a max-min (or min-max) characterization of eigenvalues (the Courant--Fischer theorem). With the definitions here, one can state and prove interlacing results for eigenvalues of principal submatrices or rank-one updates.

## Summary

- \`sorted_eigenvalues_list\` sorts roots of the characteristic polynomial.
- \`interlacing\` formalizes the classic eigenvalue interlacing pattern.
- \`isSymm_iff_isHermitian_real\` bridges symmetric and Hermitian worlds.
- \`sorted_eigenvalues\` extracts eigenvalues of symmetric matrices and sorts them.
- \`sorted_eigenvalues_length\` and \`dotProduct_mulVec_symm\` are foundational lemmas for variational principles.

These pieces form the Lean infrastructure for talking about ordered eigenvalues and their interlacing behavior.
`;D1[10]=`# Section 10: MinMax Eigenvalues and Spectral Theory (Lean Walkthrough)

This section defines the minmax eigenvalue of a real symmetric matrix and proves two key spectral facts:

- the list of sorted eigenvalues is just a permutation of the (unsorted) eigenvalues, and
- there is an orthonormal eigenbasis aligned with the sorted eigenvalues.

We also record that the Euclidean inner product is the same as \`dotProduct\` in Lean.

Throughout, \`A : Matrix (Fin n) (Fin n) \` is a real matrix and \`hA : A.IsSymm\` means \`A\` is symmetric.

---

## 1. The minmax eigenvalue (RayleighRitz form)

Lean definition:

\`\`\`lean
def min_max_eigenvalue {n : } (A : Matrix (Fin n) (Fin n) ) (k : ) :  :=
   (C : Submodule  (Fin n  )) (_ : Module.finrank  C = k + 1),
     (x : {x : C // dotProduct (x : Fin n  ) (x : Fin n  ) = 1}),
      dotProduct (A.mulVec (x : Fin n  )) (x : Fin n  )
\`\`\`

**What this means** (mathematically):

- You look at all subspaces \`C\` of dimension \`k+1\`.
- In each subspace, you take the **minimum** of the Rayleigh quotient over unit vectors \`x\` in \`C\`.
- Then you take the **maximum** of those minima over all such subspaces.

This is the classical minmax characterization of the \`k\`-th eigenvalue for symmetric matrices.

Key Lean ideas:

- \`\` and \`\` are \`iSup\` and \`iInf\`, the supremum and infimum operators.
- \`Module.finrank  C = k + 1\` enforces the subspace dimension.
- The unit sphere in \`C\` is encoded as a subtype
  \`x : {x : C // dotProduct x x = 1}\`.
- The Rayleigh quotient is just \`dotProduct (A.mulVec x) x\` for real symmetric matrices.
- \`def\` introduces a definition; \`:=\` provides its value.
- \`{n : }\` is an implicit parameter; \`:\` separates a name from its type.
- \`C : Submodule  (Fin n  )\` binds a submodule of functions \`Fin n  \`.
- \`(_ : Module.finrank  C = k + 1)\` is an anonymous binder that supplies a proof of the dimension constraint.
- \`x : {x : C // ...}\` is a subtype; \`x\` carries both a vector and a proof it has unit norm.
- Coercions like \`(x : Fin n  )\` turn \`x\` from a submodule element into the underlying function.
- \`A.mulVec\` is matrixvector multiplication; \`\` is scalar multiplication.

---

## 2. Sorted eigenvalues are a permutation of eigenvalues

Lemma (paraphrased):

> The list \`sorted_eigenvalues A hA\` is a permutation of the standard eigenvalue list of \`A\`.

Lean statement:

\`\`\`lean
lemma sorted_eigenvalues_is_perm {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
    : Equiv.Perm (Fin n),  (i : Fin n),
    (sorted_eigenvalues A hA).get i, ... =
    Matrix.IsHermitian.eigenvalues ((isSymm_iff_isHermitian_real A).mp hA) ( i)
\`\`\`

Lean syntax notes:

- \`lemma\` starts a named proposition; it is definitionally the same as \`theorem\`.
- \`  : Equiv.Perm (Fin n),\` is an existence statement for a permutation of \`Fin n\`.
- \` (i : Fin n)\` is a universal quantifier; \`Fin n\` is the finite type of indices.
- \`(sorted_eigenvalues A hA).get i, ...\` uses \`List.get\`, which requires a proof that \`i\` is in bounds; \`i, ...\` is a \`Subtype\` value with the omitted proof represented by \`...\`.
- \`Matrix.IsHermitian.eigenvalues\` is the standard eigenvalue list for a Hermitian matrix.
- \`(isSymm_iff_isHermitian_real A).mp hA\` converts a real symmetry proof into a Hermitian proof; \`.mp\` is the forward direction of an \`Iff\`.
- \`( i)\` applies the permutation to the index.

**Proof idea**:

1. \`sorted_eigenvalues\` is defined as a merge sort of the eigenvalues list, so it is a permutation.
2. A generic lemma shows: if two lists are permutations, then there is a bijection between their indices that matches entries.
3. That bijection is transported to a permutation of \`Fin n\` using length equalities.

**Why this matters**:

This gives a precise index map \`\` so you can connect the *sorted* eigenvalue list to the *original* eigenvalue list. It is a technical bridge for reindexing eigenvectors.

---

## 3. Orthonormal basis aligned to the sorted eigenvalues

Lemma (paraphrased):

> There is an orthonormal basis \`v\` of eigenvectors such that the eigenvalue of \`v i\` is exactly the \`i\`-th sorted eigenvalue.

Lean statement:

\`\`\`lean
lemma exists_orthonormal_basis_sorted {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
   (v : OrthonormalBasis (Fin n)  (EuclideanSpace  (Fin n))),
     i, A.mulVec (v i) =
      ((sorted_eigenvalues A hA).get i, ...)  (v i)
\`\`\`

Lean syntax notes:

- \` (v : OrthonormalBasis ...)\` quantifies an orthonormal basis as a dependent object.
- \`v i\` is the basis vector at index \`i\`; \`A.mulVec (v i)\` is the matrix acting on that vector.
- \`\` is scalar multiplication in the vector space \`EuclideanSpace  (Fin n)\`.
- \`v.reindex .symm\` (used in the proof) reorders the basis by a permutation; \`.symm\` is the inverse permutation.

**Proof idea**:

1. The spectral theorem already provides an orthonormal eigenbasis indexed by the *unsorted* eigenvalues.
2. Using the permutation \`\` from the previous lemma, reindex that basis so the \`i\`-th basis vector corresponds to the \`i\`-th sorted eigenvalue.
3. The lemma uses \`v.reindex .symm\` to align the ordering.

**Takeaway**:

For symmetric matrices, not only do eigenvalues exist and are real, but you can order them and still have an orthonormal basis of eigenvectors in that order.

---

## 4. Inner product equals dot product

Lean lemma:

\`\`\`lean
lemma inner_eq_dotProduct {n : } (x y : EuclideanSpace  (Fin n)) :
  inner  x y = dotProduct (x : Fin n  ) (y : Fin n  ) := by
    simp +decide [ dotProduct, inner ];
    ac_rfl
\`\`\`

Lean tactic notes:

- \`:= by\` starts a tactic proof.
- \`simp\` simplifies the goal using rewriting rules; \`+decide\` lets \`simp\` discharge decidable propositions automatically.
- \`[ dotProduct, inner ]\` tells \`simp\` to unfold these definitions during simplification.
- \`ac_rfl\` finishes goals that are true by associativity/commutativity of addition and multiplication.

This is a small but important bridge: \`EuclideanSpace\` in mathlib is defined using the dot product on functions \`Fin n  \`. The lemma tells Lean (and the reader) that the abstract inner product agrees with the concrete dot product formula.

---

## How these pieces fit together

- The **minmax eigenvalue** definition uses the Rayleigh quotient, which relies on the **dot product**.
- The **permutation lemma** formalizes that sorted eigenvalues are just a reordering of the standard list.
- The **orthonormal basis lemma** uses that permutation to reorder eigenvectors so each basis vector matches the sorted eigenvalue at the same index.

Altogether, this section is a Lean formalization of the spectral theorem framework needed for minmax eigenvalue proofs.
`;D1[11]=`# Section 11: g-Transform Expectation is Nonzero

This section explains the Lean theorem \`g_expectation_nonzero\`, which shows that a specific sum (an expectation-like quantity) is nonzero when a Boolean function has full degree. The statement connects the top Fourier coefficient of a Boolean function to the nonvanishing of a signed sum involving the parity character.

## The Lean statement

\`\`\`lean
theorem g_expectation_nonzero {n : } (f : (Fin n  Bool)  Bool)
  (h_deg : degree f = n) (hn : n  0) :
  let g := fun x => (if f x then 1 else 0) * chi Finset.univ x
  (Finset.sum Finset.univ g)  0 := by
  ...
\`\`\`

### Lean syntax and constructs in the statement

Below is a quick guide to the Lean keywords, binders, and notation used in the statement.

- \`theorem g_expectation_nonzero\`: declares a theorem with the given name.
- \`{n : }\`: an implicit argument (Lean will try to infer it). \`\` is the type of natural numbers.
- \`(f : (Fin n  Bool)  Bool)\`: an explicit argument. Here \`Fin n\` is the finite type with \`n\` elements (indices \`0\` to \`n-1\`), so \`Fin n  Bool\` is a length\`n\` Boolean input.
- \`(h_deg : degree f = n) (hn : n  0)\`: hypotheses with names. \`\` is not equal.
- \`:\` separates the hypotheses from the goal statement.
- \`let g := ...\`: local definition used in the goal. \`g\` is defined only for the remainder of the statement.
- \`fun x => ...\`: lambda (anonymous function) definition.
- \`if f x then 1 else 0\`: Boolean-to-number coercion via a conditional expression (gives \`1\` when \`f x\` is true, else \`0\`).
- \`*\`: multiplication in the codomain (\`\` here).
- \`chi Finset.univ x\`: the parity character \`_S\` evaluated at \`x\`, with \`S = Finset.univ\`.
- \`Finset.univ\`: the finite set containing all elements of a finite type.
- \`Finset.sum Finset.univ g\`: sum of \`g x\` over all \`x\` in the finite set; this is the discrete expectation without normalization.
- \` 0\`: the conclusion that the sum is not zero.
- \`:= by ...\`: begins a tactic proof. Everything after \`by\` is a sequence of tactics that transform the goal until it is solved.

### What it means in plain language

- We have a Boolean function \\(f : \\{0,1\\}^n \\to \\{0,1\\}\\).
- The **Fourier degree** of \\(f\\) is \\(n\\), i.e., the largest \\(|S|\\) with \\(\\hat{f}(S) \\neq 0\\) equals \\(n\\).
- We define a transform \\(g : \\{0,1\\}^n \\to \\mathbb{R}\\) by:
\\[
g(x) = \\mathbf{1}_{f(x)=\\text{true}} \\cdot \\chi_{[n]}(x)
\\]
where \\(\\mathbf{1}_{f(x)=\\text{true}}\\) is 1 if \\(f(x)\\) is true, 0 otherwise, and \\(\\chi_{[n]}(x)\\) is the full parity character (defined in **Section 3**).
- The theorem says \\(\\sum_{x \\in \\{0,1\\}^n} g(x) \\neq 0\\).

**Codomain note**: The expression \`(if f x then 1 else 0) * chi Finset.univ x\` has type \`\` in Lean, since \`chi\` returns a real number (\\(\\pm 1\\)) and the multiplication is in \\(\\mathbb{R}\\).

This sum is (up to normalization) the Fourier coefficient at the full set \\(S = [n]\\). If the degree is \\(n\\), then this top coefficient is nonzero, so the sum cannot vanish.

## Intuition: why the sum is the Fourier coefficient

For a Boolean function, the Fourier coefficient at a set \\(S\\) is:
\\[
\\hat{f}(S) = \\frac{1}{2^n} \\sum_{x \\in \\{0,1\\}^n} f(x) \\cdot \\chi_S(x)
\\]

The Lean definition uses this same formula (see **Section 4**). The key observation is:
\\[
\\sum_x g(x) = \\sum_x f(x) \\cdot \\chi_{[n]}(x) = 2^n \\cdot \\hat{f}([n])
\\]

So the sum equals \\(2^n\\) times the Fourier coefficient at the full set. Since \\(2^n \\neq 0\\), the sum is nonzero if and only if \\(\\hat{f}([n]) \\neq 0\\).

In the theorem:

- \`S\` is the full set \`Finset.univ\`.
- \`f(x)\` is represented as \`(if f x then 1 else 0)\` to move from \`Bool\` to \`Nat\` (or \`Int\`).
- \`chi Finset.univ x\` is the parity character on all \`n\` bits.

So the sum

\`\`\`
Finset.sum Finset.univ (fun x => (if f x then 1 else 0) * chi Finset.univ x)
\`\`\`

is exactly the (unnormalized) Fourier coefficient at the full set. If the degree is \`n\`, then the top coefficient is nonzero, and therefore the sum cannot be zero.

## How the Lean proof works

The proof is structured in three logical steps:

1. **Extract a nonzero top coefficient.**
   It proves there exists a set \`S\` of size \`n\` such that \`fourier_coeff f S  0\`. This uses the assumption \`degree f = n\` and a contradiction argument: if all size-\`n\` coefficients were zero, the degree would be at most \`n-1\`.

2. **Specialize to the full set.**
   For \`Fin n\`, the only subset of size \\(n\\) is \`Finset.univ\`. The argument is:
   - We have \\(S \\subseteq \\text{Finset.univ}\\) (any finset over \`Fin n\`)
   - We have \\(|S| = n\\)
   - But \\(|\\text{Finset.univ}| = n\\) (since \`Fintype.card (Fin n) = n\`)
   - A subset of a finite set with equal cardinality must be the whole set

   Lean uses \`Finset.eq_of_subset_of_card_le\` to conclude \\(S = \\text{Finset.univ}\\).

3. **Rewrite the coefficient as a sum.**
   After simplification, the coefficient is shown to be exactly the sum of \`g(x)\` over all \`x\`. Since the coefficient is nonzero, the sum is nonzero.

In Lean, those steps appear as:

\`\`\`lean
have h_fourier_coeff :  S : Finset (Fin n), fourier_coeff f S  0  S.card = n := by
  ...
obtain  S, hS, hS  := h_fourier_coeff
simp_all +decide [ fourier_coeff ]
have := Finset.eq_of_subset_of_card_le ( Finset.subset_univ S )
...
\`\`\`

The proof uses \`simp_all\` to unfold \`fourier_coeff\` and reduce to the explicit sum, and \`Finset.eq_of_subset_of_card_le\` to pin down \`S = Finset.univ\` from the cardinality equation.

### Lean tactics and proof keywords used above

- \`have h_fourier_coeff : ... := by\`: introduces an intermediate lemma with a proof block. The type after \`:\` is the statement being proved.
- \` S : Finset (Fin n), ...\`: an existential statement (there exists a finite set \`S\` ). \`Finset (Fin n)\` is a finite set of indices from \`Fin n\`.
- \`\`: conjunction (and), so the witness \`S\` must satisfy both properties.
- \`S.card = n\`: the cardinality (size) of the finite set \`S\` is \`n\`.
- \`obtain  S, hS, hS  := h_fourier_coeff\`: destructs the existential proof, binding the witness \`S\` and its two properties to names \`hS\` and \`hS\`.
- \`simp_all\`: a simplification tactic that uses all available hypotheses and simp lemmas to reduce the goal. It performs rewriting, unfolding, and canonical simplifications.
- \`+decide\`: adds \`decide\`-based simp lemmas, allowing \`simp_all\` to solve or simplify goals that depend on decidable propositions (e.g., finite set membership).
- \`[ fourier_coeff ]\`: tells \`simp_all\` to unfold the definition \`fourier_coeff\`.
- \`have := ...\`: introduces a new fact with an inferred name (Lean creates a fresh identifier). Often used when the exact name is not important.
- \`Finset.eq_of_subset_of_card_le\`: lemma stating that if \`A  B\` and \`card B  card A\`, then \`A = B\`. Here it shows \`S = Finset.univ\`.
- \`Finset.subset_univ S\`: proof that any finite set \`S\` is a subset of the universal finite set.

## Takeaway

If a Boolean function has full Fourier degree, then its correlation with the full parity character is nonzero. The \`g\`-transform expectation encodes that correlation, so the sum (expectation) cannot vanish. This is a compact way to say: **full degree implies a nonzero top Fourier coefficient, which forces a nonzero global parity sum.**
`;D1[12]="# Section 12: Reindexed Huang Matrix and Symmetry\n\nThis section introduces a convenient reindexing of the Huang matrix so that its rows and columns are indexed by `Fin (2^n)` instead of boolean functions `Fin n -> Bool`. It then proves that both the original and reindexed Huang matrices are symmetric. The main ideas are:\n\n- Build an explicit equivalence between boolean functions and `Fin (2^n)`.\n- Use `Matrix.reindex` to transport the Huang matrix across that equivalence.\n- Prove symmetry for the original matrix by induction on `n`.\n- Conclude symmetry for the reindexed matrix by rewriting via the equivalence.\n\n## 1. Reindexing boolean functions to `Fin (2^n)`\n\n```lean\ndef boolFunEquivFin (n : ) : (Fin n  Bool)  Fin (2^n) :=\n  (Fintype.equivFin (Fin n  Bool)).trans (finCongr (by\n  norm_num [ Fintype.card_pi ]))\n```\n\n**What this does:**\n- `Fintype.equivFin` produces an equivalence between any finite type and `Fin (card _)`.\n- `Fin n -> Bool` has cardinality `2^n`. The proof uses `Fintype.card_pi` and `norm_num` to simplify the count.\n- `finCongr` adjusts the `Fin` index to exactly `Fin (2^n)`.\n\nSo `boolFunEquivFin n` is the canonical bridge between boolean functions on `n` bits and the `2^n` sized `Fin` type.\n\n**Lean syntax and tactic details:**\n- `def` introduces a new definition; the name `boolFunEquivFin` is the constant being defined.\n- `(n : )` is a typed parameter; `` is the natural numbers.\n- `: (Fin n  Bool)  Fin (2^n)` is the type annotation, saying this is an equivalence (``) between two types.\n- `:=` starts the definition body.\n- `(Fintype.equivFin (Fin n  Bool))` is a term that builds an equivalence from a finite type to `Fin (card _)`.\n- `.trans` composes equivalences: `e.trans f` is the equivalence obtained by first applying `e`, then `f`.\n- `finCongr` changes the `Fin` index using a proof that the sizes are equal.\n- `by ...` starts a tactic proof block.\n- `norm_num` is a simplification tactic for arithmetic/numeral goals; here it reduces the cardinality formula.\n- `[ Fintype.card_pi ]` is a simp-lemma list telling `norm_num` which lemma to use; `Fintype.card_pi` computes the cardinality of a function type.\n\n## 2. The reindexed Huang matrix\n\n```lean\nnoncomputable def huang_matrix_fin (n : ) : Matrix (Fin (2^n)) (Fin (2^n))  :=\n  Matrix.reindex (boolFunEquivFin n) (boolFunEquivFin n) (huang_matrix n)\n```\n\n`Matrix.reindex` transports a matrix along equivalences of row and column indices. Here we use the same equivalence for rows and columns, so we are simply relabeling the indices, not changing any numeric entries.\n\nThis gives a version of the Huang matrix whose index type matches the usual `2^n x 2^n` dimension found in linear algebra statements.\n\n**Lean syntax and tactic details:**\n- `noncomputable` marks the definition as potentially noncomputable (e.g., it uses choice); Lean will not demand computational content.\n- `Matrix (Fin (2^n)) (Fin (2^n)) ` is a matrix with row and column index types `Fin (2^n)` over the reals ``.\n- `Matrix.reindex` takes two equivalences (for rows and columns) and a matrix, and returns the relabeled matrix.\n- `huang_matrix n` is the original Huang matrix, with indices in `Fin n  Bool`.\n\n## 3. The original Huang matrix is symmetric\n\n```lean\ntheorem huang_matrix_isSymm (n : ) : (huang_matrix n).IsSymm := by\n  induction' n with n ih;\n   exact rfl\n   -- By definition of huang_matrix, we know that huang_matrix (n + 1) is a block matrix ...\n    have h_block : huang_matrix (n + 1) = Matrix.reindex (finSuccEquiv_huang_custom n).symm\n      (finSuccEquiv_huang_custom n).symm\n      (Matrix.fromBlocks (huang_matrix n) (1 : Matrix (Fin n  Bool) (Fin n  Bool) )\n        (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) (-huang_matrix n)) := by\n      rfl;\n    simp_all +decide [ Matrix.IsSymm ];\n    ext i j; simp +decide [ Matrix.fromBlocks_transpose, ih ] ;\n```\n\n**Key idea:** the matrix for `n+1` is built as a block matrix (with `huang_matrix n` and `-huang_matrix n` on the diagonal, and identities off-diagonal), then reindexed to match the boolean hypercube structure. The proof:\n\n- Proceeds by induction on `n`.\n- For `n = 0`, symmetry is `rfl`.\n- For `n + 1`, it unfolds the block structure and uses the inductive hypothesis that `huang_matrix n` is symmetric.\n- `simp` with `Matrix.fromBlocks_transpose` shows the block matrix is symmetric.\n\nThis is the structural heart of the symmetry result.\n\n**Lean syntax and tactic details:**\n- `theorem` introduces a named proposition with a proof.\n- `: (huang_matrix n).IsSymm` is the goal type; `IsSymm` is a predicate on matrices.\n- `by` starts a tactic proof.\n- `induction' n with n ih;` performs induction on `n`, naming the predecessor `n` and induction hypothesis `ih`. The prime `'` is the version that supports naming binders.\n- `` starts a bullet for a proof branch (base case, then inductive case).\n- `exact rfl` closes the goal by reflexivity; `rfl` proves definitional equalities.\n- `have h_block : ... := by rfl` introduces a local lemma; the `: ...` annotates the lemmas type, and `rfl` proves it by unfolding the definition.\n- `Matrix.reindex` and `.symm` reindex with the inverse equivalence (`symm` flips direction).\n- `Matrix.fromBlocks` builds a block matrix from four submatrices.\n- `1 : Matrix ...` is the identity matrix on the relevant index type; the type annotation guides elaboration.\n- `-huang_matrix n` is the pointwise negation of the matrix.\n- `simp_all` simplifies all goals and hypotheses; `+decide` tells `simp` to use decision procedures for `Decidable` propositions.\n- `[ Matrix.IsSymm ]` supplies the simp lemma characterizing symmetry via transpose.\n- `ext i j` applies the extensionality lemma for matrices, reducing the goal to entrywise equality.\n- `simp` then closes the entrywise goal, using `Matrix.fromBlocks_transpose` and the inductive hypothesis `ih`.\n\n## 4. Symmetry survives reindexing\n\n```lean\ntheorem huang_matrix_fin_isSymm (n : ) : (huang_matrix_fin n).IsSymm := by\n  exact funext fun i => funext fun j => huang_matrix_isSymm n |>.apply _ _\n```\n\nA reindexing does not change the entries, only the labels. The proof simply reduces symmetry of the reindexed matrix to symmetry of the original by expanding definitions.\n\nIn other words, symmetry is invariant under relabeling of indices by equivalence.\n\n**Lean syntax and tactic details:**\n- `funext` is function extensionality: to show two functions are equal, it suffices to show they agree on every input.\n- `fun i => ...` introduces a lambda; `funext fun i => ...` is the extensionality proof for the first index, then again for the second.\n- `huang_matrix_isSymm n |>.apply _ _` uses function application in forward-pipe style (`|>`). `IsSymm` is a function that, when applied, yields the entrywise symmetry proof; underscores `_` are placeholders for inferred indices.\n- `exact` supplies the constructed proof term directly.\n\n## 5. Takeaway\n\n- `boolFunEquivFin` is the bridge from boolean function indices to `Fin (2^n)`.\n- `huang_matrix_fin` is a pure reindexing, so algebraic properties such as symmetry carry over immediately.\n- The core symmetry proof relies on the block decomposition of the Huang matrix and an induction on dimension.\n\nIf you want to connect this to linear algebra over finite-dimensional real vector spaces, `huang_matrix_fin` is the version with the standard `2^n x 2^n` index type, and `huang_matrix_fin_isSymm` confirms it is symmetric in the usual sense.\n";D1[13]=`# Section 13: Complete Spectrum of the Huang Matrix

This section proves the full list of eigenvalues of the Huang matrix (in the \`Fin\`-indexed form) and shows that they are exactly half negative and half positive square roots.

We will walk through the proof structure and explain the key lemmas.

## Goal: the complete spectrum

For the Huang matrix on dimension \`n+1\` (size \`2^(n+1)\`), the theorem proved is:

- The sorted eigenvalues are:

\`\`\`
[-sqrt(n+1), ..., -sqrt(n+1)]  (2^n times)
[+sqrt(n+1), ..., +sqrt(n+1)]  (2^n times)
\`\`\`

In other words, the spectrum is exactly two values, \`-sqrt(n+1)\` and \`+sqrt(n+1)\`, each with multiplicity \`2^n\`.

In Lean, this appears as:

\`\`\`lean
lemma huang_eigenvalues_eq_list_succ (n : ) :
  let evs := sorted_eigenvalues (huang_matrix_fin (n + 1)) (huang_matrix_fin_isSymm (n + 1))
  evs = List.replicate (2^n) (-Real.sqrt (n + 1)) ++
        List.replicate (2^n) (Real.sqrt (n + 1))
\`\`\`

Lean syntax notes:

- \`lemma ... :\` introduces a named theorem with its statement (type).
- \`(n : )\` declares \`n\` as a natural number; \`\` is the type of naturals.
- \`let evs := ...\` is a local definition scoped to the statement.
- \`sorted_eigenvalues A hA\` expects a matrix \`A\` and a proof \`hA\` that \`A\` is symmetric.
- \`huang_matrix_fin (n + 1)\` is the \`Fin\`-indexed Huang matrix at dimension \`n+1\`.
- \`huang_matrix_fin_isSymm (n + 1)\` supplies the symmetry proof for that matrix.
- \`List.replicate k x\` is the list of length \`k\` filled with \`x\`.
- \`++\` concatenates lists.
- \`Real.sqrt\` is the real square root function; \`-Real.sqrt (n + 1)\` is unary negation.

The rest of the section is a chain of lemmas that make this statement inevitable.

## Step 1: Every eigenvalue squares to \`n\`

The theorem \`huang_eigenvalues_sq_eq_n\` shows that for the \`Fin\`-indexed Huang matrix, *every eigenvalue* satisfies

\`\`\`
mu^2 = n
\`\`\`

Sketch of the proof:

1. Use the matrix identity \`A^2 = n * I\` (proved earlier as \`huang_matrix_fin_sq\`).
2. If \`A v = mu v\`, then apply \`A\` again to get \`A (A v) = mu^2 v\`.
3. Replace \`A^2\` with \`n I\` to get \`n v\` on the left, so \`mu^2 v = n v\`.
4. Since \`v != 0\`, conclude \`mu^2 = n\`.

This lemma is then applied to every element of \`sorted_eigenvalues\` to state that *every entry in the list squares to \`n\`*.

Lean syntax notes (common constructs in this step):

- \`A v = mu v\` is an equation in the \`Matrix\`/\`LinearMap\` setting, using multiplication notation.
- \`A^2\` is \`A\` squared; the \`^\` notation uses \`Pow.pow\` for the matrix type.
- \`n * I\` is scalar multiplication of the identity matrix \`I\`.
- Proofs here typically use rewriting (\`rw\`), simplification (\`simp\`), and nonzero arguments (\`by_contra\`, \`by_cases\`).

## Step 2: Sum of eigenvalues equals trace

\`sum_sorted_eigenvalues_eq_trace\` proves that for a symmetric real matrix, the sum of the sorted eigenvalues equals the trace:

\`\`\`
(sorted_eigenvalues A hA).sum = A.trace
\`\`\`

This uses the standard fact that the trace of a symmetric matrix is the sum of its (real) eigenvalues, and shows that sorting does not change the sum.

Lean syntax notes:

- \`(sorted_eigenvalues A hA).sum\` uses \`List.sum\` via dot notation to add list entries.
- \`A.trace\` is \`Matrix.trace A\`, written with dot notation.
- Equality of sums under sorting usually comes from permutation lemmas (\`List.Perm\`) and \`List.sum_perm\`.

## Step 3: The Huang matrix has trace 0

\`huang_matrix_fin_trace\` uses reindexing to transfer the earlier result that the Huang matrix has trace 0:

\`\`\`
Matrix.trace (huang_matrix_fin n) = 0
\`\`\`

This gives the sum of all eigenvalues immediately:

\`\`\`
(sum of eigenvalues) = 0
\`\`\`

Lean syntax notes:

- \`Matrix.trace\` is defined as the sum of diagonal entries.
- Reindexing often uses \`Equiv\` or \`Fin\`-based equivalences; in Lean these show up as \`Equiv\` values and \`by simpa\` with trace lemmas.

## Step 4: A list lemma for values that square to \`c^2\`

Several list lemmas are introduced to characterize a list that:

- has length \`2m\`,
- all elements satisfy \`x^2 = c^2\`,
- and the sum is 0,
- and the list is sorted.

The key lemma is:

\`\`\`lean
sorted_list_of_sq_eq_and_sum_zero
\`\`\`

Lean syntax notes:

- Names like \`sorted_list_of_sq_eq_and_sum_zero\` package all assumptions (sorted, squares equal, sum zero) into one lemma.
- \`List.Sorted\` and \`List.length\` are standard list predicates used in the proof.
- The step \`x^2 = c^2\` implies \`x = c  x = -c\` uses lemmas like \`mul_self_eq_mul_self_iff\` or \`sq_eq_sq_iff_eq_or_eq_neg\`.

It concludes:

\`\`\`
L = List.replicate m (-c) ++ List.replicate m c
\`\`\`

The logic is simple:

- If \`x^2 = c^2\`, then \`x = c\` or \`x = -c\`.
- If the sum is 0 and \`c != 0\`, then there must be the same number of \`c\` and \`-c\`.
- Sorting forces all \`-c\` values to appear first.

This lemma is the engine behind the final spectral statement.

## Step 5: Apply to \`n+1\`

With the ingredients in place, the final proof is short:

- The list \`sorted_eigenvalues\` has length \`2^(n+1)\`.
- Every entry squares to \`n+1\` (Step 1).
- The sum of the list is 0 (Steps 2 and 3).
- The list is sorted (by construction).

Therefore the list is exactly \`2^n\` copies of \`-sqrt(n+1)\` followed by \`2^n\` copies of \`+sqrt(n+1)\`.

This is the **complete spectrum** of the Huang matrix in the \`Fin\`-indexed model.

Lean syntax notes:

- \`2^n\` is exponentiation in \`\` and is coerced when used as a list length or as a real number.
- Type coercions from \`Nat\` to \`Real\` are inserted by instances; you may see \`Nat.cast\` in explicit proofs.
- Tactics like \`simp\` and \`linarith\` typically discharge algebraic and linear arithmetic goals in these steps.

## Takeaway

The section combines three classic facts:

1. \`A^2 = n I\` forces eigenvalues to satisfy \`mu^2 = n\`.
2. Trace equals sum of eigenvalues.
3. Sorting plus a zero sum forces exact multiplicities.

As a result, the Huang matrix has only two eigenvalues, \`-sqrt(n)\` and \`+sqrt(n)\`, with equal multiplicity.
`;D1[14]=`# Section 14: Adjacency and Row-Sum Bounds

This section has two themes:

1. The Huang matrix has entries whose **absolute values** match the adjacency matrix of the hypercube.
2. Any eigenvalue of a real matrix is bounded in absolute value by the **maximum absolute row sum**.

We'll walk through both statements and how the Lean proofs are structured.

---

## 1. Absolute values give the hypercube adjacency

### Statement

\`\`\`lean
theorem abs_huang_eq_adjacency (n : ) (i j : Fin n  Bool) :
  |huang_matrix n i j| =
    if (Finset.filter (fun k => i k  j k) Finset.univ).card = 1
    then 1 else 0 := by
  ...
\`\`\`

Interpretation:

- The vertices of the \`n\`-dimensional hypercube are functions \`Fin n  Bool\`.
- Two vertices \`i\` and \`j\` are adjacent exactly when they differ in **one** coordinate.
- The proof shows that the absolute value of the Huang matrix entry is \`1\` precisely in that case, and \`0\` otherwise.

So \`|huang_matrix n|\` is the adjacency matrix of the hypercube.

Lean syntax notes for the statement above:

- \`theorem\` introduces a named proposition with a proof. Here the name is \`abs_huang_eq_adjacency\`.
- \`(n : )\` declares a natural number argument; \`\` is the type of natural numbers.
- \`(i j : Fin n  Bool)\` declares two functions from \`Fin n\` (the finite type \`{0, , n-1}\`) to \`Bool\`.
- \`|...|\` is the absolute value notation (uses \`abs\` on \`\` or \`\`, depending on the matrix entry type).
- \`if ... then ... else ...\` is the standard conditional expression in Lean.
- \`Finset.filter\` keeps elements satisfying the predicate; \`fun k => i k  j k\` is a lambda function.
- \`Finset.univ\` is the finset of all elements of a finite type; here it is all \`k : Fin n\`.
- \`.card\` is the cardinality of a finset.
- \`:= by\` starts a proof block in tactic mode (the proof is filled in by Lean tactics).

### Proof idea

The proof is by induction on \`n\`. There are two main ingredients:

1. **Base case (\`n = 0\`)**: There is only one vertex. The proof is done by case analysis on the only possible indices.
2. **Inductive step**: The Huang matrix for size \`n+2\` is defined in a block form
   \`\`\`lean
   [  A   1
      1  -A ]
   \`\`\`
   after reindexing. This induces a split into two cases based on whether the first coordinates agree:
   - If \`i 0 = j 0\`, the entry reduces to the corresponding entry of the smaller Huang matrix.
   - If \`i 0  j 0\`, the entry comes from a \`1\` block, but only when the remaining coordinates are identical.

The proof formalizes this with a split lemma \`h_split\` that matches this block structure.
Then it rewrites the "differ in exactly one coordinate" condition to separate the first coordinate from the rest. The cardinality calculation is then handled by \`simp\` and \`Finset.card\` lemmas.

Lean tactic notes for this proof sketch:

- \`simp\` is the simplifier: it rewrites using definitional equalities and lemmas tagged \`[simp]\`.
- \`cases\` or \`cases\`-style case splits (often used for the \`n = 0\` base case) enumerate constructors of a type.
- \`simp [h_split]\` means "simplify, also using the lemma \`h_split\` as a rewrite rule."
- \`Finset.card\` lemmas relate cardinality to \`filter\` and to singleton/empty finsets; these are often triggered by \`simp\`.

---

## 2. Eigenvalues bounded by max absolute row sum

### Statement

\`\`\`lean
theorem eigenvalue_le_max_row_sum {n : } (A : Matrix (Fin n) (Fin n) ) ( : )
  (h : Module.End.HasEigenvalue (Matrix.toLin' A) ) :
   i : Fin n, ||  Finset.sum Finset.univ (fun j => |A i j|) := by
  ...
\`\`\`

Interpretation:

- If \`\` is an eigenvalue of \`A\`, then there exists a row \`i\` whose absolute row sum bounds \`||\`.
- This is a standard norm estimate: the spectral radius is bounded by the max row sum norm.

Lean syntax notes for the statement above:

- \`{n : }\` uses implicit arguments; Lean can infer \`n\` from context.
- \`Matrix (Fin n) (Fin n) \` is an \`n  n\` real matrix indexed by \`Fin n\`.
- \` : \` declares a real number.
- \`Module.End.HasEigenvalue (Matrix.toLin' A) \` states that the linear map corresponding to \`A\` has eigenvalue \`\`.
- \`Matrix.toLin'\` coerces a matrix into a linear map on \`Fin n  \`.
- \` i : Fin n, ...\` is an existential quantifier: there exists an index \`i\`.
- \`Finset.sum Finset.univ (fun j => |A i j|)\` is the finite sum of absolute values in row \`i\`.
- \`by\` again begins a tactic proof.

### Proof idea

The proof follows the textbook argument:

1. **Pick an eigenvector** \`v\` with \`A.mulVec v =   v\`.
2. **Choose an index** \`i\` where \`|v i|\` is maximal (this is done via \`Finset.exists_max_image\`).
3. **Compare absolute values**:
   \`\`\`lean
   | * v i| = |(A.mulVec v) i| = | j, A i j * v j|
     j, |A i j| * |v j|
     j, |A i j| * |v i|
   \`\`\`
4. If \`|v i| = 0\`, then \`v = 0\`, which contradicts the eigenvector being nonzero. So we can divide by \`|v i|\` and obtain the desired bound on \`||\`.

In Lean, the proof is structured around these steps:

- \`obtain v, hv\` extracts a nonzero eigenvector.
- \`obtain i, hi\` chooses the maximal coordinate.
- \`h_bound\` proves the inequality on \`| * v i|\` using \`abs_sum_le_sum_abs\` and the maximality of \`|v i|\`.
- The final argument shows \`|v i| > 0\` and rearranges the inequality to isolate \`||\`.

Lean tactic notes for this proof sketch:

- \`obtain x, hx\` is a structured form of \`rcases\` that pulls apart an existential or a conjunction.
- \`have h : ... := ...\` introduces a named intermediate lemma inside the proof.
- \`simp\` is often used to rewrite \`A.mulVec v\` to a sum over \`Finset.univ\`.
- \`calc\` chains equalities/inequalities in a readable block.
- \`abs_sum_le_sum_abs\` is the lemma \`||  | |\` used to bound a sum by the sum of absolute values.
- \`mul_le_mul_of_nonneg_right\` and related lemmas handle inequalities when multiplying by a nonnegative term.
- To divide by \`|v i|\`, Lean typically uses a lemma like \`div_le_iff\` or \`mul_le_mul_left\` plus \`by have : 0 < |v i| := ...\`.

---

## Takeaway

- The first theorem identifies the **combinatorial structure** of the Huang matrix: its absolute values encode hypercube adjacency.
- The second theorem gives a **spectral bound**: any eigenvalue is controlled by the maximum absolute row sum.

Together, these results make it possible to translate combinatorial properties of the hypercube into spectral bounds on the Huang matrix.
`;D1[15]="# Section 15: Spectral Radius Bound by Max Degree\n\nThis section proves a standard spectral radius bound: for a symmetric real matrix whose entries are supported on a simple graph and bounded by 1 in absolute value, the largest eigenvalue is at most the graph's maximum degree.\n\n## Statement (informal)\nLet `A` be an `n x n` real symmetric matrix. Let `G` be a simple graph on the same vertex set. Assume\n\n- `|A i j| <= 1` when `G.Adj i j`, and\n- `|A i j| <= 0` otherwise (so those entries are 0).\n\nThen the largest eigenvalue of `A` is at most `G.maxDegree`.\n\nIn Lean, this is packaged as:\n\n- `A.IsSymm` gives symmetry (required for real eigenvalues).\n- `sorted_eigenvalues A hA` is a list of eigenvalues, sorted in **nondecreasing order** (i.e., ascending: \\(\\lambda_1 \\leq \\lambda_2 \\leq \\cdots \\leq \\lambda_n\\)).\n- `lambda_max` is `getLast` of that list, i.e., the **largest** eigenvalue \\(\\lambda_n\\).\n- The conclusion is `lambda_max <= G.maxDegree`.\n\n**Type context**: `A : Matrix (Fin n) (Fin n) ` is a real matrix indexed by `Fin n`. The hypothesis `hA : A.IsSymm` asserts \\(A = A^T\\).\n\nLean syntax notes that show up here:\n\n- `:` is a type ascription, so `A : Matrix (Fin n) (Fin n) ` reads \"A has type ...\".\n- `Matrix (Fin n) (Fin n) ` is Lean's function-style matrix type, i.e., a matrix is a function `Fin n -> Fin n -> `.\n- `Fin n` is the finite type with elements `0, 1, ..., n-1`. So `Fin n` indexes rows and columns.\n- `` is the real numbers type from `Real`.\n- `:=` (when used) is definitional equality, introducing a definition. It differs from `=` (propositional equality).\n- `hA : A.IsSymm` names a proof term `hA` of the proposition `A.IsSymm`. In Lean, proofs are just terms.\n\n## Proof idea in one paragraph\nThe largest eigenvalue is bounded by the maximum absolute row sum (a standard lemma for eigenvalues). Each row sum is bounded by the number of neighbors, because each adjacent entry has absolute value at most 1 and each non-adjacent entry is 0. The neighbor count is the degree, which is at most the maximum degree. Chaining these inequalities gives the bound.\n\n## How the Lean proof is organized\n\n### 1. Use a general eigenvalue bound\nThe proof starts with a lemma already in the library:\n\n```lean\neigenvalue_le_max_row_sum A mu hmu\n```\n\nHere `hmu : Module.End.HasEigenvalue (Matrix.toLin' A) mu` is a proof that \\(\\mu\\) is an eigenvalue of \\(A\\). The lemma returns an index \\(i\\) such that:\n\\[\n|\\mu| \\leq \\sum_j |A_{ij}|\n\\]\n\nThis is the standard \"eigenvalue bounded by max row sum\" inequality, a consequence of the Gershgorin circle theorem.\n\nLean construct details in this line:\n\n- `Module.End.HasEigenvalue` is a predicate on a linear map; it states \"mu is an eigenvalue.\"\n- `Matrix.toLin' A` coerces the matrix to a linear map (an element of `Module.End`), so eigenvalue facts apply.\n- Function application is by juxtaposition: `eigenvalue_le_max_row_sum A mu hmu` means \"apply the lemma to A, mu, hmu.\"\n- The lemma's output is a dependent pair: it produces an index `i` with the row-sum inequality for that `i`.\n\n### 2. Compare row sums to graph degree\nFor that specific row `i`, the code proves\n\n```\nsum_j |A i j| <= sum_{j in G.neighborFinset i} 1\n```\n\nbecause of the hypothesis `h_adj`:\n\n- if `G.Adj i j`, then `|A i j| <= 1`\n- otherwise `|A i j| <= 0`\n\nSo summing over all `j` is dominated by summing `1` over neighbors. This second sum is exactly the degree of `i`.\n\nLean constructs and tactics used here:\n\n- `G.Adj i j` is the adjacency predicate of the graph. It lives in `Prop` (a proposition).\n- `G.neighborFinset i` is the `Finset` of neighbors of `i`. `Finset` is a finite set with no duplicates.\n- `Finset.sum` is written in Lean as ` j in S, f j`, and `sum_j` in the informal sketch corresponds to ` j, ...`.\n- The inequality across sums is typically handled by `Finset.sum_le_sum`, a lemma that says if each summand is `<=`, then the total sum is `<=`.\n- `simp` is a simplification tactic. It rewrites expressions using definitional equalities and tagged lemmas (e.g., rewriting `|A i j|` to `0` when `h_adj` says non-adjacent entries are zero).\n- `by` introduces a term proof or tactic block. When you see `by`, it switches to tactic mode or term-style reasoning.\n- `have` introduces a local lemma (a named intermediate result). It is often used to package bounds on each summand before applying `Finset.sum_le_sum`.\n\n### 3. Move from degree to maximum degree\nFinally, use the graph lemma\n\n```lean\nG.degree_le_maxDegree i\n```\n\nwhich gives\n\n```\nG.degree i <= G.maxDegree\n```\n\nCombining the inequalities yields\n\n```\nmu <= G.maxDegree\n```\n\nfor any eigenvalue `mu`.\n\nLean notes:\n\n- `G.degree i` is the degree as a natural number; `G.maxDegree` is the maximum over all vertices.\n- `G.degree_le_maxDegree i` is a lemma returning a proof term of `G.degree i <= G.maxDegree`.\n- Inequality chaining is often written with `calc` blocks in Lean (e.g., `calc mu <= ... := ...; _ <= ... := ...`).\n- `<=` is a notation for `LE.le`; it uses typeclass instances to pick the right order (here, for `` or ``).\n\n### 4. Apply the bound to the largest eigenvalue\nThe list `sorted_eigenvalues A hA` contains all eigenvalues. The proof shows every element of this list is bounded by `G.maxDegree`, so the last element (the maximum) is also bounded. The non-emptiness of the list is guaranteed by `hn : n != 0`.\n\n## Practical reading of the Lean code\n\nKey constructs:\n\n- `h_bound`: proves every eigenvalue `mu` is `<= G.maxDegree`.\n- `h_sorted`: lifts that bound to every element of `sorted_eigenvalues`.\n- `List.getLast_mem` plugs the bound into `lambda_max`.\n\nThe only nontrivial steps are the sum estimate and the passage from an eigenvalue proof to the row-sum lemma. Those are handled by `eigenvalue_le_max_row_sum` and a short inequality chain using `simp` and `Finset.sum_le_sum`.\n\nMore Lean syntax detail for this step:\n\n- `sorted_eigenvalues A hA` is a `List `. A list is a finite sequence, not a set; it can contain duplicates.\n- `List.getLast` extracts the final element, but it needs a proof that the list is nonempty. That is why `hn : n != 0` appears.\n- `List.getLast_mem` is a lemma that says the last element is a member of the list. This is used to transfer a bound that holds for all elements to the last one.\n- A proof like `h_sorted` typically has the shape `   sorted_eigenvalues A hA,  <= G.maxDegree`, which is a `forall` + membership statement. In Lean, this is written as ` ,   ... ->  <= ...`.\n- `->` is implication. So `  L ->  <= M` is \"if  is in L, then  <= M.\"\n\n## Why this is called a spectral radius bound\nFor symmetric real matrices, the spectral radius equals the largest absolute eigenvalue, and the largest eigenvalue is the last element of the sorted list. Thus bounding `lambda_max` bounds the spectral radius as well.\n\n## Side note: Rayleigh quotient\nThe file ends with a reminder:\n\n\"The Rayleigh quotient of a vector x with respect to a matrix A is <x, Ax> / <x, x>.\"\n\nThis is the classical tool for characterizing eigenvalues of symmetric matrices, and it is another route to the same bound. The Lean proof above uses a library lemma instead of explicitly working with the Rayleigh quotient.\n";D1[16]="# Rayleigh quotient and Courant-Fischer (Lean walkthrough)\n\nThis section introduces the Rayleigh quotient, the Courant-Fischer min-max characterization, and several supporting lemmas about eigenvalues of symmetric matrices. The Lean code works with real symmetric matrices and vectors indexed by `Fin n`.\n\n## Rayleigh quotient\n\nThe Rayleigh quotient of a matrix `A` and a nonzero vector `x` is\n\n```\nR_A(x) = (x^T A x) / (x^T x).\n```\n\nIn Lean:\n\n```lean\ndef rayleigh_quotient {n : } (A : Matrix (Fin n) (Fin n) ) (x : Fin n  ) :  :=\n  dotProduct x (A.mulVec x) / dotProduct x x\n```\n\nLean syntax notes for this definition:\n\n- `def` introduces a new constant (here, a function).\n- `{n : }` is an implicit argument: Lean can often infer `n` from later arguments.\n- `Matrix (Fin n) (Fin n) ` is the type of `n  n` real matrices, indexed by `Fin n`.\n- `Fin n` is the type of naturals `< n`; using it for indices ensures bounds are enforced by the type.\n- `x : Fin n  ` views a vector as a function from indices to coordinates.\n- `:=` separates the name and type from the definition body.\n- `A.mulVec x` is dot-notation for `Matrix.mulVec A x` (matrixvector multiplication).\n- `dotProduct x y` is the standard inner product; here it encodes `x A x` and `x x`.\n- `/` is real division; the result is in ``.\n\nKey properties used later:\n\n- **Reindexing invariance.** If you change coordinates by a bijection of indices, the Rayleigh quotient is unchanged.\n- **Zero padding and principal submatrices.** If you embed a vector supported on a subset `S` into the full space (padding with zeros outside `S`), its Rayleigh quotient with respect to `A` matches the Rayleigh quotient of the corresponding principal submatrix.\n\nThese facts let you compare eigenvalue information between a matrix and its principal submatrices.\n\n## Courant-Fischer (inf-sup) definition\n\nThe Courant-Fischer min-max principle characterizes the `k`-th eigenvalue as a min over subspaces of a max of the Rayleigh quotient. The Lean definition in this file is the **inf-sup** form:\n\n```lean\ndef courant_fischer_inf_sup {n : } (A : Matrix (Fin n) (Fin n) ) (k : Fin n) :  :=\n   (V : Submodule  (Fin n  )) (_ : Module.finrank  V = k + 1),\n     (x : {x : V // x.1  0}), rayleigh_quotient A x.1\n```\n\nLean syntax notes for this definition:\n\n- `` and `` are the big infimum/supremum binders (`iInf`/`iSup`) from order theory.\n- `Submodule  (Fin n  )` is a linear subspace of the vector space `Fin n  `.\n- `(_ : Module.finrank  V = k + 1)` is an anonymous proof argument; it restricts the infimum to `V` of dimension `k + 1`.\n- `k : Fin n` coerces to `` when used in arithmetic like `k + 1`.\n- `{x : V // x.1  0}` is a subtype: an element of `V` paired with a proof it is nonzero.\n- `x.1` is the first projection of the subtype (the underlying vector in `V`); `x.2` would be the proof.\n- `rayleigh_quotient A x.1` uses coercions: `x.1 : V` can be treated as a vector in `Fin n  `.\n\nRead it as:\n\n- take all subspaces `V` of dimension `k + 1`,\n- for each `V` take the supremum of `R_A(x)` over nonzero `x` in `V`,\n- then take the infimum of those suprema.\n\n## Eigenbasis expansion and Rayleigh bounds\n\nMuch of the section expands vectors in an orthonormal eigenbasis and uses the sorted eigenvalues. The core idea:\n\nIf\n\n```\nx = sum_i c_i v_i\n```\n\nwith `v_i` orthonormal eigenvectors, then\n\n```\nR_A(x) = (sum_i c_i^2 * lambda_i) / (sum_i c_i^2).\n```\n\nThis immediately implies:\n\n- **Upper bound by the largest eigenvalue.** If `x != 0`, then `R_A(x) <= lambda_max`.\n- **Lower bound on a top-eigenspace span.** If `x` lives in the span of eigenvectors indexed `i >= k`, then `R_A(x) >= lambda_k`.\n\nIn Lean this appears as:\n\n- `rayleigh_le_max_eigenvalue` for the upper bound.\n- `rayleigh_ge_of_mem_span_top` for the lower bound on the top-eigenspace span.\n\nBoth proofs expand `x` in the orthonormal eigenbasis given by `exists_orthonormal_basis_sorted` and use monotonicity of the sorted eigenvalues.\n\nLean syntax notes for the surrounding constructs:\n\n- `span` refers to `Submodule.span`, the subspace generated by a set of vectors.\n- Names like `rayleigh_ge_of_mem_span_top` follow Lean convention: `of` indicates a lemma derived from a hypothesis like `x  span`.\n- `exists_orthonormal_basis_sorted` is a lemma providing a basis with extra structure; the `exists` prefix signals an existential statement.\n\n## Dimension arguments and nontrivial intersection\n\nTo apply Courant-Fischer, we need a nonzero vector in the intersection of two subspaces. There are two related lemmas:\n\n1. **Intersection dimension is positive.**\n   If `U` has dimension `n - k` and `V` has dimension `k + 1` in an `n`-dimensional space, then `U  V` is nontrivial.\n\n2. **Specialized intersection for eigenvector spans.**\n   In `le_sup_rayleigh_of_dim_eq_succ`, the code defines\n   `U = span {v_i | i >= k}`.\n   Since `dim U = n - k` and `dim V = k + 1`, the intersection contains a nonzero vector `x`.\n\nThis nonzero `x` is used to show that for any `V` of dimension `k+1`, the supremum of the Rayleigh quotient on `V` is at least `lambda_k`.\n\n## Courant-Fischer inequality (one direction)\n\nThe lemma\n\n```lean\nle_sup_rayleigh_of_dim_eq_succ\n```\n\nproves the key inequality:\n\n```\nlambda_k <= sup_{x in V, x != 0} R_A(x)\n```\n\nfor every `V` with `dim V = k + 1`. The proof is:\n\n- pick a nonzero `x` in `U  V` using the dimension argument,\n- apply `rayleigh_ge_of_mem_span_top` to get `R_A(x) >= lambda_k`,\n- conclude `lambda_k <= sup_{x in V} R_A(x)`.\n\nThis is the \"inf-sup\" half of Courant-Fischer.\n\n## Principal submatrices\n\nThe file defines principal submatrices and reindexing:\n\n```lean\ndef principal_submatrix {n : } (A : Matrix (Fin n) (Fin n) ) (S : Finset (Fin n)) : Matrix S S  :=\n  A.submatrix Subtype.val Subtype.val\n\n\ndef principal_submatrix_fin {n : } (A : Matrix (Fin n) (Fin n) ) (S : Finset (Fin n)) :\n  Matrix (Fin (Fintype.card {x // x  S})) (Fin (Fintype.card {x // x  S}))  :=\n  Matrix.reindex (Fintype.equivFin {x // x  S}) (Fintype.equivFin {x // x  S}) (principal_submatrix A S)\n```\n\nLean syntax notes for these definitions:\n\n- `Finset (Fin n)` is a finite set of indices; it carries membership proofs.\n- `Matrix S S ` uses the subtype `S` as an index type; elements are of the form `{x // x  S}`.\n- `A.submatrix f g` reindexes `A` by functions `f` and `g`; `Subtype.val` forgets the membership proof.\n- `{x // x  S}` is the subtype of elements of `Fin n` that lie in `S`.\n- `Fintype.card {x // x  S}` is the cardinality of that subtype.\n- `Fintype.equivFin {x // x  S}` is a canonical equivalence between the subtype and `Fin (card S)`.\n- `Matrix.reindex` transports a matrix along equivalences to change its index types.\n\nThere is a lemma that the reindexed principal submatrix remains symmetric if `A` is symmetric. This supports eigenvalue comparisons between a matrix and its principal submatrices using the Rayleigh quotient with zero-padded vectors.\n\n## Takeaways\n\n- The Rayleigh quotient is the core numerical bridge between vectors and eigenvalues.\n- Reindexing and zero-padding allow precise transfer between submatrices and the original matrix.\n- The Courant-Fischer min-max principle uses dimension arguments to guarantee vectors in intersections of subspaces.\n- In Lean, these ideas appear as lemmas about reindexing, spans, finrank, and eigenbasis expansions.\n\nIf you want to extend this section, the next natural step is to formalize the full equality of Courant-Fischer (both directions), and then derive interlacing inequalities for eigenvalues of principal submatrices.\n\n### Quick glossary of Lean keywords and tactic-style cues (as used in this section)\n\n- `def`: define a new constant or function.\n- `:`: type ascription (e.g., `x : Fin n  `).\n- ``: function type (e.g., `Fin n  ` is the type of vectors).\n- `:=`: separates a declaration from its defining term.\n- `//`: subtype constructor; pairs a term with a proof of a property.\n- `.`: field/namespace access via dot-notation (e.g., `A.mulVec`).\n- ``, ``: infimum/supremum binders (`iInf`/`iSup`) from lattice theory.\n- Tactic blocks are not shown in the snippets above; when present in Lean, they begin with `by` and use tactics (like `simp` for simplification or `linarith` for linear arithmetic) to build proofs.\n";D1[17]='# Eigenvalue interlacing for principal submatrices\n\nThis section formalizes a standard interlacing fact for symmetric matrices:\n\n> If you take a symmetric matrix `A` and restrict it to a principal submatrix `subA`\n> indexed by a nonempty set `S`, then the **largest eigenvalue** of `subA` is **at least**\n> the `(m-1)`-th eigenvalue of `A`, where `m = |S|`.\n\nIn Lean, the lemma is called `eigenvalue_interlacing_max`.\n\n## The mathematical statement (informal)\n\nLet:\n\n- `A` be an `n x n` real symmetric matrix,\n- `S` be a nonempty subset of `{0,1,...,n-1}` with `m = |S|`,\n- `subA` be the principal submatrix of `A` indexed by `S`,\n- `evs_A` be the sorted list of eigenvalues of `A` (in nondecreasing order),\n- `evs_sub` be the sorted list of eigenvalues of `subA`.\n\nThen:\n\n```\nmax_eigenvalue(subA) >= evs_A[m-1].\n```\n\nIn the Lean lemma, `max_eigenvalue(subA)` is expressed as\n`evs_sub.getLast`.\n\nThis is the "top-end" half of eigenvalue interlacing: the largest eigenvalue of a\nprincipal submatrix sits **above** the `(m-1)`-th eigenvalue of the full matrix.\n\n**Lean syntax notes that show up here:**\n- `lemma eigenvalue_interlacing_max ... : ... := by` introduces a named theorem and its proof. The `: ...` is the statement, and `:= by` switches to tactic mode.\n- `A : Matrix (Fin n) (Fin n) ` means `A` is a function `Fin n  Fin n  ` (Leans matrix encoding).\n- `S : Finset (Fin n)` is a finite set of indices; `S.Nonempty` is a `Prop` proof that `S` has an element.\n- `let m := S.card` and `let subA := ...` bind local names in the statement. These `let`s are definitional abbreviations visible inside the lemma.\n- `evs_sub.getLast hne` uses `List.getLast`, which requires a proof `hne` that the list is nonempty.\n- The index `m - 1, ...` is a `Fin` value built from a natural number plus a proof that it is in range.\n\n## How the proof works\n\nThe proof is a clean application of the min-max principle (a.k.a. CourantFischer) plus\na Rayleigh quotient comparison.\n\n### 1. The subspace of supported vectors\n\nDefine a subspace `V` of `R^n` consisting of vectors supported on `S`:\n\n- entries outside `S` are zero,\n- dimension of `V` is `m = |S|`.\n\nIn Lean this is `subspace_of_support S` and the dimension lemma is\n`subspace_of_support_dim S`.\n\n### 2. Min-max principle gives a lower bound\n\nThe min-max principle says:\n\n```\nev_A[m-1] <= sup_{x in V, x != 0} R_A(x)\n```\n\nwhere `R_A(x)` is the Rayleigh quotient of `A` at `x`.\n\nLean encapsulates this with `le_sup_rayleigh_of_dim_eq_succ`.\n\n**Lean syntax and tactic details for this step:**\n- `set V := subspace_of_support S` creates a definitional abbreviation *and* a local proof that the new name is equal to the original expression; it is useful when rewriting.\n- `have h_min_max : ... := by` introduces a local lemma. `have` is how Lean names intermediate results.\n- `apply le_sup_rayleigh_of_dim_eq_succ ...` tells Lean to use that lemma and turns its premises into subgoals.\n- `rw [Nat.sub_add_cancel ...]` rewrites a goal using a lemma; `rw` replaces equals by equals.\n- `exact subspace_of_support_dim S` closes a goal with a named lemma.\n\n### 3. Rayleigh quotient is preserved on the submatrix\n\nFor any nonzero `x` in `V`, you can compress it to a vector `y` in `R^m`\nby keeping only coordinates in `S`.\n\nThen:\n\n```\nR_A(x) = R_subA(y).\n```\n\nThis is the technical heart of the proof: it matches the quadratic form\nof `A` on a supported vector with the quadratic form of the principal\nsubmatrix.\n\nIn Lean this is the long lemma `h_rayleigh_eq`:\n\n- it builds a coordinate map from `x` to `y`,\n- shows the Rayleigh quotients agree.\n\n**Lean syntax and tactic details for this step:**\n- `have h_rayleigh_eq :  x  V, x  0   y, ... := by` introduces a dependent ``/`` statement proved by tactics.\n- `intro x hx hx_ne_zero` introduces universally quantified variables and hypotheses.\n- `obtain y, hy := ...` destructs an `` (or other structure) into witnesses and proofs.\n- `refine\' y, ?_, ?_` builds an `` goal by providing a witness and leaving placeholders.\n- `contrapose!` turns a goal `P  False` or `P` into a goal about `P` by contrapositive; the bang version simplifies negations.\n- `unfold rayleigh_quotient` expands a definition; it exposes the underlying dot products and matrix multiplication.\n- `simp` and `simp +decide` simplify expressions using rewrite rules and decision procedures; `+decide` allows `simp` to discharge `Decidable` goals.\n- `split_ifs` splits on `if` conditions, creating one subgoal per branch.\n- `ext i` invokes extensionality (pointwise equality), common when proving two functions are equal.\n- `congr!` is a stronger congruence tactic that reduces an equality of complex expressions to equalities of corresponding parts.\n\n### 4. Rayleigh quotient is at most the max eigenvalue\n\nFor symmetric matrices, the Rayleigh quotient is always bounded by the\nmaximum eigenvalue:\n\n```\nR_subA(y) <= max_eigenvalue(subA).\n```\n\nLean uses `rayleigh_le_max_eigenvalue` for this.\n\n**Lean syntax and tactic details for this step:**\n- `have h_rayleigh_le_max :  y, y  0  ... := by` is a typical way to package a reusable bound.\n- `intros y hy_nonzero` is shorthand for multiple `intro`s.\n- `apply rayleigh_le_max_eigenvalue ...` uses the bound lemma, leaving the nonzero and dimension side conditions as goals.\n- `exact ne_of_gt ...` converts a strict inequality into a non-equality when a lemma expects ``.\n\n### 5. Put it together\n\nChaining all inequalities:\n\n```\nev_A[m-1]\n  <= sup_{x in V} R_A(x)\n  =  sup_{y} R_subA(y)\n  <= max_eigenvalue(subA).\n```\n\nThis yields the interlacing bound:\n\n```\nmax_eigenvalue(subA) >= ev_A[m-1].\n```\n\n**Lean syntax and tactic details for the final glue:**\n- `refine le_trans h_min_max ?_` applies transitivity of ``, leaving the second inequality as a goal.\n- `convert ciSup_le _` changes the goal by definitional equality before applying `ciSup_le` (the `` bound for `iSup`).\n- `simp +zetaDelta` expands `let` bindings and simplifies; `zetaDelta` is a simp lemma for `let`-bound definitions.\n- `grind` is an automation tactic for first-order goals; it often closes routine set-membership and order subgoals.\n\n## Key Lean objects and lemmas\n\n- `principal_submatrix_fin A S`: principal submatrix indexed by `S`.\n- `principal_submatrix_fin_isSymm`: symmetry is preserved.\n- `sorted_eigenvalues A hA`: sorted eigenvalues list.\n- `subspace_of_support S`: vectors supported on `S`.\n- `le_sup_rayleigh_of_dim_eq_succ`: min-max inequality.\n- `rayleigh_le_max_eigenvalue`: Rayleigh quotient bounded by max eigenvalue.\n\n**Lean keyword/tactic glossary (as used in this proof):**\n- `by`: starts a tactic block; what follows is a sequence of tactics producing the proof term.\n- `classical`: opens classical logic (choice and excluded middle), often needed for `Finset`/`Fintype` constructions.\n- `set` vs `let`: `set` introduces a name *and* a proof of definitional equality; `let` is a local abbreviation without a proof.\n- `have`: introduces a local lemma with a name; often used to store intermediate bounds.\n- `apply`: uses a lemma, turning its premises into new goals.\n- `rw`: rewrite with an equality lemma.\n- `simp`: simplify the goal using rewrite rules; `simp_all` simplifies all goals and hypotheses.\n- `exact`: close a goal by providing a term of the required type.\n- `intro`/`intros`: introduce variables/hypotheses for `` or `` goals.\n- `obtain`/`rcases`: destruct a structure or `` to get witnesses and proofs.\n- `refine`/`refine\'`: build a term with placeholders (`?_`) for remaining goals.\n- `unfold`: expand a definition.\n- `ext`: extensionality; reduce equality of functions/matrices to pointwise equality.\n- `convert`: change the goal using definitional equality.\n- `aesop`/`grind`: automation tactics for routine reasoning.\n\n## Why this matters\n\nInterlacing is a core tool in spectral graph theory and matrix analysis.\nHere it is applied to principal submatrices, which correspond to restricting\nthe quadratic form to a coordinate subspace. This lemma isolates the\n**maximum eigenvalue** bound that is later used to show large principal\nsubmatrices inherit large eigenvalues.\n';D1[18]="# Huang submatrix eigenvalue bounds\n\nThis section explains the Lean lemma\n`huang_submatrix_max_eigenvalue_ge_sqrt_n`, which proves a lower bound on the\nlargest eigenvalue of a principal submatrix of the Huang matrix.\n\n## The mathematical claim\n\nLet `n` be a positive integer, and let `S` be a subset of the `2^n` indices with\n`|S| > 2^(n-1)`. Consider the principal submatrix `subA` of the Huang matrix\n`A = huang_matrix_fin n` obtained by restricting to the rows and columns in `S`.\nThen the largest eigenvalue of `subA` is at least `sqrt n`.\n\nIn other words, any principal submatrix of size strictly larger than half the\nrows must inherit an eigenvalue of size at least `sqrt n`.\n\n## How the lemma is structured in Lean\n\nThe lemma has the following shape (simplified):\n\n- `subA` is defined as `principal_submatrix_fin (huang_matrix_fin n) S`.\n- `h_subA` is a proof that `subA` is symmetric, so its eigenvalues are real.\n- `evs_sub` is the sorted list of eigenvalues of `subA`.\n- The lemma concludes that `evs_sub.getLast ... >= Real.sqrt n`.\n\nLean uses `getLast` with a proof that the list of eigenvalues is nonempty.\nThat nonemptiness follows from the fact that `S.card > 0`.\n\n## Lean syntax and tactic notes\n\nBelow are the Lean constructs that appear in the lemma, with short explanations\nof what each keyword or tactic does.\n\n- `lemma name (args) : statement := by` defines a theorem and begins a tactic\n  proof block. The `by` keyword switches from term-style to tactic-style proof.\n- `def name (args) := term` defines a reusable definition (used elsewhere in\n  the file for auxiliary objects).\n- `let x := term` introduces a local abbreviation. In the lemma statement, `let`\n  binds `subA`, `h_subA`, and `evs_sub` so the goal can mention them without\n  repeating long expressions.\n- `have h : P := by ...` introduces a named intermediate claim `h` and proves it\n  in a nested tactic block.\n- `apply lemma` uses a lemma whose conclusion matches the current goal, turning\n  the goal into its hypotheses. `exact term` finishes the goal with a proof\n  term. `refine` is like `exact` but allows placeholders that are solved later.\n- `simp` runs the simplifier on the goal; `simp_all` simplifies the goal and all\n  hypotheses. The `+decide` flag tells `simp` to use `decide` to close goals\n  about decidable propositions. `rw [h]` rewrites the goal using an equality\n  `h`.\n- `convert` changes the goal by a definitional equality (often after rewriting),\n  letting you reuse a lemma whose conclusion is definitional equal to the goal.\n- `le_trans` is the transitivity lemma for `<=`, used to chain inequalities.\n- `omega` is an arithmetic decision tactic for Presburger arithmetic (linear\n  inequalities over naturals and integers), used to discharge index bounds.\n- `List.getLast` returns the last element of a list. It requires a proof that\n  the list is nonempty; `List.ne_nil_of_length_pos` provides that from a proof\n  that the length is positive.\n- `List.get i, hi` indexes a list using a `Fin` value. The notation `i, hi`\n  constructs a `Fin` by bundling an index `i` with a proof `hi` that `i` is in\n  range.\n- `List.replicate k a` builds a list of `k` copies of `a`, and `++` concatenates\n  lists. `List.getElem_append` is the lemma that describes how indexing behaves\n  on a concatenated list (and is used to split into the left vs. right block of\n  eigenvalues).\n\n## Key ingredients in the proof\n\n### 1) Interlacing of eigenvalues\n\nThe proof starts by applying a standard interlacing theorem for principal\nsubmatrices:\n\n- If you take a symmetric matrix `A` and a principal submatrix `subA`, then\n  the eigenvalues of `subA` interlace those of `A`.\n- In particular, the maximum eigenvalue of `subA` is at least the\n  `(m-1)`-th eigenvalue of `A`, where `m = |S|`.\n\nIn Lean, this is implemented by `eigenvalue_interlacing_max`, which yields\n\n```\nmax_eigenvalue(subA) >=\n  (sorted_eigenvalues A).get m - 1, ...\n```\n\nThe index proof is bookkeeping: it shows `m-1` is within range because\n`m <= 2^n` and `m > 0`.\n\n### 2) Explicit spectrum of the Huang matrix\n\nA separate lemma `huang_eigenvalues_eq_list` provides the full eigenvalue list\nof the Huang matrix:\n\n```\n[-sqrt n, ..., -sqrt n] (2^(n-1) times)\n++\n[+sqrt n, ..., +sqrt n] (2^(n-1) times)\n```\n\nSo the sorted eigenvalues are a block of negative values followed by a block of\npositive values, with `2^(n-1)` copies of each.\n\n### 3) Positioning the index\n\nBecause `m = |S| > 2^(n-1)`, the `(m-1)`-th eigenvalue of the full Huang matrix\nfalls in the positive block. That entry is exactly `+sqrt n`.\n\nLean encodes this by rewriting with the explicit eigenvalue list and using a\ncase split in `List.getElem_append` to show the index lands in the right half.\n\n### 4) Final inequality\n\nCombining interlacing with the explicit spectrum, the proof concludes\n\n```\nmax_eigenvalue(subA) >= sqrt n.\n```\n\nThis is exactly the statement in the lemma.\n\n## Summary\n\nThe lemma is a standard application of eigenvalue interlacing and the explicit\nspectrum of the Huang matrix. The key point is that any principal submatrix with\nmore than half the rows must inherit a large positive eigenvalue, because the\nfull matrix has `2^(n-1)` copies of `+sqrt n` and interlacing forces the submatrix\nmaximum to be at least one of them.\n";D1[19]="# g_val and its level sets\n\nThis section defines a signed function `g_val` on the Boolean cube and then uses it to split the cube into two level sets, `S_pos` and `S_neg`. The key idea is that `g_val` always evaluates to either `1` or `-1`, so these level sets form a clean partition of all inputs.\n\n## The definition of g_val\n\nIn Lean:\n\n```lean\ndef g_val {n : } (f : (Fin n  Bool)  Bool) (x : Fin n  Bool) :  :=\n  (if f x then -1 else 1) * chi Finset.univ x\n```\n\nInterpretation:\n\n- `x : Fin n  Bool` is a Boolean input of length `n`.\n- `chi Finset.univ x` is the parity character on the full index set. Concretely, it is `(-1)^{|{ i | x i = true }|}`.\n- `(if f x then -1 else 1)` flips the sign depending on whether the Boolean function `f` returns `true` at `x`.\n\nSo `g_val f x` is a signed value that combines the parity of `x` with the output of `f`. Both factors are `1`, so the product is also `1`.\n\nLean syntax notes for this definition:\n\n- `def` introduces a new definition; `g_val` is the name being defined.\n- `{n : }` is an implicit argument: Lean can infer `n` from context, so callers usually omit it. The type `` is the natural numbers.\n- `(f : (Fin n  Bool)  Bool)` is a function argument. `Fin n` is the finite type `{0, , n-1}`, so `Fin n  Bool` is an `n`-bit Boolean input, and `f` is a Boolean function on that cube.\n- `(x : Fin n  Bool)` is another argument, explicitly the input point.\n- `: ` states the return type is real numbers.\n- `:=` separates the definition head from its body.\n- `if f x then -1 else 1` is Leans conditional; it has type `` here because both branches are real numbers.\n- `*` is real multiplication.\n- `chi Finset.univ x` is a function application; `Finset.univ` is the full finite set of all inputs, and `chi` is applied to it and then to `x`.\n\n## Why g_val is always 1\n\nThe parity character `chi Finset.univ x` is always `1` or `-1`. The conditional `(if f x then -1 else 1)` is also always `1` or `-1`. Their product therefore can only be `1` or `-1`.\n\nThis observation is the backbone of the level set definitions and the union/disjointness lemmas that follow.\n\n## The positive and negative level sets\n\nThe section defines two finite sets of inputs:\n\n```lean\ndef S_pos {n : } (f : (Fin n  Bool)  Bool) : Finset (Fin n  Bool) :=\n  Finset.filter (fun x => g_val f x = 1) Finset.univ\n\ndef S_neg {n : } (f : (Fin n  Bool)  Bool) : Finset (Fin n  Bool) :=\n  Finset.filter (fun x => g_val f x = -1) Finset.univ\n```\n\n- `S_pos f` collects all inputs where `g_val f x = 1`.\n- `S_neg f` collects all inputs where `g_val f x = -1`.\n- Both are subsets of the full Boolean cube `Finset.univ`.\n\nBecause `g_val` only takes values `1`, every input belongs to exactly one of these sets.\n\nLean syntax notes for these definitions:\n\n- `Finset (Fin n  Bool)` is the type of finite sets of Boolean inputs. `Finset.univ` is the universal finite set over that type.\n- `Finset.filter` takes a predicate and keeps only elements that satisfy it.\n- `(fun x => g_val f x = 1)` is an anonymous function (a lambda). It maps an input `x` to the proposition `g_val f x = 1`.\n- `=` is definitional equality in Leans propositions; inside `Finset.filter` it is treated as a predicate.\n- `-1` is a literal of type `` here, inferred from `g_val f x : `.\n\n## The level sets cover the whole space\n\nLemma in Lean:\n\n```lean\nlemma S_pos_union_S_neg {n : } (f : (Fin n  Bool)  Bool) :\n  S_pos f  S_neg f = Finset.univ := by\n  ...\n```\n\nInformally: for any input `x`, `g_val f x` is either `1` or `-1`, so `x` must be in `S_pos f` or in `S_neg f`. The proof unfolds `g_val`, uses the fact that `chi` is also `1`, and performs a case split on parity.\n\nLean syntax notes for this lemma statement:\n\n- `lemma` declares a theorem with proof. The name is `S_pos_union_S_neg`.\n- `S_pos f  S_neg f` uses `` for finset union.\n- `=` is equality between finsets.\n- `:= by` switches into tactic mode, where the proof is built step-by-step.\n- `...` is a placeholder in this writeup; in Lean, it stands for omitted proof steps.\n\n## The level sets are disjoint\n\nLemma in Lean:\n\n```lean\nlemma S_pos_disjoint_S_neg {n : } (f : (Fin n  Bool)  Bool) :\n  Disjoint (S_pos f) (S_neg f) := by\n  exact Finset.disjoint_filter.mpr fun _ _ _ _ => by linarith;\n```\n\nThis uses the fact that an element cannot satisfy both `g_val f x = 1` and `g_val f x = -1`. The `linarith` step closes the contradiction.\n\nLean syntax notes for the proof:\n\n- `Disjoint (S_pos f) (S_neg f)` is the proposition that the two finsets have empty intersection.\n- `exact` tells Lean to accept the following term as a complete proof of the goal.\n- `Finset.disjoint_filter.mpr` is a lemma in reverse direction (`mpr` stands for *modus ponens reverse*), converting a disjointness goal into a pointwise proof about the filter predicates.\n- `fun _ _ _ _ =>` introduces an anonymous function with four arguments. The underscores mean unused arguments, so Lean doesnt require names for them.\n- `by linarith` invokes the `linarith` tactic, which solves linear arithmetic contradictions automatically (here, `1 = -1` is impossible).\n- The trailing `;` ends the tactic block (Lean allows it but it is optional here).\n\n## Why this matters\n\nThe level sets `S_pos` and `S_neg` give a clean partition of the Boolean cube based on the sign of `g_val`. Later arguments can compare the sizes of these sets or relate them to sums like ` x, g_val f x`. For instance, if the sum is nonzero, then one of the sets must be larger than the other.\n\n## Takeaways\n\n- `g_val` is a signed combination of `f` and parity, always equal to `1` or `-1`.\n- `S_pos` and `S_neg` are the level sets where `g_val` is positive or negative.\n- These sets partition the entire space: they cover all inputs and are disjoint.\n";D1[20]=`# Why One Level Set Must Be Large

This section proves a simple but powerful counting fact: if a Boolean function has full degree, then one of its two "level sets" (where a related 1-valued function is positive or negative) must contain **more than half** of the hypercube.

## The Lemma (informal)

Let \\(f : \\{0,1\\}^n \\to \\{0,1\\}\\) with \\(\\deg(f) = n\\) and \\(n \\neq 0\\). Recall from **Section 19** that \\(g_{\\text{val}}(f, x) = \\mathbf{1}_{f(x)} \\cdot \\chi_{[n]}(x)\\), which always equals \\(\\pm 1\\).

Define the level sets:
\\[
S_{\\text{pos}}(f) = \\{x \\in \\{0,1\\}^n : g_{\\text{val}}(f, x) = 1\\}
\\]
\\[
S_{\\text{neg}}(f) = \\{x \\in \\{0,1\\}^n : g_{\\text{val}}(f, x) = -1\\}
\\]

**Theorem**: At least one of these sets has size strictly greater than \\(2^{n-1}\\):
\\[
|S_{\\text{pos}}(f)| > 2^{n-1} \\quad \\text{or} \\quad |S_{\\text{neg}}(f)| > 2^{n-1}
\\]

## Intuition

Think of \\(g_{\\text{val}}(f, \\cdot)\\) as a \\(\\pm 1\\) labeling of the hypercube. The sum of all labels is:
\\[
\\sum_{x \\in \\{0,1\\}^n} g_{\\text{val}}(f, x) = |S_{\\text{pos}}| - |S_{\\text{neg}}|
\\]

If this sum is **nonzero**, then \\(|S_{\\text{pos}}| \\neq |S_{\\text{neg}}|\\). But the two sets partition the whole cube, so:
\\[
|S_{\\text{pos}}| + |S_{\\text{neg}}| = 2^n
\\]

If two non-negative integers sum to \\(2^n\\) and are unequal, one must exceed \\(2^{n-1}\\).

**Key fact** (from **Section 11**): For a full-degree function (\\(\\deg(f) = n\\)) and \\(n \\neq 0\\), the sum \\(\\sum_x g_{\\text{val}}(f, x) \\neq 0\\). This is because the sum equals (up to normalization) the top Fourier coefficient \\(\\hat{f}([n])\\), which is nonzero when \\(\\deg(f) = n\\).

## Proof Outline (Lean)

The Lean proof has two main parts.

### 1. Show the two level sets have different sizes

The proof computes the sum of \`g_val f\` by splitting over \`S_pos\` and \`S_neg\`:

- On \`S_pos\`, \`g_val f x = 1\`.
- On \`S_neg\`, \`g_val f x = -1\`.

So:

\`\`\`
 g_val f = |S_pos f|  |S_neg f|.
\`\`\`

The lemma \`g_val_sum_ne_zero f h_deg hn\` gives that this sum is nonzero, hence

\`\`\`
|S_pos f|  |S_neg f|.
\`\`\`

Lean snippet (paraphrased):

\`\`\`lean
have h_card_ne : (S_pos f).card  (S_neg f).card := by
  have h_card_ne : (Finset.sum Finset.univ (g_val f))
    = (S_pos f).card - (S_neg f).card := by
    -- split sum over S_pos and S_neg, then use g_val = 1
    ...
  have := g_val_sum_ne_zero f h_deg hn
  aesop
\`\`\`

**Lean syntax/tactic notes (what each piece does):**

- \`have h_card_ne : ... := by\` introduces a **local lemma** named \`h_card_ne\` and starts a **tactic block** (\`by\`) to prove it.
- \`Finset.sum Finset.univ (g_val f)\` is a **finite sum** over the entire finite universe. \`Finset.univ\` is the finset of *all* elements of the finite type, and \`g_val f\` is the summand function.
- \`(S_pos f).card\` and \`(S_neg f).card\` are the **cardinalities** of the finsets \`S_pos f\` and \`S_neg f\`.
- \`= ... - ...\` is an equality in the target type of the sum. In Lean, this typically uses a coercion to an additive type (often \`\`) so the subtraction is well-defined; Lean inserts these coercions automatically when needed.
- \`...\` is a **placeholder** inside a proof block, signaling proof details omitted here; Lean would normally require actual steps (e.g., \`simp\`, \`rw\`, \`by_cases\`, etc.).
- \`have := g_val_sum_ne_zero f h_deg hn\` creates an **anonymous hypothesis** from the lemma \`g_val_sum_ne_zero\` specialized to \`f\` and the assumptions \`h_deg\` and \`hn\`.
- \`aesop\` is an **automation tactic** that tries to solve the goal using the available hypotheses and standard lemmas (a best effort proof search).

### 2. Use the partition of the cube

The sets \`S_pos\` and \`S_neg\` are disjoint and cover the whole hypercube, so:

\`\`\`
|S_pos f| + |S_neg f| = 2^n.
\`\`\`

Lean computes this using \`Finset.card_union_of_disjoint\` and the fact that the
universe of \`Fin n  Bool\` has size \`2^n\`. Since \`n  0\`, it rewrites

\`\`\`
2^n = 2 * 2^(n-1).
\`\`\`

So the sum of the two sizes is exactly twice \`2^(n-1)\`.

**Lean syntax/tactic notes (part 2):**

- \`Finset.card_union_of_disjoint\` is a lemma stating that if two finsets are **disjoint**, then the \`card\` of their union is the sum of their \`card\`s.
- The universe of inputs is typically expressed in Lean via \`Finset.univ\` (if you are in \`Finset\`) or \`Fintype.card\` (if you are counting the whole type). Both rely on the fact that \`Fin n  Bool\` is a finite type.
- The rewrite \`2^n = 2 * 2^(n-1)\` is usually done with rewriting lemmas like \`Nat.pow_succ\` (or \`pow_succ\`) plus \`Nat.succ_eq_add_one\` and \`Nat.mul_comm\`. Tactic-wise this is often a \`simp\` or \`rw\` step with those lemmas.

### 3. Conclude one side is larger than half

With:
- \\(|S_{\\text{pos}}| + |S_{\\text{neg}}| = 2 \\cdot 2^{n-1}\\), and
- \\(|S_{\\text{pos}}| \\neq |S_{\\text{neg}}|\\),

we can derive that one must exceed \\(2^{n-1}\\). Here's the explicit arithmetic:

**Proof**: Suppose for contradiction that both \\(|S_{\\text{pos}}| \\leq 2^{n-1}\\) and \\(|S_{\\text{neg}}| \\leq 2^{n-1}\\). Then:
\\[
|S_{\\text{pos}}| + |S_{\\text{neg}}| \\leq 2 \\cdot 2^{n-1}
\\]
But we know \\(|S_{\\text{pos}}| + |S_{\\text{neg}}| = 2 \\cdot 2^{n-1}\\), so equality holds throughout. This means \\(|S_{\\text{pos}}| = 2^{n-1}\\) and \\(|S_{\\text{neg}}| = 2^{n-1}\\), contradicting \\(|S_{\\text{pos}}| \\neq |S_{\\text{neg}}|\\).

Therefore, at least one of \\(|S_{\\text{pos}}| > 2^{n-1}\\) or \\(|S_{\\text{neg}}| > 2^{n-1}\\) must hold. Lean closes this with \`grind\`.

**Lean syntax/tactic note (part 3):**

- \`grind\` is another **automation tactic** (from the \`grind\`/\`simp\`/\`linarith\` family) that tries to solve arithmetic and logical goals by combining rewriting and decision procedures. Here it discharges the final one side is larger arithmetic goal.

## Takeaway

The full-degree condition forces a global imbalance in the 1 labeling \`g_val f\`. Once you know the two level sets partition the hypercube, that imbalance means one level set must contain **strictly more than half** of all inputs.

This fact is a recurring lever: it turns algebraic information (nonzero sum) into a combinatorial guarantee (a large level set).
`;D1[21]="# Hypercube Graph Definition and Properties\n\nThis section formalizes the n-dimensional hypercube graph in Lean and records a few key properties that connect adjacency, parity, and induced subgraphs. The vertices are Boolean vectors of length `n`, modeled as functions `Fin n -> Bool`.\n\n## 1. Defining the hypercube graph\n\nIn Lean, the hypercube graph is defined as a `SimpleGraph` whose adjacency relation holds exactly when two vertices differ in exactly one coordinate:\n\n```lean\ndef hypercube_graph (n : ) : SimpleGraph (Fin n  Bool) :=\n  SimpleGraph.fromRel (fun x y => (Finset.filter (fun i => x i  y i) Finset.univ).card = 1)\n```\n\nKey ideas:\n\n- `Fin n  Bool` is the type of Boolean strings of length `n` (each index `i : Fin n` gives a bit).\n- `Finset.univ` is the finite set of all indices `i : Fin n`.\n- `Finset.filter (fun i => x i  y i)` selects the coordinates where `x` and `y` differ.\n- The adjacency condition is that this set has cardinality 1, i.e., Hamming distance 1.\n\nLean details:\n\n- `def` introduces a new definition. Here it defines a function `hypercube_graph` that takes `n` and returns a graph.\n- `` is the type of natural numbers.\n- `:` is type ascription, so `(n : )` reads \"n has type Nat\".\n- `SimpleGraph (Fin n  Bool)` is a graph whose vertices are functions `Fin n  Bool`.\n- `:=` separates the definition name from its value.\n- `SimpleGraph.fromRel` builds a simple graph from a symmetric, irreflexive relation.\n- `fun x y => ...` is lambda notation, defining the adjacency predicate as a function of two vertices.\n- The expression `(Finset.filter (fun i => x i  y i) Finset.univ).card = 1` is a Boolean proposition. `filter` restricts `Finset.univ`, `.card` is its size, and `= 1` is equality in ``.\n- `x i` means applying the function `x` to the index `i`.\n\nThe lemma `hypercube_graph_adj` immediately unfolds this definition:\n\n```lean\nlemma hypercube_graph_adj {n : } (x y : Fin n  Bool) :\n  (hypercube_graph n).Adj x y \n    (Finset.filter (fun i => x i  y i) Finset.univ).card = 1 := by\n  simp [hypercube_graph]\n```\n\nThis lemma is a convenience rule for rewriting adjacency into a cardinality statement.\n\nLean details:\n\n- `lemma` introduces a named theorem.\n- `{n : }` is an implicit argument; Lean can usually infer it.\n- `(x y : Fin n  Bool)` are explicit arguments.\n- `:` starts the statement being proved.\n- `` is logical equivalence (\"if and only if\").\n- `(hypercube_graph n).Adj x y` uses dot-notation to access the adjacency relation of a graph.\n- `:= by` starts a tactic proof block.\n- `simp [hypercube_graph]` runs the simplifier and tells it to unfold `hypercube_graph` using the definition in the bracketed list.\n\n## 2. Neighbor parity and the `chi` sign\n\nThe file uses a parity-based function `chi` (defined elsewhere) and proves that neighbors in the hypercube have opposite `chi` values:\n\n```lean\nlemma chi_univ_neighbor {n : } (x y : Fin n  Bool)\n  (h_adj : (hypercube_graph n).Adj x y) :\n  chi Finset.univ x = -chi Finset.univ y := by\n  -- proof omitted\n```\n\nIntuition:\n\n- If `x` and `y` differ in exactly one coordinate, then the number of `true` bits changes by 1.\n- Therefore the parity flips, and a parity-based sign like `chi` must change sign.\n\nLean details:\n\n- A line break after the lemma name is just formatting; the arguments continue on the next line.\n- `(h_adj : (hypercube_graph n).Adj x y)` is a hypothesis that `x` and `y` are adjacent.\n- `chi Finset.univ x` applies `chi` to the full set of indices and the vertex `x`.\n- The unary `-` is numeric negation; here it flips the sign.\n- `:= by` again signals a tactic proof (omitted in the file).\n\n## 3. Relating `g_val` and function changes on edges\n\nThe lemma `g_val_neighbor_eq_iff_f_ne` states that along a hypercube edge, equality of `g_val` is equivalent to `f` changing value:\n\n```lean\nlemma g_val_neighbor_eq_iff_f_ne {n : }\n  (f : (Fin n  Bool)  Bool) (x y : Fin n  Bool)\n  (h_adj : (hypercube_graph n).Adj x y) :\n  g_val f x = g_val f y  f x  f y := by\n  -- proof omitted\n```\n\nThis is used later to relate graph-theoretic degrees to sensitivity. The key point is that adjacency plus a sign flip controls how `g_val` behaves across an edge.\n\nLean details:\n\n- `(f : (Fin n  Bool)  Bool)` is a Boolean function on vertices.\n- `g_val f x` uses function application; `g_val` is defined elsewhere.\n- `` is inequality. `f x  f y` is the proposition that the Boolean values differ.\n\n## 4. Sensitivity as degree in induced subgraphs\n\nTwo lemmas connect Boolean function sensitivity to degrees in induced subgraphs of the hypercube. The positive and negative level sets are written `S_pos f` and `S_neg f`.\n\nFor `S_pos`:\n\n```lean\nlemma sensitivity_at_x_eq_degree_in_S_pos {n : }\n  (f : (Fin n  Bool)  Bool) (x : Fin n  Bool) (hx : x  S_pos f) :\n  (Finset.filter (fun y => (hypercube_graph n).Adj x y  f x  f y) Finset.univ).card =\n  (Finset.filter (fun y => (hypercube_graph n).Adj x y  y  S_pos f) Finset.univ).card := by\n  -- proof omitted\n```\n\nAnd similarly for `S_neg`:\n\n```lean\nlemma sensitivity_at_x_eq_degree_in_S_neg {n : }\n  (f : (Fin n  Bool)  Bool) (x : Fin n  Bool) (hx : x  S_neg f) :\n  (Finset.filter (fun y => (hypercube_graph n).Adj x y  f x  f y) Finset.univ).card =\n  (Finset.filter (fun y => (hypercube_graph n).Adj x y  y  S_neg f) Finset.univ).card := by\n  -- proof omitted\n```\n\nInterpretation:\n\n- The left side counts neighbors where `f` changes value (sensitivity at `x`).\n- The right side counts neighbors staying inside the same level set, i.e., degree in the induced subgraph on `S_pos` or `S_neg`.\n- These lemmas show that in the appropriate level set, sensitivity is exactly a graph degree.\n\nLean details:\n\n- `x  S_pos f` and `x  S_neg f` are membership propositions in finite sets.\n- `` is logical conjunction, so the filter conditions require adjacency and an additional property.\n- `Finset.filter` again selects neighbors that satisfy the conjunction.\n- `card` is used on both sides, so the lemma is a statement about equality of counts.\n\n## 5. Induced hypercube graphs and reindexing\n\nThe file defines induced hypercube graphs and also a version where vertices are reindexed by `Fin (2^n)`.\n\nInduced subgraph on a finite set `S` of Boolean vectors:\n\n```lean\ndef induced_hypercube_graph {n : } (S : Finset (Fin n  Bool)) :\n  SimpleGraph {x // x  S} :=\n  SimpleGraph.induce (S : Set (Fin n  Bool)) (hypercube_graph n)\n```\n\nHypercube graph on `Fin (2^n)` using the equivalence between bitstrings and numbers:\n\n```lean\ndef hypercube_graph_fin (n : ) : SimpleGraph (Fin (2^n)) :=\n  (hypercube_graph n).map (boolFunEquivFin n).toEmbedding\n```\n\nAnd the induced graph reindexed by `Fin (card S)`:\n\n```lean\ndef induced_hypercube_graph_fin_card {n : } (S : Finset (Fin (2^n))) :\n  SimpleGraph (Fin (Fintype.card {x // x  S})) :=\n  let G := SimpleGraph.induce (S : Set (Fin (2^n))) (hypercube_graph_fin n)\n  let equiv := Fintype.equivFin {x // x  S}\n  G.map equiv.toEmbedding\n```\n\nThese definitions allow later spectral arguments to be stated over standard finite types (`Fin k`) while preserving the hypercube adjacency structure.\n\nLean details:\n\n- `{x // x  S}` is a subtype: pairs of `x` with a proof that `x  S`.\n- `SimpleGraph.induce` restricts a graph to a subset of vertices.\n- `(S : Set (Fin n  Bool))` coerces a `Finset` to a `Set` using the canonical coercion.\n- `.map` transfers a graph along an embedding between vertex types.\n- `(boolFunEquivFin n).toEmbedding` is the embedding underlying an equivalence between Boolean functions and `Fin (2^n)`.\n- `let G := ...` and `let equiv := ...` introduce local definitions within the term; they are in scope for the final expression.\n- `Fintype.card` gives the number of elements in a finite type.\n- `Fintype.equivFin` produces an equivalence between a finite type and `Fin (card ...)`.\n\n## Takeaways\n\n- The hypercube graph is defined by Hamming distance 1 using a filtered index set.\n- Adjacency implies parity flips, which shows up as a sign change in `chi`.\n- Sensitivity at a point is captured by degree in an induced subgraph of the hypercube.\n- The hypercube can be reindexed to `Fin (2^n)` and induced subgraphs can be reindexed to `Fin (card S)` without losing adjacency information.\n";D1[22]=`# Restriction to Subcubes

This section defines **restriction** of a Boolean function to a subset of coordinates. This is a fundamental operation that allows us to focus on a "subcube" by fixing some variables to constant values.

## What is restriction?

Given a Boolean function

\`\`\`
f : (Fin n  Bool)  Bool
\`\`\`

and a subset of coordinates \`S : Finset (Fin n)\`, we can **restrict** \`f\` by:

- allowing the coordinates in \`S\` to vary freely, and
- fixing all coordinates outside \`S\` to some assignment \`z : Fin n  Bool\`.

In Lean, the restriction is:

\`\`\`lean
def restriction {n : } (f : (Fin n  Bool)  Bool) (S : Finset (Fin n)) (z : Fin n  Bool) :
  (Fin (Fintype.card {x // x  S})  Bool)  Bool :=
  fun y => f (fun i =>
    if h : i  S
    then y ((Fintype.equivFin {x // x  S}).symm i, h)
    else z i)
\`\`\`

### Lean syntax walkthrough

Below is a Lean-oriented explanation of the constructs in the definition above. This is about *syntax and semantics* of Lean, not the math.

- \`def restriction ... := ...\` introduces a new definition named \`restriction\`. The \`:=\` separates the name/signature from the body.
- \`{n : }\` is an *implicit* argument (Lean will infer \`n\` when possible). \`\` is the type of natural numbers.
- \`(f : (Fin n  Bool)  Bool)\` is a *named argument* with a type. \`\` is the function type constructor, so \`Fin n  Bool\` is a Boolean assignment on \`n\` coordinates, and \`(Fin n  Bool)  Bool\` is a Boolean function on such assignments.
- \`S : Finset (Fin n)\` is a finite set of indices. \`Fin n\` is the type of natural numbers strictly less than \`n\`.
- \`(z : Fin n  Bool)\` is the fixed assignment outside \`S\`.
- The result type
  \`\`\`
  (Fin (Fintype.card {x // x  S})  Bool)  Bool
  \`\`\`
  says the restricted function takes inputs indexed by a set of size \`|S|\`. \`Fintype.card\` gives the cardinality of a finite type, and \`{x // x  S}\` is a *subtype* (elements \`x\` with a proof they are in \`S\`).
- \`fun y => ...\` is an anonymous function. This is Lean's lambda syntax.
- \`f (fun i => ...)\` applies \`f\` to a *constructed* full assignment. The inner \`fun i => ...\` is a function of a coordinate \`i : Fin n\`.
- \`if h : i  S then ... else ...\` is a *dependent if*: it not only checks membership, it also binds \`h\` as a proof of \`i  S\` in the \`then\` branch.
- \`i, h\` is a *subtype constructor*: it builds an element of \`{x // x  S}\` from \`i : Fin n\` and the proof \`h\`.
- \`(Fintype.equivFin {x // x  S})\` is an equivalence between the subtype and \`Fin (Fintype.card {x // x  S})\`. The \`.symm\` field takes the inverse direction of that equivalence.
- \`y ((Fintype.equivFin {x // x  S}).symm i, h)\` means: convert the \`S\`-element \`i, h\` to an index in \`Fin |S|\`, then feed it to \`y\`.
- \`else z i\` uses the fixed assignment on coordinates not in \`S\`.

The input to the restricted function is a Boolean assignment only on the coordinates in \`S\`. The code constructs a full assignment \`x : Fin n  Bool\` by:

- using the input \`y\` on indices in \`S\` (via an equivalence between \`S\` and \`Fin |S|\`),
- using \`z\` on indices outside \`S\`.

Then it evaluates \`f x\`.

## Intuition: plugging in constants

Intuitively, a restriction is the usual "plug in constants outside S" operation. If you have a Boolean function on 5 variables and you fix variables 2 and 4 to specific values, you get a new function on the remaining 3 variables.

Example: Suppose \`f(x, x, x) = x XOR x XOR x\` and we restrict to \`S = {0, 2}\` with \`z = true\`. Then:

\`\`\`
restriction f S z (y, y) = y XOR true XOR y = NOT(y XOR y)
\`\`\`

The restricted function depends only on the free variables in \`S\`.

## Why restriction matters

Restriction is a key tool for several reasons:

1. **Fourier analysis**: Restricting to a subset \`S\` that supports a top-degree Fourier coefficient turns that coefficient into the "full set" coefficient of the restricted function.

2. **Induction**: Many proofs about Boolean functions proceed by restricting to smaller subcubes.

3. **Sensitivity bounds**: As we'll see in the next section, sensitivity cannot increase under restriction, which allows us to transfer bounds.

## Connection to Fourier coefficients

A crucial lemma (proved elsewhere) states:

\`\`\`lean
lemma exists_restriction_fourier_coeff_univ_ne_zero (f : (Fin n  Bool)  Bool) (S : Finset (Fin n))
  (hS : fourier_coeff f S  0) :
   z, fourier_coeff (restriction f S z) Finset.univ  0
\`\`\`

Lean syntax notes for this statement:

- \`lemma\` introduces a named theorem; it behaves like \`theorem\` but is often used for helper results.
- \`(hS : fourier_coeff f S  0)\` is a hypothesis argument. \`\` is inequality, and \`0\` is the zero element of the coefficient type inferred by Lean.
- The colon \`:\` before the final line separates the hypotheses from the conclusion.
- \` z, ...\` is the existential quantifier (there exists \`z\`). In Lean it is a binder that introduces \`z\` in the conclusion.
- \`Finset.univ\` is the finite set of all elements of the relevant finite type (here, all coordinates in the restricted domain).

This says: if \`f\` has a nonzero Fourier coefficient at \`S\`, then there exists a restriction \`z\` such that the restricted function has a nonzero coefficient at the full set (i.e., \`Finset.univ\` for the smaller domain).

This is exactly what we need to connect the degree of \`f\` to the degree of its restrictions.

## Takeaways

- Restriction fixes variables outside a set \`S\` and keeps only the \`S\`-coordinates free.
- The Lean definition uses an explicit equivalence to map between the restricted and full coordinate spaces.
- Restriction is essential for transferring Fourier-analytic information between functions of different dimensions.
`;D1[23]="# Sensitivity Monotonicity Under Restriction\n\nThis section proves the key monotonicity fact: **restricting a function cannot increase its sensitivity**. This lemma is the bridge that lets us transfer sensitivity bounds from restricted functions back to the original.\n\n## The Lemma\n\n```lean\nlemma sensitivity_restriction_le {n : } (f : (Fin n  Bool)  Bool)\n  (S : Finset (Fin n)) (z : Fin n  Bool) :\n  sensitivity (restriction f S z)  sensitivity f\n```\n\nIn plain language: the sensitivity of the restricted function is at most the sensitivity of the original function.\n\nLean syntax notes for the statement above:\n- `lemma` introduces a named theorem; its name is `sensitivity_restriction_le`.\n- `{n : }` is an **implicit** argument (curly braces); Lean will infer `n` when possible. `` is the type of natural numbers.\n- `(f : (Fin n  Bool)  Bool)` declares a function taking a Boolean input on `Fin n` (i.e., a length-`n` Boolean vector) and returning a `Bool`.\n- `Fin n` is the finite type `{0, , n-1}`; `Fin n  Bool` is a function assigning a Boolean to each coordinate.\n- `(S : Finset (Fin n))` is a finite set of indices; `Finset` is the computational (decidable) finite set type.\n- `(z : Fin n  Bool)` is a fixed Boolean assignment used for coordinates outside `S`.\n- The colon `:` before the last line separates the hypotheses from the conclusion.\n- `sensitivity (restriction f S z)  sensitivity f` is the goal; `` is the usual order on ``.\n- Function application is by juxtaposition: `restriction f S z` means `restriction` applied to `f`, then `S`, then `z`.\n\n## Why it's true: intuition\n\nRecall from **Section 22** that `restriction f S z` is a function on \\(\\{0,1\\}^{|S|}\\), where we fix coordinates outside \\(S\\) to the values in \\(z\\).\n\n**Key observation about Hamming distance**: In the restricted space \\(\\{0,1\\}^{|S|}\\), two inputs \\(y, y'\\) are neighbors (Hamming distance 1) if they differ in exactly one coordinate of \\(S\\). This corresponds exactly to neighbors in the full space \\(\\{0,1\\}^n\\) that:\n- Differ in exactly one coordinate\n- That coordinate is in \\(S\\)\n- Both inputs agree with \\(z\\) outside \\(S\\)\n\nSo the restricted space has **fewer** neighbors to consider (only flips within \\(S\\)), not more.\n\nEvery input \\(y \\in \\{0,1\\}^{|S|}\\) to the restricted function corresponds to a full input \\(x \\in \\{0,1\\}^n\\), obtained by:\n\\[\nx_i = \\begin{cases} y_j & \\text{if } i \\text{ is the } j\\text{-th element of } S \\\\ z_i & \\text{if } i \\notin S \\end{cases}\n\\]\n\nSince the restriction only explores a subset of inputs and a subset of bit flips, it cannot create more sensitive directions than the original function already had.\n\n## Proof structure in Lean\n\nThe Lean proof formalizes this intuition by:\n\n### 1. Unfold sensitivity as a supremum\n\nRecall that sensitivity is defined as:\n\n```lean\ndef sensitivity (f : (Fin n  Bool)  Bool) :  :=\n  Finset.sup Finset.univ (fun x =>\n    (Finset.filter (fun y => hammingDist x y = 1  f x  f y) Finset.univ).card)\n```\n\nLean syntax notes for the definition above:\n- `def` introduces a definition (as opposed to a theorem).\n- `: ` annotates the return type; `:=` starts the definition body.\n- `Finset.sup` takes a finite set and a function, returning the supremum (maximum) value of that function over the set.\n- `Finset.univ` is the full finite set of all elements of the relevant finite type (here, all `x : Fin n  Bool`).\n- `fun x => ...` is a lambda (anonymous function) mapping each `x` to its number of sensitive neighbors.\n- `Finset.filter` keeps only elements satisfying a predicate; here it filters neighbors `y` with Hamming distance 1 and output flip.\n- `hammingDist x y = 1` uses `=` for equality; `` is logical and.\n- `f x  f y` uses `` for inequality.\n- `( ... ).card` takes the cardinality of the filtered finite set.\n\nSo we need to show that the supremum over the restricted domain is at most the supremum over the full domain.\n\n### 2. Map restricted inputs to full inputs\n\nFor each restricted input `y`, construct the corresponding full input `x` by combining `y` on `S` with `z` outside `S`. This is the inverse of the restriction operation.\n\n### 3. Show sensitive neighbors inject\n\nThe key step is constructing an **injection** from sensitive neighbors of \\(y\\) in the restricted domain to sensitive neighbors of \\(x\\) in the full domain.\n\nLet \\(y' \\in \\{0,1\\}^{|S|}\\) be a sensitive neighbor of \\(y\\) for the restricted function, meaning:\n- \\(y'\\) differs from \\(y\\) in exactly one coordinate \\(j \\in S\\)\n- \\((\\text{restriction } f\\, S\\, z)(y) \\neq (\\text{restriction } f\\, S\\, z)(y')\\)\n\nConstruct \\(x' \\in \\{0,1\\}^n\\) by: keeping \\(z\\) outside \\(S\\), and using \\(y'\\) on \\(S\\).\n\nThen \\(x'\\) differs from \\(x\\) in exactly one coordinate (the same \\(j\\)), and by definition of restriction:\n\\[\nf(x) = (\\text{restriction } f\\, S\\, z)(y) \\neq (\\text{restriction } f\\, S\\, z)(y') = f(x')\n\\]\n\nSo \\(x'\\) is a sensitive neighbor of \\(x\\) for \\(f\\). This map \\(y' \\mapsto x'\\) is injective because distinct \\(y'\\) give distinct \\(x'\\).\n\n### 4. Apply cardinality comparison\n\nSince there's an injection from sensitive neighbors in the restricted domain to sensitive neighbors in the full domain:\n\n```lean\n(restricted sensitive neighbors at y).card  (sensitive neighbors at x).card\n```\n\nTaking the supremum over all `y` and noting that each maps to some `x`:\n\n```lean\nsup_y (restricted sensitivity at y)  sup_x (sensitivity at x)\n```\n\nThis gives the desired inequality.\n\n## Why this matters for the main proof\n\nThis monotonicity lemma is crucial in the final argument:\n\n1. We find a top-degree Fourier coefficient at some set `S`.\n2. We restrict to `S` so that the restricted function has full degree equal to `|S|`.\n3. We apply the \"full-degree implies large sensitivity\" bound to the restricted function.\n4. We use `sensitivity_restriction_le` to lift this bound back to the original function:\n\n```\nsensitivity f  sensitivity (restriction f S z)  (degree (restriction f S z)) = (degree f)\n```\n\nWithout monotonicity, we couldn't transfer the bound from the restriction to the original function.\n\n## Takeaways\n\n- Sensitivity is monotone under restriction: it can only stay the same or decrease.\n- The Lean proof mirrors the combinatorial argument by building an explicit injection from restricted sensitive neighbors to original sensitive neighbors.\n- This lemma is the key bridge between the full-degree case (where spectral methods give bounds) and the general case (arbitrary Boolean functions).\n";D1[24]=`# Final theorem: sensitivity_conjecture

This section proves the final statement of the sensitivity conjecture in the Boolean setting:

\`\`\`lean
theorem sensitivity_conjecture {n : } (f : (Fin n  Bool)  Bool) :
  (sensitivity f : )  Real.sqrt (degree f)
\`\`\`

In mathematical notation:
\\[
s(f) \\geq \\sqrt{\\deg(f)}
\\]

**Fourier basis convention**: Throughout this project, we use the \\(\\{0,1\\}\\)-valued encoding for Boolean functions (see **Section 4**). The Fourier degree is defined using the parity characters \\(\\chi_S\\) (see **Section 3**).

The proof is a clean chain of earlier lemmas. Below is a walkthrough of the ideas and how the Lean proof stitches them together.

---

## Goal and strategy

We want to show the sensitivity of any Boolean function is at least the square root of its Fourier degree. The proof splits into two cases:

1. \`degree f = 0\` (constant function): then the inequality is trivial.
2. \`degree f  0\`: find a top-degree Fourier coefficient, restrict to that support so the full coefficient is nonzero, deduce the restricted function has degree equal to the number of variables, apply a degree-to-sensitivity lower bound, then lift back to the original function using monotonicity under restriction.

The proof is essentially:

\`\`\`
sensitivity f
  >= sensitivity (restriction f S z)
  >= sqrt (degree (restriction f S z))
  =  sqrt (degree f)
\`\`\`

---

## Step-by-step explanation

### 1) Case split on \\(\\deg(f) = 0\\)

Lean starts with:

\`\`\`lean
cases eq_or_ne (degree f) 0 <;> simp_all +decide
\`\`\`

**Lean syntax notes**:
- \`eq_or_ne a b\` is a lemma producing \`a = b  a  b\`.
- \`cases\` performs case analysis on that disjunction, creating two goals: one for \`degree f = 0\` and one for \`degree f  0\`.
- \`<;>\` is tactic sequencing that applies the following tactic(s) to *all* goals generated so far.
- \`simp_all\` simplifies the goal and all hypotheses using the simp lemma set and any available rewrite rules.
- \`+decide\` extends simplification with \`decide\`, which discharges decidable propositions by computation.

**Why the degree-0 case is trivial**: If \\(\\deg(f) = 0\\), then \\(\\sqrt{\\deg(f)} = 0\\). Since sensitivity is always \\(\\geq 0\\) (it's a natural number), the inequality \\(s(f) \\geq 0\\) holds trivially.

**What degree 0 means**: A function has \\(\\deg(f) = 0\\) if and only if all Fourier coefficients \\(\\hat{f}(S)\\) with \\(|S| \\geq 1\\) are zero. This means \\(f\\) depends only on the empty set of variables, i.e., \\(f\\) is a **constant function**. Constant functions have sensitivity 0.

The rest of the proof assumes \\(\\deg(f) \\neq 0\\), i.e., \\(f\\) is non-constant.

### 2) Choose a maximal-support nonzero Fourier coefficient

The degree is defined as the maximum cardinality of a subset \`S\` with nonzero Fourier coefficient \`fourier_coeff f S\`.

The proof unfolds the definition and uses finite set arguments to pick an \`S\` with:

- \`fourier_coeff f S  0\`
- \`S.card\` is maximal among those with nonzero coefficient

Lean uses \`Set.exists_max_image\` after establishing finiteness of the set of such \`S\`. This yields:

\`\`\`
 k, k = degree f   S, S.card = k  fourier_coeff f S  0
\`\`\`

This is the there is a top-degree coefficient step.

**Lean syntax notes (existentials and pattern matching)**:
- \`obtain k, hk :  k, ... := by ...\` extracts a witness \`k\` and its proof \`hk\` from an existential statement.
- The \`\` syntax constructs or destructs tuples/existentials; it is Leans canonical pair notation.
- Projections like \`hk.1\` and \`hk.2\` pick out components of nested conjunctions/tuples.
- \`unfold degree\` expands the definition of \`degree\` so the \`Finset\`/\`Set\` machinery is visible to subsequent tactics.

### 3) Restrict to the top-degree support

Using the lemma \`exists_restriction_fourier_coeff_univ_ne_zero\`, we select a restriction \`z\` such that for the restricted function

\`\`\`
 g = restriction f S z
\`\`\`

the Fourier coefficient at the full set is nonzero:

\`\`\`
fourier_coeff g Finset.univ  0
\`\`\`

Intuitively: after fixing all variables outside \`S\`, the coefficient on the remaining variables becomes the top coefficient of the restricted function.

**Lean syntax notes (application and \`exact\`)**:
- Function application is written by juxtaposition: \`restriction f S z\` means \`restriction\` applied to \`f\`, \`S\`, and \`z\`.
- \`Finset.univ\` is the universal finite set for the current finite type (here, the remaining variables after restriction).
- \`exact\` supplies a term that matches the goal exactly; in this step the lemma \`exists_restriction_fourier_coeff_univ_ne_zero f S hS_fourier\` directly provides the witness and proof.

### 4) Degree of the restricted function is exactly \`|S|\`

Now the lemma \`degree_eq_n_of_fourier_coeff_univ_ne_zero\` applies:

\`\`\`
 degree (restriction f S z) = S.card
\`\`\`

Because the full set coefficient is nonzero, the restricted function has full degree on its remaining variables.

**Lean syntax notes (\`have\` and automation)**:
- \`have h_deg_g : ... := by ...\` introduces a named local lemma; the \`by\` opens a tactic block to construct it.
- An underscore \`_\` is an implicit argument placeholder; Lean infers it from context.
- \`aesop\` is a proof automation tactic that tries to solve goals using a database of lemmas and heuristics.

### 5) Sensitivity lower bound in the full-degree case

Earlier we proved:

\`\`\`
sensitivity_ge_sqrt_degree_of_degree_eq_n
\`\`\`

This gives:

\`\`\`
sensitivity (restriction f S z)  sqrt (degree (restriction f S z))
\`\`\`

Combine with the degree equality from Step 4 to get a lower bound in terms of \`S.card\`.

**Lean syntax notes (casts and \`Real.sqrt\`)**:
- \`(sensitivity (restriction f S z) : )\` uses a type coercion from \`\` to \`\`, guided by the explicit \`: \` annotation.
- \`Real.sqrt\` is the real square root; simplification tactics can rewrite expressions involving it when given nonnegativity facts.

### 6) Lift the bound back to the original function

Restrictions cannot increase sensitivity, so:

\`\`\`
sensitivity f  sensitivity (restriction f S z)
\`\`\`

This is exactly \`sensitivity_restriction_le\` (casted to \`\` in the proof).

**Lean syntax notes (\`exact_mod_cast\`)**:
- \`exact_mod_cast\` applies a lemma after automatically inserting the necessary coercions between related numeric types (like \`\` and \`\`) and rewriting with coercion lemmas.
- It is especially handy for inequalities that are true in \`\` but the goal is in \`\`.

### 7) Finish with arithmetic and rewriting

The final line \`grind\` closes the goal by chaining the inequalities and rewriting \`S.card = degree f\`.

**Lean syntax notes (\`grind\`)**:
- \`grind\` is a finishing tactic that combines rewriting, simplification, and arithmetic reasoning.
- Here it uses the accumulated \`\` chain and the equality \`S.card = degree f\` to solve the final real inequality.

---

## How the pieces fit together

- **Fourier degree** is characterized by the largest subset \`S\` with a nonzero Fourier coefficient.
- **Restriction** focuses on that subset and turns its coefficient into the \`univ\` coefficient of the restricted function.
- **Full-degree sensitivity bound** shows that for any function whose top coefficient is at \`univ\`, sensitivity is at least \`sqrt degree\`.
- **Monotonicity of sensitivity under restriction** lets us transfer the bound back to the original function.

That chain is exactly the proof structure in Lean.

---

## Lean proof outline (annotated)

\`\`\`
cases eq_or_ne (degree f) 0 <;> simp_all +decide
-- pick top-degree Fourier coefficient
obtain k, hk :  k, k = degree f   S, S.card = k  fourier_coeff f S  0 := by
  unfold degree; ...
-- restrict so univ coefficient is nonzero
obtain S, hS_card, hS_fourier := hk.2
obtain z, hz :  z, fourier_coeff (restriction f S z) Finset.univ  0 := by
  exact exists_restriction_fourier_coeff_univ_ne_zero f S hS_fourier
-- degree of restriction is full
have h_deg_g : degree (restriction f S z) = S.card := by
  have := degree_eq_n_of_fourier_coeff_univ_ne_zero _ hz; aesop
-- sensitivity bound on restricted function
have h_sens_g : (sensitivity (restriction f S z) : )  Real.sqrt (degree (restriction f S z)) := by
  have := sensitivity_ge_sqrt_degree_of_degree_eq_n (restriction f S z); aesop
-- sensitivity monotonicity under restriction
have h_sens_f : (sensitivity f : )  (sensitivity (restriction f S z) : ) := by
  exact_mod_cast sensitivity_restriction_le f S z
-- finish
 grind
\`\`\`

This completes the formal proof of the sensitivity conjecture in the project.
`;var CI=D1;var f=U6(lQ(),1),L1={primerGold:"#d4a574",primerGoldLight:"#f5e6d3",primerInk:"#2c1810",primerPaper:"#faf6f1",primerAccent:"#8b4513",cubeVertex:"#4a90d9",cubeEdge:"#6bb3f7",cubeActive:"#ff6b6b",cubePositive:"#51cf66",cubeNegative:"#ff6b6b",matrixPositive:"#51cf66",matrixNegative:"#ff6b6b",matrixZero:"#dee2e6"};function YF({children:F,display:_=!1}){let $=CF.useRef(null),[W,H]=CF.useState(!1);return CF.useEffect(()=>{if(window.katex){H(!0);return}let Y=setInterval(()=>{if(window.katex)H(!0),clearInterval(Y)},50);return()=>clearInterval(Y)},[]),CF.useEffect(()=>{if($.current&&W&&window.katex)try{window.katex.render(F,$.current,{displayMode:_,throwOnError:!1})}catch(Y){console.error("KaTeX error:",Y),$.current.textContent=F}},[F,_,W]),f.jsxDEV("span",{ref:$,className:_?"block my-4 text-center":"inline"},void 0,!1,void 0,this)}function S6({children:F,title:_}){return f.jsxDEV("div",{className:"my-6",children:[_&&f.jsxDEV("div",{className:"bg-stone-700 text-stone-200 text-xs px-4 py-2 rounded-t-lg font-mono",children:_},void 0,!1,void 0,this),f.jsxDEV("pre",{className:`bg-stone-800 text-stone-100 p-4 overflow-x-auto text-sm font-mono leading-relaxed ${_?"rounded-b-lg":"rounded-lg"}`,children:f.jsxDEV("code",{children:F.trim()},void 0,!1,void 0,this)},void 0,!1,void 0,this)]},void 0,!0,void 0,this)}function dQ(F){let _=[];for(let $=0;$<1<<F;$++){let W=[];for(let H=0;H<F;H++)W.push(($>>H&1)===1);_.push({bits:W,label:W.map((H)=>H?"1":"0").join("")})}return _}function Iz(F,_){let $=0;for(let W=0;W<F.length;W++)if(F[W]!==_[W])$++;return $}function vv(F,_){let $=0;for(let W of F)if(_[W])$++;return $%2===0?1:-1}function yY({n:F,highlightNeighbors:_=!1,colorFunction:$,onVertexSelect:W,selectedVertex:H}){let Y=CF.useRef(null),K=CF.useRef(null),G=CF.useRef(null),U=CF.useRef(null),z=CF.useRef(null),h=CF.useRef([]),A=CF.useRef([]),N=CF.useRef(0),M=CF.useMemo(()=>dQ(F),[F]),T=CF.useCallback((P)=>{if(F===2)return new w0((P[0]?1:-1)*1.5,(P[1]?1:-1)*1.5,0);else if(F===3)return new w0((P[0]?1:-1)*1.5,(P[1]?1:-1)*1.5,(P[2]?1:-1)*1.5);let O=0,b=0,k=0;for(let y=0;y<P.length;y++){let m=y/P.length*Math.PI*2,x=P[y]?1:-1;O+=Math.cos(m)*x*0.5,b+=Math.sin(m)*x*0.5,k+=(y%2===0?1:-1)*x*0.3}return new w0(O*1.5,b*1.5,k*1.5)},[F]);return CF.useEffect(()=>{if(!Y.current)return;let P=new FY;P.background=new lF(L1.primerPaper),K.current=P;let D=new V6(50,1,0.1,100);D.position.set(4,3,4),U.current=D;let O=new KB({antialias:!0});O.setSize(300,300),O.setPixelRatio(window.devicePixelRatio),Y.current.appendChild(O.domElement),G.current=O;let b=new zB(D,O.domElement);b.enableDamping=!0,b.dampingFactor=0.05,b.autoRotate=!0,b.autoRotateSpeed=0.5,z.current=b;let k=new WY(16777215,0.6);P.add(k);let y=new QY(16777215,0.8);y.position.set(5,5,5),P.add(y);let m=new EQ(0.15,32,32);h.current=[],M.forEach((d,$0)=>{let X0=$?$(d.bits):L1.cubeVertex,K0=new _Y({color:X0}),J0=new X8(m,K0);J0.position.copy(T(d.bits)),J0.userData={index:$0,bits:d.bits},P.add(J0),h.current.push(J0)}),A.current=[];let x=new TQ({color:L1.cubeEdge,opacity:0.4,transparent:!0});for(let d=0;d<M.length;d++)for(let $0=d+1;$0<M.length;$0++)if(Iz(M[d].bits,M[$0].bits)===1){let X0=[T(M[d].bits),T(M[$0].bits)],K0=new l6().setFromPoints(X0),J0=new qY(K0,x.clone());J0.userData={from:d,to:$0},P.add(J0),A.current.push(J0)}let o=()=>{N.current=requestAnimationFrame(o),b.update(),O.render(P,D)};o();let s=new HY,j=new DF,V=(d)=>{let $0=O.domElement.getBoundingClientRect();j.x=(d.clientX-$0.left)/$0.width*2-1,j.y=-((d.clientY-$0.top)/$0.height)*2+1,s.setFromCamera(j,D);let X0=s.intersectObjects(h.current);if(X0.length>0&&W){let K0=X0[0].object.userData.index;W(H===K0?null:K0)}};return O.domElement.addEventListener("click",V),()=>{if(cancelAnimationFrame(N.current),O.domElement.removeEventListener("click",V),Y.current&&O.domElement)Y.current.removeChild(O.domElement);O.dispose()}},[F,M,T,$]),CF.useEffect(()=>{if(!K.current)return;h.current.forEach((P,D)=>{let O=H===D,b=_&&H!==null&&Iz(M[H].bits,M[D].bits)===1,k;if(O)k=L1.cubeActive;else if(b)k=L1.cubePositive;else if($)k=$(M[D].bits);else k=L1.cubeVertex;P.material.color.set(k),P.scale.setScalar(O?1.5:b?1.3:1)}),A.current.forEach((P)=>{let{from:D,to:O}=P.userData,b=_&&(H===D||H===O),k=P.material;k.color.set(b?L1.cubeActive:L1.cubeEdge),k.opacity=b?1:0.4})},[H,_,M,$]),f.jsxDEV("div",{ref:Y,className:"w-[300px] h-[300px] mx-auto rounded-lg overflow-hidden shadow-lg",style:{cursor:"grab"}},void 0,!1,void 0,this)}function bv({currentSection:F,setSection:_}){return f.jsxDEV("nav",{className:"fixed top-0 left-0 right-0 z-50 bg-primer-paper border-b-2 border-primer-gold shadow-sm",children:f.jsxDEV("div",{className:"max-w-6xl mx-auto px-4",children:f.jsxDEV("div",{className:"flex items-center justify-between h-16",children:[f.jsxDEV("h1",{className:"primer-heading text-lg text-primer-ink",children:"The Sensitivity Conjecture"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"flex gap-1",children:[{id:"intro",label:"The Conjecture",icon:"I"},{id:"cube",label:"The Hypercube",icon:"II"},{id:"sensitivity",label:"Sensitivity",icon:"III"},{id:"fourier",label:"Fourier Analysis",icon:"IV"},{id:"gTransform",label:"The g-Transform",icon:"V"},{id:"huang",label:"Huang's Matrix",icon:"VI"},{id:"spectral",label:"Spectral Bounds",icon:"VII"},{id:"proof",label:"The Proof",icon:"VIII"},{id:"leanProof",label:"Full Lean Code",icon:"IX"}].map((W)=>f.jsxDEV("button",{onClick:()=>_(W.id),className:`px-3 py-2 text-sm primer-text transition-all rounded ${F===W.id?"bg-primer-gold text-white":"text-primer-ink hover:bg-primer-gold-light"}`,children:[f.jsxDEV("span",{className:"font-bold mr-1",children:[W.icon,"."]},void 0,!0,void 0,this),f.jsxDEV("span",{className:"hidden md:inline",children:W.label},void 0,!1,void 0,this)]},W.id,!0,void 0,this))},void 0,!1,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)},void 0,!1,void 0,this)}function Eq({title:F,subtitle:_,children:$}){return f.jsxDEV("section",{className:"min-h-screen pt-24 pb-16 px-4",children:f.jsxDEV("div",{className:"max-w-4xl mx-auto",children:[f.jsxDEV("div",{className:"text-center mb-12",children:[f.jsxDEV("h2",{className:"primer-heading text-4xl text-primer-ink mb-4",children:F},void 0,!1,void 0,this),_&&f.jsxDEV("p",{className:"primer-text text-lg text-primer-accent",children:_},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"primer-text text-lg leading-relaxed",children:$},void 0,!1,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function jv(){let[F,_]=CF.useState(0),$=CF.useMemo(()=>dQ(3),[]),W=(G)=>{return G.filter((z)=>z).length>=2},H=(G)=>{return W(G)?L1.cubePositive:L1.cubeNegative},Y=F!==null?$.filter((G,U)=>U!==F&&Iz($[F].bits,G.bits)===1):[],K=F!==null?Y.filter((G)=>W(G.bits)!==W($[F].bits)):[];return f.jsxDEV("div",{className:"flex flex-col items-center gap-6",children:[f.jsxDEV("div",{className:"text-center primer-text",children:[f.jsxDEV("p",{className:"mb-2",children:["Function: ",f.jsxDEV("span",{className:"primer-code",children:"f(x) = majority(x)"},void 0,!1,void 0,this),f.jsxDEV("br",{},void 0,!1,void 0,this),f.jsxDEV("span",{className:"text-sm text-stone-500",children:"(outputs 1 if at least 2 bits are 1)"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("p",{className:"text-sm text-stone-500",children:[f.jsxDEV("span",{className:"inline-block w-3 h-3 rounded-full bg-cube-positive mr-1"},void 0,!1,void 0,this)," f=1 (green)",f.jsxDEV("span",{className:"inline-block w-3 h-3 rounded-full bg-cube-negative ml-3 mr-1"},void 0,!1,void 0,this)," f=0 (red)"]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV(yY,{n:3,colorFunction:H,onVertexSelect:_,selectedVertex:F,highlightNeighbors:!1},void 0,!1,void 0,this),F!==null&&f.jsxDEV("div",{className:"bg-primer-gold-light p-4 rounded-lg text-center",children:[f.jsxDEV("p",{className:"primer-text",children:["At vertex ",f.jsxDEV("span",{className:"primer-code",children:$[F].label},void 0,!1,void 0,this),"(f=",W($[F].bits)?"1":"0","):"]},void 0,!0,void 0,this),f.jsxDEV("p",{className:"text-2xl font-bold text-primer-accent mt-2",children:["Local sensitivity = ",K.length]},void 0,!0,void 0,this),f.jsxDEV("p",{className:"text-sm text-stone-600 mt-1",children:["(",K.length," neighbor",K.length!==1?"s":""," flip the output)"]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)}function xv(){let[F,_]=CF.useState([0,1]),$=CF.useMemo(()=>dQ(3),[]),W=3,H=(Y)=>{if(F.includes(Y))_(F.filter((K)=>K!==Y));else _([...F,Y].sort())};return f.jsxDEV("div",{className:"flex flex-col items-center gap-6",children:[f.jsxDEV("div",{className:"flex gap-4 items-center",children:[f.jsxDEV("span",{className:"primer-text",children:"Select S:"},void 0,!1,void 0,this),Array.from({length:3},(Y,K)=>f.jsxDEV("button",{onClick:()=>H(K),className:`w-10 h-10 rounded-full font-mono text-sm transition-all ${F.includes(K)?"bg-primer-gold text-white":"bg-stone-200 text-stone-600 hover:bg-stone-300"}`,children:["x",K+1]},K,!0,void 0,this))]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"primer-text text-center",children:["S = ","{",F.map((Y)=>`x${Y+1}`).join(", ")||"empty","}"]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"grid grid-cols-4 gap-3",children:$.map((Y,K)=>{let G=vv(F,Y.bits);return f.jsxDEV("div",{className:`p-3 rounded-lg text-center transition-all ${G===1?"bg-matrix-positive text-white":"bg-matrix-negative text-white"}`,children:[f.jsxDEV("div",{className:"font-mono text-xs",children:Y.label},void 0,!1,void 0,this),f.jsxDEV("div",{className:"text-lg font-bold",children:G===1?"+1":"-1"},void 0,!1,void 0,this)]},K,!0,void 0,this)})},void 0,!1,void 0,this),f.jsxDEV("div",{className:"text-center primer-text text-sm text-stone-600 max-w-md",children:"The parity character measures whether an even or odd number of bits in S are set to 1. Notice how adjacent vertices always have opposite signs when S contains all coordinates!"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)}function gv(){let[F,_]=CF.useState(2),$=CF.useCallback((Y)=>{if(Y===1)return[[0,1],[1,0]];let K=$(Y-1),G=K.length,U=Array(G*2).fill(null).map(()=>Array(G*2).fill(0));for(let z=0;z<G;z++)for(let h=0;h<G;h++)U[z][h]=K[z][h];for(let z=0;z<G;z++)U[z][G+z]=1;for(let z=0;z<G;z++)U[G+z][z]=1;for(let z=0;z<G;z++)for(let h=0;h<G;h++)U[G+z][G+h]=-K[z][h];return U},[]),W=CF.useMemo(()=>$(F),[F,$]),H=Math.sqrt(F).toFixed(2);return f.jsxDEV("div",{className:"flex flex-col items-center gap-6",children:[f.jsxDEV("div",{className:"flex gap-4 items-center",children:[f.jsxDEV("span",{className:"primer-text",children:"Dimension n:"},void 0,!1,void 0,this),[1,2,3].map((Y)=>f.jsxDEV("button",{onClick:()=>_(Y),className:`w-10 h-10 rounded-full font-mono transition-all ${F===Y?"bg-primer-gold text-white":"bg-stone-200 text-stone-600 hover:bg-stone-300"}`,children:Y},Y,!1,void 0,this))]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"overflow-x-auto",children:f.jsxDEV("div",{className:"grid gap-1 p-4 bg-stone-100 rounded-lg",style:{gridTemplateColumns:`repeat(${W.length}, minmax(2rem, 1fr))`},children:W.flatMap((Y,K)=>Y.map((G,U)=>f.jsxDEV("div",{className:`w-8 h-8 flex items-center justify-center text-sm font-mono rounded ${G>0?"bg-matrix-positive text-white":G<0?"bg-matrix-negative text-white":"bg-matrix-zero text-stone-400"}`,children:G>0?"+":G<0?"-":"0"},`${K}-${U}`,!1,void 0,this)))},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-4 rounded-lg text-center max-w-md",children:[f.jsxDEV("p",{className:"primer-text font-semibold mb-2",children:"Key Properties:"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"text-left primer-text text-sm space-y-1",children:[f.jsxDEV("li",{children:["Matrix size: ",W.length," x ",W.length]},void 0,!0,void 0,this),f.jsxDEV("li",{children:["Eigenvalues: exactly ",f.jsxDEV(YF,{children:`\\pm\\sqrt{${F}} = \\pm${H}`},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("li",{children:["Each eigenvalue has multiplicity ",W.length/2]},void 0,!0,void 0,this),f.jsxDEV("li",{children:"The nonzero pattern matches the hypercube adjacency!"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)}function uv(){let F=CF.useMemo(()=>dQ(3),[]),_=(U)=>U.filter((z)=>z).length>=2?1:0,$=(U)=>{return U.filter((h)=>h).length%2===0?1:-1},W=(U)=>{return(_(U)===1?-1:1)*$(U)},H=F.filter((U)=>W(U.bits)===1),Y=F.filter((U)=>W(U.bits)===-1),K=H.length>Y.length?"S+":"S-";return f.jsxDEV("div",{className:"flex flex-col items-center gap-6",children:[f.jsxDEV(yY,{n:3,colorFunction:(U)=>{return W(U)===1?L1.cubePositive:L1.cubeNegative}},void 0,!1,void 0,this),f.jsxDEV("div",{className:"flex gap-8",children:[f.jsxDEV("div",{className:"text-center",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"S+ (g = +1)"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"flex flex-wrap gap-2 justify-center max-w-32",children:H.map((U,z)=>f.jsxDEV("div",{className:"bg-cube-positive text-white px-2 py-1 rounded font-mono text-sm",children:U.label},z,!1,void 0,this))},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mt-2 font-bold",children:["|S+| = ",H.length]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"text-center",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"S- (g = -1)"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"flex flex-wrap gap-2 justify-center max-w-32",children:Y.map((U,z)=>f.jsxDEV("div",{className:"bg-cube-negative text-white px-2 py-1 rounded font-mono text-sm",children:U.label},z,!1,void 0,this))},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mt-2 font-bold",children:["|S-| = ",Y.length]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-4 rounded-lg text-center max-w-lg",children:[f.jsxDEV("p",{className:"primer-text",children:["Since ",H.length," + ",Y.length," = ",F.length," = 2^3, and they're unequal..."]},void 0,!0,void 0,this),f.jsxDEV("p",{className:"text-xl font-bold text-primer-accent mt-2",children:["|",K,"| = ",Math.max(H.length,Y.length)," ",">"," 2^",2," = 4"]},void 0,!0,void 0,this),f.jsxDEV("p",{className:"text-sm text-stone-600 mt-2",children:"This large level set is where the spectral bound applies!"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)}function pv(){let F=[{label:"\\sqrt{n}",desc:"Lower bound on eigenvalue",color:L1.cubePositive},{label:"\\lambda_{\\max}(A[S])",desc:"Largest eigenvalue of submatrix",color:L1.primerGold},{label:"\\text{maxDeg}(G[S])",desc:"Max degree in induced graph",color:L1.cubeVertex},{label:"s(f)",desc:"Sensitivity of f",color:L1.primerAccent}];return f.jsxDEV("div",{className:"flex flex-col items-center gap-6",children:[f.jsxDEV("div",{className:"flex items-center gap-2 flex-wrap justify-center",children:F.map((_,$)=>f.jsxDEV(CF.default.Fragment,{children:[f.jsxDEV("div",{className:"p-4 rounded-lg text-center text-white min-w-28",style:{backgroundColor:_.color},children:[f.jsxDEV("div",{className:"font-bold text-lg",children:f.jsxDEV(YF,{children:_.label},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("div",{className:"text-xs mt-1 opacity-90",children:_.desc},void 0,!1,void 0,this)]},void 0,!0,void 0,this),$<F.length-1&&f.jsxDEV("div",{className:"text-2xl font-bold text-stone-400",children:f.jsxDEV(YF,{children:"\\leq"},void 0,!1,void 0,this)},void 0,!1,void 0,this)]},$,!0,void 0,this))},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg max-w-2xl",children:[f.jsxDEV("p",{className:"primer-text text-center",children:"This chain of inequalities is the heart of the proof:"},void 0,!1,void 0,this),f.jsxDEV("ol",{className:"list-decimal list-inside mt-4 space-y-2 primer-text",children:[f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"Interlacing:"},void 0,!1,void 0,this)," A large submatrix inherits a large eigenvalue"]},void 0,!0,void 0,this),f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"Row-sum bound:"},void 0,!1,void 0,this)," Eigenvalues are bounded by graph degrees"]},void 0,!0,void 0,this),f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"Level set property:"},void 0,!1,void 0,this)," Induced degrees equal sensitivity counts"]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)}function mv(){let F=[{id:"degree",label:"degree(f) = n",x:200,y:50,color:L1.cubeVertex},{id:"fourier",label:"f([n])  0",x:200,y:120,color:L1.cubeVertex},{id:"gtransform",label:"g  0",x:200,y:190,color:L1.cubeEdge},{id:"levelset",label:"|S| > 2^(n-1)",x:200,y:260,color:L1.cubeEdge},{id:"spectral",label:"  n",x:100,y:330,color:L1.cubePositive},{id:"graph",label:"maxDeg  n",x:300,y:330,color:L1.cubePositive},{id:"sensitivity",label:"s(f)  n",x:200,y:400,color:L1.cubeActive}],_=[{from:"degree",to:"fourier"},{from:"fourier",to:"gtransform"},{from:"gtransform",to:"levelset"},{from:"levelset",to:"spectral"},{from:"levelset",to:"graph"},{from:"spectral",to:"sensitivity"},{from:"graph",to:"sensitivity"}],$=Object.fromEntries(F.map((W)=>[W.id,W]));return f.jsxDEV("div",{className:"flex justify-center",children:f.jsxDEV("svg",{viewBox:"0 0 400 460",className:"w-full max-w-md",children:[_.map((W,H)=>{let Y=$[W.from],K=$[W.to];return f.jsxDEV("line",{x1:Y.x,y1:Y.y+15,x2:K.x,y2:K.y-15,stroke:"#999",strokeWidth:2,markerEnd:"url(#arrowhead)"},H,!1,void 0,this)}),f.jsxDEV("defs",{children:f.jsxDEV("marker",{id:"arrowhead",markerWidth:"10",markerHeight:"7",refX:"9",refY:"3.5",orient:"auto",children:f.jsxDEV("polygon",{points:"0 0, 10 3.5, 0 7",fill:"#999"},void 0,!1,void 0,this)},void 0,!1,void 0,this)},void 0,!1,void 0,this),F.map((W)=>f.jsxDEV("g",{children:[f.jsxDEV("rect",{x:W.x-70,y:W.y-15,width:140,height:30,rx:6,fill:W.color},void 0,!1,void 0,this),f.jsxDEV("text",{x:W.x,y:W.y+4,textAnchor:"middle",fill:"white",fontSize:"12",fontFamily:"Georgia, serif",fontWeight:"bold",children:W.label},void 0,!1,void 0,this)]},W.id,!0,void 0,this))]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function lv(){return f.jsxDEV(Eq,{title:"The Sensitivity Conjecture",subtitle:"An Illustrated Primer",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("div",{className:"primer-border p-8 bg-white rounded-lg",children:[f.jsxDEV("p",{className:"text-center text-xl italic",children:'"For any Boolean function f on n bits,"'},void 0,!1,void 0,this),f.jsxDEV("div",{className:"text-center my-4",children:f.jsxDEV(YF,{display:!0,children:"s(f) \\geq \\sqrt{\\deg(f)}"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-center text-sm text-stone-500",children:" Hao Huang, 2019"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("p",{children:["Imagine a machine with ",f.jsxDEV("em",{children:"n"},void 0,!1,void 0,this)," on/off switches. Each combination of switch positions produces an output: either ON or OFF. This is a ",f.jsxDEV("strong",{children:"Boolean function"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this),f.jsxDEV("p",{children:"Two questions arise naturally:"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"grid md:grid-cols-2 gap-6 my-8",children:[f.jsxDEV("div",{className:"bg-cube-positive/10 p-6 rounded-lg border-l-4 border-cube-positive",children:[f.jsxDEV("h3",{className:"primer-heading text-lg mb-2",children:"Sensitivity"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm",children:'At the most "fragile" switch setting, how many single switches can change the output when flipped?'},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-cube-vertex/10 p-6 rounded-lg border-l-4 border-cube-vertex",children:[f.jsxDEV("h3",{className:"primer-heading text-lg mb-2",children:"Degree"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm",children:'What is the largest group of switches that ever "interact together" in determining the output?'},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("p",{children:"For decades, mathematicians suspected these measures were tightly linked. In 2019, Hao Huang proved it with an elegant spectral argument. This primer will guide you through the proof, step by step, following the Lean formalization."},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"The Final Theorem in Lean"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`theorem sensitivity_conjecture {n : Nat} (f : (Fin n -> Bool) -> Bool) :
  (sensitivity f : Real) >= Real.sqrt (degree f) := by
  -- pick S with f_hat(S) != 0
  -- restrict to get full degree on S
  -- apply full-degree theorem
  -- use sensitivity monotonicity
  ...`},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm mt-4",children:"We'll explore each piece of this proof, understanding what the Lean code formalizes and why each step works."},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"What You'll Learn"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"space-y-2",children:[f.jsxDEV("li",{children:"The hypercube as a graph  where inputs live"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"Sensitivity  measuring local instability"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"Fourier analysis  decomposing functions into parity patterns"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"The g-transform  creating an imbalanced coloring"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"Huang's matrix  a spectral gadget with clean eigenvalues"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"Interlacing  connecting eigenvalues to graph degrees"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"The final assembly  putting it all together"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function dv(){let[F,_]=CF.useState(null),$=CF.useMemo(()=>dQ(3),[]);return f.jsxDEV(Eq,{title:"The Boolean Hypercube",subtitle:"Where inputs live",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("p",{children:["An ",f.jsxDEV("em",{children:"n"},void 0,!1,void 0,this),"-bit string is just a sequence of 0s and 1s, like"," ",f.jsxDEV("span",{className:"primer-code",children:"010"},void 0,!1,void 0,this)," or"," ",f.jsxDEV("span",{className:"primer-code",children:"111"},void 0,!1,void 0,this),". The set of all such strings forms the vertices of an ",f.jsxDEV("strong",{children:"n-dimensional hypercube"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"grid md:grid-cols-2 gap-8 my-8",children:[f.jsxDEV("div",{className:"text-center",children:[f.jsxDEV("h4",{className:"primer-heading mb-4",children:"2D Hypercube (n=2)"},void 0,!1,void 0,this),f.jsxDEV(yY,{n:2},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm text-stone-500 mt-2",children:"4 vertices, 4 edges"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"text-center",children:[f.jsxDEV("h4",{className:"primer-heading mb-4",children:"3D Hypercube (n=3)"},void 0,!1,void 0,this),f.jsxDEV(yY,{n:3,highlightNeighbors:!0,selectedVertex:F,onVertexSelect:_},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm text-stone-500 mt-2",children:["8 vertices, 12 edges",F!==null&&f.jsxDEV("span",{className:"block mt-1",children:[f.jsxDEV("span",{className:"primer-code",children:$[F].label},void 0,!1,void 0,this)," has 3 neighbors"]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Neighbors"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["Two vertices are ",f.jsxDEV("strong",{children:"neighbors"},void 0,!1,void 0,this)," if they differ in exactly one bit. In the graph above, this means they're connected by an edge."]},void 0,!0,void 0,this),f.jsxDEV("p",{className:"mt-3",children:["For example, ",f.jsxDEV("span",{className:"primer-code",children:"000"},void 0,!1,void 0,this)," and"," ",f.jsxDEV("span",{className:"primer-code",children:"001"},void 0,!1,void 0,this)," are neighbors (differ only in the last bit), but ",f.jsxDEV("span",{className:"primer-code",children:"000"},void 0,!1,void 0,this)," and"," ",f.jsxDEV("span",{className:"primer-code",children:"011"},void 0,!1,void 0,this)," are not (differ in two bits)."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: The Boolean Cube"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mb-4",children:["The Lean formalization represents n-bit strings as functions from ",f.jsxDEV("code",{children:"Fin n"},void 0,!1,void 0,this),"to ",f.jsxDEV("code",{children:"Bool"},void 0,!1,void 0,this),". Two inputs are neighbors when they differ in exactly one coordinate:"]},void 0,!0,void 0,this),f.jsxDEV(S6,{title:"BC1: Neighbor definition",children:`-- Two inputs are neighbors if they differ in exactly one bit
def are_neighbors {n : Nat} (x y : Fin n -> Bool) : Prop :=
  (Finset.filter (fun i => x i != y i) Finset.univ).card = 1`},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Key Insight"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["Every vertex in the n-dimensional hypercube has exactly ",f.jsxDEV("strong",{children:"n neighbors"},void 0,!1,void 0,this),". This is because you can flip any one of the n bits to get a neighbor."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function iv(){return f.jsxDEV(Eq,{title:"Sensitivity",subtitle:"Measuring fragility",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("p",{children:["Given a Boolean function f, the ",f.jsxDEV("strong",{children:"sensitivity at input x"},void 0,!1,void 0,this)," counts how many single-bit changes flip the output. In formal notation:"]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border text-center",children:f.jsxDEV(YF,{display:!0,children:"\\text{local\\_sensitivity}(f, x) = |\\{ y : x \\sim y \\text{ and } f(x) \\neq f(y) \\}|"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("p",{children:["The ",f.jsxDEV("strong",{children:"global sensitivity"},void 0,!1,void 0,this)," ",f.jsxDEV(YF,{children:"s(f)"},void 0,!1,void 0,this)," is the maximum over all inputs:"]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-accent text-white p-6 rounded-lg text-center",children:f.jsxDEV(YF,{display:!0,children:"s(f) = \\max_x \\text{local\\_sensitivity}(f, x)"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Sensitivity Definition (SEN0)"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mb-4",children:"The Lean formalization defines sensitivity by filtering all inputs y that differ from x in exactly one coordinate, and also flip the output:"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`def sensitivity {n : Nat} (f : (Fin n -> Bool) -> Bool) : Nat :=
  Finset.sup Finset.univ (fun x =>
    Finset.card (Finset.filter (fun y =>
      (Finset.card (Finset.filter (fun i => x i != y i) Finset.univ) = 1)
      && (f x != f y)
    ) Finset.univ))`},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm mt-4",children:"Read it as: for each x, count all y at Hamming distance 1 with f(x)  f(y), then take the maximum."},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("h3",{className:"primer-heading text-2xl mt-12 mb-6",children:"Interactive Demo"},void 0,!1,void 0,this),f.jsxDEV(jv,{},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Graph Perspective"},void 0,!1,void 0,this),f.jsxDEV("p",{children:'Think of the Boolean function as coloring each vertex of the hypercube green (output 1) or red (output 0). Sensitivity counts how many edges cross from green to red at the "worst" vertex.'},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Quick Examples"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"space-y-3",children:[f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"Parity function:"},void 0,!1,void 0,this)," f(x) = XOR of all n bits. Flipping any one bit changes parity, so every input has local sensitivity n. Therefore ",f.jsxDEV(YF,{children:"s(f) = n"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this),f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"First bit function:"},void 0,!1,void 0,this)," f(x) = x. Only flipping the first bit changes the value, so local sensitivity is always 1, and ",f.jsxDEV(YF,{children:"s(f) = 1"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function nv(){return f.jsxDEV(Eq,{title:"Fourier Analysis",subtitle:"Decomposing into parity patterns",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("p",{children:["Just as sound can be decomposed into pure frequencies, Boolean functions can be decomposed into ",f.jsxDEV("strong",{children:"parity characters"},void 0,!1,void 0,this),'. These are the basic "waves" in the Fourier analysis of Boolean functions.']},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:["The Parity Character ",f.jsxDEV(YF,{children:"\\chi_S"},void 0,!1,void 0,this)," (CHI0)"]},void 0,!0,void 0,this),f.jsxDEV("p",{children:["For a subset S of coordinates, the character ",f.jsxDEV(YF,{children:"\\chi_S"},void 0,!1,void 0,this)," outputs +1 if an"," ",f.jsxDEV("strong",{children:"even"},void 0,!1,void 0,this)," number of bits in S are 1, and -1 if ",f.jsxDEV("strong",{children:"odd"},void 0,!1,void 0,this),":"]},void 0,!0,void 0,this),f.jsxDEV(YF,{display:!0,children:"\\chi_S(x) = (-1)^{|S \\cap x|}"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Parity Character"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean (CHI0)",children:`def chi {n : } (S : Finset (Fin n)) (x : Fin n  Bool) :  :=
  if (Finset.filter (fun i => x i) S).card % 2 = 0 then 1 else -1`},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm mt-4",children:"Read this as: filter S to the indices where x is true, count them, and check whether the count is even. Even  1, odd  -1."},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("h3",{className:"primer-heading text-2xl mt-12 mb-6",children:["Interactive: Explore ",f.jsxDEV(YF,{children:"\\chi_S"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV(xv,{},void 0,!1,void 0,this),f.jsxDEV("div",{className:"mt-12 space-y-6",children:[f.jsxDEV("h4",{className:"primer-heading text-xl",children:"Fourier Coefficients & Degree"},void 0,!1,void 0,this),f.jsxDEV("p",{children:"Every Boolean function can be written as a weighted sum of parity characters:"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-4 rounded-lg text-center",children:f.jsxDEV(YF,{display:!0,children:"f(x) = \\sum_S \\hat{f}(S) \\cdot \\chi_S(x)"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("p",{children:["The ",f.jsxDEV("strong",{children:"Fourier coefficient"},void 0,!1,void 0,this)," ",f.jsxDEV(YF,{children:"\\hat{f}(S)"},void 0,!1,void 0,this)," measures how much f correlates with the parity pattern ",f.jsxDEV(YF,{children:"\\chi_S"},void 0,!1,void 0,this),":"]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border",children:f.jsxDEV(YF,{display:!0,children:"\\hat{f}(S) = \\frac{1}{2^n} \\sum_{x \\in \\{0,1\\}^n} f(x) \\cdot \\chi_S(x)"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Fourier Coefficient (FOURIER0)"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`noncomputable def fourier_coeff {n : Nat}
    (f : (Fin n -> Bool) -> Bool) (S : Finset (Fin n)) : Real :=
  (Finset.sum Finset.univ (fun x =>
    (if f x then 1 else 0) * chi S x)) / 2^n`},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-accent text-white p-6 rounded-lg",children:[f.jsxDEV("h5",{className:"font-bold mb-2",children:"Degree of f (DEG0)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["The ",f.jsxDEV("strong",{children:"degree"},void 0,!1,void 0,this)," of f is the largest |S| such that ",f.jsxDEV(YF,{children:"\\hat{f}(S) \\neq 0"},void 0,!1,void 0,this),'. It measures the largest group of bits that "interact together" in f.']},void 0,!0,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`noncomputable def degree {n : } (f : (Fin n  Bool)  Bool) :  :=
  Finset.sup (Finset.filter (fun S => fourier_coeff f S  0) Finset.univ) Finset.card`},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Key Fact for the Proof (FULLCOEF)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["If degree(f) = n, then ",f.jsxDEV(YF,{children:"\\hat{f}([n]) \\neq 0"},void 0,!1,void 0,this),'  the coefficient on the "full parity" pattern is nonzero. This will be crucial in the next step.']},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function cv(){return f.jsxDEV(Eq,{title:"The g-Transform",subtitle:"Creating imbalance",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("p",{children:"Now comes a clever trick. We define a new function g by twisting f with the full parity character:"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border text-center",children:f.jsxDEV(YF,{display:!0,children:"g(x) = \\begin{cases} -1 & \\text{if } f(x) = 1 \\\\ +1 & \\text{if } f(x) = 0 \\end{cases} \\cdot \\chi_{[n]}(x)"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("p",{children:"The function g only takes values +1 and -1. Here's the magic:"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-primer-accent text-white p-6 rounded-lg",children:[f.jsxDEV("p",{className:"font-bold text-lg mb-2",children:"If degree(f) = n, then the sum of g over all vertices is nonzero."},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm opacity-90",children:["This follows from ",f.jsxDEV(YF,{children:"\\hat{f}([n]) \\neq 0"},void 0,!1,void 0,this)," and the orthogonality of Fourier characters."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: The g-Transform (GVAL0)"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`def g_val {n : Nat} (f : (Fin n -> Bool) -> Bool) (x : Fin n -> Bool) : Real :=
  (if f x then -1 else 1) * chi Finset.univ x

lemma g_val_sum_ne_zero {n : Nat} (f : (Fin n -> Bool) -> Bool)
  (h_deg : degree f = n) (hn : n != 0) :
  Finset.sum Finset.univ (g_val f) != 0 := by
  ...`},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm mt-4",children:"The key insight: since g(x) = 1 always, and the sum is nonzero, one sign must appear more often than the other!"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("h3",{className:"primer-heading text-2xl mt-12 mb-6",children:"Level Sets (LEVELSETS)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:"Since g takes only values +1 and -1, we can partition all vertices into two sets:"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mb-6",children:f.jsxDEV("div",{className:"grid md:grid-cols-2 gap-4",children:[f.jsxDEV("div",{children:f.jsxDEV(YF,{display:!0,children:"S^+ = \\{ x : g(x) = +1 \\}"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("div",{children:f.jsxDEV(YF,{display:!0,children:"S^- = \\{ x : g(x) = -1 \\}"},void 0,!1,void 0,this)},void 0,!1,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this),f.jsxDEV(uv,{},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Level Sets"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean (LEVELSETS)",children:`def S_pos {n : Nat} (f : (Fin n -> Bool) -> Bool) : Finset (Fin n -> Bool) :=
  Finset.filter (fun x => g_val f x = 1) Finset.univ

def S_neg {n : Nat} (f : (Fin n -> Bool) -> Bool) : Finset (Fin n -> Bool) :=
  Finset.filter (fun x => g_val f x = -1) Finset.univ

lemma exists_large_level_set {n : Nat} (f : (Fin n -> Bool) -> Bool)
  (h_deg : degree f = n) (hn : n != 0) :
  (S_pos f).card > 2^(n-1) or (S_neg f).card > 2^(n-1) := by
  -- Use sum g_val != 0 to show |S_pos| != |S_neg|,
  -- then use |S_pos| + |S_neg| = 2^n.
  ...`},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"The Parity Flip Property (NEIGH_PARITY)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["Along any edge of the hypercube (neighbors differing in one bit), the parity",f.jsxDEV(YF,{children:"\\chi_{[n]}"},void 0,!1,void 0,this)," flips sign. This leads to a remarkable equivalence:"]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-4 rounded mt-4",children:f.jsxDEV(YF,{display:!0,children:"\\text{For neighbors } x \\sim y: \\quad g(x) = g(y) \\iff f(x) \\neq f(y)"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mt-4 text-sm",children:["In words: within a level set, neighbors in the ",f.jsxDEV("em",{children:"graph"},void 0,!1,void 0,this)," are exactly the neighbors where ",f.jsxDEV("em",{children:"f flips"},void 0,!1,void 0,this),". So the induced degree equals the sensitivity count!"]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function sv(){return f.jsxDEV(Eq,{title:"Huang's Matrix",subtitle:"The spectral gadget",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("p",{children:["Hao Huang's key insight was to construct a special matrix ",f.jsxDEV(YF,{children:"A_n"},void 0,!1,void 0,this)," related to the hypercube. Its eigenvalues are perfectly balanced: exactly ",f.jsxDEV(YF,{children:"+\\sqrt{n}"},void 0,!1,void 0,this)," and ",f.jsxDEV(YF,{children:"-\\sqrt{n}"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Recursive Definition (HUANG_DEF)"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mb-4",children:[f.jsxDEV(YF,{children:"A_1"},void 0,!1,void 0,this)," is the 22 matrix with 0s on the diagonal and 1s off-diagonal. For n+1, we build ",f.jsxDEV(YF,{children:"A_{n+1}"},void 0,!1,void 0,this)," in blocks:"]},void 0,!0,void 0,this),f.jsxDEV(YF,{display:!0,children:"A_{n+1} = \\begin{pmatrix} A_n & I_{2^n} \\\\ I_{2^n} & -A_n \\end{pmatrix}"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm text-stone-600 mt-4",children:"The minus sign in the bottom-right is the magic ingredient that makes the spectrum clean!"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Huang Matrix"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean (HUANG_DEF)",children:`def huang_matrix (n : Nat) : Matrix (Fin n -> Bool) (Fin n -> Bool) Real :=
  match n with
  | 0 => 0
  | n + 1 =>
      Matrix.reindex (finSuccEquiv_huang_custom n).symm
                     (finSuccEquiv_huang_custom n).symm
        (Matrix.fromBlocks (huang_matrix n) 1 1 (-huang_matrix n))`},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm mt-4",children:["The ",f.jsxDEV("code",{children:"reindex"},void 0,!1,void 0,this)," handles bookkeeping so the block matrix is indexed by actual (n+1)-bit strings."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("h3",{className:"primer-heading text-2xl mt-12 mb-6",children:"Explore the Matrix"},void 0,!1,void 0,this),f.jsxDEV(gv,{},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"The Spectrum (HUANG_SPEC)"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mb-4",children:["The eigenvalues of ",f.jsxDEV(YF,{children:"A_n"},void 0,!1,void 0,this)," are exactly ",f.jsxDEV(YF,{children:"\\pm\\sqrt{n}"},void 0,!1,void 0,this),", each with multiplicity ",f.jsxDEV(YF,{children:"2^{n-1}"},void 0,!1,void 0,this),". Why?"]},void 0,!0,void 0,this),f.jsxDEV("ol",{className:"list-decimal list-inside space-y-2",children:[f.jsxDEV("li",{children:[f.jsxDEV(YF,{children:"A_n^2 = nI"},void 0,!1,void 0,this),", so eigenvalues satisfy ",f.jsxDEV(YF,{children:"\\lambda^2 = n"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("li",{children:[f.jsxDEV(YF,{children:"\\text{trace}(A_n) = 0"},void 0,!1,void 0,this),", so the sum of eigenvalues is zero"]},void 0,!0,void 0,this),f.jsxDEV("li",{children:["Matrix size is ",f.jsxDEV(YF,{children:"2^n"},void 0,!1,void 0,this),", so half are positive, half negative"]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Spectrum Theorem"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean (HUANG_SPEC)",children:`theorem huang_eigenvalues_eq_list (n : Nat) (hn : n != 0) :
  let evs := sorted_eigenvalues (huang_matrix_fin n) (huang_matrix_fin_isSymm n)
  evs = List.replicate (2^(n-1)) (-Real.sqrt n) ++
        List.replicate (2^(n-1)) (Real.sqrt n) := by
  ...`},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Why This Matrix Matters"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"space-y-2",children:[f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"Clean spectrum:"},void 0,!1,void 0,this)," Eigenvalues are exactly ",f.jsxDEV(YF,{children:"\\pm\\sqrt{n}"},void 0,!1,void 0,this),", making spectral bounds easy to compute."]},void 0,!0,void 0,this),f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"Matches hypercube:"},void 0,!1,void 0,this)," The nonzero pattern (ignoring signs) is exactly the adjacency matrix of the hypercube graph."]},void 0,!0,void 0,this),f.jsxDEV("li",{children:[f.jsxDEV("strong",{children:"Interlacing applies:"},void 0,!1,void 0,this)," Large principal submatrices inherit large eigenvalues."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function ov(){return f.jsxDEV(Eq,{title:"Spectral Bounds",subtitle:"Connecting eigenvalues to degrees",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("p",{children:"The final steps use two spectral principles to create a chain of inequalities."},void 0,!1,void 0,this),f.jsxDEV("div",{className:"grid md:grid-cols-2 gap-6 my-8",children:[f.jsxDEV("div",{className:"bg-cube-positive/10 p-6 rounded-lg border-l-4 border-cube-positive",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-2",children:"Interlacing (INTERLACE)"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm",children:["If S has more than half the vertices, then the largest eigenvalue of the submatrix ",f.jsxDEV(YF,{children:"A_n[S]"},void 0,!1,void 0,this)," is at least ",f.jsxDEV(YF,{children:"\\sqrt{n}"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this),f.jsxDEV(YF,{display:!0,children:"\\lambda_{\\max}(A_n[S]) \\geq \\sqrt{n}"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-cube-vertex/10 p-6 rounded-lg border-l-4 border-cube-vertex",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-2",children:"Row-Sum Bound (SPEC_UPPER)"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm",children:"The largest eigenvalue is bounded by the maximum row sum, which corresponds to the maximum degree in the induced graph."},void 0,!1,void 0,this),f.jsxDEV(YF,{display:!0,children:"\\lambda_{\\max}(A_n[S]) \\leq \\text{maxDeg}(G[S])"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Interlacing Lower Bound (HUANG_SUB_LOWER)"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`/- The largest eigenvalue of a principal submatrix of size m
   is at least the m-th smallest eigenvalue of the original matrix. -/
lemma eigenvalue_interlacing_max ... :
  lambda_max(A[S]) >= lambda_{m-1}(A)`},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm mt-4",children:["Combined with HUANG_SPEC: if |S| > 2^(n-1), then ",f.jsxDEV(YF,{children:"\\lambda_{\\max}(A_n[S]) \\geq \\sqrt{n}"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: Spectral Upper Bound (SPEC_UPPER)"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`theorem spectral_radius_bound {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm)
  (G : SimpleGraph (Fin n))
  (h_adj :  i j, |A i j|  if G.Adj i j then 1 else 0) (hn : n  0) :
  let evs := sorted_eigenvalues A hA
  let lambda_max := evs.getLast ...
  lambda_max  G.maxDegree := by ...`},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("h3",{className:"primer-heading text-2xl mt-12 mb-6",children:"The Chain of Inequalities"},void 0,!1,void 0,this),f.jsxDEV(pv,{},void 0,!1,void 0,this),f.jsxDEV("div",{className:"bg-primer-accent text-white p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"font-bold text-lg mb-3",children:"Connecting to Sensitivity (DEG_SENS_LEVEL)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:"The induced graph degree equals the sensitivity count (from the g-transform parity flip property). So maxDeg(G[S])  sensitivity(f), completing the chain!"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`lemma induced_degree_le_sensitivity {n : Nat} (f : (Fin n -> Bool) -> Bool)
  (S : Finset (Fin n -> Bool)) (hS : is_level_set_of_g f S) :
  (induced_hypercube_graph S).maxDegree <= sensitivity f := by
  -- For vertex x in S, neighbors in S are exactly where f flips
  ...`},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function av(){return f.jsxDEV(Eq,{title:"The Complete Proof",subtitle:"Putting it all together",children:f.jsxDEV("div",{className:"space-y-8",children:[f.jsxDEV("p",{children:"Let's trace the full proof for the case where degree(f) = n, following the Lean formalization."},void 0,!1,void 0,this),f.jsxDEV(mv,{},void 0,!1,void 0,this),f.jsxDEV("div",{className:"space-y-6 mt-12",children:[f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Step 1: Full Degree  Nonzero Top Coefficient (FULLCOEF)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["If degree(f) = n, then ",f.jsxDEV(YF,{children:"\\hat{f}([n]) \\neq 0"},void 0,!1,void 0,this),". The function has a nonzero correlation with the full parity pattern."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Step 2: g-Transform Has Nonzero Sum (GVAL0)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["Define ",f.jsxDEV(YF,{children:"g(x) = (f(x) \\,?\\, {-1} : {+1}) \\cdot \\chi_{[n]}(x)"},void 0,!1,void 0,this),". By Fourier orthogonality, the sum of g over all vertices is nonzero."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Step 3: Large Level Set (LEVELSETS)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["Since ",f.jsxDEV(YF,{children:"g \\in \\{+1, -1\\}"},void 0,!1,void 0,this)," and the sum is nonzero, one level set S has size ",f.jsxDEV(YF,{children:"> 2^{n-1}"},void 0,!1,void 0,this),"."]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Step 4: Spectral Sandwich"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"mb-2",children:["Apply interlacing (HUANG_SUB_LOWER): ",f.jsxDEV(YF,{children:"\\lambda_{\\max}(A_n[S]) \\geq \\sqrt{n}"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("p",{className:"mb-2",children:["Apply row-sum bound (SPEC_UPPER): ",f.jsxDEV(YF,{children:"\\lambda_{\\max}(A_n[S]) \\leq \\text{maxDeg}(G[S])"},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("p",{children:["Therefore: ",f.jsxDEV(YF,{children:"\\text{maxDeg}(G[S]) \\geq \\sqrt{n}"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-stone-100 p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Step 5: Degree = Sensitivity (DEG_SENS_LEVEL)"},void 0,!1,void 0,this),f.jsxDEV("p",{children:["By the parity flip property, the induced degree in S equals the sensitivity count. So: ",f.jsxDEV(YF,{children:"s(f) \\geq \\text{maxDeg}(G[S]) \\geq \\sqrt{n}"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"In Lean: The Full-Degree Theorem (FULLCASE)"},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean",children:`theorem sensitivity_ge_sqrt_degree_of_degree_eq_n {n : Nat}
  (f : (Fin n -> Bool) -> Bool) (h_deg : degree f = n) (hn : n != 0) :
  (sensitivity f : Real) >= Real.sqrt n := by
  -- 1. Get large level set S from LEVELSETS
  -- 2. Apply HUANG_SUB_LOWER: lambda_max >= sqrt(n)
  -- 3. Apply SPEC_UPPER: lambda_max <= maxDegree(G[S])
  -- 4. Apply DEG_SENS_LEVEL: maxDegree(G[S]) <= sensitivity(f)
  ...`},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-accent text-white p-8 rounded-lg mt-12 text-center",children:[f.jsxDEV("h4",{className:"text-2xl font-bold mb-4",children:"The General Case (REDUCE)"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-lg mb-4",children:"For arbitrary degree k = degree(f), we restrict f to a k-dimensional subcube where it has full degree, apply FULLCASE, and note that sensitivity can only decrease under restriction (SENS_MONO)."},void 0,!1,void 0,this),f.jsxDEV(S6,{title:"sensitivity.lean (REDUCE  GOAL)",children:`theorem sensitivity_conjecture {n : Nat} (f : (Fin n -> Bool) -> Bool) :
  (sensitivity f : Real) >= Real.sqrt (degree f) := by
  -- 1. Pick S with max |S| and f_hat(S) != 0 (DEG_WITNESS)
  -- 2. Find restriction with top coefficient != 0 (EXIST_TOP)
  -- 3. Apply full-degree theorem (FULLCASE)
  -- 4. Lift via sensitivity_restriction_le (SENS_MONO)
  ...`},void 0,!1,void 0,this),f.jsxDEV("div",{className:"mt-6",children:f.jsxDEV(YF,{display:!0,children:"\\therefore\\; s(f) \\geq \\sqrt{\\deg(f)} \\quad \\blacksquare"},void 0,!1,void 0,this)},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-white p-6 rounded-lg primer-border mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"Historical Note"},void 0,!1,void 0,this),f.jsxDEV("p",{children:"The Sensitivity Conjecture was open for nearly 30 years before Huang's 2019 proof. The key insight  using a signed version of the adjacency matrix  reduced a combinatorial problem to a clean spectral argument. The proof is now a masterclass in the power of choosing the right representation."},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"bg-primer-gold-light p-6 rounded-lg mt-8",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-3",children:"The Lean Formalization"},void 0,!1,void 0,this),f.jsxDEV("p",{children:"This primer follows the structure of the Lean formalization, which provides machine-checked verification of every step. The key atoms in the proof DAG:"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"mt-4 space-y-1 text-sm font-mono",children:[f.jsxDEV("li",{children:"BC0-BC4: Boolean cube definitions"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"SEN0: Sensitivity definition"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"CHI0: Parity characters"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"FOURIER0, DEG0: Fourier coefficients and degree"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"GVAL0, LEVELSETS: g-transform and level sets"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"HUANG_DEF, HUANG_SPEC: Huang matrix and spectrum"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"INTERLACE, SPEC_UPPER: Spectral bounds"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"FULLCASE: Full-degree theorem"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"REDUCE: Restriction argument"},void 0,!1,void 0,this),f.jsxDEV("li",{children:"GOAL: Final theorem"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function rv(F){let _=[],$=["def","theorem","lemma","by","match","with","if","then","else","let","have","exact","intro","intros","rfl","simp","aesop","cases","induction","apply","refine","constructor","obtain","fun","where","noncomputable","section","end","open","import","set_option","namespace","classical","ext","conv","rw","unfold","generalize_proofs"],W=["Nat","","Bool","Prop","Type","Type*","","Real","Matrix","Finset","Fin","List","Set","Equiv","Module","Submodule","SimpleGraph","OrthonormalBasis","EuclideanSpace"],H=["simp_all","norm_num","positivity","grind","tauto","ring","field_simp","linarith","decide","assumption"],Y=0;while(Y<F.length){if(F.slice(Y,Y+2)==="/-"){let K=F.indexOf("-/",Y+2);if(K===-1)K=F.length;else K+=2;_.push({type:"comment",content:F.slice(Y,K)}),Y=K;continue}if(F.slice(Y,Y+2)==="--"){let K=F.indexOf(`
`,Y);if(K===-1)K=F.length;_.push({type:"comment",content:F.slice(Y,K)}),Y=K;continue}if(F[Y]==='"'){let K=Y+1;while(K<F.length&&F[K]!=='"'){if(F[K]==="\\")K++;K++}_.push({type:"string",content:F.slice(Y,K+1)}),Y=K+1;continue}if(/\d/.test(F[Y])){let K=Y;while(K<F.length&&/[\d.]/.test(F[K]))K++;_.push({type:"number",content:F.slice(Y,K)}),Y=K;continue}if("+-*/^=<>".includes(F[Y])){_.push({type:"operator",content:F[Y]}),Y++;continue}if("()[]{}:;,.".includes(F[Y])){_.push({type:"punctuation",content:F[Y]}),Y++;continue}if(/[a-zA-Z_--']/.test(F[Y])){let K=Y;while(K<F.length&&/[a-zA-Z0-9_--'-]/.test(F[K]))K++;let G=F.slice(Y,K);if($.includes(G))_.push({type:"keyword",content:G});else if(W.includes(G))_.push({type:"type",content:G});else if(H.includes(G))_.push({type:"tactic",content:G});else _.push({type:"text",content:G});Y=K;continue}_.push({type:"text",content:F[Y]}),Y++}return _}var I9=[{id:"imports",title:"Imports & Setup",description:"The Harmonic tactic infrastructure and Lean setup, including imports, options, and classical reasoning.",sectionNumber:1,lineStart:0,lineEnd:233},{id:"sensitivity-def",title:"Sensitivity Definition",description:"The formal definition of sensitivity: the maximum number of single-bit flips that can change the output.",sectionNumber:2,lineStart:234,lineEnd:239},{id:"chi-def",title:"Parity Character ",description:"The parity character _S(x) = (-1)^|{i  S : x_i = 1}|  the building block for Fourier analysis.",sectionNumber:3,lineStart:240,lineEnd:245},{id:"fourier-degree",title:"Fourier Coefficients & Degree",description:"The Fourier coefficient f(S) and degree  measuring the 'complexity' of a Boolean function.",sectionNumber:4,lineStart:246,lineEnd:254},{id:"equivalences",title:"Index Equivalences",description:"Type equivalences for reindexing the hypercube, enabling the block matrix construction.",sectionNumber:5,lineStart:255,lineEnd:287},{id:"huang-matrix",title:"Huang Matrix Definition",description:"The Huang matrix A_n defined recursively with block structure [A_{n-1}, I; I, -A_{n-1}].",sectionNumber:6,lineStart:288,lineEnd:296},{id:"huang-matrix-sq",title:"A = nI",description:"The key algebraic property: the Huang matrix squared equals n times the identity.",sectionNumber:7,lineStart:297,lineEnd:314},{id:"eigenvalues",title:"Eigenvalue Characterization",description:"Since A = nI, every eigenvalue  satisfies  = n, so eigenvalues are n.",sectionNumber:8,lineStart:315,lineEnd:330},{id:"sorted-eigenvalues",title:"Sorted Eigenvalues Infrastructure",description:"Infrastructure for working with sorted eigenvalues and the interlacing property.",sectionNumber:9,lineStart:331,lineEnd:377},{id:"spectral-theory",title:"Min-Max Eigenvalue Theory",description:"The Courant-Fischer min-max characterization of eigenvalues and Rayleigh quotients.",sectionNumber:10,lineStart:378,lineEnd:528},{id:"g-expectation",title:"g-Transform Expectation",description:"The expectation of g = f  _{[n]} is nonzero when f has full degree.",sectionNumber:11,lineStart:529,lineEnd:541},{id:"huang-fin",title:"Reindexed Huang Matrix",description:"Reindexing the Huang matrix to Fin(2^n) for compatibility with matrix theory.",sectionNumber:12,lineStart:542,lineEnd:598},{id:"spectrum-theorem",title:"Complete Spectrum",description:"The full spectrum: 2^{n-1} copies each of -n and +n.",sectionNumber:13,lineStart:599,lineEnd:819},{id:"adjacency",title:"Adjacency & Row Sum Bounds",description:"The absolute value of the Huang matrix is the hypercube adjacency matrix; eigenvalue bounds from row sums.",sectionNumber:14,lineStart:820,lineEnd:907},{id:"spectral-bound",title:"Spectral Radius Bound",description:"The spectral radius is bounded by the maximum degree of the underlying graph.",sectionNumber:15,lineStart:908,lineEnd:935},{id:"rayleigh",title:"Rayleigh Quotient & Courant-Fischer",description:"The Rayleigh quotient R_A(x) = x,Ax/x,x and variational characterization of eigenvalues.",sectionNumber:16,lineStart:936,lineEnd:1274},{id:"interlacing",title:"Eigenvalue Interlacing",description:"Principal submatrices inherit eigenvalues via the interlacing theorem  key for the proof!",sectionNumber:17,lineStart:1275,lineEnd:1353},{id:"huang-submatrix",title:"Huang Submatrix Eigenvalue Bound",description:"Large submatrices (> 2^{n-1}) of the Huang matrix have max eigenvalue  n.",sectionNumber:18,lineStart:1354,lineEnd:1384},{id:"g-value",title:"g-Value and Level Sets",description:"The g-transform g(x) = f(x)_{[n]}(x) and level sets S, S where g = 1.",sectionNumber:19,lineStart:1385,lineEnd:1439},{id:"level-sets",title:"Large Level Set Existence",description:"Since g  0 when f has full degree, one of S or S must have > 2^{n-1} elements.",sectionNumber:20,lineStart:1440,lineEnd:1462},{id:"hypercube-graph",title:"Hypercube Graph & Properties",description:"The hypercube graph Q_n and its connection to the Huang matrix and sensitivity.",sectionNumber:21,lineStart:1463,lineEnd:1803},{id:"restriction",title:"Restriction to Subcubes",description:"Restricting a Boolean function to a subcube by fixing some coordinates.",sectionNumber:22,lineStart:1804,lineEnd:1851},{id:"sensitivity-mono",title:"Sensitivity Monotonicity",description:"Sensitivity cannot increase under restriction: s(f)  s(f|_S).",sectionNumber:23,lineStart:1852,lineEnd:1901},{id:"conjecture",title:"The Sensitivity Conjecture",description:"The final theorem: s(f)  deg(f) for all Boolean functions f.",sectionNumber:24,lineStart:1902,lineEnd:1935}],tv=`import Mathlib

import Mathlib.Tactic.GeneralizeProofs

namespace Harmonic.GeneralizeProofs
-- Harmonic \`generalize_proofs\` tactic

open Lean Meta Elab Parser.Tactic Elab.Tactic Mathlib.Tactic.GeneralizeProofs
def mkLambdaFVarsUsedOnly' (fvars : Array Expr) (e : Expr) : MetaM (Array Expr  Expr) := do
  let mut e := e
  let mut fvars' : List Expr := []
  for i' in [0:fvars.size] do
    let fvar := fvars[fvars.size - i' - 1]!
    e  mkLambdaFVars #[fvar] e (usedOnly := false) (usedLetOnly := false)
    match e with
    | .letE _ _ v b _ => e := b.instantiate1 v
    | .lam _ _ _b _ => fvars' := fvar :: fvars'
    | _ => unreachable!
  return (fvars'.toArray, e)

partial def abstractProofs' (e : Expr) (ty? : Option Expr) : MAbs Expr := do
  if ( read).depth  ( read).config.maxDepth then MAbs.withRecurse <| visit ( instantiateMVars e) ty?
  else return e
where
  visit (e : Expr) (ty? : Option Expr) : MAbs Expr := do
    if ( read).config.debug then
      if let some ty := ty? then
        unless  isDefEq ( inferType e) ty do
          throwError "visit: type of{indentD e}
is not{indentD ty}"
    if e.isAtomic then
      return e
    else
      checkCache (e, ty?) fun _  do
        if  isProof e then
          visitProof e ty?
        else
          match e with
          | .forallE n t b i =>
            withLocalDecl n i ( visit t none) fun x  MAbs.withLocal x do
              mkForallFVars #[x] ( visit (b.instantiate1 x) none) (usedOnly := false) (usedLetOnly := false)
          | .lam n t b i => do
            withLocalDecl n i ( visit t none) fun x  MAbs.withLocal x do
              let ty'? 
                if let some ty := ty? then
                  let .forallE _ _ tyB _  pure ty
                    | throwError "Expecting forall in abstractProofs .lam"
                  pure <| some <| tyB.instantiate1 x
                else
                  pure none
              mkLambdaFVars #[x] ( visit (b.instantiate1 x) ty'?) (usedOnly := false) (usedLetOnly := false)
          | .letE n t v b _ =>
            let t'  visit t none
            withLetDecl n t' ( visit v t') fun x  MAbs.withLocal x do
              mkLetFVars #[x] ( visit (b.instantiate1 x) ty?) (usedLetOnly := false)
          | .app .. =>
            e.withApp fun f args  do
              let f'  visit f none
              let argTys  appArgExpectedTypes f' args ty?
              let mut args' := #[]
              for arg in args, argTy in argTys do
                args' := args'.push <|  visit arg argTy
              return mkAppN f' args'
          | .mdata _ b  => return e.updateMData! ( visit b ty?)
          | .proj _ _ b => return e.updateProj! ( visit b none)
          | _           => unreachable!
  visitProof (e : Expr) (ty? : Option Expr) : MAbs Expr := do
    let eOrig := e
    let fvars := ( read).fvars
    let e := e.withApp' fun f args => f.beta args
    if e.withApp' fun f args => f.isAtomic && args.all fvars.contains then return e
    let e 
      if let some ty := ty? then
        if ( read).config.debug then
          unless  isDefEq ty ( inferType e) do
            throwError m!"visitProof: incorrectly propagated type{indentD ty}
for{indentD e}"
        mkExpectedTypeHint e ty
      else pure e
    if ( read).config.debug then
      unless  Lean.MetavarContext.isWellFormed ( getLCtx) e do
        throwError m!"visitProof: proof{indentD e}
is not well-formed in the current context
          fvars: {fvars}"
    let (fvars', pf)  mkLambdaFVarsUsedOnly' fvars e
    if !( read).config.abstract && !fvars'.isEmpty then
      return eOrig
    if ( read).config.debug then
      unless  Lean.MetavarContext.isWellFormed ( read).initLCtx pf do
        throwError m!"visitProof: proof{indentD pf}
is not well-formed in the initial context
          fvars: {fvars}
{( mkFreshExprMVar none).mvarId!}"
    let pfTy  instantiateMVars ( inferType pf)
    let pfTy  abstractProofs' pfTy none
    if let some pf'  MAbs.findProof? pfTy then
      return mkAppN pf' fvars'
    MAbs.insertProof pfTy pf
    return mkAppN pf fvars'
partial def withGeneralizedProofs' { : Type} [Inhabited ] (e : Expr) (ty? : Option Expr)
    (k : Array Expr  Array Expr  Expr  MGen ) :
    MGen  := do
  let propToFVar := ( get).propToFVar
  let (e, generalizations)  MGen.runMAbs <| abstractProofs' e ty?
  let rec
    go [Inhabited ] (i : Nat) (fvars pfs : Array Expr)
        (proofToFVar propToFVar : ExprMap Expr) : MGen  := do
      if h : i < generalizations.size then
        let (ty, pf) := generalizations[i]
        let ty := ( instantiateMVars (ty.replace proofToFVar.get?)).cleanupAnnotations
        withLocalDeclD ( mkFreshUserName \`pf) ty fun fvar => do
          go (i + 1) (fvars := fvars.push fvar) (pfs := pfs.push pf)
            (proofToFVar := proofToFVar.insert pf fvar)
            (propToFVar := propToFVar.insert ty fvar)
      else
        withNewLocalInstances fvars 0 do
          let e' := e.replace proofToFVar.get?
          modify fun s => { s with propToFVar }
          k fvars pfs e'
  go 0 #[] #[] (proofToFVar := {}) (propToFVar := propToFVar)

partial def generalizeProofsCore'
    (g : MVarId) (fvars rfvars : Array FVarId) (target : Bool) :
    MGen (Array Expr  MVarId) := go g 0 #[]
where
  go (g : MVarId) (i : Nat) (hs : Array Expr) : MGen (Array Expr  MVarId) := g.withContext do
    let tag  g.getTag
    if h : i < rfvars.size then
      let fvar := rfvars[i]
      if fvars.contains fvar then
        let tgt  instantiateMVars <|  g.getType
        let ty := (if tgt.isLet then tgt.letType! else tgt.bindingDomain!).cleanupAnnotations
        if  pure tgt.isLet <&&> Meta.isProp ty then
          let tgt' := Expr.forallE tgt.letName! ty tgt.letBody! .default
          let g'  mkFreshExprSyntheticOpaqueMVar tgt' tag
          g.assign <| .app g' tgt.letValue!
          return  go g'.mvarId! i hs
        if let some pf := ( get).propToFVar.get? ty then
          let tgt' := tgt.bindingBody!.instantiate1 pf
          let g'  mkFreshExprSyntheticOpaqueMVar tgt' tag
          g.assign <| .lam tgt.bindingName! tgt.bindingDomain! g' tgt.bindingInfo!
          return  go g'.mvarId! (i + 1) hs
        match tgt with
        | .forallE n t b bi =>
          let prop  Meta.isProp t
          withGeneralizedProofs' t none fun hs' pfs' t' => do
            let t' := t'.cleanupAnnotations
            let tgt' := Expr.forallE n t' b bi
            let g'  mkFreshExprSyntheticOpaqueMVar tgt' tag
            g.assign <| mkAppN ( mkLambdaFVars hs' g' (usedOnly := false) (usedLetOnly := false)) pfs'
            let (fvar', g')  g'.mvarId!.intro1P
            g'.withContext do Elab.pushInfoLeaf <|
              .ofFVarAliasInfo { id := fvar', baseId := fvar, userName :=  fvar'.getUserName }
            if prop then
              MGen.insertFVar t' (.fvar fvar')
            go g' (i + 1) (hs ++ hs')
        | .letE n t v b _ =>
          withGeneralizedProofs' t none fun hs' pfs' t' => do
            withGeneralizedProofs' v t' fun hs'' pfs'' v' => do
              let tgt' := Expr.letE n t' v' b false
              let g'  mkFreshExprSyntheticOpaqueMVar tgt' tag
              g.assign <| mkAppN ( mkLambdaFVars (hs' ++ hs'') g' (usedOnly := false) (usedLetOnly := false)) (pfs' ++ pfs'')
              let (fvar', g')  g'.mvarId!.intro1P
              g'.withContext do Elab.pushInfoLeaf <|
                .ofFVarAliasInfo { id := fvar', baseId := fvar, userName :=  fvar'.getUserName }
              go g' (i + 1) (hs ++ hs' ++ hs'')
        | _ => unreachable!
      else
        let (fvar', g')  g.intro1P
        g'.withContext do Elab.pushInfoLeaf <|
          .ofFVarAliasInfo { id := fvar', baseId := fvar, userName :=  fvar'.getUserName }
        go g' (i + 1) hs
    else if target then
      withGeneralizedProofs' ( g.getType) none fun hs' pfs' ty' => do
        let g'  mkFreshExprSyntheticOpaqueMVar ty' tag
        g.assign <| mkAppN ( mkLambdaFVars hs' g' (usedOnly := false) (usedLetOnly := false)) pfs'
        return (hs ++ hs', g'.mvarId!)
    else
      return (hs, g)

end GeneralizeProofs

open Lean Elab Parser.Tactic Elab.Tactic Mathlib.Tactic.GeneralizeProofs
partial def generalizeProofs'
    (g : MVarId) (fvars : Array FVarId) (target : Bool) (config : Config := {}) :
    MetaM (Array Expr  MVarId) := do
  let (rfvars, g)  g.revert fvars (clearAuxDeclsInsteadOfRevert := true)
  g.withContext do
    let s := { propToFVar :=  initialPropToFVar }
    GeneralizeProofs.generalizeProofsCore' g fvars rfvars target |>.run config |>.run' s

elab (name := generalizeProofsElab'') "generalize_proofs" config?:(Parser.Tactic.config)?
    hs:(ppSpace colGt binderIdent)* loc?:(location)? : tactic => withMainContext do
  let config  elabConfig (mkOptionalNode config?)
  let (fvars, target) 
    match expandOptLocation (Lean.mkOptionalNode loc?) with
    | .wildcard => pure (( getLCtx).getFVarIds, true)
    | .targets t target => pure ( getFVarIds t, target)
  liftMetaTactic1 fun g => do
    let (pfs, g)  generalizeProofs' g fvars target config
    g.withContext do
      let mut lctx  getLCtx
      for h in hs, fvar in pfs do
        if let \`(binderIdent| $s:ident) := h then
          lctx := lctx.setUserName fvar.fvarId! s.getId
        Expr.addLocalVarInfoForBinderIdent fvar h
      Meta.withLCtx lctx ( Meta.getLocalInstances) do
        let g'  Meta.mkFreshExprSyntheticOpaqueMVar ( g.getType) ( g.getTag)
        g.assign g'
        return g'.mvarId!

end Harmonic

set_option linter.mathlibStandardSet false

open scoped BigOperators

open scoped Real

open scoped Nat

open scoped Classical

open scoped Pointwise

set_option maxHeartbeats 0

set_option maxRecDepth 4000

set_option synthInstance.maxHeartbeats 20000

set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false

set_option autoImplicit false

noncomputable section

/-
The sensitivity of a boolean function f is the maximum over all inputs x of the number of neighbors y of x such that f(x)  f(y).
-/
def sensitivity {n : } (f : (Fin n  Bool)  Bool) :  :=
  Finset.sup Finset.univ (fun x => Finset.card (Finset.filter (fun y => (Finset.card (Finset.filter (fun i => x i  y i) Finset.univ) = 1)  f x  f y) Finset.univ))

/-
chi_S(x) is (-1)^(x cdot S), which is 1 if the number of indices in S where x is true is even, and -1 otherwise.
-/
def chi {n : } (S : Finset (Fin n)) (x : Fin n  Bool) :  :=
  if (Finset.filter (fun i => x i) S).card % 2 = 0 then 1 else -1

/-
The Fourier coefficient f_hat(S) is the expectation of f(x) * chi_S(x). The degree of f is the size of the largest set S such that f_hat(S) is non-zero.
-/
noncomputable def fourier_coeff {n : } (f : (Fin n  Bool)  Bool) (S : Finset (Fin n)) :  :=
  (Finset.sum Finset.univ (fun x => (if f x then 1 else 0) * chi S x)) / 2^n

noncomputable def degree {n : } (f : (Fin n  Bool)  Bool) :  :=
  Finset.sup (Finset.filter (fun S => fourier_coeff f S  0) Finset.univ) Finset.card

/-
Equivalence between Bool x alpha and alpha + alpha.
-/
def boolProdEquivSum_custom { : Type*} : Bool       where
  toFun := fun p => if p.1 then Sum.inr p.2 else Sum.inl p.2
  invFun := fun s => match s with
    | Sum.inl a => (false, a)
    | Sum.inr a => (true, a)
  left_inv := by
    rintro  _ | _, _  <;> simp +decide
  right_inv := by
    rintro (a | a) <;> rfl

/-
Equivalence between functions from Fin (n+1) to alpha and pairs of (alpha, function from Fin n to alpha).
-/
def finSuccEquiv_custom (n : ) ( : Type*) : (Fin (n + 1)  )    (Fin n  ) where
  toFun f := (f 0, f  Fin.succ)
  invFun p := Fin.cons p.1 p.2
  left_inv f := by
    ext i
    refine Fin.cases ?_ ?_ i <;> simp
  right_inv p := by
    ext <;> simp

/-
Equivalence between functions from Fin (n+1) to Bool and the sum of two copies of functions from Fin n to Bool.
-/
def finSuccEquiv_huang_custom (n : ) : (Fin (n + 1)  Bool)  (Fin n  Bool)  (Fin n  Bool) :=
  Equiv.trans
    (finSuccEquiv_custom n Bool)
    (boolProdEquivSum_custom)

/-
The Huang matrix A_n is defined recursively. A_0 is 0. A_{n+1} is a block matrix with A_n on the diagonal, I on the off-diagonal, and -A_n on the other diagonal, reindexed to match the boolean hypercube indices.
-/
def huang_matrix (n : ) : Matrix (Fin n  Bool) (Fin n  Bool)  :=
  match n with
  | 0 => 0
  | n + 1 => Matrix.reindex (finSuccEquiv_huang_custom n).symm (finSuccEquiv_huang_custom n).symm
      (Matrix.fromBlocks (huang_matrix n) (1 : Matrix _ _ ) (1 : Matrix _ _ ) (-huang_matrix n))

/-
The square of the Huang matrix A_n is n times the identity matrix.
-/
theorem huang_matrix_sq (n : ) : (huang_matrix n) ^ 2 = (n : )  (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) := by
  induction' n with n ih;
   norm_num [ sq ];
    exact mul_eq_zero_of_left rfl (huang_matrix 0)
   -- By definition of huang_matrix, we have:
    have h_def : huang_matrix (n + 1) = Matrix.reindex (finSuccEquiv_huang_custom n).symm (finSuccEquiv_huang_custom n).symm (Matrix.fromBlocks (huang_matrix n) (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) (-huang_matrix n)) := by
      rfl;
    -- By definition of matrix multiplication and the induction hypothesis, we can expand the square of the block matrix.
    have h_expand : (Matrix.fromBlocks (huang_matrix n) (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) (-huang_matrix n)) ^ 2 = Matrix.fromBlocks ((n + 1 : )  1) 0 0 ((n + 1 : )  1) := by
      simp_all +decide [ sq, Matrix.fromBlocks_multiply ];
      norm_num [ add_smul, add_comm ];
    simp_all +decide [ sq, Matrix.reindex_apply ];
    ext i j; simp +decide [ Matrix.submatrix, Matrix.smul_eq_diagonal_mul ] ;
    by_cases hij : i = j <;> simp +decide [ hij, Matrix.one_apply ]

/-
The eigenvalues of the Huang matrix square to n.
-/
theorem huang_matrix_eigenvalues {n : } { : } (h : Module.End.HasEigenvalue (Matrix.toLin' (huang_matrix n)) ) :  ^ 2 = n := by
  obtain  v, hv  := h.exists_hasEigenvector;
  -- Since $A^2 = nI$, we have $A^2 v = n v$.
  have h_sq : (Matrix.toLin' (huang_matrix n)) (Matrix.toLin' (huang_matrix n) v) = (n : )  v := by
    convert congr_arg ( fun x : Matrix ( Fin n  Bool ) ( Fin n  Bool )  => x.mulVec v ) <| huang_matrix_sq n using 1;
     simp +decide [ sq ];
     simp +decide [ Matrix.smul_eq_diagonal_mul ];
  -- Since $v$ is an eigenvector of $A$, we have $A v = mu v$.
  have h_eigen : (Matrix.toLin' (huang_matrix n)) v =   v := by
    cases hv ; aesop;
  simp_all +decide [ sq ];
  exact smul_left_injective _ hv.2 <| by simpa [ mul_assoc, smul_smul ] using h_sq;

/-
The sorted list of eigenvalues of a real matrix, defined as the sorted roots of its characteristic polynomial.
-/
noncomputable def sorted_eigenvalues_list {n : } (A : Matrix (Fin n) (Fin n) ) : List  :=
  (A.charpoly.roots).sort (  )

/-
A predicate asserting that list M interlaces list L.
-/
def interlacing (L M : List ) : Prop :=
  L.length = M.length + 1 
   i : Fin M.length, L[i]!  M[i]!  M[i]!  L[i.1 + 1]!

/-
A real matrix is symmetric if and only if it is Hermitian.
-/
theorem isSymm_iff_isHermitian_real {n : Type*} [Fintype n] (A : Matrix n n ) :
  A.IsSymm  A.IsHermitian := by
  rw [Matrix.IsSymm, Matrix.IsHermitian, Matrix.conjTranspose, Matrix.transpose]
  simp
  rfl

/-
The sorted eigenvalues of a symmetric matrix.
-/
noncomputable def sorted_eigenvalues {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) : List  :=
  let hA' : A.IsHermitian := (isSymm_iff_isHermitian_real A).mp hA
  (List.ofFn (hA'.eigenvalues)).mergeSort (  )

/-
The number of sorted eigenvalues is n.
-/
theorem sorted_eigenvalues_length {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
  (sorted_eigenvalues A hA).length = n := by
    unfold sorted_eigenvalues; aesop;

/-
For a symmetric matrix A, <Ax, y> = <x, Ay>.
-/
theorem dotProduct_mulVec_symm {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) (x y : Fin n  ) :
  dotProduct (A.mulVec x) y = dotProduct x (A.mulVec y) := by
    simp +decide [ Matrix.mulVec, dotProduct, mul_comm ];
    simp +decide only [Finset.mul_sum _ _ _, mul_left_comm, mul_comm];
    rw [ Finset.sum_comm ];
    conv_rhs => rw [  hA ] ;
    rfl

/-
The max-min value for the k-th eigenvalue.
-/
def min_max_eigenvalue {n : } (A : Matrix (Fin n) (Fin n) ) (k : ) :  :=
   (C : Submodule  (Fin n  )) (_ : Module.finrank  C = k + 1),
     (x : {x : C // dotProduct (x : Fin n  ) (x : Fin n  ) = 1}),
      dotProduct (A.mulVec (x : Fin n  )) (x : Fin n  )

/-
The sorted eigenvalues are a permutation of the eigenvalues.
-/
lemma sorted_eigenvalues_is_perm {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
    : Equiv.Perm (Fin n),  (i : Fin n),
    (sorted_eigenvalues A hA).get i, by rw [sorted_eigenvalues_length]; exact i.2 =
    Matrix.IsHermitian.eigenvalues ((isSymm_iff_isHermitian_real A).mp hA) ( i) := by
      classical
      -- Since L and M are permutations, there is a permutation of indices matching their entries.
      have h_perm :  (L M : List ), List.Perm L M 
            : Fin L.length  Fin M.length,  i : Fin L.length, L.get i = M.get ( i) := by
        intro L M h_perm
        induction h_perm with
        | nil =>
            refine Equiv.refl _, ?_
            intro i
            exact (Fin.elim0 i)
        | cons a h_perm ih =>
            rename_i L' M'
            obtain , h := ih
            let f : Fin (L'.length + 1)  Fin (M'.length + 1) :=
              fun i => Fin.cases 0, by simp (fun i => Fin.succ ( i)) i
            have hf_inj : Function.Injective f := by
              intro i j hij
              cases i using Fin.cases with
              | zero =>
                  cases j using Fin.cases with
                  | zero => rfl
                  | succ j =>
                      simp [f] at hij
                      exact (Fin.succ_ne_zero _ (Eq.symm hij)).elim
              | succ i =>
                  cases j using Fin.cases with
                  | zero =>
                      simp [f] at hij
                      -- goal is closed by simp
                  | succ j =>
                      simp [f] at hij
                      exact congrArg Fin.succ hij
            have hf_surj : Function.Surjective f := by
              intro j
              cases j using Fin.cases with
              | zero =>
                  refine 0, by simp, ?_
                  simp [f]
              | succ j =>
                  refine Fin.succ (.symm j), ?_
                  simp [f]
            let ' : Fin (L'.length + 1)  Fin (M'.length + 1) :=
              Equiv.ofBijective f hf_inj, hf_surj
            refine ', ?_
            intro i
            cases i using Fin.cases with
            | zero =>
                simp [', f]
            | succ i =>
                simpa [', f, List.get_cons_succ'] using h i
        | swap a b l =>
            refine Equiv.swap 0, by simp 1, by simp, ?_
            intro i
            refine Fin.cases ?h0 ?hs i
            
              simp
             intro i
              refine Fin.cases ?h1 ?hrest i
              
                simp
               intro j
                have hne0 : (Fin.succ (Fin.succ j) : Fin (l.length + 2))  0 := by
                  exact Fin.succ_ne_zero _
                have hne1 : (Fin.succ (Fin.succ j) : Fin (l.length + 2))  1 := by
                  exact Fin.succ_succ_ne_one _
                simp [Equiv.swap_apply_of_ne_of_ne hne0 hne1]
        | trans h h ih ih =>
            obtain , h := ih
            obtain , h := ih
            refine .trans , ?_
            intro i
            exact (h i).trans (h ( i))
      generalize_proofs at *
      -- Apply the permutation property to the sorted eigenvalues and the original eigenvalues.
      obtain , h :
            : Fin n  Fin n,
             i : Fin n,
              (sorted_eigenvalues A hA).get i, by rw [sorted_eigenvalues_length]; exact i.2 =
                (Matrix.IsHermitian.eigenvalues (isSymm_iff_isHermitian_real A |>.mp hA)) ( i) := by
        have h_perm_list :
            List.Perm (sorted_eigenvalues A hA)
              (List.ofFn (Matrix.IsHermitian.eigenvalues (isSymm_iff_isHermitian_real A |>.mp hA))) := by
          unfold sorted_eigenvalues
          generalize_proofs at *
          simpa using
            (List.mergeSort_perm
              (List.ofFn (Matrix.IsHermitian.eigenvalues (isSymm_iff_isHermitian_real A |>.mp hA)))
              (  ))
        rcases h_perm _ _ h_perm_list with , h
        let f := Matrix.IsHermitian.eigenvalues (isSymm_iff_isHermitian_real A |>.mp hA)
        have hlenL : (sorted_eigenvalues A hA).length = n := sorted_eigenvalues_length A hA
        have hlenM : (List.ofFn f).length = n := by
          simp
        -- transport  to a permutation on Fin n using the length equalities
        let ' : Fin n  Fin n :=
          (finCongr hlenL.symm).trans (.trans (finCongr hlenM))
        refine ', ?_
        intro i
        let iL : Fin (sorted_eigenvalues A hA).length := finCongr hlenL.symm i
        have hidx :
            (i, by
                simp [sorted_eigenvalues_length] :
              Fin (sorted_eigenvalues A hA).length) = iL := by
          apply Fin.ext
          rfl
        have hi := h iL
        simpa [', iL, hidx, f, List.get_ofFn] using hi
      exact , h

/-
There exists an orthonormal basis of eigenvectors corresponding to the sorted eigenvalues.
-/
lemma exists_orthonormal_basis_sorted {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
   (v : OrthonormalBasis (Fin n)  (EuclideanSpace  (Fin n))),
     i, A.mulVec (v i) = ((sorted_eigenvalues A hA).get i, by rw [sorted_eigenvalues_length]; exact i.2)  (v i) := by
      have h_eigen_decomp :  ( : Equiv.Perm (Fin n)),  i : Fin n, Matrix.IsHermitian.eigenvalues ((isSymm_iff_isHermitian_real A).mp hA) ( i) = (sorted_eigenvalues A hA).get i, by
        rw [ sorted_eigenvalues_length ] ; exact i.2 := by
        have := sorted_eigenvalues_is_perm A hA
        generalize_proofs at *;
        exact  this.choose, fun i => this.choose_spec i  rfl 
      generalize_proofs at *;
      obtain  , h  := h_eigen_decomp
      generalize_proofs at *;
      -- By the properties of the spectral theorem, there exists an orthonormal basis of eigenvectors corresponding to the eigenvalues.
      obtain v, hv :  v : OrthonormalBasis (Fin n)  (EuclideanSpace  (Fin n)),  i : Fin n, A.mulVec (v i) = Matrix.IsHermitian.eigenvalues ((isSymm_iff_isHermitian_real A).mp hA) i  v i := by
        exact  Matrix.IsHermitian.eigenvectorBasis ( by tauto ), fun i => by simpa using Matrix.IsHermitian.mulVec_eigenvectorBasis ( by tauto ) i ;
      refine'  v.reindex .symm, fun i => _  ; aesop

/-
The inner product in EuclideanSpace is the dot product.
-/
lemma inner_eq_dotProduct {n : } (x y : EuclideanSpace  (Fin n)) :
  inner  x y = dotProduct (x : Fin n  ) (y : Fin n  ) := by
    simp +decide [ dotProduct, inner ];
    ac_rfl

/-
$EE(g) 
eq 0$
-/
theorem g_expectation_nonzero {n : } (f : (Fin n  Bool)  Bool) (h_deg : degree f = n) (hn : n  0) :
  let g := fun x => (if f x then 1 else 0) * chi Finset.univ x
  (Finset.sum Finset.univ g)  0 := by
    have h_fourier_coeff :  S : Finset (Fin n), fourier_coeff f S  0  S.card = n := by
      contrapose! h_deg;
      refine' ne_of_lt ( lt_of_le_of_lt ( Finset.sup_le _ ) _ );
      exacts [ n - 1, fun S hS => Nat.le_sub_one_of_lt <| lt_of_le_of_ne ( le_trans ( Finset.card_le_univ _ ) <| by simp ) <| h_deg S <| by simpa using hS, Nat.pred_lt hn ];
    obtain  S, hS, hS  := h_fourier_coeff; simp_all +decide [ fourier_coeff ] ;
    have := Finset.eq_of_subset_of_card_le ( Finset.subset_univ S ) ; aesop;

/-
Equivalence between boolean functions and Fin (2^n).
-/
def boolFunEquivFin (n : ) : (Fin n  Bool)  Fin (2^n) :=
  (Fintype.equivFin (Fin n  Bool)).trans (finCongr (by
  norm_num [ Fintype.card_pi ]))

/-
Reindexing of Huang matrix to Fin (2^n).
-/
noncomputable def huang_matrix_fin (n : ) : Matrix (Fin (2^n)) (Fin (2^n))  :=
  Matrix.reindex (boolFunEquivFin n) (boolFunEquivFin n) (huang_matrix n)

/-
The Huang matrix is symmetric.
-/
theorem huang_matrix_isSymm (n : ) : (huang_matrix n).IsSymm := by
  induction' n with n ih;
   exact rfl
   -- By definition of huang_matrix, we know that huang_matrix (n + 1) is a block matrix with huang_matrix n on the diagonal, I on the off-diagonal, and -huang_matrix n on the other diagonal, reindexed to match the boolean hypercube indices.
    have h_block : huang_matrix (n + 1) = Matrix.reindex (finSuccEquiv_huang_custom n).symm (finSuccEquiv_huang_custom n).symm (Matrix.fromBlocks (huang_matrix n) (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) (1 : Matrix (Fin n  Bool) (Fin n  Bool) ) (-huang_matrix n)) := by
      rfl;
    simp_all +decide [ Matrix.IsSymm ];
    ext i j; simp +decide [ Matrix.fromBlocks_transpose, ih ] ;

/-
The reindexed Huang matrix is symmetric.
-/
theorem huang_matrix_fin_isSymm (n : ) : (huang_matrix_fin n).IsSymm := by
  exact funext fun i => funext fun j => huang_matrix_isSymm n |>.apply _ _

/-
The square of the reindexed Huang matrix is n*I.
-/
theorem huang_matrix_fin_sq (n : ) : (huang_matrix_fin n) ^ 2 = (n : )  (1 : Matrix (Fin (2^n)) (Fin (2^n)) ) := by
  ext i j;
  simp +decide [ huang_matrix_fin, sq ];
  convert congr_fun ( congr_fun ( huang_matrix_sq n ) ( ( boolFunEquivFin n ).symm i ) ) ( ( boolFunEquivFin n ).symm j ) using 1 ; norm_num [ Matrix.mul_apply ];
   rw [ sq, Matrix.mul_apply ];
   simp +decide [ Matrix.one_apply, Matrix.smul_apply ]

/-
The trace of the Huang matrix is 0.
-/
theorem huang_matrix_trace (n : ) : Matrix.trace (huang_matrix n) = 0 := by
  induction n <;> simp_all +decide [ Matrix.trace ];
   rfl;
   rename_i n ih; rw [ show ( huang_matrix ( n + 1 ) ) = Matrix.reindex ( finSuccEquiv_huang_custom n ).symm ( finSuccEquiv_huang_custom n ).symm ( Matrix.fromBlocks ( huang_matrix n ) ( 1 : Matrix _ _  ) ( 1 : Matrix _ _  ) ( -huang_matrix n ) ) by rfl ] ; simp +decide ;
    unfold finSuccEquiv_huang_custom;
    unfold finSuccEquiv_custom boolProdEquivSum_custom; simp +decide [ Matrix.fromBlocks ] ;
    rw [ show ( Finset.univ : Finset ( Fin ( n + 1 )  Bool ) ) = Finset.image ( fun x : Fin n  Bool => Fin.cons true x ) Finset.univ  Finset.image ( fun x : Fin n  Bool => Fin.cons false x ) Finset.univ from ?_, Finset.sum_union ] <;> norm_num [ Finset.sum_image, ih ];
     rw [ neg_add_eq_zero ];
      exact rfl
     norm_num [ Finset.disjoint_left ];
     ext x; simp +decide ;
      exact if h : x 0 then Or.inl  fun i => x i.succ, by ext i; cases i using Fin.inductionOn <;> aesop  else Or.inr  fun i => x i.succ, by ext i; cases i using Fin.inductionOn <;> aesop 

/-
Every eigenvalue of the Huang matrix squares to n.
-/
theorem huang_eigenvalues_sq_eq_n (n : ) (i : Fin (2^n)) :
  ((sorted_eigenvalues (huang_matrix_fin n) (huang_matrix_fin_isSymm n)).get i, by rw [sorted_eigenvalues_length]; exact i.2) ^ 2 = n := by
    -- Apply the fact that the eigenvalues of the Huang matrix square to n.
    have h_eigenvalue :   : , Module.End.HasEigenvalue (Matrix.toLin' (huang_matrix_fin n))    ^ 2 = n := by
      intro  h
      generalize_proofs at *;
      have h_eigenvalue :  ^ 2 = n := by
        have h_sq : (huang_matrix_fin n) ^ 2 = (n : )  (1 : Matrix (Fin (2^n)) (Fin (2^n)) ) := by
          exact huang_matrix_fin_sq n
        have h_eigenvalue :  (v : Fin (2^n)  ), v  0  (huang_matrix_fin n).mulVec v =   v   ^ 2 = n := by
          intros v hv hv
          have h_eigenvalue : (huang_matrix_fin n).mulVec ((huang_matrix_fin n).mulVec v) =  ^ 2  v := by
            rw [ hv, Matrix.mulVec_smul, pow_two, MulAction.mul_smul ];
            rw [ hv ]
          generalize_proofs at *;
          have h_eigenvalue : (huang_matrix_fin n).mulVec ((huang_matrix_fin n).mulVec v) = (n : )  v := by
            simp +decide [  sq, h_sq ];
            simp +decide [ Matrix.smul_eq_diagonal_mul ]
          generalize_proofs at *;
          exact smul_left_injective _ hv <| by aesop;
        generalize_proofs at *;
        obtain  v, hv  := h.exists_hasEigenvector;
        cases hv ; aesop
      generalize_proofs at *;
      exact h_eigenvalue
    generalize_proofs at *;
    -- By definition of sorted_eigenvalues, every element in the list is an eigenvalue of the matrix.
    have h_sorted_eigenvalue :    sorted_eigenvalues (huang_matrix_fin n) _, Module.End.HasEigenvalue (Matrix.toLin' (huang_matrix_fin n))  := by
      unfold sorted_eigenvalues;
      simp_all +decide [ Module.End.HasUnifEigenvalue ];
      intro a; specialize h_eigenvalue ( Matrix.IsHermitian.eigenvalues _ a ) ; simp_all +decide [ Submodule.eq_bot_iff ] ;
      have := Matrix.IsHermitian.eigenvectorBasis _ |> OrthonormalBasis.orthonormal;
      exact  _, Matrix.IsHermitian.mulVec_eigenvectorBasis _ _, this.linearIndependent.ne_zero _ ;
    aesop

/-
The sum of sorted eigenvalues is the trace.
-/
theorem sum_sorted_eigenvalues_eq_trace {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
  (sorted_eigenvalues A hA).sum = A.trace := by
    -- The sum of the eigenvalues of a symmetric matrix is equal to its trace.
    have h_sum_eigenvalues : (List.ofFn (Matrix.IsHermitian.eigenvalues ((isSymm_iff_isHermitian_real A).mp hA))).sum = Matrix.trace A := by
      -- Apply the theorem that states the trace of a matrix is equal to the sum of its eigenvalues.
      have h_trace_eq_sum_eigenvalues : Matrix.trace A =  i : Fin n, (Matrix.IsHermitian.eigenvalues (isSymm_iff_isHermitian_real A |>.mp hA)) i := by
        have := ( isSymm_iff_isHermitian_real A ).mp hA;
        have := this.trace_eq_sum_eigenvalues;
        exact_mod_cast this;
      rw [ h_trace_eq_sum_eigenvalues, List.sum_ofFn ];
    rw [  h_sum_eigenvalues ];
    unfold sorted_eigenvalues;
    rw [ List.Perm.sum_eq ( List.mergeSort_perm _ _ ) ]

/-
If a list contains only c and -c and sums to 0, then the counts are equal.
-/
lemma list_sum_zero_eq_count {c : } (hc : c  0) (L : List )
  (h_mem :  x  L, x = c  x = -c) (h_sum : L.sum = 0) :
  L.count c = L.count (-c) := by
    -- We can split the sum into the sum of the c's and the sum of the -c's.
    have h_split_sum :  x  L.toFinset, x * (L.count x) = c * (L.count c) + (-c) * (L.count (-c)) := by
      field_simp;
      rw [ Finset.sum_eq_add ( c ) ( -c ) ] <;> norm_num;
       ring;
       exact fun h => hc <| by linarith;
       grind;
       exact fun h => Or.inr <| List.count_eq_zero_of_not_mem h;
       exact fun h => Or.inr <| List.count_eq_zero_of_not_mem h;
    have h_split_sum_eq_zero :  x  L.toFinset, x * (L.count x) = L.sum := by
      simp +decide [ Finset.sum_list_count ];
      ac_rfl;
    exact_mod_cast ( mul_left_cancel hc <| by linarith : ( L.count c :  ) = L.count ( -c ) )

/-
A list of -c's followed by c's is sorted if c  0.
-/
lemma sorted_replicate_append_replicate {c : } (hc : 0  c) (m : ) :
  (List.replicate m (-c) ++ List.replicate m c).Sorted (  ) := by
    -- The list is sorted because each element in the first part is -c and each element in the second part is c, and -c  c since c  0.
    simp [List.Sorted];
    rw [ List.pairwise_append ] ; aesop

/-
If a sorted list has m -c's and m c's, it is equal to m -c's followed by m c's.
-/
lemma list_eq_replicate_append_replicate {c : } (hc : 0  c) (L : List ) (m : )
  (h_len : L.length = 2 * m)
  (h_count_neg : L.count (-c) = m)
  (h_count_pos : L.count c = m)
  (h_mem :  x  L, x = c  x = -c)
  (h_sorted : L.Sorted (  )) :
  L = List.replicate m (-c) ++ List.replicate m c := by
    refine' List.eq_of_perm_of_sorted _ h_sorted ( sorted_replicate_append_replicate hc m );
    rw [ List.perm_iff_count ];
    intro a; by_cases ha : a = c <;> by_cases ha' : a = -c <;> simp_all +decide [ List.count_replicate ] ;
     cases m <;> simp_all +decide [ neg_eq_iff_add_eq_zero ];
      rw [ List.eq_replicate_of_mem h_mem ] at h_count_pos ; aesop;
     aesop;
     exact fun h => False.elim <| ha <| by linarith;
     rw [ List.count_eq_zero_of_not_mem fun h => by cases h_mem a h <;> tauto ] ; aesop

/-
If a list contains only c and d, their counts sum to the length.
-/
lemma list_count_add_count_eq_length { : Type*} [DecidableEq ] {c d : } (hcd : c  d) (L : List )
  (h_mem :  x  L, x = c  x = d) :
  L.count c + L.count d = L.length := by
    induction' L with x xs ih;
     rfl;
     cases h_mem x ( by simp +decide ) <;> simp_all +decide [ List.count_cons ];
       linarith;
       grind

/-
Trace is invariant under reindexing.
-/
theorem trace_reindex_eq_trace {n : Type*} [Fintype n] {m : Type*} [Fintype m] [DecidableEq n] [DecidableEq m]
  (e : n  m) (A : Matrix n n ) :
  Matrix.trace (Matrix.reindex e e A) = Matrix.trace A := by
    simp +decide [ Matrix.trace ];
    conv_rhs => rw [  Equiv.sum_comp e.symm ] ;

/-
The trace of the reindexed Huang matrix is 0.
-/
theorem huang_matrix_fin_trace (n : ) : Matrix.trace (huang_matrix_fin n) = 0 := by
  -- The trace of the reindexed matrix is the same as the original matrix, which is 0 by huang_matrix_trace. Hence, we can conclude.
  have h_trace_reindex : Matrix.trace (Matrix.reindex (boolFunEquivFin n) (boolFunEquivFin n) (huang_matrix n)) = Matrix.trace (huang_matrix n) := by
    exact trace_reindex_eq_trace (boolFunEquivFin n) (huang_matrix n)
  exact h_trace_reindex.trans ( huang_matrix_trace n )

/-
sorted_eigenvalues returns a sorted list.
-/
theorem sorted_eigenvalues_sorted {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm) :
  (sorted_eigenvalues A hA).Sorted (  ) := by
    unfold sorted_eigenvalues;
    exact
      List.sorted_mergeSort' (fun x1 x2 => x1  x2)
        (List.ofFn (sorted_eigenvalues._proof_1 A hA).eigenvalues)

/-
Accessing an element in a list of two concatenated replicated lists.
-/
lemma list_replicate_append_replicate_get {n : } {c : } (i : Fin (2 * n)) :
  (List.replicate n (-c) ++ List.replicate n c).get i, by
    simpa [ two_mul ] using i.2 = if i < n then -c else c := by
    aesop

/-
A sorted list of length 2m with elements squaring to c^2 and sum 0 is m -c's then m c's.
-/
lemma sorted_list_of_sq_eq_and_sum_zero {L : List } {c : } {m : } (hc : 0 < c)
  (h_len : L.length = 2 * m)
  (h_sq :  x  L, x^2 = c^2)
  (h_sum : L.sum = 0)
  (h_sorted : L.Sorted (  )) :
  L = List.replicate m (-c) ++ List.replicate m c := by
    -- Since every element in L is either c or -c and their sum is zero, the counts of c and -c must be equal.
    have h_count_eq : L.count c = L.count (-c) := by
      apply_rules [ list_sum_zero_eq_count ];
       positivity;
       exact fun x hx => eq_or_eq_neg_of_sq_eq_sq _ _ <| h_sq x hx;
    -- Since the counts of $c$ and $-c$ are equal and their sum is zero, the number of $c$'s and $-c$'s must be $m$ each.
    have h_count_m : L.count c = m  L.count (-c) = m := by
      have h_count_eq : L.count c + L.count (-c) = 2 * m := by
        rw [  h_len, List.length_eq_countP_add_countP ];
        congr;
        rw [ List.countP_congr ] ; aesop;
        grind;
      grind;
    apply list_eq_replicate_append_replicate hc.le L m h_len;
     exact h_count_m.2;
     exact h_count_m.1;
     exact fun x hx => eq_or_eq_neg_of_sq_eq_sq _ _ <| h_sq x hx;
     assumption

/-
If a list satisfies the properties, its elements are determined.
-/
lemma list_properties_to_values {L : List } {c : } {m : } (hc : 0 < c)
  (h_len : L.length = 2 * m)
  (h_sq :  x  L, x^2 = c^2)
  (h_sum : L.sum = 0)
  (h_sorted : L.Sorted (  ))
  (i : Fin (2 * m)) :
  L.get i, by rw [h_len]; exact i.2 = if (i : ) < m then -c else c := by
    have h_eq_replicate_append_replicate : L = List.replicate m (-c) ++ List.replicate m c := by
      exact sorted_list_of_sq_eq_and_sum_zero hc h_len h_sq h_sum h_sorted
    generalize_proofs at *; aesop;

/-
The sorted eigenvalues of A_{n+1} are 2^n copies of -sqrt(n+1) followed by 2^n copies of sqrt(n+1).
-/
lemma huang_eigenvalues_eq_list_succ (n : ) :
  let evs := sorted_eigenvalues (huang_matrix_fin (n + 1)) (huang_matrix_fin_isSymm (n + 1))
  evs = List.replicate (2^n) (-Real.sqrt (n + 1)) ++ List.replicate (2^n) (Real.sqrt (n + 1)) := by
    generalize_proofs at *;
    apply sorted_list_of_sq_eq_and_sum_zero;
     positivity;
     rw [ sorted_eigenvalues_length ] ; norm_num [ pow_succ' ];
     intro x hx;
      obtain  i, hi  := List.mem_iff_get.mp hx;
      have := huang_eigenvalues_sq_eq_n ( n + 1 )  i, by
        refine' i.2.trans_le _;
        rw [ sorted_eigenvalues_length ] 
      generalize_proofs at *;
      rw [ Real.sq_sqrt <| by positivity ] ; aesop;
     rw [ sum_sorted_eigenvalues_eq_trace, huang_matrix_fin_trace ];
     exact (by
        expose_names
        exact sorted_eigenvalues_sorted (huang_matrix_fin (n + 1)) pf)

/-
The sorted eigenvalues of the Huang matrix.
-/
noncomputable def huang_eigenvalues (n : ) : List  :=
  sorted_eigenvalues (huang_matrix_fin n) (huang_matrix_fin_isSymm n)

/-
The absolute value of the Huang matrix entries is the adjacency matrix of the hypercube.
-/
theorem abs_huang_eq_adjacency (n : ) (i j : Fin n  Bool) :
  |huang_matrix n i j| = if (Finset.filter (fun k => i k  j k) Finset.univ).card = 1 then 1 else 0 := by
    rcases n with ( _ | n );
     aesop;
     -- By induction on $n$, we can show that the absolute value of the entries of the Huang matrix is the adjacency matrix of the hypercube.
      have h_ind :  n : ,  i j : Fin (n + 1)  Bool, |(huang_matrix (n + 1)) i j| = if (Finset.card (Finset.filter (fun k => i k  j k) Finset.univ)) = 1 then 1 else 0 := by
        -- We proceed by induction on $n$.
        intro n
        induction' n with n ih;
         simp +decide [ huang_matrix ];
          intro i j; fin_cases i <;> fin_cases j <;> simp +decide [ finSuccEquiv_huang_custom ] ;
           rfl;
           simp +decide [ boolProdEquivSum_custom, finSuccEquiv_custom ];
            simp +decide [ Matrix.one_apply ];
           simp +decide [ boolProdEquivSum_custom, finSuccEquiv_custom ];
            simp +decide [ Matrix.one_apply ];
           rfl;
         intro i j;
          -- By definition of \`huang_matrix\`, we can split into cases based on whether \`i\` and \`j\` are in the same block or different blocks.
          have h_split :  i j : Fin (n + 2)  Bool, |(huang_matrix (n + 2)) i j| = if (i 0 = j 0) then |(huang_matrix (n + 1)) (fun k => i (Fin.succ k)) (fun k => j (Fin.succ k))| else if (Finset.card (Finset.filter (fun k => i (Fin.succ k)  j (Fin.succ k)) Finset.univ)) = 0 then 1 else 0 := by
            intros i j;
            have h_split :  i j : Fin (n + 2)  Bool, |(huang_matrix (n + 2)) i j| = if (i 0 = j 0) then |(huang_matrix (n + 1)) (fun k => i (Fin.succ k)) (fun k => j (Fin.succ k))| else if (Finset.card (Finset.filter (fun k => i (Fin.succ k)  j (Fin.succ k)) Finset.univ)) = 0 then 1 else 0 := by
              intro i j
              have h_def : huang_matrix (n + 2) = Matrix.reindex (finSuccEquiv_huang_custom (n + 1)).symm (finSuccEquiv_huang_custom (n + 1)).symm (Matrix.fromBlocks (huang_matrix (n + 1)) (1 : Matrix _ _ ) (1 : Matrix _ _ ) (-huang_matrix (n + 1))) := by
                exact rfl
              simp +decide [ h_def, Matrix.fromBlocks ];
              unfold finSuccEquiv_huang_custom;
              unfold finSuccEquiv_custom; simp +decide ;
              unfold boolProdEquivSum_custom; simp +decide ;
              split_ifs <;> simp +decide [ *, Matrix.one_apply ];
              all_goals simp_all +decide [ funext_iff ];
            exact h_split i j;
          rw [ show ( Finset.univ.filter fun k => i k  j k ) = if i 0 = j 0 then Finset.image ( Fin.succ ) ( Finset.univ.filter fun k => i ( Fin.succ k )  j ( Fin.succ k ) ) else Finset.image ( Fin.succ ) ( Finset.univ.filter fun k => i ( Fin.succ k )  j ( Fin.succ k ) )  { 0 } from ?_ ];
           split_ifs <;> simp_all +decide [ Finset.card_image_of_injective, Function.Injective ];
           ext ( _ | k ) <;> simp +decide;
             split_ifs <;> simp +decide [ * ];
             split_ifs <;> simp_all +decide [ Finset.mem_image, Finset.mem_insert ];
               exact  fun h =>   k, by linarith , h, rfl , by rintro  a, ha, ha'  ; cases a ; aesop ;
               exact  fun h =>   k, by linarith , h, rfl , by rintro  a, h, ha  ; cases a ; aesop ;
      exact h_ind n i j

/-
The sorted eigenvalues of the Huang matrix A_n (for n > 0) are 2^(n-1) copies of -sqrt(n) and 2^(n-1) copies of sqrt(n).
-/
theorem huang_eigenvalues_eq_list (n : ) (hn : n  0) :
  let evs := sorted_eigenvalues (huang_matrix_fin n) (huang_matrix_fin_isSymm n)
  evs = List.replicate (2^(n-1)) (-Real.sqrt n) ++ List.replicate (2^(n-1)) (Real.sqrt n) := by
    induction' n with n ih;
     contradiction;
     convert huang_eigenvalues_eq_list_succ n using 1;
      norm_cast

/-
Any eigenvalue of a real matrix is bounded in absolute value by the maximum absolute row sum.
-/
theorem eigenvalue_le_max_row_sum {n : } (A : Matrix (Fin n) (Fin n) ) ( : )
  (h : Module.End.HasEigenvalue (Matrix.toLin' A) ) :
   i : Fin n, ||  Finset.sum Finset.univ (fun j => |A i j|) := by
    -- Let v be a nonzero eigenvector. Let i be the index maximizing |v_i|.
    obtain v, hv :  v : Fin n  , v  0  A.mulVec v =   v := by
      obtain  v, hv  := h.exists_hasEigenvector;
      cases hv ; aesop
    obtain i, hi :  i : Fin n,  j : Fin n, |v j|  |v i| := by
      have := Finset.exists_max_image Finset.univ ( fun i => |v i| )   0, Nat.pos_of_ne_zero ( by aesop_cat ) , Finset.mem_univ _  ; aesop;
    -- Then | v_i| = |(Av)_i| = |sum_j A_ij v_j|  sum_j |A_ij| |v_j|  sum_j |A_ij| |v_i| = |v_i| sum_j |A_ij|.
    have h_bound : | * v i|  |v i| *  j, |A i j| := by
      have h_bound : | * v i| = | j, A i j * v j| := by
        have := congr_fun hv.2 i; simp_all +decide [ Matrix.mulVec, dotProduct ] ;
      rw [ h_bound, Finset.mul_sum _ _ _ ];
      exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun j _ => by rw [ abs_mul, mul_comm ] ; exact mul_le_mul_of_nonneg_right ( hi j ) ( abs_nonneg _ ) );
    exact  i, by
      rw [ abs_mul ] at h_bound
      refine le_of_not_gt ?_
      intro hi'
      have hvipos : 0 < |v i| := by
        apply abs_pos.mpr
        intro hi''
        exact hv.1 <| funext fun j => by simpa [ hi'' ] using hi j
      have hgtmul : || * |v i| > |v i| *  j, |A i j| := by
        nlinarith [hi', hvipos]
      exact (not_le_of_gt hgtmul) h_bound 

/-
Checking Fintype.card_coe
-/
/-
The largest eigenvalue of a symmetric matrix is bounded by the maximum degree of the graph defined by its non-zero entries.
-/
theorem spectral_radius_bound {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm)
  (G : SimpleGraph (Fin n))
  (h_adj :  i j, |A i j|  if G.Adj i j then 1 else 0) (hn : n  0) :
  let evs := sorted_eigenvalues A hA
  let lambda_max := evs.getLast (List.ne_nil_of_length_pos (by rw [sorted_eigenvalues_length A hA]; exact Nat.pos_of_ne_zero hn))
  lambda_max  G.maxDegree := by
    -- Since the largest eigenvalue is bounded by the maximum degree of the graph (from Lemma~\ref{lem:eigenvalue_le_max_row_sum}), we have:
    have h_bound :   : , Module.End.HasEigenvalue (Matrix.toLin' A)     G.maxDegree := by
      intro  h
      obtain i, hi := eigenvalue_le_max_row_sum A  h;
      -- Since $|A i j| leq 1$ if $G.Adj i j$ and $0$ otherwise, we have $sum j, |A i j| leq sum j in G.neighborFinset i, 1$.
      have h_sum_le_neighbor :  j, |A i j|   j  G.neighborFinset i, 1 := by
        exact le_trans ( Finset.sum_le_sum fun _ _ => h_adj _ _ ) ( by simp +decide [ SimpleGraph.neighborFinset_def ] );
      exact le_trans ( le_abs_self  ) ( hi.trans <| h_sum_le_neighbor.trans <| mod_cast by simpa using G.degree_le_maxDegree i );
    have h_sorted :    sorted_eigenvalues A hA,   G.maxDegree := by
      intros  h
      obtain i, hi :  i : Fin n,  = Matrix.IsHermitian.eigenvalues ((isSymm_iff_isHermitian_real A).mp hA) i := by
        unfold sorted_eigenvalues at h; aesop;
      convert h_bound  ?_;
      have := ( Matrix.IsHermitian.eigenvalues_eq hA );
      simp_all +decide [ Module.End.HasUnifEigenvalue ];
      simp_all +decide [ Submodule.eq_bot_iff ];
      exact  _, by simpa [ this ] using Matrix.IsHermitian.mulVec_eigenvectorBasis hA i, by simpa [ this ] using ( Matrix.IsHermitian.eigenvectorBasis hA ).orthonormal.ne_zero i ;
    exact h_sorted _ <| List.getLast_mem _

/-
The Rayleigh quotient of a vector x with respect to a matrix A is <x, Ax> / <x, x>.
-/
def rayleigh_quotient {n : } (A : Matrix (Fin n) (Fin n) ) (x : Fin n  ) :  :=
  dotProduct x (A.mulVec x) / dotProduct x x

/-
The Courant-Fischer Min-Max value (Inf-Sup) for the k-th eigenvalue.
-/
def courant_fischer_inf_sup {n : } (A : Matrix (Fin n) (Fin n) ) (k : Fin n) :  :=
   (V : Submodule  (Fin n  )) (_ : Module.finrank  V = k + 1),
     (x : {x : V // x.1  0}), rayleigh_quotient A x.1

/-
The Rayleigh quotient is invariant under reindexing.
-/
lemma rayleigh_quotient_reindex {n m : } (A : Matrix (Fin n) (Fin n) ) (e : Fin n  Fin m) (x : Fin n  ) :
  rayleigh_quotient A x = rayleigh_quotient (Matrix.reindex e e A) (x  e.symm) := by
    unfold rayleigh_quotient;
    simp +decide [ Matrix.mulVec, dotProduct ];
    simp +decide only [ Equiv.sum_comp e];
    simp +decide

/-
The Rayleigh quotient of a zero-padded vector is equal to the Rayleigh quotient of the original vector with respect to the submatrix.
-/
lemma rayleigh_quotient_submatrix_eq {n : } (A : Matrix (Fin n) (Fin n) ) (S : Finset (Fin n))
  (equiv : {x // x  S}  Fin S.card)
  (y : Fin S.card  ) :
  let x : Fin n   := fun i => if h : i  S then y (equiv i, h) else 0
  rayleigh_quotient A x = rayleigh_quotient (Matrix.reindex equiv equiv (A.submatrix Subtype.val Subtype.val)) y := by
    -- By definition of $x$, we can split the sum into two parts: one over $S$ and one over the complement of $S$.
    simp [rayleigh_quotient];
    congr 1;
     simp +decide [ dotProduct, Matrix.mulVec ];
      -- By reindexing the sums using the equivalence \`equiv\`, we can show that the two expressions are equal.
      have h_reindex :  x : Fin n, (if h : x  S then y (equiv x, h) *  x_1 : Fin n, (if h : x_1  S then A x x_1 * y (equiv x_1, h) else 0) else 0) =  x : S, y (equiv x) *  x_1 : S, A x x_1 * y (equiv x_1) := by
        rw [  Finset.sum_subset ( Finset.subset_univ S ) ];
         rw [  Finset.sum_coe_sort ];
          simp +decide;
          refine' Finset.sum_congr rfl fun x hx => congr_arg _ _;
          rw [  Finset.sum_subset ( Finset.subset_univ S ) ];
           refine' Finset.sum_bij ( fun x hx =>  x, by aesop  ) _ _ _ _ <;> aesop;
           aesop;
         aesop;
      convert h_reindex using 1;
      conv_rhs => rw [  Equiv.sum_comp equiv.symm ] ;
      refine' Finset.sum_congr rfl fun i hi => _;
      rw [  Equiv.sum_comp equiv ] ; aesop;
     simp +decide [ dotProduct ];
      rw [  Finset.sum_subset ( Finset.subset_univ S ) ];
       rw [  Finset.sum_attach ];
        rw [  Equiv.sum_comp equiv ] ; aesop;
       aesop

/-
If a vector lies in the span of the eigenvectors corresponding to eigenvalues $ge alpha_k$, its Rayleigh quotient is at least $alpha_k$.
-/
lemma rayleigh_ge_of_mem_span_top {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm)
  (k : Fin n)
  (v : OrthonormalBasis (Fin n)  (EuclideanSpace  (Fin n)))
  (hv :  i, A.mulVec (v i) = ((sorted_eigenvalues A hA).get i, by rw [sorted_eigenvalues_length]; exact i.isLt)  (v i))
  (x : EuclideanSpace  (Fin n))
  (hx : x  Submodule.span  (Set.range (fun i : {j : Fin n // k  j} => v i)))
  (hx0 : x  0) :
  rayleigh_quotient A x  (sorted_eigenvalues A hA).get k, by rw [sorted_eigenvalues_length]; exact k.isLt := by
    classical
    set ev := sorted_eigenvalues A hA
    have hv' :  i, A.mulVec (v i) = (ev.get i, by simp [ev, sorted_eigenvalues_length])  v i := by
      simpa [ev] using hv
    -- Let $x = sum_{i in K} c_i v_i$ be the decomposition of $x$ in the orthonormal basis $v$.
    obtain c, hc :  c : Fin n  , x =  i : Fin n, c i  v i   i : Fin n, i < k  c i = 0 := by
      -- By definition of submodule span, there exists a finite subset of the basis vectors that spans x.
      obtain c, hc :  c : Fin n  , x =  i : Fin n, c i  v i   i : Fin n, i < k  c i = 0 := by
        have h_span : x  Submodule.span  (Set.range (fun i : Fin n => if i < k then 0 else v i)) := by
          refine' Submodule.span_le.mpr _ hx;
          rintro _  i, rfl  ; by_cases hi : ( i : Fin n ) < k <;> simp +decide;
           exfalso; exact (not_le_of_gt hi) i.2;
           exact Submodule.subset_span  i, by aesop 
        rw [ Finsupp.mem_span_range_iff_exists_finsupp ] at h_span;
        obtain  c, hc  := h_span; use fun i => if i < k then 0 else c i; simp_all +decide [ Finsupp.sum_fintype ] ;
      use c;
    -- Since $v$ is an orthonormal basis, we have $|x|^2 = sum_{i=0}^{n-1} c_i^2$ and $langle x, Ax \rangle = sum_{i=0}^{n-1} c_i^2 lambda_i$.
    have h_norm : dotProduct x x =  i : Fin n, c i ^ 2 := by
      simp +decide [ hc.1, dotProduct, sq ];
      have h_norm :  i j : Fin n, dotProduct (v i) (v j) = if i = j then 1 else 0 := by
        intro i j; specialize hv' i; replace hv' := congr_arg ( fun x => dotProduct x ( v j ) ) hv'; simp_all +decide [ Matrix.mulVec, dotProduct ] ;
        have := v.orthonormal; simp_all +decide [ orthonormal_iff_ite ] ;
        simpa [ mul_comm, inner ] using this i j
      generalize_proofs at *;
      -- By expanding the dot product and using the orthonormality of the basis vectors, we can simplify the expression.
      have h_expand :  x y : Fin n  , ( i, x i  v i)  ( j, y j  v j) =  i, x i * y i := by
        simp +decide [ dotProduct, Finset.mul_sum _ _ _, mul_comm, mul_left_comm ];
        simp +decide [  Finset.mul_sum _ _ _,  Finset.sum_comm ];
        simp_all +decide [ dotProduct ]
      generalize_proofs at *;
      convert h_expand c c using 1
    have h_inner : dotProduct x (A.mulVec x) =  i : Fin n, c i ^ 2 * ev.get i, by
      simp [ev, sorted_eigenvalues_length] := by
      -- By linearity of the inner product and the fact that $A.mulVec$ is linear, we can distribute the inner product over the sum.
      have h_inner_dist : dotProduct ( i, c i  v i) (A.mulVec ( j, c j  v j)) =  i,  j, c i * c j * dotProduct (v i) (A.mulVec (v j)) := by
        simp +decide [ Matrix.mulVec, dotProduct, Finset.mul_sum _ _ _, Finset.sum_mul ];
        simp +decide only [ Finset.sum_product'];
        apply Finset.sum_bij (fun x _ => (x.2.2.2, x.2.2.1, x.1, x.2.1));
         simp +decide;
         aesop;
         simp +zetaDelta at *;
         simp +decide [ mul_assoc, mul_comm, mul_left_comm ];
      -- Since $v$ is an orthonormal basis, we have $langle v_i, v_j \rangle = delta_{ij}$.
      have h_orthonormal :  i j, dotProduct (v i) (v j) = if i = j then 1 else 0 := by
        intro i j; have := v.orthonormal; simp_all +decide [ orthonormal_iff_ite ] ;
        convert this i j using 1;
        simp +decide [ dotProduct, inner ];
        ac_rfl
      generalize_proofs at *;
      simp_all +decide [ pow_two, mul_assoc ];
      simp +decide [ dotProduct, Finset.mul_sum _ _ _, mul_left_comm ];
      simp_all +decide [  Finset.mul_sum _ _ _, dotProduct ];
      simp [ev]
    generalize_proofs at *;
    -- Since $v$ is an orthonormal basis, we have $lambda_i geq alpha_k$ for all $i geq k$.
    have h_lambda_ge_alpha :  i : Fin n, k  i  ev.get i, by
      simp [ev, sorted_eigenvalues_length]  ev.get k, by
      simp [ev, sorted_eigenvalues_length] := by
      intros i hi
      have h_sorted : ev.get i, by
        simp [ev, sorted_eigenvalues_length]  ev.get k, by
        simp [ev, sorted_eigenvalues_length] := by
        have h_sorted_list : List.Sorted (  ) ev := by
          simpa [ev] using sorted_eigenvalues_sorted A hA
        have := List.pairwise_iff_get.mp h_sorted_list;
        grind
      generalize_proofs at *;
      exact h_sorted
    generalize_proofs at *;
    -- Since $v$ is an orthonormal basis, we have $sum_{i=0}^{n-1} c_i^2 lambda_i geq alpha_k sum_{i=0}^{n-1} c_i^2$.
    have h_sum_ge_alpha :  i : Fin n, c i ^ 2 * ev.get i, by
      simp [ev, sorted_eigenvalues_length]  ev.get k, by
      simp [ev, sorted_eigenvalues_length] *  i : Fin n, c i ^ 2 := by
      rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_le_sum fun i _ => by cases le_or_gt k i <;> [ exact by nlinarith only [ h_lambda_ge_alpha i _ ] ; ; exact by rw [ hc.2 i _ ] ; nlinarith only [ h_lambda_ge_alpha k le_rfl ] ] ;
    generalize_proofs at *;
    field_simp;
    rw [ rayleigh_quotient ];
    rw [ h_inner, h_norm, le_div_iff ];
     exact h_sum_ge_alpha;
     exact h_norm  lt_of_le_of_ne ( Finset.sum_nonneg fun _ _ => mul_self_nonneg _ ) ( Ne.symm <| by intro H; exact hx0 <| by ext i; simp_all +decide [ Finset.sum_eq_zero_iff_of_nonneg, sq_nonneg ] )

/-
The k-th eigenvalue is less than or equal to the supremum of the Rayleigh quotient over any (k+1)-dimensional subspace.
-/
lemma le_sup_rayleigh_of_dim_eq_succ {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm)
  (k : Fin n)
  (V : Submodule  (Fin n  ))
  (hV : Module.finrank  V = k + 1) :
  (sorted_eigenvalues A hA).get k, by rw [sorted_eigenvalues_length]; exact k.isLt   (x : {x : V // x.1  0}), rayleigh_quotient A x.1 := by
    -- Let U be the span of eigenvectors v_k, ..., v_{n-1}.
    set U : Submodule  (Fin n  ) := Submodule.span  (Set.range (fun i : {j : Fin n // k  j} => (Classical.choose (exists_orthonormal_basis_sorted A hA)) i));
    -- Since $V$ is $k+1$-dimensional and $U$ is $n-k$-dimensional, their intersection $U cap V$ has dimension at least $1$.
    have h_inter : Module.finrank  ((U  V))  1 := by
      have h_inter : Module.finrank  U = n - k := by
        rw [ @finrank_span_eq_card ];
         rw [ Fintype.card_subtype ];
          rw [ show ( Finset.univ.filter fun x : Fin n => k  x ) = Finset.Ici k by ext; simp +decide ] ; simp +decide;
         refine' LinearIndependent.comp _ _ _;
           exact ( Classical.choose ( exists_orthonormal_basis_sorted A hA ) ).orthonormal.linearIndependent;
           exact Subtype.coe_injective;
      have h_inter : Module.finrank  ((U  V))  n := by
        exact le_trans ( Submodule.finrank_le _ ) ( by simp );
      have := Submodule.finrank_sup_add_finrank_inf_eq U V;
      linarith [ Nat.sub_add_cancel ( show ( k :  )  n from k.2.le ) ];
    -- Let $x$ be a nonzero vector in $U cap V$.
    obtain x, hx :  x : Fin n  , x  0  x  U  V := by
      contrapose! h_inter;
      rw [ show U  V =  from eq_bot_iff.mpr fun x hx => Classical.not_not.1 fun hx' => h_inter x hx' hx ] ; norm_num;
    refine' le_trans _ ( le_ciSup _   x, by aesop , by aesop  );
     apply rayleigh_ge_of_mem_span_top A hA k (Classical.choose (exists_orthonormal_basis_sorted A hA)) (Classical.choose_spec (exists_orthonormal_basis_sorted A hA)) x;
       exact hx.2.1;
       exact hx.1;
     refine'   i,  j, |A i j|, Set.forall_mem_range.2 fun x => _ ;
      refine' div_le_of_le_mul _ _ _;
       exact Finset.sum_nonneg fun _ _ => mul_self_nonneg _;
       exact Finset.sum_nonneg fun i _ => Finset.sum_nonneg fun j _ => abs_nonneg _;
       -- By the properties of the dot product and the triangle inequality, we can bound the expression.
        have h_dot_product :  (x : Fin n  ), x  0  |dotProduct x (A.mulVec x)|  ( i,  j, |A i j|) * dotProduct x x := by
          intros x hx_nonzero
          have h_dot_product : |dotProduct x (A.mulVec x)|   i,  j, |A i j| * |x i| * |x j| := by
            simp +decide [ dotProduct, Matrix.mulVec, Finset.mul_sum _ _ _, mul_comm, mul_left_comm ];
            exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun i _ => Finset.abs_sum_le_sum_abs _ _ |> le_trans <| Finset.sum_le_sum fun j _ => by rw [ abs_mul, abs_mul ] );
          refine le_trans h_dot_product ?_;
          norm_num [ Finset.sum_mul _ _ _, mul_assoc, dotProduct ];
          exact Finset.sum_le_sum fun i _ => Finset.sum_le_sum fun j _ => mul_le_mul_of_nonneg_left ( by nlinarith only [ abs_mul_abs_self ( x i ), abs_mul_abs_self ( x j ), Finset.single_le_sum ( fun i _ => mul_self_nonneg ( x i ) ) ( Finset.mem_univ i ), Finset.single_le_sum ( fun i _ => mul_self_nonneg ( x i ) ) ( Finset.mem_univ j ) ] ) ( abs_nonneg _ );
        exact le_of_abs_le ( h_dot_product _ x.2 )

/-
The intersection of a subspace of dimension n-k and a subspace of dimension k+1 in an n-dimensional space is non-trivial.
-/
lemma intersection_dim_pos {n : } (k : ) (U V : Submodule  (Fin n  ))
  (hU : Module.finrank  U = n - k)
  (hV : Module.finrank  V = k + 1)
  (hk : k < n) :
   x  U  V, x  0 := by
    by_contra h_contra;
    have h_dim_sum : Module.finrank  ((U  V)) = Module.finrank  U + Module.finrank  V := by
      rw [  Submodule.finrank_sup_add_finrank_inf_eq, show U  V =  from eq_bot_iff.mpr fun x hx => Classical.not_not.mp fun hx' => h_contra  x, hx, hx'  ] ; aesop;
    linarith [ Nat.sub_add_cancel hk.le, show Module.finrank  (  ( U  V ) )  n from le_trans ( Submodule.finrank_le _ ) ( by simp ) ]

/-
The dimension of the span of the first k+1 eigenvectors is k+1.
-/
lemma span_bot_dim {n : } (A : Matrix (Fin n) (Fin n) ) (_ : A.IsSymm)
  (k : Fin n)
  (v : OrthonormalBasis (Fin n)  (EuclideanSpace  (Fin n))) :
  Module.finrank  (Submodule.span  (Set.range (fun i : {j : Fin n // j  k} => v i))) = k + 1 := by
    rw [ finrank_span_eq_card ];
     rw [ Fintype.card_subtype ];
      rw [ show ( Finset.filter ( fun x => x  k ) Finset.univ : Finset ( Fin n ) ) = Finset.Iic k by ext; simp +decide ] ; simp +decide;
     have := v.orthonormal;
      exact this.linearIndependent.comp _ ( by aesop_cat )

/-
Definition of a principal submatrix.
-/
def principal_submatrix {n : } (A : Matrix (Fin n) (Fin n) ) (S : Finset (Fin n)) : Matrix S S  :=
  A.submatrix Subtype.val Subtype.val

/-
Reindexed principal submatrix to Fin (card S).
-/
def principal_submatrix_fin {n : } (A : Matrix (Fin n) (Fin n) ) (S : Finset (Fin n)) :
  Matrix (Fin (Fintype.card {x // x  S})) (Fin (Fintype.card {x // x  S}))  :=
  Matrix.reindex (Fintype.equivFin {x // x  S}) (Fintype.equivFin {x // x  S}) (principal_submatrix A S)

/-
The principal submatrix of a symmetric matrix is symmetric.
-/
lemma principal_submatrix_fin_isSymm {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm)
  (S : Finset (Fin n)) :
  (principal_submatrix_fin A S).IsSymm := by
    unfold principal_submatrix_fin;
    unfold principal_submatrix; aesop;

/-
The dimension of the subspace of vectors supported on S is |S|.
-/
def subspace_of_support {n : } (S : Finset (Fin n)) : Submodule  (Fin n  ) :=
  Submodule.span  (Set.range (fun i : S => (Pi.single (i : Fin n) 1 : Fin n  )))

lemma subspace_of_support_dim {n : } (S : Finset (Fin n)) :
  Module.finrank  (subspace_of_support S) = S.card := by
    -- The subspace_of_support S is isomorphic to the space of functions from S to , which has dimension |S|.
    have h_iso : subspace_of_support S [] (S  ) := by
      -- The subspace of vectors with support in S is isomorphic to the space of functions from S to .
      have h_iso : ((subspace_of_support S)) [] (S  ) := by
        have h_subspace : subspace_of_support S = Submodule.span  (Set.range (fun i : S => fun j : Fin n => if j = i then 1 else 0)) := by
          ext x; simp [subspace_of_support];
          congr!;
          aesop
        rw [ h_subspace ];
        refine' ( LinearEquiv.ofFinrankEq .. );
        rw [ @finrank_span_eq_card ] <;> norm_num;
        refine' Fintype.linearIndependent_iff.2 _;
        intro g hg i; replace hg := congr_fun hg i; simp_all +decide [ Finset.sum_ite ] ;
        rw [ Finset.sum_eq_single i ] at hg <;> aesop;
      exact h_iso;
    have := h_iso.finrank_eq;
    aesop

/-
The Rayleigh quotient is bounded by the maximum eigenvalue.
-/
lemma rayleigh_le_max_eigenvalue {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm)
  (x : Fin n  ) (hx : x  0) (hn : n  0) :
  rayleigh_quotient A x  (sorted_eigenvalues A hA).getLast (List.ne_nil_of_length_pos (by
  rw [ sorted_eigenvalues_length A hA ] ; positivity)) := by
    classical
    set ev := sorted_eigenvalues A hA
    obtain  v, hv  := exists_orthonormal_basis_sorted A hA;
    -- Expand x in the orthonormal basis of eigenvectors provided by \`exists_orthonormal_basis_sorted\`.
    obtain c, hc :  c : Fin n  , x =  i, c i  v i := by
      have := v.sum_repr x;
      exact  _, this.symm ;
    -- Substitute $x = sum c_i v_i$ into the Rayleigh quotient.
    have h_rayleigh_subst : rayleigh_quotient A x = ( i, c i ^ 2 * ev.get i, by
      simp [ev, sorted_eigenvalues_length]) / ( i, c i ^ 2) := by
      have h_rayleigh : dotProduct x (A.mulVec x) =  i, c i^2 * (ev.get i, by
        simp [ev, sorted_eigenvalues_length]) := by
        have h_rayleigh : dotProduct ( i, c i  v i) ( i, c i  (ev.get i, by
          simp [ev, sorted_eigenvalues_length])  v i) =  i, c i ^ 2 * ev.get i, by
          simp [ev, sorted_eigenvalues_length] := by
          have h_inner :  i j : Fin n, dotProduct (v i) (v j) = if i = j then 1 else 0 := by
            intro i j; have := v.orthonormal; simp_all +decide [ orthonormal_iff_ite ] ;
            convert this i j using 1;
            simp +decide [ dotProduct, inner ];
            ac_rfl
          generalize_proofs at *;
          simp +decide [ dotProduct, Finset.sum_mul _ _ _, Finset.mul_sum, mul_assoc, mul_comm, mul_left_comm, sq ];
          simp +decide [  Finset.mul_sum _ _ _,  Finset.sum_comm ];
          simp_all +decide [ dotProduct ]
        generalize_proofs at *;
        convert h_rayleigh using 2;
        rw [ hc, Matrix.mulVec_sum ];
        exact Finset.sum_congr rfl fun i _ => by rw [ Matrix.mulVec_smul, hv ] ;
      generalize_proofs at *;
      have h_rayleigh : dotProduct x x =  i, c i^2 := by
        have h_rayleigh :  i j, dotProduct (v i) (v j) = if i = j then 1 else 0 := by
          intro i j; have := v.orthonormal; simp_all +decide [ orthonormal_iff_ite ] ;
          convert this i j using 1;
          exact Finset.sum_congr rfl fun _ _ => by simp +decide [ mul_comm ] ;
        have h_rayleigh :  i j, dotProduct (c i  v i) (c j  v j) = c i * c j * (if i = j then 1 else 0) := by
          simp +decide [  h_rayleigh, mul_assoc ];
          simp +decide [ dotProduct, Finset.mul_sum _ _ _, mul_assoc, mul_left_comm ];
        have h_rayleigh : dotProduct ( i, c i  v i) ( i, c i  v i) =  i,  j, dotProduct (c i  v i) (c j  v j) := by
          simp +decide only [dotProduct];
          simp +decide only [ Finset.sum_comm,  Finset.mul_sum _ _ _,  Finset.sum_mul];
          exact Finset.sum_congr rfl fun _ _ => by rw [ Finset.sum_apply ] ;
        simp_all +decide [ sq ];
      unfold rayleigh_quotient; aesop;
    generalize_proofs at *;
    -- Since $lambda_i le lambda_{max}$, we have $sum c_i^2 lambda_i le lambda_{max} sum c_i^2$.
    have h_sum_le_max :  i, c i ^ 2 * ev.get i, by
      simp [ev, sorted_eigenvalues_length]  ( i, c i ^ 2) * ev.getLast _ := by
      rw [ Finset.sum_mul _ _ _ ];
      gcongr;
      -- Since the list is sorted in non-decreasing order, the last element is the maximum.
      have h_sorted :  (i j : Fin ev.length), i  j  ev.get i  ev.get j := by
        have h_sorted' : List.Sorted (  ) ev := by
          simpa [ev] using sorted_eigenvalues_sorted A hA
        exact fun i j hij => h_sorted'.rel_get_of_le hij
      convert h_sorted _ _ _;
      rotate_left;
      exact  ev.length - 1, Nat.sub_lt ((List.length_pos_iff).mpr _) zero_lt_one ;
       exact Nat.le_sub_one_of_lt ( by solve_by_elim );
       grind
    generalize_proofs at *;
    rw [ h_rayleigh_subst, div_le_iff ];
     linarith;
     contrapose! hx;
      exact hc.trans ( Finset.sum_eq_zero fun i _ => by rw [ show c i = 0 by exact sq_eq_zero_iff.mp ( le_antisymm ( le_trans ( Finset.single_le_sum ( fun i _ => sq_nonneg ( c i ) ) ( Finset.mem_univ i ) ) hx ) ( sq_nonneg ( c i ) ) ) ] ; norm_num )

/-
The largest eigenvalue of a principal submatrix of size m is at least the m-th smallest eigenvalue of the original matrix.
-/
lemma eigenvalue_interlacing_max {n : } (A : Matrix (Fin n) (Fin n) ) (hA : A.IsSymm)
  (S : Finset (Fin n)) (hS : S.Nonempty) :
  let m := S.card
  let subA := principal_submatrix_fin A S
  let h_subA := principal_submatrix_fin_isSymm A hA S
  let evs_A := sorted_eigenvalues A hA
  let evs_sub := sorted_eigenvalues subA h_subA
  evs_sub.getLast (List.ne_nil_of_length_pos (by
  rw [ sorted_eigenvalues_length ] ; aesop))  evs_A.get m - 1, by
    rw [ sorted_eigenvalues_length ];
    exact lt_of_lt_of_le ( Nat.sub_lt ( Finset.card_pos.mpr hS ) zero_lt_one ) ( le_trans ( Finset.card_le_univ _ ) ( by norm_num ) ) := by
    classical
    -- Let $V$ be the subspace of vectors supported on $S$. Its dimension is $m$.
    set V := subspace_of_support S;
    -- By the Min-Max principle, the $(m-1)$-th eigenvalue of $A$ is $le sup_{x in V, x 
e 0} R_A(x)$.
    have h_min_max : (sorted_eigenvalues A hA).get S.card - 1, by
        rw [ sorted_eigenvalues_length ];
        exact lt_of_lt_of_le ( Nat.sub_lt ( Finset.card_pos.mpr hS ) zero_lt_one ) ( le_trans ( Finset.card_le_univ _ ) ( by norm_num ) ) 
         (x : {x : V // x.1  0}), rayleigh_quotient A x.1 := by
      apply le_sup_rayleigh_of_dim_eq_succ A hA S.card - 1, by
        exact lt_of_lt_of_le ( Nat.sub_lt ( Finset.card_pos.mpr hS ) zero_lt_one ) ( le_trans ( Finset.card_le_univ _ ) ( by norm_num ) ) V
      rw [ Nat.sub_add_cancel ( Finset.card_pos.mpr hS ) ] ; exact subspace_of_support_dim S;
    -- For any $x in V$, let $y$ be the corresponding vector in $mathbb{R}^m$. Then $R_A(x) = R_{subA}(y)$.
    have h_rayleigh_eq :  x  V, x  0   y : Fin (Fintype.card {x // x  S})  , y  0  rayleigh_quotient A x = rayleigh_quotient (principal_submatrix_fin A S) y := by
      intro x hx hx_ne_zero
      obtain y, hy :  y : Fin (Fintype.card {x // x  S})  , x = fun i => if h : i  S then y (Fintype.equivFin {x // x  S} i, h) else 0 := by
        have h_span :  x  V,  y : {x // x  S}  , x = fun i => if h : i  S then y i, h else 0 := by
          intro x hx
          obtain y, hy :  y : {x // x  S}  , x =  i : {x // x  S}, y i  (Pi.single (i : Fin n) 1 : Fin n  ) := by
            have h_span : x  Submodule.span  (Set.range (fun i : {x // x  S} => (Pi.single (i : Fin n) 1 : Fin n  ))) := by
              exact hx;
            rw [ Finsupp.mem_span_range_iff_exists_finsupp ] at h_span;
            obtain  c, rfl  := h_span; use fun i => c i; simp +decide [ Finsupp.sum_fintype ] ;
          use y; ext i; simp [hy];
          split_ifs <;> simp_all +decide [ Pi.single_apply ];
           rw [ Finset.sum_eq_single  i, by assumption  ] <;> aesop;
           exact Finset.sum_eq_zero fun x hx => if_neg <| by aesop;
        obtain  y, rfl  := h_span x hx;
        exact  fun i => y ( Fintype.equivFin { x // x  S } |>.symm i ), by ext i; aesop ;
      refine'  y, _, _ ;
       contrapose! hx_ne_zero; aesop;
       unfold rayleigh_quotient;
        unfold principal_submatrix_fin;
        unfold principal_submatrix; simp +decide [ hy, Matrix.mulVec, dotProduct ] ;
        congr! 1;
         rw [  Finset.sum_subset ( Finset.subset_univ S ) ];
           refine' Finset.sum_bij ( fun i hi => Fintype.equivFin { x // x  S }  i, hi  ) _ _ _ _ <;> simp +decide;
             exact fun b =>  _, Finset.mem_coe.mp ( Fintype.equivFin { x // x  S } |>.symm b |>.2 ), by simp +decide ;
             intro a ha; simp +decide [ ha ] ;
              rw [  Finset.sum_subset ( Finset.subset_univ S ) ];
               rw [  Finset.sum_coe_sort ];
                refine' Or.inl ( Finset.sum_bij ( fun i hi => Fintype.equivFin { x // x  S }  i, by aesop  ) _ _ _ _ ) <;> simp +decide;
                exact fun b =>  _, Finset.mem_coe.mp ( Fintype.equivFin { x // x  S } |>.symm b |>.2 ), by simp +decide ;
               aesop;
           aesop;
         rw [  Finset.sum_subset ( Finset.subset_univ S ) ];
           refine' Finset.sum_bij ( fun i hi => Fintype.equivFin { x // x  S }  i, hi  ) _ _ _ _ <;> simp +decide;
             exact fun b =>  _, Finset.mem_coe.mp ( Fintype.equivFin { x // x  S } |>.symm b |>.2 ), by simp +decide ;
             aesop;
           aesop;
    -- By \`rayleigh_le_max_eigenvalue\`, $R_{subA}(y) le lambda_{max}(subA)$.
    have h_rayleigh_le_max :  y : Fin (Fintype.card {x // x  S})  , y  0 
        rayleigh_quotient (principal_submatrix_fin A S) y 
          (sorted_eigenvalues (principal_submatrix_fin A S) (principal_submatrix_fin_isSymm A hA S)).getLast
            (List.ne_nil_of_length_pos (by
              rw [ sorted_eigenvalues_length ];
              exact Fintype.card_pos_iff.mpr   hS.choose, hS.choose_spec   )) := by
      intros y hy_nonzero
      apply rayleigh_le_max_eigenvalue (principal_submatrix_fin A S) (principal_submatrix_fin_isSymm A hA S) y hy_nonzero;
      exact ne_of_gt ( Fintype.card_pos_iff.mpr   hS.choose, hS.choose_spec   );
    refine le_trans h_min_max ?_;
    convert ciSup_le _;
     simp +zetaDelta at *;
      exact  _, Submodule.subset_span   hS.choose, hS.choose_spec , rfl , ne_of_apply_ne ( fun x => x hS.choose ) ( by simp +decide ) ;
     grind

/-
If a principal submatrix of the Huang matrix has size > 2^(n-1), its maximum eigenvalue is at least sqrt(n).
-/
lemma huang_submatrix_max_eigenvalue_ge_sqrt_n {n : } (hn : n  0)
  (S : Finset (Fin (2^n))) (hS : S.card > 2^(n-1)) :
  let subA := principal_submatrix_fin (huang_matrix_fin n) S
  let h_subA := principal_submatrix_fin_isSymm (huang_matrix_fin n) (huang_matrix_fin_isSymm n) S
  let evs_sub := sorted_eigenvalues subA h_subA
  evs_sub.getLast (List.ne_nil_of_length_pos (by
  rw [ sorted_eigenvalues_length ];
  exact Fintype.card_pos_iff.mpr  Classical.choose ( Finset.card_pos.mp ( pos_of_gt hS ) ), Classical.choose_spec ( Finset.card_pos.mp ( pos_of_gt hS ) ) ))  Real.sqrt n := by
    have h_max_eigenvalue_ge_sqrt : let m := S.card
      let subA := principal_submatrix_fin (huang_matrix_fin n) S
      let h_subA := principal_submatrix_fin_isSymm (huang_matrix_fin n) (huang_matrix_fin_isSymm n) S
      let evs_sub := sorted_eigenvalues subA h_subA
      evs_sub.getLast (List.ne_nil_of_length_pos (by
      have hSpos : 0 < S.card := lt_of_le_of_lt (Nat.zero_le _) hS
      have hlen : evs_sub.length = S.card := by
        simp [evs_sub, sorted_eigenvalues_length, Fintype.card_coe]
      rw [hlen]
      exact hSpos))  (sorted_eigenvalues (huang_matrix_fin n) (huang_matrix_fin_isSymm n)).get m - 1, by
        rw [ sorted_eigenvalues_length ];
        exact lt_of_lt_of_le ( Nat.pred_lt ( ne_bot_of_gt hS ) ) ( le_trans ( Finset.card_le_univ _ ) ( by norm_num ) ) := by
        apply eigenvalue_interlacing_max;
        exact Finset.card_pos.mp ( pos_of_gt hS )
    have h_eigenvalues_eq_list : let evs := sorted_eigenvalues (huang_matrix_fin n) (huang_matrix_fin_isSymm n)
      evs = List.replicate (2^(n-1)) (-Real.sqrt n) ++ List.replicate (2^(n-1)) (Real.sqrt n) := by
        exact huang_eigenvalues_eq_list n hn
    simp_all +decide [ List.getElem_append ];
    exact le_trans ( by rw [ if_neg ( by omega ) ] ) h_max_eigenvalue_ge_sqrt

/-
The sum of g_val is non-zero if f has full degree.
-/
def g_val {n : } (f : (Fin n  Bool)  Bool) (x : Fin n  Bool) :  :=
  (if f x then -1 else 1) * chi Finset.univ x

lemma g_val_sum_ne_zero {n : } (f : (Fin n  Bool)  Bool) (h_deg : degree f = n) (hn : n  0) :
  Finset.sum Finset.univ (g_val f)  0 := by
    unfold g_val;
    -- By definition of \`g_val\`, we can rewrite it in terms of \`chi\` and \`f\`.
    have hg_val :  x : Fin n  Bool, (if f x then -1 else 1) * chi Finset.univ x = -2 *  x : Fin n  Bool, (if f x then 1 else 0) * chi Finset.univ x +  x : Fin n  Bool, chi Finset.univ x := by
      rw [ Finset.mul_sum _ _ _ ] ; rw [  Finset.sum_add_distrib ] ; exact Finset.sum_congr rfl fun _ _ => by split_ifs <;> ring;
    -- Since $sum_{x} chi_{Finset.univ}(x) = 0$ for $n 
eq 0$, we have:
    have h_sum_chi :  x : Fin n  Bool, chi Finset.univ x = 0 := by
      unfold chi;
      -- Let's simplify the sum $sum_{x : Fin n  Bool} (-1)^{	ext{card}({i | x i = true})}$.
      have h_sum_simplified :  x : Fin n  Bool, (-1 : ) ^ (Finset.card (Finset.filter (fun i => x i) Finset.univ)) =  i : Fin n, ( x_i : Bool, (-1 : ) ^ (if x_i then 1 else 0)) := by
        rw [ Finset.prod_sum ];
        refine' Finset.sum_bij ( fun x _ => fun i _ => x i ) _ _ _ _ <;> simp +decide;
         simp +decide [ funext_iff ];
         exact fun b =>  fun i => b i ( Finset.mem_univ i ), rfl ;
         intro a; rw [ Finset.prod_ite ] ; aesop;
      convert h_sum_simplified using 1;
       exact Finset.sum_congr rfl fun x hx => by rcases Nat.mod_two_eq_zero_or_one ( Finset.card ( Finset.filter ( fun i => x i = true ) Finset.univ ) ) with h | h <;> rw [  Nat.mod_add_div ( Finset.card ( Finset.filter ( fun i => x i = true ) Finset.univ ) ) 2 ] <;> norm_num [ pow_add, pow_mul, h ] ;
       norm_num [ Finset.prod_eq_zero_iff ];
        rw [ zero_pow hn ];
    have := g_expectation_nonzero f h_deg hn; aesop;

/-
Definitions of the positive and negative level sets of g.
-/
def S_pos {n : } (f : (Fin n  Bool)  Bool) : Finset (Fin n  Bool) :=
  Finset.filter (fun x => g_val f x = 1) Finset.univ

def S_neg {n : } (f : (Fin n  Bool)  Bool) : Finset (Fin n  Bool) :=
  Finset.filter (fun x => g_val f x = -1) Finset.univ

/-
S_pos and S_neg cover the whole space.
-/
lemma S_pos_union_S_neg {n : } (f : (Fin n  Bool)  Bool) :
  S_pos f  S_neg f = Finset.univ := by
    ext x; simp [S_pos, S_neg];
    unfold g_val;
    split_ifs <;> unfold chi <;> simp +decide;
     cases Nat.mod_two_eq_zero_or_one ( Finset.card ( Finset.filter ( fun i => x i = true ) Finset.univ ) ) <;> simp +decide [ * ];
     cases Nat.mod_two_eq_zero_or_one ( Finset.card ( Finset.filter ( fun i => x i = true ) Finset.univ ) ) <;> simp +decide [ * ]

/-
S_pos and S_neg are disjoint.
-/
lemma S_pos_disjoint_S_neg {n : } (f : (Fin n  Bool)  Bool) :
  Disjoint (S_pos f) (S_neg f) := by
    exact Finset.disjoint_filter.mpr fun _ _ _ _ => by linarith;

/-
One of the level sets of g has size > 2^(n-1).
-/
lemma exists_large_level_set {n : } (f : (Fin n  Bool)  Bool) (h_deg : degree f = n) (hn : n  0) :
  (S_pos f).card > 2^(n-1)  (S_neg f).card > 2^(n-1) := by
    -- Since sum g_val  0, we have |S_pos|  |S_neg|.
    have h_card_ne : (S_pos f).card  (S_neg f).card := by
      have h_card_ne : (Finset.sum Finset.univ (g_val f)) = (S_pos f).card - (S_neg f).card := by
        -- By definition of $g_val$, we can split the sum into the sum over $S_pos$ and the sum over $S_neg$.
        have h_split_sum : Finset.sum Finset.univ (g_val f) = Finset.sum (S_pos f) (fun x => g_val f x) + Finset.sum (S_neg f) (fun x => g_val f x) := by
          rw [  Finset.sum_union ];
           rw [ S_pos_union_S_neg ];
           exact S_pos_disjoint_S_neg f;
        rw [ h_split_sum, Finset.sum_congr rfl fun x hx => show g_val f x = 1 by exact Finset.mem_filter.mp hx |>.2, Finset.sum_congr rfl fun x hx => show g_val f x = -1 by exact Finset.mem_filter.mp hx |>.2 ] ; norm_num;
        ring;
      have := g_val_sum_ne_zero f h_deg hn; aesop;
    -- Since $|S_pos| + |S_neg| = 2^n$, we have $|S_pos| + |S_neg| = 2 * 2^{n-1}$.
    have h_card_sum : (S_pos f).card + (S_neg f).card = 2 * 2 ^ (n - 1) := by
      have h_card_sum : (S_pos f).card + (S_neg f).card = (Finset.univ : Finset (Fin n  Bool)).card := by
        rw [  Finset.card_union_of_disjoint ( S_pos_disjoint_S_neg f ), S_pos_union_S_neg ];
      cases n <;> simp_all +decide [ pow_succ' ];
    grind

/-
Definition of the hypercube graph.
-/
def hypercube_graph (n : ) : SimpleGraph (Fin n  Bool) :=
  SimpleGraph.fromRel (fun x y => (Finset.filter (fun i => x i  y i) Finset.univ).card = 1)

lemma hypercube_graph_adj {n : } (x y : Fin n  Bool) :
  (hypercube_graph n).Adj x y  (Finset.filter (fun i => x i  y i) Finset.univ).card = 1 := by
    simp [hypercube_graph];
    -- If x and y are not equal, then there must be at least one index where they differ. The cardinality of the set of such indices being 1 means there's exactly one difference, which implies x and y are not equal. Conversely, if the cardinality is 1, then there's exactly one difference, so x and y can't be equal.
    apply Iff.intro;
     simp_all +decide [ eq_comm ];
     aesop

/-
Neighbors in the hypercube graph have opposite chi values.
-/
lemma chi_univ_neighbor {n : } (x y : Fin n  Bool) (h_adj : (hypercube_graph n).Adj x y) :
  chi Finset.univ x = -chi Finset.univ y := by
    -- Since x and y differ by exactly one bit, their parities are opposite.
    have h_parity : (Finset.filter (fun i => x i) Finset.univ).card % 2  (Finset.filter (fun i => y i) Finset.univ).card % 2 := by
      have h_parity : (Finset.filter (fun i => x i  y i) Finset.univ).card = 1 := by
        exact (hypercube_graph_adj x y).mp h_adj;
      -- Since x and y differ by exactly one bit, the number of 1s in x and y differ by 1.
      have h_diff : (Finset.filter (fun i => x i = true) Finset.univ).card + (Finset.filter (fun i => y i = true) Finset.univ).card = (Finset.filter (fun i => x i  y i) Finset.univ).card + 2 * (Finset.filter (fun i => x i = true  y i = true) Finset.univ).card := by
        rw [ Finset.card_filter, Finset.card_filter, Finset.card_filter ];
        rw [ Finset.card_filter ];
        rw [ Finset.mul_sum _ _ _ ] ; rw [  Finset.sum_add_distrib ] ; rw [  Finset.sum_add_distrib ] ; congr ; ext i ; by_cases hi : x i <;> by_cases hj : y i <;> simp +decide [ hi, hj ] ;
      omega;
    unfold chi; aesop;

/-
g values are equal for neighbors iff f values are different.
-/
lemma g_val_neighbor_eq_iff_f_ne {n : } (f : (Fin n  Bool)  Bool) (x y : Fin n  Bool) (h_adj : (hypercube_graph n).Adj x y) :
  g_val f x = g_val f y  f x  f y := by
    have h_univ_neighbor : chi Finset.univ x = -chi Finset.univ y := by
      exact chi_univ_neighbor x y h_adj;
    unfold g_val;
    cases f x <;> cases f y <;> simp +decide [ * ];
     unfold chi at *;
      split_ifs at * <;> norm_num at *;
     unfold chi; split_ifs <;> norm_num;

/-
For x in S_pos, the sensitivity at x equals the degree of x in the induced subgraph on S_pos.
-/
lemma sensitivity_at_x_eq_degree_in_S_pos {n : } (f : (Fin n  Bool)  Bool) (x : Fin n  Bool) (hx : x  S_pos f) :
  (Finset.filter (fun y => (hypercube_graph n).Adj x y  f x  f y) Finset.univ).card =
  (Finset.filter (fun y => (hypercube_graph n).Adj x y  y  S_pos f) Finset.univ).card := by
    -- Apply the lemma \`g_val_neighbor_eq_iff_f_ne\` to each neighbor \`y\` of \`x\`.
    have h_neighbor :  y : Fin n  Bool, (hypercube_graph n).Adj x y  (f x  f y  y  S_pos f) := by
      intros y hy_adj
      have h_g_eq : g_val f x = g_val f y  f x  f y := by
        exact g_val_neighbor_eq_iff_f_ne f x y hy_adj;
      unfold S_pos at *; aesop;
    exact congr_arg Finset.card ( Finset.ext fun y => by specialize h_neighbor y; aesop )

/-
Checking SimpleGraph.induce
-/
/-
Definition of the induced subgraph of the hypercube graph on S.
-/
def induced_hypercube_graph {n : } (S : Finset (Fin n  Bool)) : SimpleGraph {x // x  S} :=
  SimpleGraph.induce (S : Set (Fin n  Bool)) (hypercube_graph n)

/-
Definition of the hypercube graph on Fin (2^n).
-/
def hypercube_graph_fin (n : ) : SimpleGraph (Fin (2^n)) :=
  (hypercube_graph n).map (boolFunEquivFin n).toEmbedding

/-
Definition of the induced subgraph of the hypercube graph on S, mapped to Fin (card S).
-/
def induced_hypercube_graph_fin_card {n : } (S : Finset (Fin (2^n))) : SimpleGraph (Fin (Fintype.card {x // x  S})) :=
  let G := SimpleGraph.induce (S : Set (Fin (2^n))) (hypercube_graph_fin n)
  let equiv := Fintype.equivFin {x // x  S}
  G.map equiv.toEmbedding

/-
The absolute values of the reindexed Huang matrix entries correspond to the adjacency of the reindexed hypercube graph.
-/
lemma abs_huang_fin_eq_adjacency_fin {n : } (i j : Fin (2^n)) :
  |huang_matrix_fin n i j| = if (hypercube_graph_fin n).Adj i j then 1 else 0 := by
    -- Apply the result that |huang_matrix u v| = 1 if u~v else 0.
    have h_abs :  u v : Fin n  Bool, |(huang_matrix n) u v| = if (hypercube_graph n).Adj u v then 1 else 0 := by
      -- By definition of $A_n$, we know that $|A_n u v| = 1$ if $u$ and $v$ are adjacent in the hypercube graph, and $|A_n u v| = 0$ otherwise.
      intros u v
      simp [abs_huang_eq_adjacency, hypercube_graph];
      by_cases h : u = v <;> simp +decide [ h, eq_comm ];
    unfold huang_matrix_fin;
    unfold hypercube_graph_fin; aesop;

/-
The entries of the principal submatrix of the Huang matrix are bounded by the adjacency matrix of the induced subgraph.
-/
lemma huang_submatrix_bounded_by_induced_adjacency {n : } (S : Finset (Fin (2^n))) (i j : Fin (Fintype.card {x // x  S})) :
  |principal_submatrix_fin (huang_matrix_fin n) S i j|  if (induced_hypercube_graph_fin_card S).Adj i j then 1 else 0 := by
    unfold principal_submatrix_fin induced_hypercube_graph_fin_card;
    simp +decide [ principal_submatrix ];
    split_ifs <;> simp_all +decide [ abs_huang_fin_eq_adjacency_fin ];
     split_ifs <;> norm_num;
     rename_i h;
      contrapose! h;
      use (Fintype.equivFin { x // x  S }).symm i, by
        exact Finset.mem_coe.mp ( Subtype.mem _ ), (Fintype.equivFin { x // x  S }).symm j, by
        exact ( Fintype.equivFin { x // x  S } ).symm j |>.2
      generalize_proofs at *;
      aesop

/-
For x in S_neg, the sensitivity at x equals the degree of x in the induced subgraph on S_neg.
-/
lemma sensitivity_at_x_eq_degree_in_S_neg {n : } (f : (Fin n  Bool)  Bool) (x : Fin n  Bool) (hx : x  S_neg f) :
  (Finset.filter (fun y => (hypercube_graph n).Adj x y  f x  f y) Finset.univ).card =
  (Finset.filter (fun y => (hypercube_graph n).Adj x y  y  S_neg f) Finset.univ).card := by
    unfold S_neg at *;
    congr! 2;
    ext y;
    constructor <;> intro h;
     have := chi_univ_neighbor x y h.1; unfold g_val at *; aesop;
     have := g_val_neighbor_eq_iff_f_ne f x y h.1; aesop;

/-
A boolean function of degree n has sensitivity at least sqrt(n).
-/
theorem sensitivity_ge_sqrt_degree_of_degree_eq_n {n : } (f : (Fin n  Bool)  Bool) (h_deg : degree f = n) (hn : n  0) :
  (sensitivity f : )  Real.sqrt n := by
  classical
  -- Reduce to any level set with the "right" adjacency-count equality.
  have h_main :
       (S0 : Finset (Fin n  Bool)),
        ( x  S0,
            (Finset.filter (fun y => (hypercube_graph n).Adj x y  y  S0) Finset.univ).card =
              (Finset.filter (fun y => (hypercube_graph n).Adj x y  f x  f y) Finset.univ).card) 
        S0.card > 2^(n-1) 
        (sensitivity f : )  Real.sqrt n := by
    intro S0 h_eq hS0
    -- Reindex S0 to Fin (2^n).
    let S : Finset (Fin (2^n)) := S0.map (boolFunEquivFin n).toEmbedding
    have hS : S.card > 2^(n-1) := by
      simp [S, hS0]
    let subA := principal_submatrix_fin (huang_matrix_fin n) S
    let h_subA := principal_submatrix_fin_isSymm (huang_matrix_fin n) (huang_matrix_fin_isSymm n) S
    let evs_sub := sorted_eigenvalues subA h_subA

    -- Nonempty list witness for the spectral bounds.
    have hnS : Fintype.card {x // x  S}  0 := by
      have hSpos : 0 < S.card := lt_of_le_of_lt (Nat.zero_le _) hS
      rw [Fintype.card_coe]
      exact ne_of_gt hSpos
    have h_ne : evs_sub  [] := by
      apply List.ne_nil_of_length_pos
      dsimp [evs_sub]
      rw [sorted_eigenvalues_length]
      exact Nat.pos_of_ne_zero hnS

    -- Lower bound on _max from interlacing.
    have hpos_sub : 0 < Fintype.card {x // x  S} := by
      exact Fintype.card_pos_iff.mpr
          Classical.choose (Finset.card_pos.mp (pos_of_gt hS)),
            Classical.choose_spec (Finset.card_pos.mp (pos_of_gt hS))  
    have h_ne0 : evs_sub  [] := by
      apply List.ne_nil_of_length_pos
      dsimp [evs_sub]
      rw [sorted_eigenvalues_length]
      exact hpos_sub
    have h_lower0 :
        Real.sqrt n  evs_sub.getLast h_ne0 := by
      simpa [subA, h_subA, evs_sub, h_ne0] using
        (huang_submatrix_max_eigenvalue_ge_sqrt_n (n := n) hn S hS)
    have h_lower : Real.sqrt n  evs_sub.getLast h_ne := by
      have h_eq_last :
          evs_sub.getLast h_ne0 = evs_sub.getLast h_ne := by
        exact
          (List.getLast_congr (l := evs_sub) (l := evs_sub)
            (h := h_ne0) (h := h_ne) (h := rfl))
      rw [ h_eq_last]
      exact h_lower0

    -- Upper bound on _max by max degree of the induced graph.
    have h_adj :
         i j,
          |subA i j|  if (induced_hypercube_graph_fin_card S).Adj i j then 1 else 0 := by
      intro i j
      simpa [subA] using (huang_submatrix_bounded_by_induced_adjacency (S := S) i j)
    have h_lambda_le_max :
        evs_sub.getLast h_ne  (induced_hypercube_graph_fin_card S).maxDegree := by
      simpa [subA, h_subA, evs_sub, h_ne] using
        (spectral_radius_bound (A := subA) (hA := h_subA)
          (G := induced_hypercube_graph_fin_card S) h_adj hnS)

    -- Max degree of the induced graph is at most sensitivity.
    let G0 : SimpleGraph {x // x  (S0 : Set (Fin n  Bool))} :=
      (hypercube_graph n).induce (S0 : Set (Fin n  Bool))
    let G1 : SimpleGraph {x // x  (S : Set (Fin (2^n)))} :=
      (hypercube_graph_fin n).induce (S : Set (Fin (2^n)))
    -- Prefer the \`Subtype.fintype\` instance to avoid instance mismatch in neighbor finsets.
    letI : Fintype {x // x  (S0 : Set (Fin n  Bool))} := by
      classical
      exact (Subtype.fintype (p := fun x => x  (S0 : Set (Fin n  Bool))))
    let eS : {x // x  (S0 : Set (Fin n  Bool))}  {x // x  (S : Set (Fin (2^n)))} :=
      { toFun := fun x =>
           (boolFunEquivFin n) x.1,
            by
              have hx0 : x.1  S0 := by
                exact Finset.mem_coe.mp x.2
              show (boolFunEquivFin n) x.1  S
              exact Finset.mem_map.mpr  x.1, hx0, rfl  
        invFun := fun y =>
           (boolFunEquivFin n).symm y.1,
            by
              have hy : y.1  S := by
                exact Finset.mem_coe.mp y.2
              rcases Finset.mem_map.mp hy with  x0, hx0, hx0eq 
              have hx0eq' : (boolFunEquivFin n).symm y.1 = x0 := by
                have h := congrArg (fun z => (boolFunEquivFin n).symm z) hx0eq
                simp at h
                exact h.symm
              have hx0' : (boolFunEquivFin n).symm y.1  S0 := by
                rw [hx0eq']
                exact hx0
              exact hx0' 
        left_inv := by
          intro x; ext; simp
        right_inv := by
          intro y; ext; simp }
    let iso1 : G0 g G1 :=
      { toEquiv := eS
        map_rel_iff' := by
          intro a b
          -- Reduce to adjacency in the base graphs, then use the map-adj lemma.
          change (hypercube_graph_fin n).Adj (eS a).1 (eS b).1  (hypercube_graph n).Adj a.1 b.1
          simp [hypercube_graph_fin, eS] }
    let equivS := Fintype.equivFin {x // x  S}
    have iso2 : G1 g induced_hypercube_graph_fin_card S := by
      dsimp [induced_hypercube_graph_fin_card, G1]
      exact SimpleGraph.Iso.map equivS G1
    let iso : G0 g induced_hypercube_graph_fin_card S := iso2.comp iso1

    have h_deg_le_G0 :  v0 : {x // x  S0}, G0.degree v0  sensitivity f := by
      intro v0
      have h_map := SimpleGraph.map_neighborFinset_induce
        (G := hypercube_graph n) (s := (S0 : Set (Fin n  Bool))) v0
      have h_card :
          (G0.neighborFinset v0).card =
            ((hypercube_graph n).neighborFinset v0  S0).card := by
        have h_card' := congrArg Finset.card h_map
        simpa [G0, Finset.card_map, Finset.toFinset_coe, -SimpleGraph.card_neighborFinset_eq_degree] using
          h_card'
      have h_filter :
          (hypercube_graph n).neighborFinset v0  S0 =
            Finset.filter (fun y => (hypercube_graph n).Adj v0 y  y  S0) Finset.univ := by
        ext y
        simp [SimpleGraph.neighborFinset_eq_filter, Finset.mem_inter, Finset.mem_filter]
      have h_degree_formula :
          G0.degree v0 =
            (Finset.filter (fun y => (hypercube_graph n).Adj v0 y  y  S0) Finset.univ).card := by
        have h_card'' :
            (G0.neighborFinset v0).card =
              (Finset.filter (fun y => (hypercube_graph n).Adj v0 y  y  S0) Finset.univ).card := by
          rw [ h_filter]
          exact h_card
        rw [ SimpleGraph.card_neighborFinset_eq_degree]
        exact h_card''
      have h_eq' := h_eq v0.1 (by exact Finset.mem_coe.mp v0.2)
      have h_card_le :
          (Finset.filter (fun y => (hypercube_graph n).Adj v0 y  f v0  f y) Finset.univ).card
             sensitivity f := by
        unfold sensitivity
        have :=
          Finset.le_sup (s := Finset.univ)
            (f := fun x =>
              Finset.card
                (Finset.filter
                  (fun y =>
                    (Finset.card
                        (Finset.filter (fun i => x i  y i) Finset.univ) = 1)  f x  f y)
                  Finset.univ))
            (by simp : (v0 : Fin n  Bool)  (Finset.univ : Finset (Fin n  Bool)))
        simp [hypercube_graph_adj]
        exact this
      calc
        G0.degree v0
            = (Finset.filter (fun y => (hypercube_graph n).Adj v0 y  y  S0) Finset.univ).card := h_degree_formula
        _ = (Finset.filter (fun y => (hypercube_graph n).Adj v0 y  f v0  f y) Finset.univ).card := h_eq'
        _  sensitivity f := h_card_le

    have h_maxDegree_le : (induced_hypercube_graph_fin_card S).maxDegree  sensitivity f := by
      refine SimpleGraph.maxDegree_le_of_forall_degree_le (G := induced_hypercube_graph_fin_card S)
        (k := sensitivity f) ?_
      intro i
      let v0 := iso.symm i
      have hdeg : (induced_hypercube_graph_fin_card S).degree i = G0.degree v0 := by
        classical
        have hcard := Fintype.card_congr (iso.mapNeighborSet v0)
        have hiso :
            (induced_hypercube_graph_fin_card S).degree (iso v0) = G0.degree v0 := by
          calc
            (induced_hypercube_graph_fin_card S).degree (iso v0) =
                Fintype.card ((induced_hypercube_graph_fin_card S).neighborSet (iso v0)) := by
                  symm
                  simpa using
                    (SimpleGraph.card_neighborSet_eq_degree
                      (G := induced_hypercube_graph_fin_card S) (v := iso v0))
            _ = Fintype.card (G0.neighborSet v0) := by
                  simpa using hcard.symm
            _ = G0.degree v0 := by
                  simpa using (SimpleGraph.card_neighborSet_eq_degree (G := G0) (v := v0))
        have hv0 : iso v0 = i := by
          -- \`iso\` is an equivalence; rewrite with \`Equiv.apply_symm_apply\`.
          simp [v0]
        have hiso' := hiso
        rw [hv0] at hiso'
        exact hiso'
      rw [hdeg]
      exact h_deg_le_G0 v0

    -- Combine the bounds.
    have h_maxDegree_le' : (induced_hypercube_graph_fin_card S).maxDegree  (sensitivity f : ) := h_maxDegree_le
    have h_upper : evs_sub.getLast h_ne  (sensitivity f : ) := by
      exact le_trans h_lambda_le_max (by exact_mod_cast h_maxDegree_le')

    exact le_trans h_lower h_upper

  -- Pick the large level set (S_pos or S_neg).
  have h_large := exists_large_level_set f h_deg hn
  cases h_large with
  | inl hpos =>
      apply h_main (S_pos f)
       intro x hx
        simpa using (sensitivity_at_x_eq_degree_in_S_pos f x hx).symm
       exact hpos
  | inr hneg =>
      apply h_main (S_neg f)
       intro x hx
        simpa using (sensitivity_at_x_eq_degree_in_S_neg f x hx).symm
       exact hneg

/-
The sensitivity of a restriction is at most the sensitivity of the original function.
-/
def restriction {n : } (f : (Fin n  Bool)  Bool) (S : Finset (Fin n)) (z : Fin n  Bool) : (Fin (Fintype.card {x // x  S})  Bool)  Bool :=
  fun y =>
    let x : Fin n  Bool := fun i =>
      if h : i  S then
        y (Fintype.equivFin {j // j  S} i, h)
      else
        z i
    f x

lemma sensitivity_restriction_le {n : } (f : (Fin n  Bool)  Bool) (S : Finset (Fin n)) (z : Fin n  Bool) :
  sensitivity (restriction f S z)  sensitivity f := by
    unfold sensitivity;
    simp +decide only [Finset.sup_le_iff];
    intro x;
    simp +decide [ restriction ];
    refine' le_trans _ ( Finset.le_sup <| Finset.mem_univ <| fun i => if h : i  S then x ( Fintype.equivFin _  i, h  ) else z i );
    refine' le_trans _ ( Finset.card_le_card _ );
    rotate_left;
    exact Finset.image ( fun y : Fin ( Fintype.card { x // x  S })  Bool => fun i => if h : i  S then y ( Fintype.equivFin _  i, h  ) else z i ) ( Finset.filter ( fun y => Finset.card ( Finset.filter ( fun i => x i = y i ) Finset.univ ) = 1  f ( fun i => if h : i  S then x ( Fintype.equivFin _  i, h  ) else z i ) = f ( fun i => if h : i  S then y ( Fintype.equivFin _  i, h  ) else z i ) ) ( Finset.univ : Finset ( Fin ( Fintype.card { x // x  S })  Bool ) ) );
     simp +decide [ Finset.subset_iff ];
      rintro _ y hy hy rfl; simp_all +decide [ Finset.card_eq_one ] ;
      obtain  a, ha  := hy; use ( Fintype.equivFin { x // x  S } ).symm a; ext i; by_cases hi : i  S <;> simp_all +decide [ Finset.ext_iff ] ;
       aesop;
       intro H; have := ha a; simp_all +decide [ Fin.ext_iff ] ;
     rw [ Finset.card_image_of_injective ];
      intro y y hy; ext i; replace hy := congr_fun hy ( Fintype.equivFin { x // x  S } |>.symm i ) ; aesop;

/-
The Fourier coefficient of f at S is the average of the Fourier coefficients of the restrictions at univ.
-/
lemma fourier_coeff_restriction_avg {n : } (f : (Fin n  Bool)  Bool) (S : Finset (Fin n)) :
  fourier_coeff f S = (Finset.sum Finset.univ (fun z => fourier_coeff (restriction f S z) Finset.univ)) / 2^n := by
    unfold fourier_coeff;
    -- Let's simplify the expression using the definition of \`restriction\`.
    have h_restrict :  z : Fin n  Bool, ( x : Fin (Fintype.card {x : Fin n // x  S})  Bool, (if (restriction f S z x) then 1 else 0) * chi Finset.univ x) = ( x : Fin n  Bool, (if f x then 1 else 0) * (chi S x) * (if  i  S, x i = z i then 1 else 0)) := by
      intro z;
      have h_restrict : Finset.sum (Finset.univ.image (fun y : Fin (Fintype.card {x : Fin n // x  S})  Bool => fun i => if h : i  S then y (Fintype.equivFin {x : Fin n // x  S} i, h) else z i)) (fun x => (if f x then 1 else 0) * (chi S x)) = Finset.sum (Finset.univ : Finset (Fin (Fintype.card {x : Fin n // x  S})  Bool)) (fun y => (if (restriction f S z y) then 1 else 0) * (chi Finset.univ y)) := by
        rw [ Finset.sum_image ];
         refine' Finset.sum_congr rfl fun y hy => _;
          unfold chi restriction; simp +decide ;
          rw [ Finset.card_filter ];
          rw [  Finset.sum_attach ];
          rw [ Finset.card_filter ];
          rw [  Equiv.sum_comp ( Fintype.equivFin { x // x  S } ) ] ; aesop;
         intro y hy y' hy' h_eq;
          ext i; replace h_eq := congr_fun h_eq ( Fintype.equivFin { x // x  S } |>.symm i ) ; aesop;
      rw [  h_restrict, Finset.sum_image ];
       rw [  Finset.sum_subset ( Finset.subset_univ ( Finset.image ( fun y : Fin ( Fintype.card { x // x  S } )  Bool => fun i => if h : i  S then y ( Fintype.equivFin { x // x  S }  i, h  ) else z i ) Finset.univ ) ) ];
         rw [ Finset.sum_image ];
           exact Finset.sum_congr rfl fun x hx => by aesop;
           intro y hy y hy h_eq; ext i; replace h_eq := congr_fun h_eq ( Fintype.equivFin { x // x  S } |>.symm i ) ; aesop;
         simp +zetaDelta at *;
          intro x hx hx hx; specialize hx ( fun i => x ( Fintype.equivFin { x // x  S } |>.symm i ) ) ; simp_all +decide [ funext_iff ] ;
       intro y hy y hy h_eq; ext i; replace h_eq := congr_fun h_eq ( Fintype.equivFin { x // x  S } |>.symm i ) ; aesop;
    have h_restrict :  x : Fin n  Bool,  z : Fin n  Bool, (if  i  S, x i = z i then 1 else 0) = 2 ^ (Finset.card S) := by
      intros x
      have h_restrict : Finset.card (Finset.filter (fun z : Fin n  Bool =>  i  S, x i = z i) Finset.univ) = 2 ^ (Finset.card S) := by
        have h_restrict : Finset.card (Finset.image (fun z : Fin n  Bool => fun i : S => z i) (Finset.filter (fun z : Fin n  Bool =>  i  S, x i = z i) Finset.univ)) = 2 ^ (Finset.card S) := by
          rw [ show ( Finset.image ( fun z : Fin n  Bool => fun i : S => z i ) { z : Fin n  Bool |  i  S, x i = z i } ) = Finset.univ from ?_ ];
           simp +decide [ Finset.card_univ ];
           ext z; simp [Finset.mem_image];
            use fun i => if hi : i  S then z  i, hi  else x i; aesop;
        rw [  h_restrict, Finset.card_image_of_injOn ];
        intros z hz z' hz' h_eq;
        simp +zetaDelta at *;
        ext i; by_cases hi : i  S <;> simp_all +decide [ funext_iff ] ;
      aesop;
    have h_restrict :  z : Fin n  Bool,  x : Fin n  Bool, (if f x then 1 else 0) * (chi S x) * (if  i  S, x i = z i then 1 else 0) =  x : Fin n  Bool, (if f x then 1 else 0) * (chi S x) * 2 ^ (Finset.card S) := by
      rw [ Finset.sum_comm ];
      simp +decide only [ Finset.mul_sum _ _ _,  Finset.sum_mul];
      rw [ Finset.sum_mul ] ; exact Finset.sum_congr rfl fun _ _ => by aesop;
    have h_restrict :  z : Fin n  Bool,  x : Fin (Fintype.card {x : Fin n // x  S})  Bool, (if (restriction f S z x) then 1 else 0) * chi Finset.univ x =  x : Fin n  Bool, (if f x then 1 else 0) * (chi S x) * 2 ^ (Finset.card S) := by
      rw [  h_restrict, Finset.sum_congr rfl fun _ _ =>  z : Fin n  Bool,  x : Fin ( Fintype.card { x // x  S } )  Bool, ( if restriction f S z x = true then 1 else 0 ) * chi Finset.univ x =  x : Fin n  Bool, ( if f x = true then 1 else 0 ) * chi S x * if  i  S, x i = z i then 1 else 0 _ ];
    rw [  Finset.sum_div _ _ _ ];
    rw [ h_restrict,  Finset.sum_mul _ _ _ ];
    norm_num [ Fintype.card_subtype ]

/-
If the Fourier coefficient at S is non-zero, there is a restriction with non-zero Fourier coefficient at univ.
-/
lemma exists_restriction_fourier_coeff_univ_ne_zero {n : } (f : (Fin n  Bool)  Bool) (S : Finset (Fin n)) (hS : fourier_coeff f S  0) :
   z : Fin n  Bool, fourier_coeff (restriction f S z) Finset.univ  0 := by
    rw [ fourier_coeff_restriction_avg ] at hS;
    exact not_forall.mp fun h => hS <| by rw [ Finset.sum_eq_zero fun _ _ => h _ ] ; norm_num;

/-
If the Fourier coefficient at univ is non-zero, the degree is n.
-/
lemma degree_eq_n_of_fourier_coeff_univ_ne_zero {n : } (f : (Fin n  Bool)  Bool) (h : fourier_coeff f Finset.univ  0) :
  degree f = n := by
    refine' le_antisymm _ _;
     exact Finset.sup_le fun S hS => Nat.le_trans ( Finset.card_le_univ _ ) ( by norm_num );
     refine' le_trans _ ( Finset.le_sup <| Finset.mem_filter.mpr  Finset.mem_univ Finset.univ, h  );
      norm_num

/-
A boolean function of degree n has sensitivity at least sqrt(n).
-/
theorem sensitivity_conjecture {n : } (f : (Fin n  Bool)  Bool) :
  (sensitivity f : )  Real.sqrt (degree f) := by
    cases eq_or_ne ( degree f ) 0 <;> simp_all +decide;
    -- Let k = degree f. There exists a set S with |S| = k and f_hat(S)  0.
    obtain k, hk :  k : , k = degree f   S : Finset (Fin n), S.card = k  fourier_coeff f S  0 := by
      unfold degree at *;
      -- Since the set of S where fourier_coeff f S is non-zero is finite, it must have a maximum element in terms of cardinality.
      obtain S, hS :  S : Finset (Fin n), fourier_coeff f S  0   T : Finset (Fin n), fourier_coeff f T  0  T.card  S.card := by
        have h_finite : Set.Finite {S : Finset (Fin n) | fourier_coeff f S  0} := by
          exact Set.toFinite _;
        apply_rules [ Set.exists_max_image ];
        contrapose! h_finite; aesop;
      refine'  _, rfl, S, _, hS.1 ;
      refine' le_antisymm _ _;
       exact Finset.le_sup ( f := Finset.card ) ( by aesop );
       aesop;
    -- By \`exists_restriction_fourier_coeff_univ_ne_zero\`, there exists z such that the restriction g = restriction f S z has g_hat(univ)  0.
    obtain S, hS_card, hS_fourier := hk.2
    obtain z, hz :  z : Fin n  Bool, fourier_coeff (restriction f S z) Finset.univ  0 := by
      exact exists_restriction_fourier_coeff_univ_ne_zero f S hS_fourier
    -- By \`degree_eq_n_of_fourier_coeff_univ_ne_zero\`, degree g = k.
    have h_deg_g : degree (restriction f S z) = S.card := by
      have := degree_eq_n_of_fourier_coeff_univ_ne_zero ( restriction f S z ) hz; aesop;
    -- By \`sensitivity_ge_sqrt_degree_of_degree_eq_n\`, sensitivity g  k.
    have h_sens_g : (sensitivity (restriction f S z) : )  Real.sqrt (degree (restriction f S z)) := by
      have := sensitivity_ge_sqrt_degree_of_degree_eq_n ( restriction f S z ) ; aesop;
    -- By \`sensitivity_restriction_le\`, sensitivity f  sensitivity g.
    have h_sens_f : (sensitivity f : )  (sensitivity (restriction f S z) : ) := by
      exact_mod_cast sensitivity_restriction_le f S z;
    grind
`;function ev(){let[F,_]=CF.useState(0),[$,W]=CF.useState(null),[H,Y]=CF.useState(!1),K=$!==null?$:F,G=CF.useRef([]),U=CF.useRef(null),z=CF.useRef(null),h=[[0,236],[237,242],[243,248],[249,257],[258,290],[291,299],[300,317],[318,333],[334,380],[381,531],[532,544],[545,601],[602,822],[823,910],[911,938],[939,1277],[1278,1356],[1357,1387],[1388,1442],[1443,1465],[1466,1806],[1807,1854],[1855,1904],[1905,1935]];CF.useEffect(()=>{let T=new IntersectionObserver((P)=>{P.forEach((D)=>{if(D.isIntersecting){let O=G.current.findIndex((b)=>b===D.target);if(O!==-1)_(O),W(null)}})},{root:null,rootMargin:"-180px 0px -70% 0px",threshold:0});return G.current.forEach((P)=>{if(P)T.observe(P)}),()=>T.disconnect()},[]),CF.useEffect(()=>{if(z.current)z.current.scrollTo({top:0,behavior:"smooth"})},[K]);let A=I9[Math.min(K,I9.length-1)],N=tv.split(`
`),M=()=>{return h.map((T,P)=>{let[D,O]=T,b=N.slice(D,O+1),k=P===K;return f.jsxDEV("div",{ref:(y)=>{G.current[P]=y},className:`transition-all duration-300 cursor-pointer ${k?"bg-primer-gold/10":"hover:bg-stone-100"}`,"data-section":P,onMouseEnter:()=>W(P),children:[b.map((y,m)=>{let x=D+m+1,o=rv(y);return f.jsxDEV("div",{className:`px-2 hover:bg-stone-100/50 ${k?"border-l-4 border-primer-gold":"border-l-4 border-transparent"}`,children:[f.jsxDEV("span",{className:"inline-block w-10 text-stone-400 text-right mr-4 select-none text-xs",children:x},void 0,!1,void 0,this),o.map((s,j)=>{let V={keyword:"text-purple-600 font-semibold",type:"text-blue-600",function:"text-amber-600",comment:"text-stone-400 italic",string:"text-green-600",number:"text-orange-500",operator:"text-rose-500",punctuation:"text-stone-500",tactic:"text-teal-600 font-medium",text:"text-stone-800"}[s.type];return f.jsxDEV("span",{className:V,children:s.content},j,!1,void 0,this)})]},m,!0,void 0,this)}),P<h.length-1&&f.jsxDEV("div",{className:"h-4 border-l-4 border-transparent"},void 0,!1,void 0,this)]},P,!0,void 0,this)})};return f.jsxDEV("section",{className:"min-h-screen pt-24 pb-16",children:f.jsxDEV("div",{className:"max-w-7xl mx-auto px-4",children:[f.jsxDEV("div",{className:"text-center mb-8",children:[f.jsxDEV("h2",{className:"primer-heading text-4xl text-primer-ink mb-4",children:"Full Lean Formalization"},void 0,!1,void 0,this),f.jsxDEV("p",{className:"primer-text text-lg text-primer-accent max-w-2xl mx-auto",children:"Scroll through the complete proof. Explanations update as you explore different sections."},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"mb-8 bg-primer-gold-light p-6 rounded-lg",children:[f.jsxDEV("h4",{className:"primer-heading text-lg mb-4",children:"Proof Structure Summary"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"grid md:grid-cols-3 gap-6 text-sm",children:[f.jsxDEV("div",{children:[f.jsxDEV("h5",{className:"font-bold text-primer-accent mb-2",children:"Definitions"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"space-y-1 text-stone-700",children:[f.jsxDEV("li",{children:" sensitivity  max flip count"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" chi  parity character"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" fourier_coeff & degree"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" huang_matrix  signed adjacency"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{children:[f.jsxDEV("h5",{className:"font-bold text-primer-accent mb-2",children:"Spectral Theory"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"space-y-1 text-stone-700",children:[f.jsxDEV("li",{children:" A = nI"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" Eigenvalues: n"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" Interlacing theorem"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" Spectral radius bound"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{children:[f.jsxDEV("h5",{className:"font-bold text-primer-accent mb-2",children:"Combinatorics"},void 0,!1,void 0,this),f.jsxDEV("ul",{className:"space-y-1 text-stone-700",children:[f.jsxDEV("li",{children:" g-transform & level sets"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" Parity flip on edges"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" Degree = sensitivity in S"},void 0,!1,void 0,this),f.jsxDEV("li",{children:" Restriction monotonicity"},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"sticky top-16 z-20 bg-primer-paper py-4 -mx-4 px-4 border-b border-stone-200 shadow-sm",children:[f.jsxDEV("div",{className:"flex gap-1 flex-wrap justify-center mb-2",children:I9.map((T,P)=>f.jsxDEV("button",{onClick:()=>{let D=G.current[P];if(D)D.scrollIntoView({behavior:"smooth",block:"start"})},className:`px-2 py-1 text-xs rounded transition-all ${P===K?"bg-primer-gold text-white":P<K?"bg-cube-positive/20 text-cube-positive":"bg-stone-200 text-stone-600 hover:bg-stone-300"}`,title:T.title,children:P+1},P,!1,void 0,this))},void 0,!1,void 0,this),f.jsxDEV("div",{className:"w-full bg-stone-200 rounded-full h-1.5",children:f.jsxDEV("div",{className:"bg-primer-gold h-1.5 rounded-full transition-all duration-300",style:{width:`${(K+1)/I9.length*100}%`}},void 0,!1,void 0,this)},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"flex flex-col lg:flex-row gap-4 mt-6",children:[f.jsxDEV("div",{ref:U,className:"lg:w-[70%] min-w-0 overflow-hidden",onMouseEnter:()=>Y(!0),onMouseLeave:()=>Y(!1),children:f.jsxDEV("div",{className:"bg-stone-50 rounded-lg border border-stone-200 overflow-x-auto",children:f.jsxDEV("pre",{className:"text-xs font-mono leading-relaxed p-3 whitespace-pre min-w-0",children:M()},void 0,!1,void 0,this)},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("div",{ref:z,className:"lg:w-[30%] lg:sticky lg:top-36 lg:max-h-[calc(100vh-10rem)] lg:overflow-y-auto",children:[f.jsxDEV("div",{className:"bg-white rounded-lg primer-border p-6 shadow-lg",children:[f.jsxDEV("div",{className:"flex items-center gap-3 mb-4",children:[f.jsxDEV("span",{className:"w-10 h-10 rounded-full bg-primer-gold text-white flex items-center justify-center font-bold",children:K+1},void 0,!1,void 0,this),f.jsxDEV("span",{className:"text-xs text-stone-500 uppercase tracking-wide",children:["Section ",K+1," of ",I9.length]},void 0,!0,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("h3",{className:"primer-heading text-2xl text-primer-ink mb-3",children:A.title},void 0,!1,void 0,this),f.jsxDEV("p",{className:"primer-text text-stone-700 mb-4 leading-relaxed",children:A.description},void 0,!1,void 0,this),f.jsxDEV(EI,{content:CI[A.sectionNumber]||"Loading...",className:"text-stone-800"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"mt-4 pt-4 border-t border-stone-200 text-xs text-stone-500",children:["Lines ",(h[K]?.[0]??0)+1,"",(h[K]?.[1]??0)+1]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"mt-6 pt-4 border-t border-stone-200 text-sm text-stone-500",children:f.jsxDEV("p",{children:"Scroll the code panel to explore, or click the section numbers above."},void 0,!1,void 0,this)},void 0,!1,void 0,this)]},void 0,!0,void 0,this),f.jsxDEV("div",{className:"lg:hidden flex gap-2 mt-4",children:[f.jsxDEV("button",{onClick:()=>{let T=Math.max(0,K-1);G.current[T]?.scrollIntoView({behavior:"smooth",block:"center"})},disabled:K===0,className:`flex-1 py-2 rounded-lg font-semibold ${K===0?"bg-stone-300 text-stone-500":"bg-primer-ink text-white"}`,children:" Previous"},void 0,!1,void 0,this),f.jsxDEV("button",{onClick:()=>{let T=Math.min(I9.length-1,K+1);G.current[T]?.scrollIntoView({behavior:"smooth",block:"center"})},disabled:K===I9.length-1,className:`flex-1 py-2 rounded-lg font-semibold ${K===I9.length-1?"bg-stone-300 text-stone-500":"bg-primer-ink text-white"}`,children:"Next "},void 0,!1,void 0,this)]},void 0,!0,void 0,this),K===I9.length-1&&f.jsxDEV("div",{className:"mt-6 bg-primer-accent text-white p-6 rounded-lg text-center",children:[f.jsxDEV("h4",{className:"text-xl font-bold mb-2",children:"Proof Complete!"},void 0,!1,void 0,this),f.jsxDEV("div",{className:"my-4",children:f.jsxDEV(YF,{display:!0,children:"s(f) \\geq \\sqrt{\\deg(f)} \\quad \\blacksquare"},void 0,!1,void 0,this)},void 0,!1,void 0,this),f.jsxDEV("p",{className:"text-sm opacity-90",children:"You've explored the complete Lean formalization of the Sensitivity Conjecture."},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)},void 0,!1,void 0,this)}function Fb(){let[F,_]=CF.useState("intro"),$=()=>{switch(F){case"intro":return f.jsxDEV(lv,{},void 0,!1,void 0,this);case"cube":return f.jsxDEV(dv,{},void 0,!1,void 0,this);case"sensitivity":return f.jsxDEV(iv,{},void 0,!1,void 0,this);case"fourier":return f.jsxDEV(nv,{},void 0,!1,void 0,this);case"gTransform":return f.jsxDEV(cv,{},void 0,!1,void 0,this);case"huang":return f.jsxDEV(sv,{},void 0,!1,void 0,this);case"spectral":return f.jsxDEV(ov,{},void 0,!1,void 0,this);case"proof":return f.jsxDEV(av,{},void 0,!1,void 0,this);case"leanProof":return f.jsxDEV(ev,{},void 0,!1,void 0,this)}},W=["intro","cube","sensitivity","fourier","gTransform","huang","spectral","proof","leanProof"],H=W.indexOf(F);return f.jsxDEV("div",{className:"min-h-screen bg-primer-paper",children:[f.jsxDEV(bv,{currentSection:F,setSection:_},void 0,!1,void 0,this),$(),f.jsxDEV("div",{className:"max-w-4xl mx-auto px-4 pb-16 flex justify-between",children:[f.jsxDEV("button",{onClick:()=>{if(H>0)_(W[H-1])},className:`px-8 py-4 rounded-lg text-lg font-semibold transition-all shadow-md ${F==="intro"?"bg-stone-300 text-stone-500 cursor-not-allowed":"bg-primer-ink text-white hover:bg-primer-accent"}`,disabled:F==="intro",children:" Previous"},void 0,!1,void 0,this),f.jsxDEV("button",{onClick:()=>{if(H<W.length-1)_(W[H+1])},className:`px-8 py-4 rounded-lg text-lg font-semibold transition-all shadow-md ${F==="leanProof"?"bg-stone-300 text-stone-500 cursor-not-allowed":"bg-primer-ink text-white hover:bg-primer-accent"}`,disabled:F==="leanProof",children:"Next "},void 0,!1,void 0,this)]},void 0,!0,void 0,this)]},void 0,!0,void 0,this)}var qb=PI.createRoot(document.getElementById("root"));qb.render(f.jsxDEV(Fb,{},void 0,!1,void 0,this));
