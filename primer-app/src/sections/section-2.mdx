# Section 2: Equivalences and Huang matrix definition


---

This section defines three explicit type equivalences in Lean. They are not just abstract conveniences: they are exactly the "index bookkeeping" needed to describe the recursive block structure of the Huang matrix when rows/columns are indexed by Boolean hypercube vertices.

Below is what each definition does, how it works, and why it matters for the Huang matrix.

---

## 1) `boolProdEquivSum_custom` : `Bool × α ≃ α ⊕ α`

**Lean definition**
```lean
def boolProdEquivSum_custom {α : Type*} : Bool × α ≃ α ⊕ α where
  toFun := fun p => if p.1 then Sum.inr p.2 else Sum.inl p.2
  invFun := fun s => match s with
    | Sum.inl a => (false, a)
    | Sum.inr a => (true, a)
  left_inv := by
    rintro ⟨ _ | _, _ ⟩ <;> simp +decide
  right_inv := by
    rintro (a | a) <;> rfl
```

### What it means
- A pair `(b, a)` with `b : Bool` and `a : α` can be seen as **"choose left or right copy of α"** depending on `b`.
- Thus `Bool × α` is equivalent to `α ⊕ α` (a sum of two copies of `α`).

### How it works
- **Forward map**: send `(true, a)` to `Sum.inr a` and `(false, a)` to `Sum.inl a`.
- **Inverse map**: send `Sum.inl a` back to `(false, a)`, and `Sum.inr a` back to `(true, a)`.
- The proofs `left_inv` and `right_inv` show these two functions undo each other.

### Why it matters
When you split the Boolean hypercube by the first coordinate, every vertex is "either in the 0-slice or the 1-slice." The sum type `α ⊕ α` captures exactly this "either/or" split, which is perfect for block matrices: the two summands correspond to two diagonal blocks.

---

## 2) `finSuccEquiv_custom` : `(Fin (n+1) → α) ≃ α × (Fin n → α)`

**Lean definition**
```lean
def finSuccEquiv_custom (n : ℕ) (α : Type*) : (Fin (n + 1) → α) ≃ α × (Fin n → α) where
  toFun f := (f 0, f ∘ Fin.succ)
  invFun p := Fin.cons p.1 p.2
  left_inv f := by
    ext i
    refine Fin.cases ?_ ?_ i <;> simp
  right_inv p := by
    ext <;> simp
```

### What it means
- A function `f : Fin (n+1) → α` is completely determined by:
  1) its value at `0`, and
  2) its values on the remaining indices `{1, …, n}` (which are in bijection with `Fin n`).
- So such a function is equivalent to a pair `(α, Fin n → α)`.

### How it works
- **Forward map**: `f ↦ (f 0, f ∘ Fin.succ)`.
  - `Fin.succ : Fin n → Fin (n+1)` is the canonical injection that maps `i` to `i+1`.
  - So `f ∘ Fin.succ` is the "tail" of `f`, giving values at indices `1, 2, ..., n`.
- **Inverse map**: `Fin.cons p.1 p.2` rebuilds a function from a head value `p.1` and tail `p.2`.
  - `Fin.cons : α → (Fin n → α) → (Fin (n+1) → α)` prepends a head to a tail.
- The proof uses `Fin.cases` to split the index into "zero" vs. "successor."

### Why it matters
Vertices of the Boolean hypercube of dimension `n+1` are functions `Fin (n+1) → Bool`. This equivalence lets you pull out the first coordinate explicitly as a separate piece. It is the fundamental "peel off the first bit" operation.

---

## 3) `finSuccEquiv_huang_custom` : `(Fin (n+1) → Bool) ≃ (Fin n → Bool) ⊕ (Fin n → Bool)`

**Lean definition**
```lean
def finSuccEquiv_huang_custom (n : ℕ) : (Fin (n + 1) → Bool) ≃ (Fin n → Bool) ⊕ (Fin n → Bool) :=
  Equiv.trans
    (finSuccEquiv_custom n Bool)
    (boolProdEquivSum_custom)
```

### What it means
This simply **composes** the previous two equivalences:
1) First, split a Boolean function on `Fin (n+1)` into `(Bool, Fin n → Bool)`.
2) Then turn `(Bool, Fin n → Bool)` into a sum of two copies of `Fin n → Bool`.

So we get a clean equivalence:

```
(Fin (n+1) → Bool)  ≃  (Fin n → Bool) ⊕ (Fin n → Bool)
```

**Summand ordering convention**: The composition sends:
- `(false, tail)` to `Sum.inl tail` — the "left" or "top" block
- `(true, tail)` to `Sum.inr tail` — the "right" or "bottom" block

This means vertices with first coordinate `false` go to `Sum.inl`, and vertices with first coordinate `true` go to `Sum.inr`. This ordering determines which block of the matrix corresponds to which summand.

`Equiv.trans` composes equivalences: if `e₁ : A ≃ B` and `e₂ : B ≃ C`, then `Equiv.trans e₁ e₂ : A ≃ C`.

### Why it matters for the Huang matrix
The Huang matrix `A_n` is indexed by Boolean hypercube vertices, i.e.

```
indices_n := Fin n → Bool
```

The recursion for `A_{n+1}` is a **block matrix** with four `2^n × 2^n` blocks:

- top-left: `A_n`
- top-right: `I`
- bottom-left: `I`
- bottom-right: `-A_n`

To even *state* this block structure in Lean, you must identify the index set for dimension `n+1` with **two copies** of the index set for dimension `n`.

That is exactly what `finSuccEquiv_huang_custom` gives you:

```
indices_{n+1}  ≃  indices_n ⊕ indices_n
```

Once you have this equivalence, you can:
- reindex rows and columns of `A_{n+1}` into "upper" and "lower" halves,
- align those halves with the two copies of `indices_n`, and
- express the recursion as a block matrix in a type-correct way.

Without this explicit equivalence, the block recursion is only informal. With it, Lean can treat `A_{n+1}` as a matrix indexed by a sum type and accept the block decomposition.

---

## Summary
- `boolProdEquivSum_custom` turns a Boolean choice into a sum type.
- `finSuccEquiv_custom` peels off the first coordinate of a function on `Fin (n+1)`.
- `finSuccEquiv_huang_custom` combines both to split the Boolean hypercube into two copies of the `n`-dimensional hypercube.

This is precisely the indexing trick needed to define the Huang matrix recursion as a block matrix in Lean.

---

This section defines a family of matrices `huang_matrix (n : ℕ)` over `ℝ` indexed by Boolean vectors of length `n`.

```lean
def huang_matrix (n : ℕ) : Matrix (Fin n → Bool) (Fin n → Bool) ℝ :=
  match n with
  | 0 => 0
  | n + 1 => Matrix.reindex (finSuccEquiv_huang_custom n).symm (finSuccEquiv_huang_custom n).symm
      (Matrix.fromBlocks (huang_matrix n) (1 : Matrix _ _ ℝ) (1 : Matrix _ _ ℝ) (-huang_matrix n))
```

## 1. What the type says

`Matrix (Fin n → Bool) (Fin n → Bool) ℝ` is a square matrix whose rows and columns are indexed by functions `Fin n → Bool`, i.e. Boolean vectors of length `n`.

So for each `n`, `huang_matrix n` is a `2^n × 2^n` real matrix, but it is indexed by *functions* rather than integer indices.

**Why 2^n?** The type `Fin n → Bool` is a function type with `2^n` elements: there are 2 choices (true/false) for each of the `n` positions. Lean's `Fintype` instance computes `Fintype.card (Fin n → Bool) = 2^n` via `Fintype.card_pi`.

## 2. Base case: `n = 0`

```lean
| 0 => 0
```

When `n = 0`, the index type `Fin 0 → Bool` has exactly one element (the empty function), so the matrix is `1 × 1`. The definition returns `0`, the zero matrix of that size.

**Note**: This means `H_0 = [0]`, the 1×1 zero matrix. This satisfies `H_0² = 0·I` (since 0² = 0 and 0·I = 0 for the 1×1 identity). The formula `H_n² = n·I` holds with `n = 0`.

## 3. Recursive case: `n + 1`

```lean
| n + 1 => Matrix.reindex ... (Matrix.fromBlocks ...)
```

The recursive step builds `huang_matrix (n+1)` as a **2×2 block matrix**, where each block is itself a matrix indexed by Boolean vectors of length `n`.

### 3.1 The block structure

The key expression is:

```lean
Matrix.fromBlocks (huang_matrix n) (1 : Matrix _ _ ℝ)
                  (1 : Matrix _ _ ℝ) (-huang_matrix n)
```

`Matrix.fromBlocks A B C D` builds the block matrix

```
[ A  B ]
[ C  D ]
```

Here:

- `A` is `huang_matrix n`
- `D` is `-huang_matrix n`
- `B` and `C` are both `1`, the identity matrix of appropriate size

**Lean notation**: In Lean's matrix library, `1 : Matrix α α R` denotes the identity matrix (diagonal 1s, off-diagonal 0s), not the all-ones matrix. This is the multiplicative identity in the matrix ring.

So the recursive definition is:

```
H_{n+1} = [  H_n     I ]
          [   I   -H_n ]
```

This is a classic recursive block construction, similar in spirit to Hadamard-type recurrences but with identity matrices on the off-diagonals and a sign flip on the bottom-right block.

### 3.2 Where the indices live

`fromBlocks` naturally produces a matrix indexed by a *sum type* of indices:

```
(Fin n → Bool) ⊕ (Fin n → Bool)
```

That is, it expects row and column indices to be either a "left" index (top block) or a "right" index (bottom block).

But we want the final result indexed by `Fin (n+1) → Bool` (Boolean vectors of length `n+1`).

### 3.3 Reindexing with an equivalence

That is why we wrap the block matrix with `Matrix.reindex`:

```lean
Matrix.reindex (finSuccEquiv_huang_custom n).symm
               (finSuccEquiv_huang_custom n).symm
               (Matrix.fromBlocks ...)
```

- `finSuccEquiv_huang_custom n` is an equivalence between
  `Fin (n+1) → Bool` and `(Fin n → Bool) ⊕ (Fin n → Bool)`
  (defined in **Section 5**). It splits a length-`n+1` Boolean vector into the first bit choosing left (`Sum.inl` for `false`) or right (`Sum.inr` for `true`), with the remaining `n` bits giving the index within that block.
- The `.symm` uses the inverse direction because `fromBlocks` already lives in the sum-indexed world.

So `reindex` converts the block-indexed matrix into one indexed by Boolean vectors of length `n+1`.

## 4. Why this is a recursive block definition

Putting it all together:

- `H_0` is the zero 1×1 matrix.
- `H_{n+1}` is built from `H_n` in a 2×2 block pattern:
  - top-left is `H_n`
  - bottom-right is `-H_n`
  - off-diagonals are identity matrices
- a reindexing step converts block indices into Boolean-vector indices

This is a canonical recursive block matrix definition: you double the dimension by stacking four blocks, two of which are the previous matrix (one with a sign flip), and two of which are identity matrices.

## 5. The accompanying statement

The comment at the end hints at a key property of the Huang matrices:

```lean
/-
The square of the Huang matrix A_n is n times the identity matrix.
-/
```

So the recursion is set up to make `H_n^2 = n * I` true for all `n`. The block form makes it possible to prove this by induction, since block multiplication decomposes into the same four-block pattern.

---

**Summary:** `huang_matrix` is defined recursively by a 2×2 block construction, with off-diagonal identities, a sign flip on the bottom-right, and a reindexing step to convert the block sum indices into Boolean-vector indices. This is the Lean encoding of a structured matrix recurrence that supports an inductive proof of its algebraic properties.