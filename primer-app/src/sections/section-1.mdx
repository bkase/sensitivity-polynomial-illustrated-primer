# Section 1: Core definitions


---

This section defines the *sensitivity* of a Boolean function ‚Äî the central concept in the Sensitivity Conjecture.

## What sensitivity measures

For a Boolean function \(f : \{0,1\}^n \to \{0,1\}\), the **sensitivity** of `f` is the maximum, over all inputs `x`, of how many single-bit flips change the output. Informally:

- Fix an input `x`.
- Flip exactly one coordinate to get a neighbor `y`.
- Count how many such neighbors change `f`'s value.
- Sensitivity is the maximum of that count over all `x`.

So sensitivity measures how locally "fragile" the function is: if many one-bit changes flip the output, `f` is highly sensitive at that input.

## The Lean definition

The code in this section is:

```lean
def sensitivity {n : ‚Ñï} (f : (Fin n ‚Üí Bool) ‚Üí Bool) : ‚Ñï :=
  Finset.sup Finset.univ (fun x =>
    Finset.card
      (Finset.filter
        (fun y =>
          (Finset.card (Finset.filter (fun i => x i ‚â† y i) Finset.univ) = 1)
          ‚àß f x ‚â† f y)
        Finset.univ))
```

Let's unpack this in pieces.

### Term-level definition (no tactics)

This snippet is written entirely in **term mode** (a direct expression), not in tactic mode. There are **no tactics** here ‚Äî no `by`, `simp`, `linarith`, etc. Everything is a nested expression that Lean can typecheck without any proof scripting.

### Types and inputs

- `n : ‚Ñï` is the input size.
- An input vector `x` is represented as a function `Fin n ‚Üí Bool`, i.e., a Boolean value for each index `0, 1, ..., n-1`.
- The Boolean function is `f : (Fin n ‚Üí Bool) ‚Üí Bool`.

**Correspondence with standard notation**: In the mathematical literature, inputs are elements of `{0,1}^n`. In Lean, we use `Fin n ‚Üí Bool` with the convention:
- `false` corresponds to `0`
- `true` corresponds to `1`

So a Boolean vector like `(0, 1, 1, 0)` becomes the function `fun i => if i = 1 ‚à® i = 2 then true else false`.

### Finsets and `Finset.univ`

Lean uses finite sets (`Finset`) to quantify over all elements of a finite type. Here:

- `Finset.univ` over `Fin n ‚Üí Bool` is the set of all Boolean vectors of length `n`.
- `Finset.univ` over `Fin n` is the set of all indices `0..n-1`.
- `Finset` is a data type for finite sets with decidable equality; it carries a list-like representation plus proofs that duplicates are removed.

**Why this works**: Lean knows that `Fin n ‚Üí Bool` is a finite type via the `Fintype` instance for function types. Specifically, `Fintype.card (Fin n ‚Üí Bool) = 2^n` because there are 2 choices (true/false) for each of the `n` positions. This instance allows `Finset.univ` to enumerate all `2^n` Boolean vectors.

### Counting Hamming distance 1

Inside the definition, this fragment:

```lean
Finset.card (Finset.filter (fun i => x i ‚â† y i) Finset.univ)
```

counts the number of indices `i` where `x i` differs from `y i`. This is the Hamming distance between `x` and `y`.

The condition

```lean
(... = 1)
```

forces `y` to differ from `x` in exactly one coordinate.

### Counting sensitive neighbors

The inner filter is:

```lean
Finset.filter (fun y => (distance = 1) ‚àß f x ‚â† f y) Finset.univ
```

So for a fixed `x`, it keeps all `y` with Hamming distance 1 from `x` and where `f` flips value. Then:

```lean
Finset.card (...)
```

counts how many such `y` exist. This is the **sensitivity of `f` at `x`**.

### Taking the maximum

Finally,

```lean
Finset.sup Finset.univ (fun x => ...)
```

computes the supremum of that count across all inputs `x`. This yields the overall sensitivity of `f`.

**Technical note on `Finset.sup`**: This is the lattice supremum operation. For natural numbers (`‚Ñï`), the lattice supremum is simply the maximum. The function `Finset.sup` requires a `SemilatticeSup` instance with a bottom element `‚ä•`; for `‚Ñï`, this bottom is `0`. If the set is empty, `Finset.sup` returns `‚ä• = 0`. For nonempty sets, you could equivalently use `Finset.sup'` which doesn't need the bottom element but requires a nonemptiness proof.

## Worked example: the OR function

Let `n = 3` and define `f` to be the OR function:

```lean
def or3 : (Fin 3 ‚Üí Bool) ‚Üí Bool := fun x => x 0 || x 1 || x 2
```

In standard notation, `or3(x‚ÇÄ, x‚ÇÅ, x‚ÇÇ) = x‚ÇÄ ‚à® x‚ÇÅ ‚à® x‚ÇÇ`, which is `true` if any bit is `true`.

**Analyzing sensitivity at each input:**

- `x = (false, false, false)` (the all-zeros input):
  - Neighbors are `(true, false, false)`, `(false, true, false)`, `(false, false, true)`
  - All three neighbors have `or3 = true`, while `or3 x = false`
  - So sensitivity at this input is **3**

- `x = (true, true, true)` (the all-ones input):
  - Neighbors are `(false, true, true)`, `(true, false, true)`, `(true, true, false)`
  - All three neighbors still have `or3 = true`, same as `or3 x = true`
  - So sensitivity at this input is **0**

- `x = (true, false, false)`:
  - Neighbors: `(false, false, false)` has `or3 = false` ‚â† `or3 x = true` ‚úì
  - Neighbors: `(true, true, false)` and `(true, false, true)` have `or3 = true` = `or3 x`
  - So sensitivity at this input is **1**

The maximum over all 8 inputs is **3**, achieved at the all-zeros input. Thus `sensitivity or3 = 3`.

In Lean, the definition enumerates all `x : Fin 3 ‚Üí Bool` (8 inputs), counts sensitive neighbors for each, and takes the maximum via `Finset.sup`.

## Formal mathematical definition

For completeness, here is the standard mathematical definition that the Lean code encodes:

**Definition**: The **sensitivity at input \(x\)** is:
\[
s(f, x) = |\{i \in [n] : f(x) \neq f(x^{\oplus i})\}|
\]
where \(x^{\oplus i}\) denotes \(x\) with the \(i\)-th bit flipped.

**Definition**: The **sensitivity of \(f\)** is:
\[
s(f) = \max_{x \in \{0,1\}^n} s(f, x)
\]

The Lean definition directly implements this: `Finset.filter` computes the set \(\{i : f(x) \neq f(x^{\oplus i})\}\), `Finset.card` computes its cardinality, and `Finset.sup` computes the maximum.

## Summary

- The definition computes the maximum number of one-bit flips that change \(f\).
- It uses `Finset.univ` to enumerate all inputs and all indices.
- The Hamming distance test `= 1` enforces single-bit flips.
- The final `Finset.sup` takes the maximum over all inputs.

This is a direct, faithful Lean translation of the standard mathematical definition of sensitivity.

---

This section defines the Boolean character \(\chi_S(x)\), a basic building block of Fourier analysis on the Boolean cube \(\{0,1\}^n\).

## Definition in math form

The Lean code defines:

```lean
def chi {n : ‚Ñï} (S : Finset (Fin n)) (x : Fin n ‚Üí Bool) : ‚Ñù :=
  if (Finset.filter (fun i => x i) S).card % 2 = 0 then 1 else -1
```

Translated to math, if we view a Boolean input \(x : \{0,1\}^n\) and a subset \(S \subseteq [n]\), then

\[
\chi_S(x) = (-1)^{|\{ i \in S : x_i = 1 \}|}.
\]

In words: count how many indices in \(S\) have value 1 under \(x\). If that count is even, \(\chi_S(x) = 1\); if it is odd, \(\chi_S(x) = -1\).

The code expresses exactly this parity test:
- `Finset.filter (fun i => x i) S` is the subset of \(S\) where \(x_i\) is true.
- `.card % 2` takes the parity of that count.
- Even parity gives `1`, odd parity gives `-1`.

## Why it always returns ¬±1

Because \(\chi_S(x)\) is defined as a parity test, it has only two possible outcomes:
- If the count of ones in \(S\) is even, then \(\chi_S(x)=1\).
- If the count is odd, then \(\chi_S(x)=-1\).

There is no other possibility. Parity only distinguishes even vs. odd, so the output is always \(+1\) or \(-1\).

Another way to see this is through the exponent form:
\[
\chi_S(x) = (-1)^{k}, \quad k = |\{ i \in S : x_i = 1 \}|.
\]
When \(k\) is even, \((-1)^k=1\); when \(k\) is odd, \((-1)^k=-1\).

## Role in Fourier analysis on the Boolean cube

The characters \(\chi_S\) form the Fourier basis for functions \(f : \{0,1\}^n \to \mathbb{R}\). Concretely:

- The collection \(\{\chi_S : S \subseteq [n]\}\) is an orthonormal basis under the inner product
  \[
  \langle f, g \rangle = \mathbb{E}_x[f(x)g(x)] = \frac{1}{2^n} \sum_{x \in \{0,1\}^n} f(x)g(x),
  \]
  where \(x\) is uniformly random in \(\{0,1\}^n\).

**Orthonormality proof sketch**: To show \(\langle \chi_S, \chi_T \rangle = \delta_{S,T}\):
- When \(S = T\): \(\chi_S(x)^2 = 1\) for all \(x\), so \(\mathbb{E}[\chi_S^2] = 1\).
- When \(S \neq T\): Let \(i \in S \triangle T\) (the symmetric difference). For each assignment to coordinates outside \(\{i\}\), flipping \(x_i\) flips the sign of \(\chi_S(x)\chi_T(x)\). Since exactly half the inputs have \(x_i = 0\) and half have \(x_i = 1\), the contributions cancel, giving \(\mathbb{E}[\chi_S \chi_T] = 0\).

- Every function can be expanded as
  \[
  f(x) = \sum_{S \subseteq [n]} \hat f(S) \chi_S(x).
  \]

- The Fourier coefficient for subset \(S\) is exactly the expectation noted in the Lean comment:
  \[
  \hat f(S) = \mathbb{E}_x\big[f(x)\,\chi_S(x)\big].
  \]

Intuitively, \(\chi_S\) measures the parity of \(x\) on the coordinates in \(S\). Multiplying by \(\chi_S(x)\) and averaging over all \(x\) tells us how much of that parity pattern is present in \(f\). Large coefficients indicate that \(f\) correlates with the parity on \(S\).

Finally, the **Fourier degree** (or simply **degree**) of a function \(f : \{0,1\}^n \to \mathbb{R}\) is the largest size \(|S|\) for which \(\hat f(S)\neq 0\). This is the maximum order of parity interaction appearing in the Fourier expansion. For a Boolean function \(f : \{0,1\}^n \to \{0,1\}\), we treat the output as real-valued (0 or 1) and apply the same definition. By convention, the constant zero function has degree 0 (or sometimes ‚àí‚àû).

## Summary

- \(\chi_S(x)\) is defined as \((-1)^{|\{i \in S : x_i = 1\}|}\), computed via a parity test.
- It always returns \(+1\) or \(-1\).
- The characters \(\chi_S\) form an orthonormal Fourier basis on the Boolean cube.
- Fourier coefficients measure correlation with parity patterns.
- The degree of a Boolean function is the largest set size with a nonzero Fourier coefficient.

---

This section introduces two definitions in Lean:

```lean
noncomputable def fourier_coeff {n : ‚Ñï} (f : (Fin n ‚Üí Bool) ‚Üí Bool) (S : Finset (Fin n)) : ‚Ñù :=
  (Finset.sum Finset.univ (fun x => (if f x then 1 else 0) * chi S x)) / 2^n

noncomputable def degree {n : ‚Ñï} (f : (Fin n ‚Üí Bool) ‚Üí Bool) : ‚Ñï :=
  Finset.sup (Finset.filter (fun S => fourier_coeff f S ‚â† 0) Finset.univ) Finset.card
```

The `noncomputable` keyword tells Lean this definition relies on classical choice or real-number operations that are not algorithmically computable.

---

## 1. Boolean functions as real‚Äëvalued functions

A Boolean function `f : (Fin n ‚Üí Bool) ‚Üí Bool` takes an `n`‚Äëbit input and returns a Boolean output. The Fourier analysis of Boolean functions usually works with real‚Äëvalued functions, so the code converts the output to a real number using:

```lean
(if f x then 1 else 0)
```

This maps `false ‚Ü¶ 0` and `true ‚Ü¶ 1`. (Sometimes the literature uses `{-1, +1}` instead; here we stick to `{0,1}` because that's exactly what the code does.)

---

## 2. Fourier coefficients in the code

### The definition

```lean
fourier_coeff f S =
  (sum over all x) ((if f x then 1 else 0) * chi S x) / 2^n
```

This is the average value of `f(x) * chi_S(x)` over all inputs `x`.

### What is `chi S x`?

`chi S x` is the parity character defined in **Section 3**:

```lean
chi S x = (-1)^{|{i ‚àà S : x i = true}|}
```

It returns `+1` if an even number of coordinates in `S` are true, and `-1` if odd. This is the standard Fourier basis function for Boolean analysis.

### Expectation interpretation

The Fourier coefficient is the expectation of `f(x) ¬∑ œá_S(x)` under the uniform distribution:

```
fourier_coeff f S = ùîº_x[f(x) ¬∑ œá_S(x)] = (1/2^n) ¬∑ Œ£_{x ‚àà {0,1}^n} f(x) ¬∑ œá_S(x)
```

where `f(x)` is treated as 0 or 1 (the `{0,1}` encoding). This measures how much `f` "aligns" with the parity pattern on `S`.

---

## 3. Degree from Fourier support

The second definition uses the Fourier coefficients to define the **degree**:

```lean
degree f =
  sup (card S) over all S with fourier_coeff f S ‚â† 0
```

In words:

- Look at every subset `S` of variables.
- Keep only those where the Fourier coefficient is nonzero.
- Take the maximum size of such a set.

This is exactly the **Fourier degree**: the largest subset size for which the Fourier expansion has a non‚Äëzero coefficient.

**Convention for edge cases**: If `f` is the constant zero function, then all Fourier coefficients are zero, and `Finset.sup` over an empty set returns `0` (the lattice bottom for `‚Ñï`). So the constant zero function has degree 0. The constant one function has `fourier_coeff f ‚àÖ = 1 ‚â† 0` and all other coefficients zero, so it also has degree 0.

### Intuition

- Low degree means the function is well‚Äëapproximated by small‚Äëinteraction terms (few variables at a time).
- High degree means the function needs large, global parity patterns to describe it.

---

## 4. Connection to sensitivity

**Sensitivity** measures how many single‚Äëbit flips can change the function's value at a given input. For a Boolean function `f`, the sensitivity at input `x` counts how many coordinates `i` satisfy:

```
  f(x) ‚â† f(x with bit i flipped)
```

The maximum of that count over all `x` is the sensitivity of `f`.

### Why Fourier degree matters

Fourier analysis provides a powerful bridge between algebraic structure and combinatorial measures like sensitivity:

- A nonzero Fourier coefficient on a large set `S` means the function depends (in a parity sense) on many variables at once.
- That kind of global dependence tends to force the function to be sensitive to bit flips.

More concretely:

- If a function has **high Fourier degree**, then there must be some input where many variables matter. That often implies higher sensitivity.
- Conversely, if the function has very low sensitivity everywhere, the Fourier expansion tends to concentrate on small sets, leading to low degree.

This is the basic intuition behind the **Sensitivity Conjecture** (now a theorem, proved by Huang 2019):

**Theorem (Sensitivity Conjecture)**: For any Boolean function `f : {0,1}^n ‚Üí {0,1}`,
```
sensitivity(f) ‚â• ‚àö(degree(f))
```

This says that high Fourier degree implies high sensitivity. The Lean formalization in this project proves exactly this inequality. The converse direction (`degree(f) ‚â§ sensitivity(f)^2`) is easier and was known earlier; together they show that sensitivity and degree are polynomially related.

---

## 5. Takeaway

- `fourier_coeff f S` is the normalized correlation of `f` with the parity character on `S`.
- `degree f` is the maximum size of a subset with a nonzero Fourier coefficient.
- High degree captures global interactions among many variables.
- Sensitivity captures how fragile `f` is to individual bit flips.
- Fourier degree and sensitivity are tightly linked, making Fourier analysis a natural tool for studying sensitivity.

---

If you want, the next step is to look at how `chi S x` is defined in the Lean code and how the `{0,1}` output encoding compares to the more common `{‚àí1,+1}` normalization‚Äîthis will clarify constants and sign conventions in later lemmas.