# Section 7: Hypercube graph and adjacency bridge


---

This section formalizes the n-dimensional hypercube graph in Lean and records a few key properties that connect adjacency, parity, and induced subgraphs. The vertices are Boolean vectors of length `n`, modeled as functions `Fin n -> Bool`.

## 1. Defining the hypercube graph

In Lean, the hypercube graph is defined as a `SimpleGraph` whose adjacency relation holds exactly when two vertices differ in exactly one coordinate:

```lean
def hypercube_graph (n : ℕ) : SimpleGraph (Fin n → Bool) :=
  SimpleGraph.fromRel (fun x y => (Finset.filter (fun i => x i ≠ y i) Finset.univ).card = 1)
```

Key ideas:

- `Fin n → Bool` is the type of Boolean strings of length `n` (each index `i : Fin n` gives a bit).
- `Finset.univ` is the finite set of all indices `i : Fin n`.
- `Finset.filter (fun i => x i ≠ y i)` selects the coordinates where `x` and `y` differ.
- The adjacency condition is that this set has cardinality 1, i.e., Hamming distance 1.

The lemma `hypercube_graph_adj` immediately unfolds this definition:

```lean
lemma hypercube_graph_adj {n : ℕ} (x y : Fin n → Bool) :
  (hypercube_graph n).Adj x y ↔
    (Finset.filter (fun i => x i ≠ y i) Finset.univ).card = 1 := by
  simp [hypercube_graph]
```

This lemma is a convenience rule for rewriting adjacency into a cardinality statement.

## 2. Neighbor parity and the `chi` sign

The file uses a parity-based function `chi` (defined elsewhere) and proves that neighbors in the hypercube have opposite `chi` values:

```lean
lemma chi_univ_neighbor {n : ℕ} (x y : Fin n → Bool)
  (h_adj : (hypercube_graph n).Adj x y) :
  chi Finset.univ x = -chi Finset.univ y := by
  -- proof omitted
```

Intuition:

- If `x` and `y` differ in exactly one coordinate, then the number of `true` bits changes by 1.
- Therefore the parity flips, and a parity-based sign like `chi` must change sign.

## 3. Relating `g_val` and function changes on edges

The lemma `g_val_neighbor_eq_iff_f_ne` states that along a hypercube edge, equality of `g_val` is equivalent to `f` changing value:

```lean
lemma g_val_neighbor_eq_iff_f_ne {n : ℕ}
  (f : (Fin n → Bool) → Bool) (x y : Fin n → Bool)
  (h_adj : (hypercube_graph n).Adj x y) :
  g_val f x = g_val f y ↔ f x ≠ f y := by
  -- proof omitted
```

This is used later to relate graph-theoretic degrees to sensitivity. The key point is that adjacency plus a sign flip controls how `g_val` behaves across an edge.

## 4. Sensitivity as degree in induced subgraphs

Two lemmas connect Boolean function sensitivity to degrees in induced subgraphs of the hypercube. The positive and negative level sets are written `S_pos f` and `S_neg f`.

For `S_pos`:

```lean
lemma sensitivity_at_x_eq_degree_in_S_pos {n : ℕ}
  (f : (Fin n → Bool) → Bool) (x : Fin n → Bool) (hx : x ∈ S_pos f) :
  (Finset.filter (fun y => (hypercube_graph n).Adj x y ∧ f x ≠ f y) Finset.univ).card =
  (Finset.filter (fun y => (hypercube_graph n).Adj x y ∧ y ∈ S_pos f) Finset.univ).card := by
  -- proof omitted
```

And similarly for `S_neg`:

```lean
lemma sensitivity_at_x_eq_degree_in_S_neg {n : ℕ}
  (f : (Fin n → Bool) → Bool) (x : Fin n → Bool) (hx : x ∈ S_neg f) :
  (Finset.filter (fun y => (hypercube_graph n).Adj x y ∧ f x ≠ f y) Finset.univ).card =
  (Finset.filter (fun y => (hypercube_graph n).Adj x y ∧ y ∈ S_neg f) Finset.univ).card := by
  -- proof omitted
```

Interpretation:

- The left side counts neighbors where `f` changes value (sensitivity at `x`).
- The right side counts neighbors staying inside the same level set, i.e., degree in the induced subgraph on `S_pos` or `S_neg`.
- These lemmas show that in the appropriate level set, sensitivity is exactly a graph degree.

## 5. Induced hypercube graphs and reindexing

The file defines induced hypercube graphs and also a version where vertices are reindexed by `Fin (2^n)`.

Induced subgraph on a finite set `S` of Boolean vectors:

```lean
def induced_hypercube_graph {n : ℕ} (S : Finset (Fin n → Bool)) :
  SimpleGraph {x // x ∈ S} :=
  SimpleGraph.induce (S : Set (Fin n → Bool)) (hypercube_graph n)
```

Hypercube graph on `Fin (2^n)` using the equivalence between bitstrings and numbers:

```lean
def hypercube_graph_fin (n : ℕ) : SimpleGraph (Fin (2^n)) :=
  (hypercube_graph n).map (boolFunEquivFin n).toEmbedding
```

And the induced graph reindexed by `Fin (card S)`:

```lean
def induced_hypercube_graph_fin_card {n : ℕ} (S : Finset (Fin (2^n))) :
  SimpleGraph (Fin (Fintype.card {x // x ∈ S})) :=
  let G := SimpleGraph.induce (S : Set (Fin (2^n))) (hypercube_graph_fin n)
  let equiv := Fintype.equivFin {x // x ∈ S}
  G.map equiv.toEmbedding
```

These definitions allow later spectral arguments to be stated over standard finite types (`Fin k`) while preserving the hypercube adjacency structure.

## Takeaways

- The hypercube graph is defined by Hamming distance 1 using a filtered index set.
- Adjacency implies parity flips, which shows up as a sign change in `chi`.
- Sensitivity at a point is captured by degree in an induced subgraph of the hypercube.
- The hypercube can be reindexed to `Fin (2^n)` and induced subgraphs can be reindexed to `Fin (card S)` without losing adjacency information.