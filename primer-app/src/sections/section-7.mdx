# Section 7: Why A² = nI for the Huang Matrix, and What That Means for Eigenvalues

This section proves a key identity for the Huang matrix `huang_matrix n`:

```
(huang_matrix n)^2 = n * I
```

where `I` is the identity matrix of the same size. In Lean, this appears as:

```lean
theorem huang_matrix_sq (n : ℕ) :
  (huang_matrix n) ^ 2 = (n : ℝ) • (1 : Matrix (Fin n → Bool) (Fin n → Bool) ℝ)
```

Here `•` is scalar multiplication: `r • M` multiplies every entry of matrix `M` by scalar `r`.

The matrix is indexed by `Fin n -> Bool`, so it has size `2^n x 2^n`. The proof uses induction on `n` and the special block structure of the Huang matrix.

## Big picture

The Huang matrix is built recursively using a block form. At a high level, if we write

```
A_{n+1} = [ A_n   I
            I    -A_n ]
```

then squaring this block matrix gives

```
A_{n+1}^2 = [ A_n^2 + I   0
              0     A_n^2 + I ]
```

By the induction hypothesis, `A_n^2 = n I`, so each diagonal block becomes `(n+1) I`. That yields

```
A_{n+1}^2 = (n+1) I
```

This is exactly what the Lean proof encodes.

## Step-by-step reading of the Lean proof

### 1) Induction on n

The proof starts with:

```lean
induction' n with n ih;
```

- Base case `n = 0`: the matrix `H_0` is the 1×1 zero matrix `[0]` (see Section 6). Its square is `[0]`, and `0 • I = [0]`, so `H_0² = 0 • I` ✓
- Inductive step: assume the result holds for `n`, prove it for `n+1`.

### 2) Use the block definition

The Huang matrix is defined recursively. The proof names that definition:

```lean
have h_def : huang_matrix (n + 1) =
  Matrix.reindex ... (Matrix.fromBlocks (huang_matrix n) 1 1 (-huang_matrix n)) := by rfl
```

Two details:

- `Matrix.fromBlocks` builds the block matrix `[A_n I; I -A_n]`.
- `Matrix.reindex` just reorders indices so the block form matches the indexing by `(Fin (n+1) -> Bool)`. It does not change the algebraic content.

### 3) Square the block matrix

The proof then expands the square of the block matrix:

```lean
(Matrix.fromBlocks A I I (-A))^2
  = Matrix.fromBlocks ((n+1)•I) 0 0 ((n+1)•I)
```

This is the critical calculation. Let's expand the block multiplication explicitly:

\[
\begin{bmatrix} A & I \\ I & -A \end{bmatrix}
\begin{bmatrix} A & I \\ I & -A \end{bmatrix}
= \begin{bmatrix} A^2 + I & AI - IA \\ IA - AI & I + A^2 \end{bmatrix}
= \begin{bmatrix} A^2 + I & 0 \\ 0 & A^2 + I \end{bmatrix}
\]

**Off-diagonal cancellation**: Since \(AI = IA = A\) (identity commutes with everything), we have \(AI + I(-A) = A - A = 0\).

**Diagonal blocks**: Both diagonal blocks are \(A^2 + I\). By the induction hypothesis \(A^2 = nI\), so:
\[
A^2 + I = nI + I = (n+1)I
\]

Therefore:
\[
A_{n+1}^2 = \begin{bmatrix} (n+1)I & 0 \\ 0 & (n+1)I \end{bmatrix} = (n+1)I
\]

Lean typically achieves this with:
- `simp` to rewrite `A ⬝ I`, `I ⬝ A`, and `A ⬝ (-A)` using matrix identities
- `simp [ih]` to apply the induction hypothesis `ih : (huang_matrix n)^2 = (n : ℝ) • I`
- `simp` with `Matrix.fromBlocks` multiplication lemmas to reduce off-diagonal blocks to `0`
- A ring- or arithmetic-simplification step to turn `n + 1` into `(n + 1 : ℝ)` after coercions

### 4) Reindexing and extensionality

The remainder of the Lean code uses `simp`, `ext`, and a case split on `i = j` to conclude the final equality after reindexing. This is bookkeeping to align the matrix entries with the identity matrix definition.

## Why \(A^2 = nI\) matters: eigenvalues

If a square matrix \(A\) satisfies \(A^2 = nI\), then every eigenvalue \(\lambda\) must satisfy \(\lambda^2 = n\).

**Proof**: If \(Av = \lambda v\) for some nonzero vector \(v\), then:
\[
A^2 v = A(Av) = A(\lambda v) = \lambda(Av) = \lambda^2 v
\]

But \(A^2 = nI\) also implies \(A^2 v = nv\). Therefore:
\[
\lambda^2 v = nv
\]

Since \(v \neq 0\), we conclude \(\lambda^2 = n\).

### Consequences

- Over \(\mathbb{R}\), the only possible eigenvalues are \(+\sqrt{n}\) and \(-\sqrt{n}\).
- The spectrum is symmetric: if \(\lambda\) is an eigenvalue, so is \(-\lambda\).
- The matrix is diagonalizable over \(\mathbb{R}\) if it is symmetric. The Huang matrix is symmetric (proved in **Section 12**), so it has an orthonormal eigenbasis with eigenvalues \(\pm\sqrt{n}\).

## Summary

The proof shows that the Huang matrix is an involution up to scaling: squaring it gives a scalar multiple of the identity. This immediately pins down the eigenvalues to the square roots of `n`, which is exactly why the comment at the end of the Lean file says: "The eigenvalues of the Huang matrix square to n."
