# Section 6: Recursive Block Definition of the Huang Matrix

This section defines a family of matrices `huang_matrix (n : ℕ)` over `ℝ` indexed by Boolean vectors of length `n`.

```lean
def huang_matrix (n : ℕ) : Matrix (Fin n → Bool) (Fin n → Bool) ℝ :=
  match n with
  | 0 => 0
  | n + 1 => Matrix.reindex (finSuccEquiv_huang_custom n).symm (finSuccEquiv_huang_custom n).symm
      (Matrix.fromBlocks (huang_matrix n) (1 : Matrix _ _ ℝ) (1 : Matrix _ _ ℝ) (-huang_matrix n))
```

## 1. What the type says

`Matrix (Fin n → Bool) (Fin n → Bool) ℝ` is a square matrix whose rows and columns are indexed by functions `Fin n → Bool`, i.e. Boolean vectors of length `n`.

So for each `n`, `huang_matrix n` is a `2^n × 2^n` real matrix, but it is indexed by *functions* rather than integer indices.

**Why 2^n?** The type `Fin n → Bool` is a function type with `2^n` elements: there are 2 choices (true/false) for each of the `n` positions. Lean's `Fintype` instance computes `Fintype.card (Fin n → Bool) = 2^n` via `Fintype.card_pi`.

## 2. Base case: `n = 0`

```lean
| 0 => 0
```

When `n = 0`, the index type `Fin 0 → Bool` has exactly one element (the empty function), so the matrix is `1 × 1`. The definition returns `0`, the zero matrix of that size.

**Note**: This means `H_0 = [0]`, the 1×1 zero matrix. This satisfies `H_0² = 0·I` (since 0² = 0 and 0·I = 0 for the 1×1 identity). The formula `H_n² = n·I` holds with `n = 0`.

## 3. Recursive case: `n + 1`

```lean
| n + 1 => Matrix.reindex ... (Matrix.fromBlocks ...)
```

The recursive step builds `huang_matrix (n+1)` as a **2×2 block matrix**, where each block is itself a matrix indexed by Boolean vectors of length `n`.

### 3.1 The block structure

The key expression is:

```lean
Matrix.fromBlocks (huang_matrix n) (1 : Matrix _ _ ℝ)
                  (1 : Matrix _ _ ℝ) (-huang_matrix n)
```

`Matrix.fromBlocks A B C D` builds the block matrix

```
[ A  B ]
[ C  D ]
```

Here:

- `A` is `huang_matrix n`
- `D` is `-huang_matrix n`
- `B` and `C` are both `1`, the identity matrix of appropriate size

**Lean notation**: In Lean's matrix library, `1 : Matrix α α R` denotes the identity matrix (diagonal 1s, off-diagonal 0s), not the all-ones matrix. This is the multiplicative identity in the matrix ring.

So the recursive definition is:

```
H_{n+1} = [  H_n     I ]
          [   I   -H_n ]
```

This is a classic recursive block construction, similar in spirit to Hadamard-type recurrences but with identity matrices on the off-diagonals and a sign flip on the bottom-right block.

### 3.2 Where the indices live

`fromBlocks` naturally produces a matrix indexed by a *sum type* of indices:

```
(Fin n → Bool) ⊕ (Fin n → Bool)
```

That is, it expects row and column indices to be either a "left" index (top block) or a "right" index (bottom block).

But we want the final result indexed by `Fin (n+1) → Bool` (Boolean vectors of length `n+1`).

### 3.3 Reindexing with an equivalence

That is why we wrap the block matrix with `Matrix.reindex`:

```lean
Matrix.reindex (finSuccEquiv_huang_custom n).symm
               (finSuccEquiv_huang_custom n).symm
               (Matrix.fromBlocks ...)
```

- `finSuccEquiv_huang_custom n` is an equivalence between
  `Fin (n+1) → Bool` and `(Fin n → Bool) ⊕ (Fin n → Bool)`
  (defined in **Section 5**). It splits a length-`n+1` Boolean vector into the first bit choosing left (`Sum.inl` for `false`) or right (`Sum.inr` for `true`), with the remaining `n` bits giving the index within that block.
- The `.symm` uses the inverse direction because `fromBlocks` already lives in the sum-indexed world.

So `reindex` converts the block-indexed matrix into one indexed by Boolean vectors of length `n+1`.

## 4. Why this is a recursive block definition

Putting it all together:

- `H_0` is the zero 1×1 matrix.
- `H_{n+1}` is built from `H_n` in a 2×2 block pattern:
  - top-left is `H_n`
  - bottom-right is `-H_n`
  - off-diagonals are identity matrices
- a reindexing step converts block indices into Boolean-vector indices

This is a canonical recursive block matrix definition: you double the dimension by stacking four blocks, two of which are the previous matrix (one with a sign flip), and two of which are identity matrices.

## 5. The accompanying statement

The comment at the end hints at a key property of the Huang matrices:

```lean
/-
The square of the Huang matrix A_n is n times the identity matrix.
-/
```

So the recursion is set up to make `H_n^2 = n * I` true for all `n`. The block form makes it possible to prove this by induction, since block multiplication decomposes into the same four-block pattern.

---

**Summary:** `huang_matrix` is defined recursively by a 2×2 block construction, with off-diagonal identities, a sign flip on the bottom-right, and a reindexing step to convert the block sum indices into Boolean-vector indices. This is the Lean encoding of a structured matrix recurrence that supports an inductive proof of its algebraic properties.
