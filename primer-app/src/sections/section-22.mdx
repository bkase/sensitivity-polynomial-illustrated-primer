# Restriction to Subcubes

This section defines **restriction** of a Boolean function to a subset of coordinates. This is a fundamental operation that allows us to focus on a "subcube" by fixing some variables to constant values.

## What is restriction?

Given a Boolean function

```
f : (Fin n → Bool) → Bool
```

and a subset of coordinates `S : Finset (Fin n)`, we can **restrict** `f` by:

- allowing the coordinates in `S` to vary freely, and
- fixing all coordinates outside `S` to some assignment `z : Fin n → Bool`.

In Lean, the restriction is:

```lean
def restriction {n : ℕ} (f : (Fin n → Bool) → Bool) (S : Finset (Fin n)) (z : Fin n → Bool) :
  (Fin (Fintype.card {x // x ∈ S}) → Bool) → Bool :=
  fun y => f (fun i =>
    if h : i ∈ S
    then y ((Fintype.equivFin {x // x ∈ S}).symm ⟨i, h⟩)
    else z i)
```

The input to the restricted function is a Boolean assignment only on the coordinates in `S`. The code constructs a full assignment `x : Fin n → Bool` by:

- using the input `y` on indices in `S` (via an equivalence between `S` and `Fin |S|`),
- using `z` on indices outside `S`.

Then it evaluates `f x`.

## Intuition: plugging in constants

Intuitively, a restriction is the usual "plug in constants outside S" operation. If you have a Boolean function on 5 variables and you fix variables 2 and 4 to specific values, you get a new function on the remaining 3 variables.

Example: Suppose `f(x₀, x₁, x₂) = x₀ XOR x₁ XOR x₂` and we restrict to `S = {0, 2}` with `z₁ = true`. Then:

```
restriction f S z (y₀, y₁) = y₀ XOR true XOR y₁ = NOT(y₀ XOR y₁)
```

The restricted function depends only on the free variables in `S`.

## Why restriction matters

Restriction is a key tool for several reasons:

1. **Fourier analysis**: Restricting to a subset `S` that supports a top-degree Fourier coefficient turns that coefficient into the "full set" coefficient of the restricted function.

2. **Induction**: Many proofs about Boolean functions proceed by restricting to smaller subcubes.

3. **Sensitivity bounds**: As we'll see in the next section, sensitivity cannot increase under restriction, which allows us to transfer bounds.

## Connection to Fourier coefficients

A crucial lemma (proved elsewhere) states:

```lean
lemma exists_restriction_fourier_coeff_univ_ne_zero (f : (Fin n → Bool) → Bool) (S : Finset (Fin n))
  (hS : fourier_coeff f S ≠ 0) :
  ∃ z, fourier_coeff (restriction f S z) Finset.univ ≠ 0
```

This says: if `f` has a nonzero Fourier coefficient at `S`, then there exists a restriction `z` such that the restricted function has a nonzero coefficient at the full set (i.e., `Finset.univ` for the smaller domain).

This is exactly what we need to connect the degree of `f` to the degree of its restrictions.

## Takeaways

- Restriction fixes variables outside a set `S` and keeps only the `S`-coordinates free.
- The Lean definition uses an explicit equivalence to map between the restricted and full coordinate spaces.
- Restriction is essential for transferring Fourier-analytic information between functions of different dimensions.
