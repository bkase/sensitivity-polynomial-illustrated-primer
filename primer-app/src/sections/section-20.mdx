# Why One Level Set Must Be Large

This section proves a simple but powerful counting fact: if a Boolean function has full degree, then one of its two "level sets" (where a related ±1-valued function is positive or negative) must contain **more than half** of the hypercube.

## The Lemma (informal)

Let \(f : \{0,1\}^n \to \{0,1\}\) with \(\deg(f) = n\) and \(n \neq 0\). Recall from **Section 19** that \(g_{\text{val}}(f, x) = \mathbf{1}_{f(x)} \cdot \chi_{[n]}(x)\), which always equals \(\pm 1\).

Define the level sets:
\[
S_{\text{pos}}(f) = \{x \in \{0,1\}^n : g_{\text{val}}(f, x) = 1\}
\]
\[
S_{\text{neg}}(f) = \{x \in \{0,1\}^n : g_{\text{val}}(f, x) = -1\}
\]

**Theorem**: At least one of these sets has size strictly greater than \(2^{n-1}\):
\[
|S_{\text{pos}}(f)| > 2^{n-1} \quad \text{or} \quad |S_{\text{neg}}(f)| > 2^{n-1}
\]

## Intuition

Think of \(g_{\text{val}}(f, \cdot)\) as a \(\pm 1\) labeling of the hypercube. The sum of all labels is:
\[
\sum_{x \in \{0,1\}^n} g_{\text{val}}(f, x) = |S_{\text{pos}}| - |S_{\text{neg}}|
\]

If this sum is **nonzero**, then \(|S_{\text{pos}}| \neq |S_{\text{neg}}|\). But the two sets partition the whole cube, so:
\[
|S_{\text{pos}}| + |S_{\text{neg}}| = 2^n
\]

If two non-negative integers sum to \(2^n\) and are unequal, one must exceed \(2^{n-1}\).

**Key fact** (from **Section 11**): For a full-degree function (\(\deg(f) = n\)) and \(n \neq 0\), the sum \(\sum_x g_{\text{val}}(f, x) \neq 0\). This is because the sum equals (up to normalization) the top Fourier coefficient \(\hat{f}([n])\), which is nonzero when \(\deg(f) = n\).

## Proof Outline (Lean)

The Lean proof has two main parts.

### 1. Show the two level sets have different sizes

The proof computes the sum of `g_val f` by splitting over `S_pos` and `S_neg`:

- On `S_pos`, `g_val f x = 1`.
- On `S_neg`, `g_val f x = -1`.

So:

```
Σ g_val f = |S_pos f| − |S_neg f|.
```

The lemma `g_val_sum_ne_zero f h_deg hn` gives that this sum is nonzero, hence

```
|S_pos f| ≠ |S_neg f|.
```

Lean snippet (paraphrased):

```lean
have h_card_ne : (S_pos f).card ≠ (S_neg f).card := by
  have h_card_ne : (Finset.sum Finset.univ (g_val f))
    = (S_pos f).card - (S_neg f).card := by
    -- split sum over S_pos and S_neg, then use g_val = ±1
    ...
  have := g_val_sum_ne_zero f h_deg hn
  aesop
```

### 2. Use the partition of the cube

The sets `S_pos` and `S_neg` are disjoint and cover the whole hypercube, so:

```
|S_pos f| + |S_neg f| = 2^n.
```

Lean computes this using `Finset.card_union_of_disjoint` and the fact that the
universe of `Fin n → Bool` has size `2^n`. Since `n ≠ 0`, it rewrites

```
2^n = 2 * 2^(n-1).
```

So the sum of the two sizes is exactly twice `2^(n-1)`.

### 3. Conclude one side is larger than half

With:
- \(|S_{\text{pos}}| + |S_{\text{neg}}| = 2 \cdot 2^{n-1}\), and
- \(|S_{\text{pos}}| \neq |S_{\text{neg}}|\),

we can derive that one must exceed \(2^{n-1}\). Here's the explicit arithmetic:

**Proof**: Suppose for contradiction that both \(|S_{\text{pos}}| \leq 2^{n-1}\) and \(|S_{\text{neg}}| \leq 2^{n-1}\). Then:
\[
|S_{\text{pos}}| + |S_{\text{neg}}| \leq 2 \cdot 2^{n-1}
\]
But we know \(|S_{\text{pos}}| + |S_{\text{neg}}| = 2 \cdot 2^{n-1}\), so equality holds throughout. This means \(|S_{\text{pos}}| = 2^{n-1}\) and \(|S_{\text{neg}}| = 2^{n-1}\), contradicting \(|S_{\text{pos}}| \neq |S_{\text{neg}}|\).

Therefore, at least one of \(|S_{\text{pos}}| > 2^{n-1}\) or \(|S_{\text{neg}}| > 2^{n-1}\) must hold. Lean closes this with `grind`.

## Takeaway

The full-degree condition forces a global imbalance in the ±1 labeling `g_val f`. Once you know the two level sets partition the hypercube, that imbalance means one level set must contain **strictly more than half** of all inputs.

This fact is a recurring lever: it turns algebraic information (nonzero sum) into a combinatorial guarantee (a large level set).
