# g_val and its level sets

This section defines a signed function `g_val` on the Boolean cube and then uses it to split the cube into two level sets, `S_pos` and `S_neg`. The key idea is that `g_val` always evaluates to either `1` or `-1`, so these level sets form a clean partition of all inputs.

## The definition of g_val

In Lean:

```lean
def g_val {n : ℕ} (f : (Fin n → Bool) → Bool) (x : Fin n → Bool) : ℝ :=
  (if f x then -1 else 1) * chi Finset.univ x
```

Interpretation:

- `x : Fin n → Bool` is a Boolean input of length `n`.
- `chi Finset.univ x` is the parity character on the full index set. Concretely, it is `(-1)^{|{ i | x i = true }|}`.
- `(if f x then -1 else 1)` flips the sign depending on whether the Boolean function `f` returns `true` at `x`.

So `g_val f x` is a signed value that combines the parity of `x` with the output of `f`. Both factors are `±1`, so the product is also `±1`.

## Why g_val is always ±1

The parity character `chi Finset.univ x` is always `1` or `-1`. The conditional `(if f x then -1 else 1)` is also always `1` or `-1`. Their product therefore can only be `1` or `-1`.

This observation is the backbone of the level set definitions and the union/disjointness lemmas that follow.

## The positive and negative level sets

The section defines two finite sets of inputs:

```lean
def S_pos {n : ℕ} (f : (Fin n → Bool) → Bool) : Finset (Fin n → Bool) :=
  Finset.filter (fun x => g_val f x = 1) Finset.univ

def S_neg {n : ℕ} (f : (Fin n → Bool) → Bool) : Finset (Fin n → Bool) :=
  Finset.filter (fun x => g_val f x = -1) Finset.univ
```

- `S_pos f` collects all inputs where `g_val f x = 1`.
- `S_neg f` collects all inputs where `g_val f x = -1`.
- Both are subsets of the full Boolean cube `Finset.univ`.

Because `g_val` only takes values `±1`, every input belongs to exactly one of these sets.

## The level sets cover the whole space

Lemma in Lean:

```lean
lemma S_pos_union_S_neg {n : ℕ} (f : (Fin n → Bool) → Bool) :
  S_pos f ∪ S_neg f = Finset.univ := by
  ...
```

Informally: for any input `x`, `g_val f x` is either `1` or `-1`, so `x` must be in `S_pos f` or in `S_neg f`. The proof unfolds `g_val`, uses the fact that `chi` is also `±1`, and performs a case split on parity.

## The level sets are disjoint

Lemma in Lean:

```lean
lemma S_pos_disjoint_S_neg {n : ℕ} (f : (Fin n → Bool) → Bool) :
  Disjoint (S_pos f) (S_neg f) := by
  exact Finset.disjoint_filter.mpr fun _ _ _ _ => by linarith;
```

This uses the fact that an element cannot satisfy both `g_val f x = 1` and `g_val f x = -1`. The `linarith` step closes the contradiction.

## Why this matters

The level sets `S_pos` and `S_neg` give a clean partition of the Boolean cube based on the sign of `g_val`. Later arguments can compare the sizes of these sets or relate them to sums like `∑ x, g_val f x`. For instance, if the sum is nonzero, then one of the sets must be larger than the other.

## Takeaways

- `g_val` is a signed combination of `f` and parity, always equal to `1` or `-1`.
- `S_pos` and `S_neg` are the level sets where `g_val` is positive or negative.
- These sets partition the entire space: they cover all inputs and are disjoint.
